
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.0">
    
    
      
        <title>15.6 std::shared_ptr - LearnCPP 中文教程</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.a3f8f96a.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.7fa14f5b.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#156-stdshared_ptr" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="LearnCPP 中文教程" class="md-header__button md-logo" aria-label="LearnCPP 中文教程">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LearnCPP 中文教程
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              15.6 std::shared_ptr
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LearnCPP 中文教程" class="md-nav__button md-logo" aria-label="LearnCPP 中文教程">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    LearnCPP 中文教程
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        目录
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BF%BB%E8%AF%91%E6%97%A5%E8%AE%B0/" class="md-nav__link">
        翻译日记
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" >
      
      <label class="md-nav__link" for="nav-3">
        00 Introduction getting started
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="00 Introduction getting started" data-md-level="1">
        <label class="md-nav__title" for="nav-3">
          <span class="md-nav__icon md-icon"></span>
          00 Introduction getting started
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../00-Introduction-getting-started/" class="md-nav__link">
        第零章 介绍/起步
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/" class="md-nav__link">
        0.1 教程介绍
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" >
      
      <label class="md-nav__link" for="nav-4">
        08 basic object oriented programming
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="08 basic object oriented programming" data-md-level="1">
        <label class="md-nav__title" for="nav-4">
          <span class="md-nav__icon md-icon"></span>
          08 basic object oriented programming
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../08-basic-object-oriented-programming/" class="md-nav__link">
        第八章 面向对象编程基础
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../08-basic-object-oriented-programming/8.1-welcome-to-object-oriented-programming/" class="md-nav__link">
        8.1 欢迎来到面向对象的世界
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../08-basic-object-oriented-programming/8.2-classes-and-class-member/" class="md-nav__link">
        8.2 类和类成员 (Classes and class member)
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" >
      
      <label class="md-nav__link" for="nav-5">
        14 exceptions
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="14 exceptions" data-md-level="1">
        <label class="md-nav__title" for="nav-5">
          <span class="md-nav__icon md-icon"></span>
          14 exceptions
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/" class="md-nav__link">
        14 异常
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.1-the-need-for-exceptions/" class="md-nav__link">
        14.1 为什么需要异常
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.2-basic-exception-handloing/" class="md-nav__link">
        14.2 基本异常处理
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.3-exceptions-functions-and-stack-unwinding/" class="md-nav__link">
        14.3 异常，函数，栈展开
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.4-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/" class="md-nav__link">
        14.4 未捕获异常，捕获全部异常和异常说明符
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.5-exceptions-classes-and-inheritance/" class="md-nav__link">
        14.5 异常，类和继承
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.6-rethrowing-exceptions/" class="md-nav__link">
        14.6 异常的再抛出
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.7-function-try-blocks/" class="md-nav__link">
        14.7 函数级的 try 代码块
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.8-exception-dangers-and-downsides/" class="md-nav__link">
        14.8 异常的危险和缺点
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" checked>
      
      <label class="md-nav__link" for="nav-6">
        15 move semantics and smart pointers
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="15 move semantics and smart pointers" data-md-level="1">
        <label class="md-nav__title" for="nav-6">
          <span class="md-nav__icon md-icon"></span>
          15 move semantics and smart pointers
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        15 移动语义和智能指针
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15.1-intro-to-smart-pointers-and-move-semantics/" class="md-nav__link">
        15.1 智能指针和移动语义的介绍
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15.2-r-value-reference/" class="md-nav__link">
        15.2 右值引用
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15.3-move-constructors-and-move-assignment/" class="md-nav__link">
        15.3 移动构造和移动赋值
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15.4-std%3A%3Amove/" class="md-nav__link">
        15.4 std::move
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15.5-std%3A%3Aunique_ptr/" class="md-nav__link">
        15.5 std::unique_ptr
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          15.6 std::shared_ptr
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        15.6 std::shared_ptr
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#stdmake_shared" class="md-nav__link">
    std::make_shared
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdshared_ptr" class="md-nav__link">
    深挖 std::shared_ptr
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shared-pointers-unique-pointers" class="md-nav__link">
    Shared pointers 可以从 Unique pointers 创建
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdshared_ptr_1" class="md-nav__link">
    使用 std::shared_ptr 的危险之处
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdshared_ptr_2" class="md-nav__link">
    std::shared_ptr 和数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    结论
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15.7-std%3A%3Aweak_ptr/" class="md-nav__link">
        15.7 std::shared_ptr 的循环依赖问题，介绍 std::weak_ptr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../15.x-chapter15-comprehensive-review/" class="md-nav__link">
        15.x 十五章理解和复习
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7" >
      
      <label class="md-nav__link" for="nav-7">
        18 virtual functions
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="18 virtual functions" data-md-level="1">
        <label class="md-nav__title" for="nav-7">
          <span class="md-nav__icon md-icon"></span>
          18 virtual functions
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/" class="md-nav__link">
        第十八章 虚函数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.1-pointers-and-references-to-the-base-class-of-derived-objects/" class="md-nav__link">
        18.1 基类指针和引用指向派生类
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.2-virtual-functions-and-polymorphism/" class="md-nav__link">
        18.2 — 虚函数和多态
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.3-The-override-and-final-specifiers-and-covariant-return-types/" class="md-nav__link">
        18.3 重写 final 标识符，并且协变返回类型
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/" class="md-nav__link">
        18.4 虚构造函数，虚赋值，重写虚函数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.5-early-binding-and-late-binding/" class="md-nav__link">
        18.5 预绑定和后期绑定
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.6-the-virtual-table/" class="md-nav__link">
        18.6 虚表
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.7-virtual-base-classes/" class="md-nav__link">
        18.7 虚基类 (Virtual base classes)
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.8-object-slicing/" class="md-nav__link">
        18.8 对象切割
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.9-dynamic-casting/" class="md-nav__link">
        18.9 动态类型转换
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../18-virtual-functions/18.x%20chapter-18-comprehensice-quiz/" class="md-nav__link">
        18.x 十二章理解和练习
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8" >
      
      <label class="md-nav__link" for="nav-8">
        19 templates
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="19 templates" data-md-level="1">
        <label class="md-nav__title" for="nav-8">
          <span class="md-nav__icon md-icon"></span>
          19 templates
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/" class="md-nav__link">
        十九章 模板
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.1-function-templates/" class="md-nav__link">
        19.1 函数模板 Function templates
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.2-function-template-instances/" class="md-nav__link">
        19.2 类模板实例
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.3-template-classes/" class="md-nav__link">
        19.3 模板类
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.4-template-non-type-parameters/" class="md-nav__link">
        19.4 模板非类型参数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.5-function-template-specialization/" class="md-nav__link">
        19.5 函数模板特化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.6-class-template-specialization/" class="md-nav__link">
        19.6 类模板特化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.7-partial-template-specialization/" class="md-nav__link">
        19.7 模板局部特化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.8-partial-template-specialization-for-pointers/" class="md-nav__link">
        19.8 局部模板特化指针的
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.x%20chapter-19-comprehensice-quiz/" class="md-nav__link">
        19.x - 19章节练习
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-9" type="checkbox" id="nav-9" >
      
      <label class="md-nav__link" for="nav-9">
        23 input and output
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="23 input and output" data-md-level="1">
        <label class="md-nav__title" for="nav-9">
          <span class="md-nav__icon md-icon"></span>
          23 input and output
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../23-input-and-output/23.1-input-and-output-streams/" class="md-nav__link">
        18.1 输入输出流
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../23-input-and-output/23.2-input-with-istream/" class="md-nav__link">
        18.2 使用 istream 输入
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../23-input-and-output/23.3-output-with-ostream-and-ios/" class="md-nav__link">
        18.3 使用 ostrea 和 ios 进行输出
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#stdmake_shared" class="md-nav__link">
    std::make_shared
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdshared_ptr" class="md-nav__link">
    深挖 std::shared_ptr
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shared-pointers-unique-pointers" class="md-nav__link">
    Shared pointers 可以从 Unique pointers 创建
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdshared_ptr_1" class="md-nav__link">
    使用 std::shared_ptr 的危险之处
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdshared_ptr_2" class="md-nav__link">
    std::shared_ptr 和数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    结论
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="156-stdshared_ptr">15.6 std::shared_ptr<a class="headerlink" href="#156-stdshared_ptr" title="Permanent link">&para;</a></h1>
<!-- 15.6 — std::shared_ptr -->

<blockquote>
<p>By Alex on March 16<sup>th</sup>, 2017 | last modified by Alex on January 23<sup>rd</sup>, 2020</p>
<p>翻译by dashjay 2020.07.18</p>
</blockquote>
<!-- Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need multiple smart pointers co-owning a resource. -->

<p>不像 <code>std::unique_ptr</code> 那样，仅仅被设计单独拥有和管理一份资源，<code>std::shared_ptr</code> 是为了解决你需要创建很多智能指针共用一个资源的情况。</p>
<!-- This means that it is fine to have multiple std::shared_ptr pointing to the same resource. Internally, std::shared_ptr keeps track of how many std::shared_ptr are sharing the resource. As long as at least one std::shared_ptr is pointing to the resource, the resource will not be deallocated, even if individual std::shared_ptr are destroyed. As soon as the last std::shared_ptr managing the resource goes out of scope (or is reassigned to point at something else), the resource will be deallocated. -->

<p>这意味着，同时许多 <code>std::shared_ptr</code> 指向同一份资源是OK的。在内部，<code>std::shared_ptr</code> 保持跟踪正在分享同一份资源的 <code>std::shared_ptr</code> 数量。当只要有一个 <code>std::shared_ptr</code> 指向资源，这个资源就不会被释放，即使一些 <code>std::shared_ptr</code> 被销毁。当最后一个管理着资源的 <code>std::shared_ptr</code> 离开作用域时（或者被重新赋值指向其他资源）原来管理的资源就会被销毁。</p>
<!-- Like std::unique_ptr, std::shared_ptr lives in the <memory> header. -->
<blockquote>
<p>和 <code>std::unique_ptr</code> 一样，<code>std_shared_ptr</code> 在 <memory> 头部中。</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="c1"> // for std::shared_ptr</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Resource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
 <span class="n">Resource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Resource acquired</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
 <span class="o">~</span><span class="n">Resource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Resource destroyed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="c1">// allocate a Resource object and have it owned by std::shared_ptr</span>
 <span class="n">Resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Resource</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
 <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span> <span class="c1">// use copy initialization to make another std::shared_ptr pointing to the same thing</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Killing one shared pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
 <span class="p">}</span> <span class="c1">// ptr2 goes out of scope here, but nothing happens</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Killing another shared pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span>
</code></pre></div>
<p>输出</p>
<div class="highlight"><pre><span></span><code>Resource acquired
Killing one shared pointer
Killing another shared pointer
Resource destroyed
</code></pre></div>
<!-- In the above code, we create a dynamic Resource object, and set a std::shared_ptr named ptr1 to manage it. Inside the nested block, we use copy initialization (which is allowed with std::shared_ptr, since the resource can be shared) to create a second std::shared_ptr (ptr2) that points to the same Resource. When ptr2 goes out of scope, the Resource is not deallocated, because ptr1 is still pointing at the Resource. When ptr1 goes out of scope, ptr1 notices there are no more std::shared_ptr managing the Resource, so it deallocates the Resource. -->

<p>在上方的代码中，我们创建了一个动态资源对象，并且设置了一个名字为 <code>ptr1</code> 的 <code>std::shared_ptr</code> 来管理它。在这个嵌套的语句块中，我们用拷贝初始化（<strong>在<code>std::shared_ptr</code> 中允许的操作，因为资源可以被共享</strong> ）来创建第二个 <code>std::shared_ptr</code>(ptr2)指向同一份资源。当<code>ptr1</code>离开作用域时，<code>ptr1</code>注意到这里已经没有 <code>std::shared_ptr</code>管理这份资源了，因此我们释放该资源。</p>
<!-- Note that we created a second shared pointer from the first shared pointer (using copy initialization). This is important. Consider the following similar program: -->

<p>注意我们创建了第二个智能指针从第一个智能指针 <strong>（使用拷贝初始化）</strong>。这很重要，思考如下代码。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="c1"> // for std::shared_ptr</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Resource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
 <span class="n">Resource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Resource acquired</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
 <span class="o">~</span><span class="n">Resource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Resource destroyed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">Resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Resource</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
 <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">res</span><span class="p">);</span> <span class="c1">// create ptr2 directly from res (instead of ptr1)</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Killing one shared pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
 <span class="p">}</span> <span class="c1">// ptr2 goes out of scope here, and the allocated Resource is destroyed</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Killing another shared pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// ptr1 goes out of scope here, and the allocated Resource is destroyed again</span>
</code></pre></div>
<p>输出</p>
<div class="highlight"><pre><span></span><code>Resource acquired
Killing one shared pointer
Resource destroyed
Killing another shared pointer
Resource destroyed
</code></pre></div>
<!-- and then crashes (at least on the author’s machine). -->

<p>然后紧接着崩溃（至少在作者的机器上）。</p>
<!-- The difference here is that we created two std::shared_ptr independently from each other. As a consequence, even though they’re both pointing to the same Resource, they aren’t aware of each other. When ptr2 goes out of scope, it thinks it’s the only owner of the Resource, and deallocates it. When ptr1 later goes out of the scope, it thinks the same thing, and tries to delete the Resource again. Then bad things happen. -->

<p>这里不同的是我们创建了两个相互独立的 <code>std::shared_Ptr</code>。结果，即使他们都指向 <strong>同一份资源</strong>，但是他们都没意识到对方的存在。当 <code>ptr2</code> 离开作用域时，他 <strong>认为</strong> 他是资源唯一的拥有者，所以释放了它。当 ptr1 之后离开作用域时，它思考的着同样的问题，并且尝试再次删除它。糟糕的事情发生了。</p>
<!-- Fortunately, this is easily avoided by using copy assignment or copy initialization when you need multiple shared pointers pointing to the same Resource. -->

<p>幸运的是，当你需要多个共享指针指向同一份资源时，这是非常容易使用 <strong>拷贝赋值</strong> 或者 <strong>拷贝初始化</strong> 来避免的。</p>
<!-- Rule: Always make a copy of an existing std::shared_ptr if you need more than one std::shared_ptr pointing to the same resource. -->

<p>规定：当你需要不止一个 <code>std::shared_ptr</code> 指向同一份资源，请总是从已存在的 <code>std::shared_ptr</code> 创建拷贝。</p>
<h2 id="stdmake_shared">std::make_shared<a class="headerlink" href="#stdmake_shared" title="Permanent link">&para;</a></h2>
<!-- std::make_shared -->

<!-- Much like std::make_unique() can be used to create a std::unique_ptr in C++14, std::make_shared() can (and should) be used to make a std::shared_ptr. std::make_shared() is available in C++11. -->

<p>就像在C++14中 <code>std::make_unique()</code> 可以被用来创建 <code>std::unique_ptr</code> 一样，<code>std::make_shared()</code> 可以（并且应该）被用来创建一个 <code>std::shared_ptr</code>。<code>std::make_shared()</code> 在C++11中就可用。</p>
<!-- Here’s our original example, using std::make_shared(): -->

<p>有些例子，使用了 <code>std::make_shared()</code>:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="c1"> // for std::shared_ptr</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Resource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
 <span class="n">Resource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Resource acquired</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
 <span class="o">~</span><span class="n">Resource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Resource destroyed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="c1">// allocate a Resource object and have it owned by std::shared_ptr</span>
 <span class="k">auto</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">();</span>
 <span class="p">{</span>
  <span class="k">auto</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span> <span class="c1">// create ptr2 using copy initialization of ptr1</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Killing one shared pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
 <span class="p">}</span> <span class="c1">// ptr2 goes out of scope here, but nothing happens</span>

 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Killing another shared pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span>
</code></pre></div>
<!-- The reasons for using std::make_shared() are the same as std::make_unique() -- std::make_shared() is simpler and safer (there’s no way to directly create two std::shared_ptr pointing to the same resource using this method). However, std::make_shared() is also more performant than not using it. The reasons for this lie in the way that std::shared_ptr keeps track of how many pointers are pointing at a given resource. -->

<p>使用 <code>std::make_shared()</code> 的原因和 <code>std::make_unique()</code>一样 ———— <code>std::make_shared()</code> 更简单更安全（使用这个方法不可能直接创建两个相互独立的 <code>std::shared_ptr</code> 指向同一块资源），而且，比起不使用它，<code>std::make_shared()</code> 有更加高性能。其原因在于 <code>std::shared ptr</code> 跟踪指向给定资源的指针数量。</p>
<h2 id="stdshared_ptr">深挖 std::shared_ptr<a class="headerlink" href="#stdshared_ptr" title="Permanent link">&para;</a></h2>
<!-- Digging into std::shared_ptr -->

<!-- Unlike std::unique_ptr, which uses a single pointer internally, std::shared_ptr uses two pointers internally. One pointer points at the resource being managed. The other points at a “control block”, which is a dynamically allocated object that tracks of a bunch of stuff, including how many std::shared_ptr are pointing at the resource. When a std::shared_ptr is created via a std::shared_ptr constructor, the memory for the managed object (which is usually passed in) and control block (which the constructor creates) are allocated separately. However, when using std::make_shared(), this can be optimized into a single memory allocation, which leads to better performance. -->

<p>不像内部仅仅使用一个指针的<code>std::unique_ptr</code> 那样，<code>std::shared_ptr</code> 内部有两个指针：一个指针指向被管理的资源，另一个指针在“控制块（control block）”，是一个动态分配的对象，会跟踪很多东西，包括有多少个 <code>std::shared_ptr</code> 指向资源。</p>
<p>当一个 <code>std::shared_ptr</code> 被使用构造函数单独创建的时候，管理对象（传入的资源）和控制块（构造器创建）的内存就被单独分配了。然而，当使用 <code>std::make_shared()</code> 时，这可以被优化成一个单独内存分配，有更好的性能。</p>
<!-- This also explains why independently creating two std::shared_ptr pointed to the same resource gets us into trouble. Each std::shared_ptr will have one pointer pointing at the resource. However, each std::shared_ptr will independently allocate its own control block, which will indicate that it is the only pointer owning that resource. Thus, when that std::shared_ptr goes out of scope, it will deallocate the resource, not realizing there are other std::shared_ptr also trying to manage that resource. -->

<p>这也解释了为什么单独创建两个 <code>std::shared_ptr</code> 会遇到问题。每个 <code>std::shared_ptr</code>将会有一个指针指向资源，然而每个 <code>std::shared_ptr</code> 独立分配它自己的控制块，这意味着这是持有资源的唯一的指针。因此，当 <code>std::shared_ptr</code> 离开作用域后，会释放资源，并没有意识到还有另一个 <code>std::shared_ptr</code> 仍然在管理资源。</p>
<!-- However, when a std::shared_ptr is cloned using copy assignment, the data in the control block can be appropriately updated to indicate that there are now additional std::shared_ptr co-managing the resource. -->

<p>然而，当一个 <code>std::shared_ptr</code> 被使用拷贝构造复制的时候，控制块中的数据同样被更新成合适的值，表明有另一个 <code>std::shared_ptr</code> 共同管理这个资源。</p>
<!-- Shared pointers can be created from unique pointers -->

<h2 id="shared-pointers-unique-pointers">Shared pointers 可以从 Unique pointers 创建<a class="headerlink" href="#shared-pointers-unique-pointers" title="Permanent link">&para;</a></h2>
<!-- A std::unique_ptr can be converted into a std::shared_ptr via a special std::shared_ptr constructor that accepts a std::unique_ptr r-value. The contents of the std::unique_ptr will be moved to the std::shared_ptr. -->

<p>一个 <code>std::unique_ptr</code> 可以被转化成一个 <code>std::shared_ptr</code> 通过一个特殊的构造函数接收右值。<code>std::unique_ptr</code> 持有的内容将会移动给 <code>std::shared_ptr</code>。</p>
<!-- However, std::shared_ptr can not be safely converted to a std::unique_ptr. This means that if you’re creating a function that is going to return a smart pointer, you’re better off returning a std::unique_ptr and assigning it to a std::shared_ptr if and when that’s appropriate. -->

<p>然而，<code>std::shared_ptr</code> 却不能安全的转化成 <code>std::unique_ptr</code>。这意味着如果你正在创建一个函数，该函数返回一个智能指针，你最好返回一个 <code>std::unique_ptr</code> 并且赋值它给一个 <code>std::shared_ptr</code> 如果合适的话。</p>
<h2 id="stdshared_ptr_1">使用 std::shared_ptr 的危险之处<a class="headerlink" href="#stdshared_ptr_1" title="Permanent link">&para;</a></h2>
<!-- The perils of std::shared_ptr -->

<!-- std::shared_ptr has some of the same challenges as std::unique_ptr -- if the std::shared_ptr is not properly disposed of (either because it was dynamically allocated and never deleted, or it was part of an object that was dynamically allocated and never deleted) then the resource it is managing won’t be deallocated either. With std::unique_ptr, you only have to worry about one smart pointer being properly disposed of. With std::shared_ptr, you have to worry about them all. If any of the std::shared_ptr managing a resource are not properly destroyed, the resource will not be deallocated properly. -->

<p><code>std::shared_ptr</code> 有一些和 <code>std::unique_ptr</code> 同样的挑战，如果 <code>std::shared_ptr</code> 没有被合适的处理（可能是因为它被动态分配并且从未删除，或者它作为对象的一部分，被动态分配并从未删除），紧接着它管理的资源也将不会被释放。使用 <code>std::unique_ptr</code>，你仅需要去关注智能指针是否被合适的处理。如果使用 <code>std::shared_ptr</code> ，你不得不担心他们全部。如果任何一个 <code>std::shared_ptr</code> 管理资源没有被合适的清理，资源将不会被释放。</p>
<h2 id="stdshared_ptr_2">std::shared_ptr 和数组<a class="headerlink" href="#stdshared_ptr_2" title="Permanent link">&para;</a></h2>
<!-- std::shared_ptr and arrays -->

<!-- In C++14 and earlier, std::shared_ptr does not have proper support for managing arrays, and should not be used to manage a C-style array. As of C++17, std::shared_ptr does have support for arrays. However, as of C++17, std::make_shared is still lacking proper support for arrays, and should not be used to create shared arrays. This will likely be addressed in C++20. -->

<p>在 C++14 或更早，<code>std::shared_ptr</code> 没办法支持管理数组，并且不应该使用C类型数组。在C++17中， <code>std::shared_ptr</code> 已经支持数组了。然而，在C++17中，<code>std::make_shared</code> 仍然缺乏合适的针对数组的支持，并且不应该被用来创建数组，这会在C++20中被解决。</p>
<h2 id="_1">结论<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<!-- Conclusion -->

<!-- std::shared_ptr is designed for the case where you need multiple smart pointers co-managing the same resource. The resource will be deallocated when the last std::shared_ptr managing the resource is destroyed. -->

<p><code>std::shared_ptr</code> 被设计用于你需要多个智能指针共同管理同样的资源。资源警徽被释放，当最后一个 <code>std::shared_ptr</code> 管理的资源被销毁时。</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../15.5-std%3A%3Aunique_ptr/" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              15.5 std::unique_ptr
            </div>
          </div>
        </a>
      
      
        <a href="../15.7-std%3A%3Aweak_ptr/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              15.7 std::shared_ptr 的循环依赖问题，介绍 std::weak_ptr
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../assets/javascripts/workers/search.217ffd95.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.926459b3.min.js"></script>
      
    
  </body>
</html>