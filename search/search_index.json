{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u76ee\u5f55 \u00b6 \u539f\u6587\u8bf7\u9605\u8bfb learncpp.com \u7ffb\u8bd1\u65e5\u8bb0 \u7b2c\u4e00\u7ae0 \u4ecb\u7ecd ... \u7b2c\u516b\u7ae0 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u57fa\u7840 \u7b2c\u5341\u4e8c\u7ae0 \u865a\u51fd\u6570 \u7b2c\u5341\u4e09\u7ae0 \u6a21\u677f \u7b2c\u5341\u56db\u7ae0 \u5f02\u5e38","title":"\u76ee\u5f55"},{"location":"#_1","text":"\u539f\u6587\u8bf7\u9605\u8bfb learncpp.com \u7ffb\u8bd1\u65e5\u8bb0 \u7b2c\u4e00\u7ae0 \u4ecb\u7ecd ... \u7b2c\u516b\u7ae0 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u57fa\u7840 \u7b2c\u5341\u4e8c\u7ae0 \u865a\u51fd\u6570 \u7b2c\u5341\u4e09\u7ae0 \u6a21\u677f \u7b2c\u5341\u56db\u7ae0 \u5f02\u5e38","title":"\u76ee\u5f55"},{"location":"%E7%BF%BB%E8%AF%91%E6%97%A5%E8%AE%B0/","text":"\u7ffb\u8bd1\u65e5\u8bb0 \u00b6 \u9047\u5230\u5947\u602a\u7684\u3001\u7ed5\u53e3\u7684\u4e1c\u897f\uff0c\u9047\u5230\u5927\u91cf\u91cd\u590d\u7684\u4e1c\u897f\uff0c\u5c31\u4f1a\u88ab\u4f5c\u4e3a\u5178\u8303\u8bb0\u5f55\u5728\u8fd9\u91cc\u3002 That yields the same result as putting all the code in the header, but helps keep things a little cleaner. \u8fd9\u548c\u5c06\u6240\u6709\u4ee3\u7801\u653e\u5728\u5934\u6587\u4ef6\u91cc\u4ea7\u751f\u540c\u6837\u7684\u7ed3\u679c\uff0c\u4f46\u662f\u80fd\u8ba9\u4e8b\u60c5\u66f4\u7b80\u6d01\u3002","title":"\u7ffb\u8bd1\u65e5\u8bb0"},{"location":"%E7%BF%BB%E8%AF%91%E6%97%A5%E8%AE%B0/#_1","text":"\u9047\u5230\u5947\u602a\u7684\u3001\u7ed5\u53e3\u7684\u4e1c\u897f\uff0c\u9047\u5230\u5927\u91cf\u91cd\u590d\u7684\u4e1c\u897f\uff0c\u5c31\u4f1a\u88ab\u4f5c\u4e3a\u5178\u8303\u8bb0\u5f55\u5728\u8fd9\u91cc\u3002 That yields the same result as putting all the code in the header, but helps keep things a little cleaner. \u8fd9\u548c\u5c06\u6240\u6709\u4ee3\u7801\u653e\u5728\u5934\u6587\u4ef6\u91cc\u4ea7\u751f\u540c\u6837\u7684\u7ed3\u679c\uff0c\u4f46\u662f\u80fd\u8ba9\u4e8b\u60c5\u66f4\u7b80\u6d01\u3002","title":"\u7ffb\u8bd1\u65e5\u8bb0"},{"location":"00-Introduction-getting-started/","text":"\u7b2c\u96f6\u7ae0 \u4ecb\u7ecd/\u8d77\u6b65 \u00b6 0.1-\u6559\u7a0b\u4ecb\u7ecd (Introduction to these tutorials)","title":"\u7b2c\u96f6\u7ae0 \u4ecb\u7ecd/\u8d77\u6b65"},{"location":"00-Introduction-getting-started/#_1","text":"0.1-\u6559\u7a0b\u4ecb\u7ecd (Introduction to these tutorials)","title":"\u7b2c\u96f6\u7ae0 \u4ecb\u7ecd/\u8d77\u6b65"},{"location":"00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/","text":"0.1 \u6559\u7a0b\u4ecb\u7ecd \u00b6 Welcome\uff01 \u00b6 \u6b22\u8fce\u6765\u5230\u4e50\u5b66C++\u6559\u7a0b\uff01\u8fd9\u4e00\u7cfb\u5217\u6559\u7a0b\u65e8\u5728\u8ba9\u4f60\u66f4\u8f7b\u677e\u5feb\u4e50\u7684\u5b66\u4f1aC++\u3002 \u548c\u5176\u4ed6\u5927\u591a\u6570\u7f51\u7ad9\u548c\u4e66\u7c4d\u4e0d\u4e00\u6837\uff0c\u5373\u4f7f\u6ca1\u6709\u7f16\u7a0b\u7ecf\u9a8c\u7684\u4eba\u4e5f\u80fd\u653e\u5fc3\u98df\u7528\u672c\u6559\u7a0b\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u6211\u4eec\u4f1a\u901a\u8fc7\u7ed9\u4f60\u5927\u91cf\u7684\u793a\u4f8b\u4ee3\u7801\uff0c\u8ba9\u4f60\u5728\u7f16\u7a0b\u7684\u5b9e\u8df5\u4e2d\u5b66\u4f1aC++\u3002 \u65e0\u8bba\u4f60\u662fC++\u7684\u4e1a\u4f59\u7231\u597d\u8005\u8fd8\u662f\u9760\u5199C++\u5403\u996d\u7684\u5f00\u53d1\u8005\uff0c\u4e0e\u672c\u6559\u7a0b\u7684\u5076\u7136\u9082\u9005\uff0c\u5c06\u4e3a\u4f60\u6307\u5f15C++\u7f16\u7a0b\u7684\u5766\u9014\u3002 \u6559\u7a0b\u7684\u7ed3\u6784 \u00b6 \u5e8f\u7ae0\u7684\u6559\u7a0b\u8ba9\u4f60\u5927\u4f53\u4e0a\u4e86\u89e3C++\u662f\u4ec0\u4e48\uff0c\u5b83\u662f\u600e\u6837\u6a2a\u7a7a\u51fa\u4e16\uff0c\u4e00\u4e2aC++\u7a0b\u5e8f\u662f\u600e\u4e48\u8dd1\u8d77\u6765\u7684\uff0c\u4ee5\u53ca\u2014\u2014\u5728\u4f60\u5f00\u59cb\u52a8\u624b\u7f16\u7a0b\u524d\u9700\u8981\u5b89\u88c5\u7684\u5de5\u5177\u3002\u7136\u540e\uff0c\u6211\u4eec\u4f1a\u6559\u4f1a\u4f60\u521b\u9020\u51fa\u4f60\u7684\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u3002 \u4e4b\u540e\u7684\u6559\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u4e00\u8d77\u63a2\u7d22C++\u8bed\u8a00\u7684\u5404\u4e2a\u90e8\u5206\u3002\u5728\u7b2c\u4e00\u7ae0\uff0c\u4f60\u4f1a\u5bf9C++\u8bed\u8a00\u7684\u5927\u591a\u6570\u91cd\u8981\u6982\u5ff5\u6709\u5168\u800c\u6d45\u7684\u8ba4\u8bc6\uff0c\u7531\u6b64\u4f60\u5f00\u59cb\u6709\u80fd\u529b\u7f16\u5199\u4e00\u4e9b\u7b80\u5355\u7684\u5c0f\u7a0b\u5e8f\u3002\u4e4b\u540e\u7684\u7ae0\u8282\u91cc\u6211\u4eec\u4f1a\u66f4\u6df1\u5165\u7684\u63a2\u8ba8\u8fd9\u4e9b\u6982\u5ff5\uff0c\u4ee5\u53ca\u2014\u2014\u4ecb\u7ecd\u4e00\u4e9b\u5168\u65b0\u7684\u6982\u5ff5\u3002 \u672c\u6559\u7a0b\u7684\u6bcf\u4e00\u4e2a\u7ae0\u8282\u90fd\u6709\u4e00\u4e2a\u4e3b\u9898\uff0c\u7ae0\u8282\u7684\u5185\u5bb9\u5927\u4f53\u4e0a\u56f4\u7ed5\u7740\u8fd9\u4e2a\u4e3b\u9898\u5c55\u5f00\u3002\u6bcf\u4e00\u7ae0\u6ca1\u6709\u56fa\u5b9a\u7684\u5efa\u8bae\u9605\u8bfb\u65f6\u95f4\uff0c\u4ee5\u4f60\u6700\u8212\u9002\u7684\u901f\u5ea6\u524d\u8fdb\u5427\uff01 \u6559\u7a0b\u7684\u76ee\u6807 \u00b6 \u5728\u5f00\u59cb\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u672c\u6559\u7a0b\u7684\u51e0\u4e2a\u91cd\u8981\u76ee\u6807\uff1a \u6db5\u76d6C++\u76f8\u5173\u7684\u5185\u5bb9\u3002 \u4f20\u7edf\u7684\u7f16\u7a0b\u6559\u6750\u5c3d\u7ba1\u5728\u8bb2\u89e3\u7f16\u7a0b\u8bed\u8a00\u8bed\u6cd5\u57fa\u7840\u4e0a\u505a\u7684\u5f88\u8be6\u7ec6\uff0c\u4f46\u4ed6\u4eec\u5f80\u5f80\u5ffd\u89c6\u4e86\u4e00\u4e9b\u8bed\u8a00\u76f8\u5173\u7684\u9644\u52a0\u5185\u5bb9\u3002\u6bd4\u65b9\u8bf4\uff0c\u8fd9\u4e9b\u4e66\u7c4d\u5f80\u5f80\u4f1a\u5728\u7f16\u7801\u98ce\u683c\u3001\u5e38\u89c1\u8bef\u533a\u3001\u8c03\u8bd5\u3001\u7f16\u7a0b\u4e60\u60ef\u7684\u597d\u574f\u3001\u4ee5\u53ca\u4ee3\u7801\u6d4b\u8bd5\u4e0a\u8282\u7701\u7b14\u58a8\u3002\u90a3\u540e\u679c\u5c31\u662f\uff0c\u5f53\u4f60\u8bfb\u5b8c\u8fd9\u4e9b\u4e66\u65f6\uff0c\u4f60\u5927\u4f53\u4e0a\u77e5\u9053\u600e\u4e48\u7528\u8fd9\u95e8\u8bed\u8a00\u8fdb\u884c\u7f16\u7a0b\uff0c\u4f46\u4f60\u53ef\u80fd\u5728\u7f16\u7801\u4e60\u60ef\u548c\u7f16\u7a0b\u98ce\u683c\u4e0a\u4e00\u584c\u7cca\u6d82\uff0c\u8fd9\u4e9b\u4e60\u60ef\u5f80\u5f80\u4f1a\u5728\u672a\u6765\u6210\u4e3a\u4f60\u7f16\u7a0b\u4e4b\u8def\u7684\u7eca\u811a\u77f3\u3002\u672c\u6559\u7a0b\u5c06\u4f1a\u5728\u6bcf\u7ae0\u8282\u6070\u5f53\u7684\u5730\u65b9\u8ba8\u8bba\u8fd9\u4e9b\u9644\u52a0\u7684\u5185\u5bb9\uff0c\u786e\u4fdd\u8bfb\u8005\u5728\u9605\u8bfb\u8fc7\u7a0b\u4e2d\u4e0d\u65ad\u53d7\u5176\u718f\u67d3\uff0c\u6df1\u5165\u4eba\u5fc3\u3002\u5f53\u4f60\u5408\u4e0a\u672c\u6559\u7a0b\u7684\u5c01\u5e95\u65f6\uff0c\u4f60\u4e0d\u4ec5\u4ec5\u5b66\u4f1a\u4e86\u600e\u6837\u7528C++\u7f16\u7a0b\uff0c\u8fd8\u5c06\u77e5\u9053\u4ec0\u4e48\u573a\u666f\u4e0b\u4e0d\u5e94\u4f7f\u7528C++\u7f16\u7a0b\uff0c\u8fd9\u4e24\u8005\u540c\u7b49\u91cd\u8981\uff0c\u4e0d\u53ef\u504f\u5e9f\u3002 \u6d77\u91cf\u4e30\u5bcc\u7684\u4f8b\u5b50\u3002 \u901a\u8fc7\u9605\u8bfb\u5b9e\u4f8b\u4ee3\u7801\uff0c\u5927\u591a\u6570\u4eba\u6216\u591a\u6216\u5c11\u5730\u80fd\u591f\u6709\u6548\u5730\u5b66\u5230\u77e5\u8bc6\u3002\u672c\u6559\u7a0b\u81f4\u529b\u4e8e\u63d0\u4f9b\u5927\u91cf\u6e05\u6670\u7b80\u6d01\u7684\u793a\u4f8b\uff0c\u901a\u8fc7\u793a\u4f8b\u6765\u5b66\u4ee5\u81f4\u7528\u3002\u540c\u65f6\u6211\u4eec\u4e5f\u4f1a\u5c3d\u53ef\u80fd\u907f\u514d\u4e24\u5927\u53d9\u8ff0\u65f6\u7684\u201c\u6076\u9b54\u201d\uff1a\uff0c\u6bd4\u65b9\u8bf4\uff0c the magic hand wave \uff08\u4e5f\u79f0\u4e3a\u2026\u2026<\u6b64\u5904\u7701\u7565\u4e00\u4e07\u5b57>\uff09 \uff0c\u8bf8\u5982\u6b64\u7c7b\u4e3a\u4e86\u8282\u7701\u7a7a\u95f4\uff0c\u628a\u793a\u4f8b\u7684\u4e00\u90e8\u5206\u7ed9\u7701\u6389\u7684\u884c\u4e3a\uff0c\u4ee5\u53ca\uff0c\u5728\u793a\u4f8b\u4e2d\u5f15\u5165\u4e86\u4e00\u4e9b\u65b0\u6982\u5ff5\uff0c\u5374\u4e0d\u5bf9\u8fd9\u4e9b\u6982\u5ff5\u8fdb\u884c\u89e3\u91ca\u8bf4\u660e\u7684\u884c\u5f84\u3002\u6211\u4eec\u4f1a\u5c3d\u91cf\u907f\u514d\u8fd9\u79cd\u5bb9\u6613\u8ba9\u8bfb\u8005\u5728\u9605\u8bfb\u4e2d\u5361\u4f4f\u7684\u53d9\u8ff0\u65b9\u5f0f\u3002 \u5927\u91cf\u7528\u4e8e\u7ec3\u4e60\u7684\u7a0b\u5e8f \u672c\u6559\u7a0b\u6bcf\u7ae0\u8282\u7684\u7ed3\u5c3e\u4f1a\u6db5\u76d6\u4e00\u90e8\u5206\u5e26\u7b54\u6848\u7684\u7ec3\u4e60\u9898\uff0c\u8bfb\u8005\u53ef\u4ee5\u5c1d\u8bd5\u81ea\u5df1\u8fdb\u884c\u7ec3\u4e60\uff0c\u5e76\u628a\u4f60\u7684\u7b54\u6848\u548c\u6211\u4eec\u63d0\u4f9b\u7684\u7b54\u6848\u8fdb\u884c\u5bf9\u6bd4\u601d\u8003\uff0c\u6216\u8005\u8bf4\u5f53\u4f60\u5361\u5728\u67d0\u9053\u9898\u7684\u65f6\u5019\u770b\u4e00\u770b\u6211\u4eec\u63d0\u4f9b\u7684\u601d\u8def\u3002\u63a5\u7740\uff0c\u4f60\u53ef\u4ee5\u56de\u5230\u4f60\u9700\u8981\u505a\u66f4\u591a\u529f\u8bfe\u7684\u5730\u65b9\u8fdb\u884c\u5b66\u4e60\u3002 \u6700\u91cd\u8981\u7684\u4e8b\uff1a\u73a9\u5f97\u5f00\u5fc3\u3002\u7f16\u7a0b\u672c\u8eab\u662f\u4e00\u4ef6\u5145\u6ee1\u4e50\u8da3\u7684\u4e8b\u60c5\uff0c\u5982\u679c\u4f60\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u65e0\u6bd4\u75db\u82e6\uff0c\u8bf4\u660e\u4f60\u8fd8\u6ca1\u6709\u771f\u6b63\u6478\u5230\u6b64\u4e2d\u7684\u95e8\u9053\u3002\u75b2\u60eb\u3001\u751a\u81f3\u95f7\u95f7\u4e0d\u4e50\u7684\u7a0b\u5e8f\u5458\u5f80\u5f80\u4f1a\u8c2c\u8bef\u4e0d\u65ad\uff0c\u5e76\u4e14\u4e0e\u5176\u8c03\u8bd5\u7a0b\u5e8f\u82b1\u8d39\u5927\u91cf\u7684\u65f6\u95f4\uff0c\u4e0d\u5982\u4e00\u5f00\u59cb\u6211\u4eec\u5c31\u5199\u51fa\u63a5\u8fd1\u5b8c\u7f8e\u7684\u4ee3\u7801\u3002\u53e6\u5916\uff0c\u4e0d\u8981\u8fc7\u52b3\u7f16\u7a0b\uff0c\u5c0f\u61a9\u7247\u523b\u6216\u8005\u9163\u7761\u81f3\u4e1c\u65b9\u53d1\u767d\uff0c\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c06\u5728\u6668\u5149\u71b9\u5fae\u65f6\u95ea\u73b0\u5728\u4f60\u7684\u8111\u6d77\u91cc\u3002 \u5145\u5206\u5229\u7528\u672c\u6559\u7a0b \u00b6 \u5728\u4f60\u5b66\u4e60\u672c\u6559\u7a0b\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u6709\u4e00\u4e9b\u5c0f\u5c0f\u7684\u5efa\u8bae\u4e5f\u8bb8\u53ef\u4ee5\u8ba9\u4f60\u5b66\u4e60\u7684\u6536\u76ca\u6700\u5927\u5316\uff1a \u4eb2\u81ea\u628a\u793a\u4f8b\u7684\u4ee3\u7801\u624b\u6253\u4e00\u904d\u5e76\u4e14\u7f16\u8bd1\u8fd0\u884c\uff0c\u4e0d\u8981\u590d\u5236\u7c98\u8d34\uff01\u8fd9\u4f1a\u5e2e\u52a9\u4f60\u77e5\u9053\u54ea\u4e9b\u5730\u65b9\u4f60\u5bb9\u6613\u51fa\u9519\uff0c\u5e76\u4e14\u8ba9\u4f60\u5bf9\u5e38\u89c1\u7684\u7f16\u8bd1\u8b66\u544a\u548c\u9519\u8bef\u719f\u6089\u3002\u4e0d\u8981\u65e0\u8111\u7684copy\u4ee3\u7801\uff0c\u5f53\u4f60\u624b\u6253\u6bcf\u4e00\u884c\u4ee3\u7801\u65f6\uff0c\u4f60\u90fd\u8981\u601d\u8003\u5b83\u4eec\u505a\u4e86\u4ec0\u4e48\uff0c\u5b9e\u73b0\u4e86\u7a0b\u5e8f\u7684\u54ea\u4e9b\u529f\u80fd\u3002\u5f53\u4f60\u9047\u5230\u4e00\u4e9b\u4e0d\u80fd\u7406\u89e3\u6216\u8005\u4f60\u8ba4\u4e3a\u4e0d\u5408\u7406\u7684\u4e1c\u897f\u65f6\uff0c\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u4f60\u8fdb\u4e00\u6b65\u67e5\u9605\u8d44\u6599\uff0c\u6df1\u5165\u8c03\u7814\u3002 \u5728\u7f16\u7a0b\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u4f1a\u72af\u4e0b\u8c2c\u8bef\u6216\u8005\u4ea7\u751fbug\u3002\u5728\u5bfb\u6c42\u5927\u4f6c\u5e2e\u52a9\u524d\uff0c\u5c3d\u91cf\u5c1d\u8bd5\u81ea\u5df1\u53bb\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002bug\u7684\u67e5\u627e\u4ee5\u53ca\u4fee\u590d\u4e5f\u662f\u4e00\u4e2a\u597d\u7684\u7a0b\u5e8f\u5458\u7684\u5173\u952e\u6280\u80fd\u3002\u522b\u5fd8\u4e86\u5b66\u4e60\u4f7f\u7528\u8c03\u8bd5\u5668\uff08\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u4e2d\u8bb2\u89e3\u4f7f\u7528\u65b9\u6cd5\uff09\u2014\u2014\u4e00\u79cd\u80fd\u5e2e\u4f60\u627e\u5230bug\u4f4d\u7f6e\u7684\u5173\u952e\u5de5\u5177\u3002 \u5bf9\u793a\u4f8b\u4ee3\u7801\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u5b9e\u9a8c\u3002\u5c1d\u8bd5\u4fee\u6539\u793a\u4f8b\u4e2d\u7684\u6570\u636e\u548c\u6587\u672c\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff0c\u4fee\u6539\u4ee3\u7801\u7684\u903b\u8f91\u4ee5\u8fdb\u4e00\u6b65\u5b9e\u73b0\u65b0\u7684\u529f\u80fd\uff08\u6bd4\u5982\u8bf4\uff0c\u539f\u6765\u7a0b\u5e8f\u662f\u8ba1\u7b97\u4e24\u6570\u548c\uff0c\u6211\u4eec\u8ba9\u4ed6\u53ef\u4ee5\u8ba1\u7b97\u4e09\u4e2a\u6570\u7684\u548c\uff09\u3002\u60f3\u4e0d\u540c\u7684\u529e\u6cd5\u8ba9\u7a0b\u5e8f\u7ec8\u6b62\u8fd0\u884c\uff08\u5982\u679c\u7a0b\u5e8f\u8981\u6c42\u7528\u6237\u8f93\u5165\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u5404\u79cd\u8f93\u5165\uff09\u3002\u901a\u8fc7\u4fee\u6539\u793a\u4f8b\u7a0b\u5e8f\u8fdb\u884c\u5b9e\u9a8c\uff0c\u4f60\u4f1a\u6bd4\u4ec5\u4ec5\u53ea\u4f7f\u7528\u5b9e\u4f8b\u7a0b\u5e8f\u5b66\u5230\u66f4\u591a\u4e1c\u897f\u3002 \u82b1\u70b9\u65f6\u95f4\u5b8c\u6210\u5c0f\u6d4b\u9a8c\u3002\u5982\u679c\u4f60\u662f\u7f16\u7a0b\u83dc\u9e21\uff0c\u4f60\u53ef\u80fd\u4f1a\u89c9\u5f97\u4ed6\u4eec\u6709\u70b9\u96be\u5ea6\uff08\u8fd9\u5f88\u6b63\u5e38\uff0c\u56e0\u4e3a\u4f60\u7684\u5927\u8111\u5728\u4e0d\u65ad\u9002\u5e94\u7f16\u7a0b\u7684\u601d\u7ef4\uff09\u3002\u5982\u679c\u4e00\u6b21\u6ca1\u6709\u505a\u5bf9\u4e5f\u4e0d\u8981\u6cae\u4e27\uff0c\u518d\u8bd5\u51e0\u6b21\u4f60\u6ca1\u51c6\u5c31\u4f1a\u6210\u529f\u3002\u5982\u679c\u4f60\u786e\u5b9e\u5361\u4f4f\u4e86\uff0c\u770b\u770b\u7b54\u6848\u4e5f\u662f\u65e0\u6240\u8c13\u7684\u3002\u53ea\u8981\u786e\u4fdd\u4f60\u7406\u89e3\u4e86\u7b54\u6848\u7684\u5185\u5bb9\u548c\u539f\u7406\u3002 \u7528\u4f60\u5b66\u5230\u7684\u6982\u5ff5\u5199\u4f60\u81ea\u5df1\u7684\u5c0f\u7a0b\u5e8f\u3002\u7eb8\u4e0a\u5f97\u6765\u7ec8\u89c9\u6d45\uff0c\u7edd\u77e5\u6b64\u4e8b\u8981\u8eac\u884c\u3002 \u7f51\u7ad9\u76f8\u5173\uff08\u6307 learncpp.com \uff09 \u00b6 \u95ee\uff1a\u7f51\u7ad9\u600e\u4e48\u6ce8\u518c\uff1f\u600e\u6837\u624d\u80fd\u767b\u5f55\uff1f \u7b54 \uff1a\u672c\u7ad9\u7684\u6240\u6709\u5185\u5bb9\u90fd\u80fd\u514d\u767b\u5f55\u6d4f\u89c8\u2014\u2014\u6240\u4ee5\uff0c\u65e0\u9700\u6ce8\u518c\uff01 \u95ee\uff1a\u8fd9\u4e9b\u6559\u7a0b\u6700\u65e92007\u5e74\u7f16\u5199\u7684\uff0c\u73b0\u5728\u8fd8\u80fd\u7528\u5417\uff1f \u7b54 \uff1a\u5f53\u7136\uff0c\u80af\u5b9a\u53ef\u4ee5\u7528\u3002 C++\u7684\u6807\u51c6\u4fee\u8ba2\u5e76\u975e\u7279\u522b\u9891\u7e41\uff0c\u5373\u4f7f\u6709\u53d8\u5316\uff0c\u4e5f\u662f\u5728\u539f\u6765\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u65b0\u7684\u7279\u6027\u3002\u5f53\u7136\uff0c\u672c\u6559\u7a0b\u4e5f\u4f1a\u968f\u7740\u8bed\u8a00\u6807\u51c6\u53d8\u5316\u548c\u8bfb\u8005\u53cd\u9988\u5b9a\u671f\u66f4\u65b0\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u7684\u6559\u7a0b\u6709pdf\u7248\u672c\u4f9b\u79bb\u7ebf\u9605\u8bfb\u5417\uff1f \u7b54\uff1a\u62b1\u6b49\uff0c\u8fd9\u4e2a\u6ca1\u6709\u3002\u672c\u7f51\u7ad9\u514d\u8d39\u5f00\u53d1\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u53d7\u5e7f\u544a\u5546\u8d5e\u52a9\u2014\u2014\u800cpdf\u7248\u672c\u65e0\u6cd5\u6295\u5165\u5e7f\u544a\u3002\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u628a\u672c\u7ad9\u4e0a\u7684\u7f51\u9875\u8f6c\u6362\u4e3apdf\u505a\u79c1\u4eba\u7528\u9014\uff0c\u53ea\u8981\u4e0d\u628apdf\u7248\u672c\u4f20\u64ad\u51fa\u53bb\u5c31ok\u4e86\u3002 \u95ee\uff1a\u5982\u679c\u6211\u5361\u5728\u67d0\u4e2a\u6982\u5ff5\u4e86\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5982\u679c\u4f60\u5bf9\u67d0\u4e00\u90e8\u5206\u4e0d\u592a\u660e\u767d\uff0c\u4f60\u53ef\u4ee5\uff1a \u9605\u8bfb\u8bc4\u8bba\u3002\u5176\u4ed6\u7684\u8bfb\u8005\u53ef\u80fd\u4e5f\u9047\u5230\u4e86\u76f8\u4f3c\u7684\u95ee\u9898\u3002 \u7c97\u8bfb\u4e0b\u4e00\u7ae0\u7684\u6559\u7a0b\u2014\u2014\u8bf4\u4e0d\u5b9a\u4f60\u7684\u7591\u60d1\u4f1a\u5728\u90a3\u91cc\u5f97\u5230\u89e3\u7b54\u3002 \u5584\u7528\u641c\u7d22\u5f15\u64ce\u67e5\u627e\u4f60\u7684\u95ee\u9898\u3002 \u5728\u7c7b\u4f3c StackOverflow \u7684\u95ee\u7b54\u7f51\u7ad9\u4e0a\u63d0\u95ee\u3002 \u5982\u679c\u90fd\u6ca1\u7528\u7684\u8bdd\uff0c\u6682\u65f6\u8df3\u8fc7\u8fd9\u4e00\u90e8\u5206\u4e0d\u61c2\u7684\u5185\u5bb9\uff0c\u4ee5\u5f85\u5c06\u6765\u7ffb\u770b\u3002\u5230\u90a3\u65f6\u4f60\u53ef\u80fd\u4f1a\u53d1\u73b0\uff0c\u5728\u5b66\u4e60\u4e86\u5176\u4ed6\u7ae0\u7684\u77e5\u8bc6\u548c\u6587\u7ae0\u4ee5\u540e\uff0c\u518d\u56de\u5934\u6765\u770b\uff0c\u66fe\u7ecf\u8270\u6da9\u96be\u61c2\u7684\u4e1c\u897f\u4e00\u4e0b\u5b50\u8305\u585e\u987f\u5f00\u3002 \u95ee\uff1a\u5982\u679c\u6211\u9057\u5fd8\u4e86\u67d0\u4e2a\u6982\u5ff5\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5584\u7528 \u4e3b\u9875\u7d22\u5f15 ,\u67e5\u627e\u4f60\u9700\u8981\u4e86\u89e3\u7684\u6982\u5ff5\uff0c\u4f60\u4f1a\u627e\u5230\u8bb2\u89e3\u76f8\u5173\u77e5\u8bc6\u7684\u7ae0\u8282\u3002 \u95ee\uff1a\u600e\u4e48\u80fd\u5728\u8bc4\u8bba\u533a\u5e26\u5934\u50cf\u8bc4\u8bba\uff1f \u8bc4\u8bba\u533a\u4f7f\u7528\u4e86gravatars\u3002\u4f60\u53ef\u4ee5\u5728 gravatar.com \u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u3002\u70b9\u51fb\u201cCreate your own gravatar\u201d\u6309\u94ae\u5e76\u6ce8\u518c\u3002\u4f60\u7684gravatar\u8d26\u6237\u5c06\u4e0e\u4f60\u7684\u90ae\u7bb1\uff08\u53ef\u9009\uff09\u5173\u8054\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u6709\u9ed1\u591c\u6a21\u5f0f\u5417\uff1f \u7b54\uff1a\u6ca1\u6709\u81ea\u5e26\u7684\u3002\u4f46\u4f60\u80fd\u624b\u52a8\u641e\u4e00\u641e\uff0c\u8be6\u89c1 darkreader.org \u6700\u540e\uff0c\u4e00\u4e2a\u5c0f\u5c0f\u7684\u4e0d\u60c5\u4e4b\u8bf7\uff1a\u672c\u7f51\u7ad9\u56e0\u5e7f\u544a\u5546\u8d5e\u52a9\u800c\u5f97\u4ee5\u514d\u8d39\u3002\u5982\u679c\u4f60\u559c\u6b22\u672c\u7f51\u7ad9\u7684\u8bfe\u7a0b\uff0c\u53ef\u8003\u8651\u5173\u95ed\u5e7f\u544a\u62e6\u622a\u5668\u6765\u652f\u6301\u6211\u4eec\u3002 \u597d\u7684\uff0c\u4e00\u5207\u5c31\u7eea\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u5427\uff01","title":"0.1 \u6559\u7a0b\u4ecb\u7ecd"},{"location":"00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#01","text":"","title":"0.1 \u6559\u7a0b\u4ecb\u7ecd"},{"location":"00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#welcome","text":"\u6b22\u8fce\u6765\u5230\u4e50\u5b66C++\u6559\u7a0b\uff01\u8fd9\u4e00\u7cfb\u5217\u6559\u7a0b\u65e8\u5728\u8ba9\u4f60\u66f4\u8f7b\u677e\u5feb\u4e50\u7684\u5b66\u4f1aC++\u3002 \u548c\u5176\u4ed6\u5927\u591a\u6570\u7f51\u7ad9\u548c\u4e66\u7c4d\u4e0d\u4e00\u6837\uff0c\u5373\u4f7f\u6ca1\u6709\u7f16\u7a0b\u7ecf\u9a8c\u7684\u4eba\u4e5f\u80fd\u653e\u5fc3\u98df\u7528\u672c\u6559\u7a0b\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u6211\u4eec\u4f1a\u901a\u8fc7\u7ed9\u4f60\u5927\u91cf\u7684\u793a\u4f8b\u4ee3\u7801\uff0c\u8ba9\u4f60\u5728\u7f16\u7a0b\u7684\u5b9e\u8df5\u4e2d\u5b66\u4f1aC++\u3002 \u65e0\u8bba\u4f60\u662fC++\u7684\u4e1a\u4f59\u7231\u597d\u8005\u8fd8\u662f\u9760\u5199C++\u5403\u996d\u7684\u5f00\u53d1\u8005\uff0c\u4e0e\u672c\u6559\u7a0b\u7684\u5076\u7136\u9082\u9005\uff0c\u5c06\u4e3a\u4f60\u6307\u5f15C++\u7f16\u7a0b\u7684\u5766\u9014\u3002","title":"Welcome\uff01"},{"location":"00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#_1","text":"\u5e8f\u7ae0\u7684\u6559\u7a0b\u8ba9\u4f60\u5927\u4f53\u4e0a\u4e86\u89e3C++\u662f\u4ec0\u4e48\uff0c\u5b83\u662f\u600e\u6837\u6a2a\u7a7a\u51fa\u4e16\uff0c\u4e00\u4e2aC++\u7a0b\u5e8f\u662f\u600e\u4e48\u8dd1\u8d77\u6765\u7684\uff0c\u4ee5\u53ca\u2014\u2014\u5728\u4f60\u5f00\u59cb\u52a8\u624b\u7f16\u7a0b\u524d\u9700\u8981\u5b89\u88c5\u7684\u5de5\u5177\u3002\u7136\u540e\uff0c\u6211\u4eec\u4f1a\u6559\u4f1a\u4f60\u521b\u9020\u51fa\u4f60\u7684\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u3002 \u4e4b\u540e\u7684\u6559\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u4e00\u8d77\u63a2\u7d22C++\u8bed\u8a00\u7684\u5404\u4e2a\u90e8\u5206\u3002\u5728\u7b2c\u4e00\u7ae0\uff0c\u4f60\u4f1a\u5bf9C++\u8bed\u8a00\u7684\u5927\u591a\u6570\u91cd\u8981\u6982\u5ff5\u6709\u5168\u800c\u6d45\u7684\u8ba4\u8bc6\uff0c\u7531\u6b64\u4f60\u5f00\u59cb\u6709\u80fd\u529b\u7f16\u5199\u4e00\u4e9b\u7b80\u5355\u7684\u5c0f\u7a0b\u5e8f\u3002\u4e4b\u540e\u7684\u7ae0\u8282\u91cc\u6211\u4eec\u4f1a\u66f4\u6df1\u5165\u7684\u63a2\u8ba8\u8fd9\u4e9b\u6982\u5ff5\uff0c\u4ee5\u53ca\u2014\u2014\u4ecb\u7ecd\u4e00\u4e9b\u5168\u65b0\u7684\u6982\u5ff5\u3002 \u672c\u6559\u7a0b\u7684\u6bcf\u4e00\u4e2a\u7ae0\u8282\u90fd\u6709\u4e00\u4e2a\u4e3b\u9898\uff0c\u7ae0\u8282\u7684\u5185\u5bb9\u5927\u4f53\u4e0a\u56f4\u7ed5\u7740\u8fd9\u4e2a\u4e3b\u9898\u5c55\u5f00\u3002\u6bcf\u4e00\u7ae0\u6ca1\u6709\u56fa\u5b9a\u7684\u5efa\u8bae\u9605\u8bfb\u65f6\u95f4\uff0c\u4ee5\u4f60\u6700\u8212\u9002\u7684\u901f\u5ea6\u524d\u8fdb\u5427\uff01","title":"\u6559\u7a0b\u7684\u7ed3\u6784"},{"location":"00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#_2","text":"\u5728\u5f00\u59cb\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u672c\u6559\u7a0b\u7684\u51e0\u4e2a\u91cd\u8981\u76ee\u6807\uff1a \u6db5\u76d6C++\u76f8\u5173\u7684\u5185\u5bb9\u3002 \u4f20\u7edf\u7684\u7f16\u7a0b\u6559\u6750\u5c3d\u7ba1\u5728\u8bb2\u89e3\u7f16\u7a0b\u8bed\u8a00\u8bed\u6cd5\u57fa\u7840\u4e0a\u505a\u7684\u5f88\u8be6\u7ec6\uff0c\u4f46\u4ed6\u4eec\u5f80\u5f80\u5ffd\u89c6\u4e86\u4e00\u4e9b\u8bed\u8a00\u76f8\u5173\u7684\u9644\u52a0\u5185\u5bb9\u3002\u6bd4\u65b9\u8bf4\uff0c\u8fd9\u4e9b\u4e66\u7c4d\u5f80\u5f80\u4f1a\u5728\u7f16\u7801\u98ce\u683c\u3001\u5e38\u89c1\u8bef\u533a\u3001\u8c03\u8bd5\u3001\u7f16\u7a0b\u4e60\u60ef\u7684\u597d\u574f\u3001\u4ee5\u53ca\u4ee3\u7801\u6d4b\u8bd5\u4e0a\u8282\u7701\u7b14\u58a8\u3002\u90a3\u540e\u679c\u5c31\u662f\uff0c\u5f53\u4f60\u8bfb\u5b8c\u8fd9\u4e9b\u4e66\u65f6\uff0c\u4f60\u5927\u4f53\u4e0a\u77e5\u9053\u600e\u4e48\u7528\u8fd9\u95e8\u8bed\u8a00\u8fdb\u884c\u7f16\u7a0b\uff0c\u4f46\u4f60\u53ef\u80fd\u5728\u7f16\u7801\u4e60\u60ef\u548c\u7f16\u7a0b\u98ce\u683c\u4e0a\u4e00\u584c\u7cca\u6d82\uff0c\u8fd9\u4e9b\u4e60\u60ef\u5f80\u5f80\u4f1a\u5728\u672a\u6765\u6210\u4e3a\u4f60\u7f16\u7a0b\u4e4b\u8def\u7684\u7eca\u811a\u77f3\u3002\u672c\u6559\u7a0b\u5c06\u4f1a\u5728\u6bcf\u7ae0\u8282\u6070\u5f53\u7684\u5730\u65b9\u8ba8\u8bba\u8fd9\u4e9b\u9644\u52a0\u7684\u5185\u5bb9\uff0c\u786e\u4fdd\u8bfb\u8005\u5728\u9605\u8bfb\u8fc7\u7a0b\u4e2d\u4e0d\u65ad\u53d7\u5176\u718f\u67d3\uff0c\u6df1\u5165\u4eba\u5fc3\u3002\u5f53\u4f60\u5408\u4e0a\u672c\u6559\u7a0b\u7684\u5c01\u5e95\u65f6\uff0c\u4f60\u4e0d\u4ec5\u4ec5\u5b66\u4f1a\u4e86\u600e\u6837\u7528C++\u7f16\u7a0b\uff0c\u8fd8\u5c06\u77e5\u9053\u4ec0\u4e48\u573a\u666f\u4e0b\u4e0d\u5e94\u4f7f\u7528C++\u7f16\u7a0b\uff0c\u8fd9\u4e24\u8005\u540c\u7b49\u91cd\u8981\uff0c\u4e0d\u53ef\u504f\u5e9f\u3002 \u6d77\u91cf\u4e30\u5bcc\u7684\u4f8b\u5b50\u3002 \u901a\u8fc7\u9605\u8bfb\u5b9e\u4f8b\u4ee3\u7801\uff0c\u5927\u591a\u6570\u4eba\u6216\u591a\u6216\u5c11\u5730\u80fd\u591f\u6709\u6548\u5730\u5b66\u5230\u77e5\u8bc6\u3002\u672c\u6559\u7a0b\u81f4\u529b\u4e8e\u63d0\u4f9b\u5927\u91cf\u6e05\u6670\u7b80\u6d01\u7684\u793a\u4f8b\uff0c\u901a\u8fc7\u793a\u4f8b\u6765\u5b66\u4ee5\u81f4\u7528\u3002\u540c\u65f6\u6211\u4eec\u4e5f\u4f1a\u5c3d\u53ef\u80fd\u907f\u514d\u4e24\u5927\u53d9\u8ff0\u65f6\u7684\u201c\u6076\u9b54\u201d\uff1a\uff0c\u6bd4\u65b9\u8bf4\uff0c the magic hand wave \uff08\u4e5f\u79f0\u4e3a\u2026\u2026<\u6b64\u5904\u7701\u7565\u4e00\u4e07\u5b57>\uff09 \uff0c\u8bf8\u5982\u6b64\u7c7b\u4e3a\u4e86\u8282\u7701\u7a7a\u95f4\uff0c\u628a\u793a\u4f8b\u7684\u4e00\u90e8\u5206\u7ed9\u7701\u6389\u7684\u884c\u4e3a\uff0c\u4ee5\u53ca\uff0c\u5728\u793a\u4f8b\u4e2d\u5f15\u5165\u4e86\u4e00\u4e9b\u65b0\u6982\u5ff5\uff0c\u5374\u4e0d\u5bf9\u8fd9\u4e9b\u6982\u5ff5\u8fdb\u884c\u89e3\u91ca\u8bf4\u660e\u7684\u884c\u5f84\u3002\u6211\u4eec\u4f1a\u5c3d\u91cf\u907f\u514d\u8fd9\u79cd\u5bb9\u6613\u8ba9\u8bfb\u8005\u5728\u9605\u8bfb\u4e2d\u5361\u4f4f\u7684\u53d9\u8ff0\u65b9\u5f0f\u3002 \u5927\u91cf\u7528\u4e8e\u7ec3\u4e60\u7684\u7a0b\u5e8f \u672c\u6559\u7a0b\u6bcf\u7ae0\u8282\u7684\u7ed3\u5c3e\u4f1a\u6db5\u76d6\u4e00\u90e8\u5206\u5e26\u7b54\u6848\u7684\u7ec3\u4e60\u9898\uff0c\u8bfb\u8005\u53ef\u4ee5\u5c1d\u8bd5\u81ea\u5df1\u8fdb\u884c\u7ec3\u4e60\uff0c\u5e76\u628a\u4f60\u7684\u7b54\u6848\u548c\u6211\u4eec\u63d0\u4f9b\u7684\u7b54\u6848\u8fdb\u884c\u5bf9\u6bd4\u601d\u8003\uff0c\u6216\u8005\u8bf4\u5f53\u4f60\u5361\u5728\u67d0\u9053\u9898\u7684\u65f6\u5019\u770b\u4e00\u770b\u6211\u4eec\u63d0\u4f9b\u7684\u601d\u8def\u3002\u63a5\u7740\uff0c\u4f60\u53ef\u4ee5\u56de\u5230\u4f60\u9700\u8981\u505a\u66f4\u591a\u529f\u8bfe\u7684\u5730\u65b9\u8fdb\u884c\u5b66\u4e60\u3002 \u6700\u91cd\u8981\u7684\u4e8b\uff1a\u73a9\u5f97\u5f00\u5fc3\u3002\u7f16\u7a0b\u672c\u8eab\u662f\u4e00\u4ef6\u5145\u6ee1\u4e50\u8da3\u7684\u4e8b\u60c5\uff0c\u5982\u679c\u4f60\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u65e0\u6bd4\u75db\u82e6\uff0c\u8bf4\u660e\u4f60\u8fd8\u6ca1\u6709\u771f\u6b63\u6478\u5230\u6b64\u4e2d\u7684\u95e8\u9053\u3002\u75b2\u60eb\u3001\u751a\u81f3\u95f7\u95f7\u4e0d\u4e50\u7684\u7a0b\u5e8f\u5458\u5f80\u5f80\u4f1a\u8c2c\u8bef\u4e0d\u65ad\uff0c\u5e76\u4e14\u4e0e\u5176\u8c03\u8bd5\u7a0b\u5e8f\u82b1\u8d39\u5927\u91cf\u7684\u65f6\u95f4\uff0c\u4e0d\u5982\u4e00\u5f00\u59cb\u6211\u4eec\u5c31\u5199\u51fa\u63a5\u8fd1\u5b8c\u7f8e\u7684\u4ee3\u7801\u3002\u53e6\u5916\uff0c\u4e0d\u8981\u8fc7\u52b3\u7f16\u7a0b\uff0c\u5c0f\u61a9\u7247\u523b\u6216\u8005\u9163\u7761\u81f3\u4e1c\u65b9\u53d1\u767d\uff0c\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u5c06\u5728\u6668\u5149\u71b9\u5fae\u65f6\u95ea\u73b0\u5728\u4f60\u7684\u8111\u6d77\u91cc\u3002","title":"\u6559\u7a0b\u7684\u76ee\u6807"},{"location":"00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#_3","text":"\u5728\u4f60\u5b66\u4e60\u672c\u6559\u7a0b\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u6709\u4e00\u4e9b\u5c0f\u5c0f\u7684\u5efa\u8bae\u4e5f\u8bb8\u53ef\u4ee5\u8ba9\u4f60\u5b66\u4e60\u7684\u6536\u76ca\u6700\u5927\u5316\uff1a \u4eb2\u81ea\u628a\u793a\u4f8b\u7684\u4ee3\u7801\u624b\u6253\u4e00\u904d\u5e76\u4e14\u7f16\u8bd1\u8fd0\u884c\uff0c\u4e0d\u8981\u590d\u5236\u7c98\u8d34\uff01\u8fd9\u4f1a\u5e2e\u52a9\u4f60\u77e5\u9053\u54ea\u4e9b\u5730\u65b9\u4f60\u5bb9\u6613\u51fa\u9519\uff0c\u5e76\u4e14\u8ba9\u4f60\u5bf9\u5e38\u89c1\u7684\u7f16\u8bd1\u8b66\u544a\u548c\u9519\u8bef\u719f\u6089\u3002\u4e0d\u8981\u65e0\u8111\u7684copy\u4ee3\u7801\uff0c\u5f53\u4f60\u624b\u6253\u6bcf\u4e00\u884c\u4ee3\u7801\u65f6\uff0c\u4f60\u90fd\u8981\u601d\u8003\u5b83\u4eec\u505a\u4e86\u4ec0\u4e48\uff0c\u5b9e\u73b0\u4e86\u7a0b\u5e8f\u7684\u54ea\u4e9b\u529f\u80fd\u3002\u5f53\u4f60\u9047\u5230\u4e00\u4e9b\u4e0d\u80fd\u7406\u89e3\u6216\u8005\u4f60\u8ba4\u4e3a\u4e0d\u5408\u7406\u7684\u4e1c\u897f\u65f6\uff0c\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u4f60\u8fdb\u4e00\u6b65\u67e5\u9605\u8d44\u6599\uff0c\u6df1\u5165\u8c03\u7814\u3002 \u5728\u7f16\u7a0b\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u4f1a\u72af\u4e0b\u8c2c\u8bef\u6216\u8005\u4ea7\u751fbug\u3002\u5728\u5bfb\u6c42\u5927\u4f6c\u5e2e\u52a9\u524d\uff0c\u5c3d\u91cf\u5c1d\u8bd5\u81ea\u5df1\u53bb\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002bug\u7684\u67e5\u627e\u4ee5\u53ca\u4fee\u590d\u4e5f\u662f\u4e00\u4e2a\u597d\u7684\u7a0b\u5e8f\u5458\u7684\u5173\u952e\u6280\u80fd\u3002\u522b\u5fd8\u4e86\u5b66\u4e60\u4f7f\u7528\u8c03\u8bd5\u5668\uff08\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u4e2d\u8bb2\u89e3\u4f7f\u7528\u65b9\u6cd5\uff09\u2014\u2014\u4e00\u79cd\u80fd\u5e2e\u4f60\u627e\u5230bug\u4f4d\u7f6e\u7684\u5173\u952e\u5de5\u5177\u3002 \u5bf9\u793a\u4f8b\u4ee3\u7801\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u5b9e\u9a8c\u3002\u5c1d\u8bd5\u4fee\u6539\u793a\u4f8b\u4e2d\u7684\u6570\u636e\u548c\u6587\u672c\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff0c\u4fee\u6539\u4ee3\u7801\u7684\u903b\u8f91\u4ee5\u8fdb\u4e00\u6b65\u5b9e\u73b0\u65b0\u7684\u529f\u80fd\uff08\u6bd4\u5982\u8bf4\uff0c\u539f\u6765\u7a0b\u5e8f\u662f\u8ba1\u7b97\u4e24\u6570\u548c\uff0c\u6211\u4eec\u8ba9\u4ed6\u53ef\u4ee5\u8ba1\u7b97\u4e09\u4e2a\u6570\u7684\u548c\uff09\u3002\u60f3\u4e0d\u540c\u7684\u529e\u6cd5\u8ba9\u7a0b\u5e8f\u7ec8\u6b62\u8fd0\u884c\uff08\u5982\u679c\u7a0b\u5e8f\u8981\u6c42\u7528\u6237\u8f93\u5165\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u5404\u79cd\u8f93\u5165\uff09\u3002\u901a\u8fc7\u4fee\u6539\u793a\u4f8b\u7a0b\u5e8f\u8fdb\u884c\u5b9e\u9a8c\uff0c\u4f60\u4f1a\u6bd4\u4ec5\u4ec5\u53ea\u4f7f\u7528\u5b9e\u4f8b\u7a0b\u5e8f\u5b66\u5230\u66f4\u591a\u4e1c\u897f\u3002 \u82b1\u70b9\u65f6\u95f4\u5b8c\u6210\u5c0f\u6d4b\u9a8c\u3002\u5982\u679c\u4f60\u662f\u7f16\u7a0b\u83dc\u9e21\uff0c\u4f60\u53ef\u80fd\u4f1a\u89c9\u5f97\u4ed6\u4eec\u6709\u70b9\u96be\u5ea6\uff08\u8fd9\u5f88\u6b63\u5e38\uff0c\u56e0\u4e3a\u4f60\u7684\u5927\u8111\u5728\u4e0d\u65ad\u9002\u5e94\u7f16\u7a0b\u7684\u601d\u7ef4\uff09\u3002\u5982\u679c\u4e00\u6b21\u6ca1\u6709\u505a\u5bf9\u4e5f\u4e0d\u8981\u6cae\u4e27\uff0c\u518d\u8bd5\u51e0\u6b21\u4f60\u6ca1\u51c6\u5c31\u4f1a\u6210\u529f\u3002\u5982\u679c\u4f60\u786e\u5b9e\u5361\u4f4f\u4e86\uff0c\u770b\u770b\u7b54\u6848\u4e5f\u662f\u65e0\u6240\u8c13\u7684\u3002\u53ea\u8981\u786e\u4fdd\u4f60\u7406\u89e3\u4e86\u7b54\u6848\u7684\u5185\u5bb9\u548c\u539f\u7406\u3002 \u7528\u4f60\u5b66\u5230\u7684\u6982\u5ff5\u5199\u4f60\u81ea\u5df1\u7684\u5c0f\u7a0b\u5e8f\u3002\u7eb8\u4e0a\u5f97\u6765\u7ec8\u89c9\u6d45\uff0c\u7edd\u77e5\u6b64\u4e8b\u8981\u8eac\u884c\u3002","title":"\u5145\u5206\u5229\u7528\u672c\u6559\u7a0b"},{"location":"00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/#learncppcom","text":"\u95ee\uff1a\u7f51\u7ad9\u600e\u4e48\u6ce8\u518c\uff1f\u600e\u6837\u624d\u80fd\u767b\u5f55\uff1f \u7b54 \uff1a\u672c\u7ad9\u7684\u6240\u6709\u5185\u5bb9\u90fd\u80fd\u514d\u767b\u5f55\u6d4f\u89c8\u2014\u2014\u6240\u4ee5\uff0c\u65e0\u9700\u6ce8\u518c\uff01 \u95ee\uff1a\u8fd9\u4e9b\u6559\u7a0b\u6700\u65e92007\u5e74\u7f16\u5199\u7684\uff0c\u73b0\u5728\u8fd8\u80fd\u7528\u5417\uff1f \u7b54 \uff1a\u5f53\u7136\uff0c\u80af\u5b9a\u53ef\u4ee5\u7528\u3002 C++\u7684\u6807\u51c6\u4fee\u8ba2\u5e76\u975e\u7279\u522b\u9891\u7e41\uff0c\u5373\u4f7f\u6709\u53d8\u5316\uff0c\u4e5f\u662f\u5728\u539f\u6765\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u65b0\u7684\u7279\u6027\u3002\u5f53\u7136\uff0c\u672c\u6559\u7a0b\u4e5f\u4f1a\u968f\u7740\u8bed\u8a00\u6807\u51c6\u53d8\u5316\u548c\u8bfb\u8005\u53cd\u9988\u5b9a\u671f\u66f4\u65b0\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u7684\u6559\u7a0b\u6709pdf\u7248\u672c\u4f9b\u79bb\u7ebf\u9605\u8bfb\u5417\uff1f \u7b54\uff1a\u62b1\u6b49\uff0c\u8fd9\u4e2a\u6ca1\u6709\u3002\u672c\u7f51\u7ad9\u514d\u8d39\u5f00\u53d1\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u53d7\u5e7f\u544a\u5546\u8d5e\u52a9\u2014\u2014\u800cpdf\u7248\u672c\u65e0\u6cd5\u6295\u5165\u5e7f\u544a\u3002\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u628a\u672c\u7ad9\u4e0a\u7684\u7f51\u9875\u8f6c\u6362\u4e3apdf\u505a\u79c1\u4eba\u7528\u9014\uff0c\u53ea\u8981\u4e0d\u628apdf\u7248\u672c\u4f20\u64ad\u51fa\u53bb\u5c31ok\u4e86\u3002 \u95ee\uff1a\u5982\u679c\u6211\u5361\u5728\u67d0\u4e2a\u6982\u5ff5\u4e86\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5982\u679c\u4f60\u5bf9\u67d0\u4e00\u90e8\u5206\u4e0d\u592a\u660e\u767d\uff0c\u4f60\u53ef\u4ee5\uff1a \u9605\u8bfb\u8bc4\u8bba\u3002\u5176\u4ed6\u7684\u8bfb\u8005\u53ef\u80fd\u4e5f\u9047\u5230\u4e86\u76f8\u4f3c\u7684\u95ee\u9898\u3002 \u7c97\u8bfb\u4e0b\u4e00\u7ae0\u7684\u6559\u7a0b\u2014\u2014\u8bf4\u4e0d\u5b9a\u4f60\u7684\u7591\u60d1\u4f1a\u5728\u90a3\u91cc\u5f97\u5230\u89e3\u7b54\u3002 \u5584\u7528\u641c\u7d22\u5f15\u64ce\u67e5\u627e\u4f60\u7684\u95ee\u9898\u3002 \u5728\u7c7b\u4f3c StackOverflow \u7684\u95ee\u7b54\u7f51\u7ad9\u4e0a\u63d0\u95ee\u3002 \u5982\u679c\u90fd\u6ca1\u7528\u7684\u8bdd\uff0c\u6682\u65f6\u8df3\u8fc7\u8fd9\u4e00\u90e8\u5206\u4e0d\u61c2\u7684\u5185\u5bb9\uff0c\u4ee5\u5f85\u5c06\u6765\u7ffb\u770b\u3002\u5230\u90a3\u65f6\u4f60\u53ef\u80fd\u4f1a\u53d1\u73b0\uff0c\u5728\u5b66\u4e60\u4e86\u5176\u4ed6\u7ae0\u7684\u77e5\u8bc6\u548c\u6587\u7ae0\u4ee5\u540e\uff0c\u518d\u56de\u5934\u6765\u770b\uff0c\u66fe\u7ecf\u8270\u6da9\u96be\u61c2\u7684\u4e1c\u897f\u4e00\u4e0b\u5b50\u8305\u585e\u987f\u5f00\u3002 \u95ee\uff1a\u5982\u679c\u6211\u9057\u5fd8\u4e86\u67d0\u4e2a\u6982\u5ff5\u600e\u4e48\u529e\uff1f \u7b54\uff1a\u5584\u7528 \u4e3b\u9875\u7d22\u5f15 ,\u67e5\u627e\u4f60\u9700\u8981\u4e86\u89e3\u7684\u6982\u5ff5\uff0c\u4f60\u4f1a\u627e\u5230\u8bb2\u89e3\u76f8\u5173\u77e5\u8bc6\u7684\u7ae0\u8282\u3002 \u95ee\uff1a\u600e\u4e48\u80fd\u5728\u8bc4\u8bba\u533a\u5e26\u5934\u50cf\u8bc4\u8bba\uff1f \u8bc4\u8bba\u533a\u4f7f\u7528\u4e86gravatars\u3002\u4f60\u53ef\u4ee5\u5728 gravatar.com \u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u3002\u70b9\u51fb\u201cCreate your own gravatar\u201d\u6309\u94ae\u5e76\u6ce8\u518c\u3002\u4f60\u7684gravatar\u8d26\u6237\u5c06\u4e0e\u4f60\u7684\u90ae\u7bb1\uff08\u53ef\u9009\uff09\u5173\u8054\u3002 \u95ee\uff1a\u672c\u7f51\u7ad9\u6709\u9ed1\u591c\u6a21\u5f0f\u5417\uff1f \u7b54\uff1a\u6ca1\u6709\u81ea\u5e26\u7684\u3002\u4f46\u4f60\u80fd\u624b\u52a8\u641e\u4e00\u641e\uff0c\u8be6\u89c1 darkreader.org \u6700\u540e\uff0c\u4e00\u4e2a\u5c0f\u5c0f\u7684\u4e0d\u60c5\u4e4b\u8bf7\uff1a\u672c\u7f51\u7ad9\u56e0\u5e7f\u544a\u5546\u8d5e\u52a9\u800c\u5f97\u4ee5\u514d\u8d39\u3002\u5982\u679c\u4f60\u559c\u6b22\u672c\u7f51\u7ad9\u7684\u8bfe\u7a0b\uff0c\u53ef\u8003\u8651\u5173\u95ed\u5e7f\u544a\u62e6\u622a\u5668\u6765\u652f\u6301\u6211\u4eec\u3002 \u597d\u7684\uff0c\u4e00\u5207\u5c31\u7eea\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u5427\uff01","title":"\u7f51\u7ad9\u76f8\u5173\uff08\u6307learncpp.com\uff09"},{"location":"08-basic-object-oriented-programming/","text":"\u7b2c\u516b\u7ae0 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u57fa\u7840 \u00b6","title":"\u7b2c\u516b\u7ae0 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u57fa\u7840"},{"location":"08-basic-object-oriented-programming/#_1","text":"","title":"\u7b2c\u516b\u7ae0 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u57fa\u7840"},{"location":"08-basic-object-oriented-programming/8.1-welcome-to-object-oriented-programming/","text":"8.1 \u6b22\u8fce\u6765\u5230\u9762\u5411\u5bf9\u8c61\u7684\u4e16\u754c \u00b6 \u56de\u770b 1.3 \u8bfe \u2014\u2014 \u53d8\u91cf\u7684\u4ecb\u7ecd \uff0c\u6211\u4eec\u5728 C++ \u4e2d\u628a\u5bf9\u8c61\u5b9a\u4e49\u4e3a\uff1a\u201c\u4e00\u5757\u5185\u5b58\u4e2d\u4e00\u4f60\u53ef\u4ee5\u50a8\u5b58\u503c\u7684\u7a7a\u95f4\u201c\u3002\u4e00\u4e2a\u5bf9\u8c61\u5e26\u6709\u540d\u5b57\u7684\u5bf9\u8c61\u53eb\u53d8\u91cf\u3002 \u5728\u4f20\u7edf\u7684\u7f16\u7a0b\u4e2d\uff0c\u7a0b\u5e8f\u901a\u5e38\u90fd\u662f\u4e00\u7cfb\u5217\u7684\u7ed9\u8ba1\u7b97\u673a\u7684\u6307\u4ee4\uff0c\u5e76\u4e14\u5b9a\u4e49\u4e86\u4e00\u4e9b\u6570\u636e\uff0c\u5e76\u4e14\u7d27\u63a5\u7740\u5904\u7406\u8fd9\u4e9b\u6570\u636e\uff08\u901a\u8fc7\u4e00\u4e9b\u51fd\u6570\uff09\u3002\u6570\u636e\u548c\u51fd\u6570\u88ab\u5206\u6210\u4e0d\u540c\u5b9e\u4f53\uff0c\u6700\u7ec8\u7ed3\u5408\u5230\u4e00\u8d77\u6765\u4ea7\u751f\u60f3\u8981\u7684\u7ed3\u679c\u3002\u7531\u4e8e\u4e24\u8005\u7684\u5206\u79bb\uff0c\u4f20\u7edf\u7684\u8ba1\u7b97\u673a\u901a\u5e38\u4e0d\u80fd\u63d0\u4f9b\u975e\u5e38\u76f4\u89c2\u7684\u5bf9\u4e8e\u73b0\u5b9e\u7684\u8868\u793a\u3002\u5982\u4f55\u7ba1\u7406\u3001\u94fe\u63a5\u8fd9\u4e9b\u5c5e\u6027\uff08\u53d8\u91cf\uff09\u548c\u884c\u4e3a\uff08\u51fd\u6570\uff09\uff0c\u4ee5\u4e00\u4e2a\u5408\u9002\u7684\u65b9\u5f0f\uff0c\u90fd\u53d6\u51b3\u4e8e\u7a0b\u5e8f\u5458\u3002\u8fd9\u79cd\u65b9\u5f0f\u5927\u7ea6\u4f1a\u4f7f\u5f97\u4ee3\u7801\u6210\u4e3a\u4ee5\u4e0b\u7684\u6837\u5b50\uff1a driveTo ( you , work ); \u90a3\u4e48\uff0c\u4ec0\u4e48\u662f\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\uff1f\u50cf\u5f88\u591a\u6982\u5ff5\u90a3\u6837\uff0c\u6700\u7b80\u5355\u6700\u5bb9\u6613\u7684\u7406\u89e3\u65b9\u5f0f\u5c31\u662f\u4e3e\u4e2a\u4f8b\u5b50\u7c7b\u6bd4\u4e00\u4e0b\u3002\u8d85\u4f60\u5468\u56f4\u770b\u4e00\u6837 \u2014\u2014 \u4f60\u770b\u5230\u7684\u6bcf\u4e00\u4ef6\u7269\u4ef6\u90fd\u662f\u5bf9\u8c61\uff1a\u4e66\u672c\ud83d\udcda\u3001\u5efa\u7b51\uff0c\u98df\u7269\uff0c\u751a\u81f3\u662f\u4f60\u81ea\u5df1\u3002\u5bf9\u8c61\u6709\u4e24\u4e2a\u4e3b\u8981\u7684\u7ec4\u4ef6\uff1a1\uff09\u4e00\u7cfb\u5217\u7684\u5c5e\u6027\uff08\u4f8b\u5982\uff1a\u8d28\u91cf\uff0c\u989c\u8272\uff0c\u5c3a\u5bf8\uff0c\u786c\u5ea6\uff0c\u5f62\u72b6\u7b49\u7b49\uff09\uff0c2\uff09\u4e00\u7cfb\u5217\u7684\u884c\u4e3a\u5c55\u793a\u51fa\u6765\uff08\u4f8b\u5982\uff1a\u88ab\u6253\u5f00\uff0c\u52a0\u70ed\u4e00\u4e9b\u7269\u54c1\u7b49\u7b49\uff09\u3002\u8fd9\u4e9b\u5c5e\u6027\u548c\u884c\u4e3a\u662f\u4e0d\u80fd\u5206\u79bb\u7684\u3002 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u63d0\u4f9b\u4e86\u7ed9\u6211\u4eec\u4e00\u4e9b\u80fd\u529b\u53bb\u5b9a\u4e49\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5bf9\u8c61\u7684\u5c5e\u6027\u548c\u8868\u73b0\u90fd\u5c01\u88c5\u5728\u4e00\u4e2a\u81ea\u6cbb\u7684\uff0c\u53ef\u590d\u7528\u7684\u5305\u4e2d\u3002\u8fd9\u4f7f\u5f97\u4ee3\u7801\u770b\u8d77\u6765\u66f4\u50cf\u8fd9\u6837 you . driveTo ( work ); \u8fd9\u65f6\u4e0d\u4ec5\u4ec5\u8bfb\u8d77\u6765\u66f4\u52a0\u6e05\u6670\uff0c\u8fd9\u4e2a\u4e3b\u8bed\uff08\u4f60\uff09\u662f\u8c01\uff0c\u5e76\u4e14\u884c\u4e3a\u88ab\u8c03\u7528\uff08\u5f00\u8f66\u53bb\u67d0\u5904\uff09\u90fd\u6e05\u6670\u65e0\u6bd4\u3002\u76f8\u6bd4\u8d77\u4e13\u6ce8\u4e8e\u5199\u51fd\u6570\uff0c\u6211\u4eec\u5374\u4e13\u6ce8\u4e8e\u5b9a\u4e49\u62e5\u6709\u4e00\u4e9b\u884c\u4e3a\u7684\u96c6\u5408\u7684\u5bf9\u8c61\u3002\u8fd9\u662f\u4e3a\u4ec0\u4e48\u8303\u5f0f\u88ab\u53eb\u505a\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u3002 \u8fd9\u5141\u8bb8\u7a0b\u5e8f\u4ee5\u66f4\u52a0\u6a21\u5757\u5316\u7684\u5f62\u5f0f\u88ab\u5199\u51fa\uff0c\u662f\u7684\u4ed6\u4eec\u7f16\u5199\u8d77\u6765\u66f4\u5bb9\u6613\uff0c\u7406\u89e3\u8d77\u6765\u4e5f\u662f\uff0c\u540c\u65f6\u80fd\u591f\u63d0\u4f9b\u4e00\u4e2a\u9ad8\u7ea7\u522b\u7684\u4ee3\u7801\u53ef\u590d\u7528\u6027\u3002\u8fd9\u4e9b\u5bf9\u8c61\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u76f4\u89c2\u7684\u65b9\u5f0f\uff0c\u8ba9\u6211\u4eec\u5b9a\u4e49\u6211\u4eec\u5982\u4f55\u4e0e\u5bf9\u8c61\u4ea4\u4e92\uff0c\u5904\u7406\u6570\u636e\uff0c\u4e5f\u8ba9\u6211\u4eec\u5b9a\u4e49\u8fd9\u4e9b\u5bf9\u8c61\u600e\u4e48\u548c\u5176\u4ed6\u5bf9\u8c61\u4ea4\u4e92\u3002 \u6ce8\u610f OOP \u5e76\u6ca1\u6709\u66ff\u4ee3\u4f20\u7edf\u7684\u7f16\u7a0b\u65b9\u5f0f\uff0c\u7136\u800c\uff0c\u5b83\u5728\u4f60\u7684\u7ed9\u4f60\u4e86\u4e00\u4e9b\u989d\u5916\u7684\u5de5\u5177\uff0c\u4ee5\u4fbf\u5728\u5fc5\u8981\u65f6\u5904\u7406\u4ee3\u7801\u590d\u6742\u6027\u3002 OOP \u4e5f\u5e26\u6765\u4e86\u4e00\u7cfb\u5217\u5176\u4ed6\u7684\u6709\u7528\u7684\u6982\u5ff5\uff0c\u5982\uff1a\u7ee7\u627f[inheritance]\uff0c\u5c01\u88c5[encapsulation]\uff0c\u62bd\u8c61[abstraction]\uff0c\u591a\u6001[polymorphism]\uff08\u4e00\u6761\u7ed9\u8bed\u8a00\u8bbe\u8ba1\u8005\u7684\u54f2\u5b66\uff1a\u6c38\u8fdc\u4e0d\u8981\u4f7f\u7528\u4e00\u4e2a\u5c0f\u7684\u5355\u8bcd\u5f53\u4e00\u4e2a\u5927\u7684\u5355\u8bcd\u53ef\u4ee5\u505a\u540c\u6837\u7684\u4e8b\uff09\uff0c\u6211\u4eec\u5c06\u4f1a\u4e00\u70b9\u70b9\u8986\u76d6\u8fd9\u4e9b\u6982\u5ff5\uff0c\u5728\u63a5\u4e0b\u6765\u51e0\u7ae0\u6559\u7a0b\u4e2d\u3002\u6709\u5927\u91cf\u7684\u65b0\u6750\u6599\uff0c\u4f46\u662f\u4e00\u65e6\u4f60\u5df2\u7ecf\u719f\u6089\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u7684\u8bdd\uff0c\u4f60\u5c31\u4e0d\u4f1a\u518d\u6b21\u56de\u5230\u539f\u6765\u7684\u7eaf\u4f20\u7edf\u7f16\u7a0b\u4e86\u3002 \u6ce8\u610f\u672f\u8bed\u201d\u5bf9\u8c61\u201c\u53ef\u80fd\u8d85\u8fc7\u4e86\u60f3\u8868\u8fbe\u7684\uff0c\u8fd9\u4e5f\u8bb8\u4f1a\u9020\u6210\u4e00\u4e9b\u56f0\u6270\u3002\u5728\u4f20\u7edf\u7684\u7f16\u7a0b\u4e2d\uff0c\u4e00\u4e2a\u5bf9\u8c61\u65f6\u4e00\u5757\u5b58\u50a8\u503c\u8fbe\u5230\u5185\u5b58\uff0c\u4ec5\u6b64\u800c\u5df2\u3002\u5728 OOP \u4e2d\uff0c\u4e00\u4e2a\u5bf9\u8c61\u610f\u5473\u7740\u4ed6\u4e5f\u80fd\u662f\u4e00\u4e2a\u4f20\u7edf\u7f16\u7a0b\u4e2d\u7684\u5bf9\u8c61\uff0c\u4e5f\u80fd\u7ed3\u5408\u5c5e\u6027\u548c\u65b9\u6cd5\u3002\u4ece\u8fd9\u70b9\u51fa\u53d1\uff0c\u5f53\u6211\u4eec\u4f7f\u7528\u672f\u8bed\u201c\u5bf9\u8c61\u201d\u65f6\uff0c\u6211\u4eec\u5c06\u5728\u9762\u5411\u5bf9\u8c61\u7684\u610f\u4e49\u4e0a\u63d0\u5230\u5bf9\u8c61\u3002","title":"8.1 \u6b22\u8fce\u6765\u5230\u9762\u5411\u5bf9\u8c61\u7684\u4e16\u754c"},{"location":"08-basic-object-oriented-programming/8.1-welcome-to-object-oriented-programming/#81","text":"\u56de\u770b 1.3 \u8bfe \u2014\u2014 \u53d8\u91cf\u7684\u4ecb\u7ecd \uff0c\u6211\u4eec\u5728 C++ \u4e2d\u628a\u5bf9\u8c61\u5b9a\u4e49\u4e3a\uff1a\u201c\u4e00\u5757\u5185\u5b58\u4e2d\u4e00\u4f60\u53ef\u4ee5\u50a8\u5b58\u503c\u7684\u7a7a\u95f4\u201c\u3002\u4e00\u4e2a\u5bf9\u8c61\u5e26\u6709\u540d\u5b57\u7684\u5bf9\u8c61\u53eb\u53d8\u91cf\u3002 \u5728\u4f20\u7edf\u7684\u7f16\u7a0b\u4e2d\uff0c\u7a0b\u5e8f\u901a\u5e38\u90fd\u662f\u4e00\u7cfb\u5217\u7684\u7ed9\u8ba1\u7b97\u673a\u7684\u6307\u4ee4\uff0c\u5e76\u4e14\u5b9a\u4e49\u4e86\u4e00\u4e9b\u6570\u636e\uff0c\u5e76\u4e14\u7d27\u63a5\u7740\u5904\u7406\u8fd9\u4e9b\u6570\u636e\uff08\u901a\u8fc7\u4e00\u4e9b\u51fd\u6570\uff09\u3002\u6570\u636e\u548c\u51fd\u6570\u88ab\u5206\u6210\u4e0d\u540c\u5b9e\u4f53\uff0c\u6700\u7ec8\u7ed3\u5408\u5230\u4e00\u8d77\u6765\u4ea7\u751f\u60f3\u8981\u7684\u7ed3\u679c\u3002\u7531\u4e8e\u4e24\u8005\u7684\u5206\u79bb\uff0c\u4f20\u7edf\u7684\u8ba1\u7b97\u673a\u901a\u5e38\u4e0d\u80fd\u63d0\u4f9b\u975e\u5e38\u76f4\u89c2\u7684\u5bf9\u4e8e\u73b0\u5b9e\u7684\u8868\u793a\u3002\u5982\u4f55\u7ba1\u7406\u3001\u94fe\u63a5\u8fd9\u4e9b\u5c5e\u6027\uff08\u53d8\u91cf\uff09\u548c\u884c\u4e3a\uff08\u51fd\u6570\uff09\uff0c\u4ee5\u4e00\u4e2a\u5408\u9002\u7684\u65b9\u5f0f\uff0c\u90fd\u53d6\u51b3\u4e8e\u7a0b\u5e8f\u5458\u3002\u8fd9\u79cd\u65b9\u5f0f\u5927\u7ea6\u4f1a\u4f7f\u5f97\u4ee3\u7801\u6210\u4e3a\u4ee5\u4e0b\u7684\u6837\u5b50\uff1a driveTo ( you , work ); \u90a3\u4e48\uff0c\u4ec0\u4e48\u662f\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\uff1f\u50cf\u5f88\u591a\u6982\u5ff5\u90a3\u6837\uff0c\u6700\u7b80\u5355\u6700\u5bb9\u6613\u7684\u7406\u89e3\u65b9\u5f0f\u5c31\u662f\u4e3e\u4e2a\u4f8b\u5b50\u7c7b\u6bd4\u4e00\u4e0b\u3002\u8d85\u4f60\u5468\u56f4\u770b\u4e00\u6837 \u2014\u2014 \u4f60\u770b\u5230\u7684\u6bcf\u4e00\u4ef6\u7269\u4ef6\u90fd\u662f\u5bf9\u8c61\uff1a\u4e66\u672c\ud83d\udcda\u3001\u5efa\u7b51\uff0c\u98df\u7269\uff0c\u751a\u81f3\u662f\u4f60\u81ea\u5df1\u3002\u5bf9\u8c61\u6709\u4e24\u4e2a\u4e3b\u8981\u7684\u7ec4\u4ef6\uff1a1\uff09\u4e00\u7cfb\u5217\u7684\u5c5e\u6027\uff08\u4f8b\u5982\uff1a\u8d28\u91cf\uff0c\u989c\u8272\uff0c\u5c3a\u5bf8\uff0c\u786c\u5ea6\uff0c\u5f62\u72b6\u7b49\u7b49\uff09\uff0c2\uff09\u4e00\u7cfb\u5217\u7684\u884c\u4e3a\u5c55\u793a\u51fa\u6765\uff08\u4f8b\u5982\uff1a\u88ab\u6253\u5f00\uff0c\u52a0\u70ed\u4e00\u4e9b\u7269\u54c1\u7b49\u7b49\uff09\u3002\u8fd9\u4e9b\u5c5e\u6027\u548c\u884c\u4e3a\u662f\u4e0d\u80fd\u5206\u79bb\u7684\u3002 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u63d0\u4f9b\u4e86\u7ed9\u6211\u4eec\u4e00\u4e9b\u80fd\u529b\u53bb\u5b9a\u4e49\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5bf9\u8c61\u7684\u5c5e\u6027\u548c\u8868\u73b0\u90fd\u5c01\u88c5\u5728\u4e00\u4e2a\u81ea\u6cbb\u7684\uff0c\u53ef\u590d\u7528\u7684\u5305\u4e2d\u3002\u8fd9\u4f7f\u5f97\u4ee3\u7801\u770b\u8d77\u6765\u66f4\u50cf\u8fd9\u6837 you . driveTo ( work ); \u8fd9\u65f6\u4e0d\u4ec5\u4ec5\u8bfb\u8d77\u6765\u66f4\u52a0\u6e05\u6670\uff0c\u8fd9\u4e2a\u4e3b\u8bed\uff08\u4f60\uff09\u662f\u8c01\uff0c\u5e76\u4e14\u884c\u4e3a\u88ab\u8c03\u7528\uff08\u5f00\u8f66\u53bb\u67d0\u5904\uff09\u90fd\u6e05\u6670\u65e0\u6bd4\u3002\u76f8\u6bd4\u8d77\u4e13\u6ce8\u4e8e\u5199\u51fd\u6570\uff0c\u6211\u4eec\u5374\u4e13\u6ce8\u4e8e\u5b9a\u4e49\u62e5\u6709\u4e00\u4e9b\u884c\u4e3a\u7684\u96c6\u5408\u7684\u5bf9\u8c61\u3002\u8fd9\u662f\u4e3a\u4ec0\u4e48\u8303\u5f0f\u88ab\u53eb\u505a\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u3002 \u8fd9\u5141\u8bb8\u7a0b\u5e8f\u4ee5\u66f4\u52a0\u6a21\u5757\u5316\u7684\u5f62\u5f0f\u88ab\u5199\u51fa\uff0c\u662f\u7684\u4ed6\u4eec\u7f16\u5199\u8d77\u6765\u66f4\u5bb9\u6613\uff0c\u7406\u89e3\u8d77\u6765\u4e5f\u662f\uff0c\u540c\u65f6\u80fd\u591f\u63d0\u4f9b\u4e00\u4e2a\u9ad8\u7ea7\u522b\u7684\u4ee3\u7801\u53ef\u590d\u7528\u6027\u3002\u8fd9\u4e9b\u5bf9\u8c61\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u76f4\u89c2\u7684\u65b9\u5f0f\uff0c\u8ba9\u6211\u4eec\u5b9a\u4e49\u6211\u4eec\u5982\u4f55\u4e0e\u5bf9\u8c61\u4ea4\u4e92\uff0c\u5904\u7406\u6570\u636e\uff0c\u4e5f\u8ba9\u6211\u4eec\u5b9a\u4e49\u8fd9\u4e9b\u5bf9\u8c61\u600e\u4e48\u548c\u5176\u4ed6\u5bf9\u8c61\u4ea4\u4e92\u3002 \u6ce8\u610f OOP \u5e76\u6ca1\u6709\u66ff\u4ee3\u4f20\u7edf\u7684\u7f16\u7a0b\u65b9\u5f0f\uff0c\u7136\u800c\uff0c\u5b83\u5728\u4f60\u7684\u7ed9\u4f60\u4e86\u4e00\u4e9b\u989d\u5916\u7684\u5de5\u5177\uff0c\u4ee5\u4fbf\u5728\u5fc5\u8981\u65f6\u5904\u7406\u4ee3\u7801\u590d\u6742\u6027\u3002 OOP \u4e5f\u5e26\u6765\u4e86\u4e00\u7cfb\u5217\u5176\u4ed6\u7684\u6709\u7528\u7684\u6982\u5ff5\uff0c\u5982\uff1a\u7ee7\u627f[inheritance]\uff0c\u5c01\u88c5[encapsulation]\uff0c\u62bd\u8c61[abstraction]\uff0c\u591a\u6001[polymorphism]\uff08\u4e00\u6761\u7ed9\u8bed\u8a00\u8bbe\u8ba1\u8005\u7684\u54f2\u5b66\uff1a\u6c38\u8fdc\u4e0d\u8981\u4f7f\u7528\u4e00\u4e2a\u5c0f\u7684\u5355\u8bcd\u5f53\u4e00\u4e2a\u5927\u7684\u5355\u8bcd\u53ef\u4ee5\u505a\u540c\u6837\u7684\u4e8b\uff09\uff0c\u6211\u4eec\u5c06\u4f1a\u4e00\u70b9\u70b9\u8986\u76d6\u8fd9\u4e9b\u6982\u5ff5\uff0c\u5728\u63a5\u4e0b\u6765\u51e0\u7ae0\u6559\u7a0b\u4e2d\u3002\u6709\u5927\u91cf\u7684\u65b0\u6750\u6599\uff0c\u4f46\u662f\u4e00\u65e6\u4f60\u5df2\u7ecf\u719f\u6089\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u7684\u8bdd\uff0c\u4f60\u5c31\u4e0d\u4f1a\u518d\u6b21\u56de\u5230\u539f\u6765\u7684\u7eaf\u4f20\u7edf\u7f16\u7a0b\u4e86\u3002 \u6ce8\u610f\u672f\u8bed\u201d\u5bf9\u8c61\u201c\u53ef\u80fd\u8d85\u8fc7\u4e86\u60f3\u8868\u8fbe\u7684\uff0c\u8fd9\u4e5f\u8bb8\u4f1a\u9020\u6210\u4e00\u4e9b\u56f0\u6270\u3002\u5728\u4f20\u7edf\u7684\u7f16\u7a0b\u4e2d\uff0c\u4e00\u4e2a\u5bf9\u8c61\u65f6\u4e00\u5757\u5b58\u50a8\u503c\u8fbe\u5230\u5185\u5b58\uff0c\u4ec5\u6b64\u800c\u5df2\u3002\u5728 OOP \u4e2d\uff0c\u4e00\u4e2a\u5bf9\u8c61\u610f\u5473\u7740\u4ed6\u4e5f\u80fd\u662f\u4e00\u4e2a\u4f20\u7edf\u7f16\u7a0b\u4e2d\u7684\u5bf9\u8c61\uff0c\u4e5f\u80fd\u7ed3\u5408\u5c5e\u6027\u548c\u65b9\u6cd5\u3002\u4ece\u8fd9\u70b9\u51fa\u53d1\uff0c\u5f53\u6211\u4eec\u4f7f\u7528\u672f\u8bed\u201c\u5bf9\u8c61\u201d\u65f6\uff0c\u6211\u4eec\u5c06\u5728\u9762\u5411\u5bf9\u8c61\u7684\u610f\u4e49\u4e0a\u63d0\u5230\u5bf9\u8c61\u3002","title":"8.1 \u6b22\u8fce\u6765\u5230\u9762\u5411\u5bf9\u8c61\u7684\u4e16\u754c"},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/","text":"8.2 \u7c7b\u548c\u7c7b\u6210\u5458 (Classes and class member) \u00b6 \u5f53 C++ \u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u57fa\u672c\u7c7b\u578b\uff08\u4f8b\u5982\uff1achar\uff0cint\uff0clong\uff0cfloat\uff0cdouble\u7b49\u7b49\uff09\u5e38\u5e38\u80fd\u591f\u89e3\u51b3\u4e00\u4e9b\u7b80\u5355\u95ee\u9898\uff0c\u5f88\u96be\u7528\u5b83\u4ec5\u4ec5\u7528\u8fd9\u4e9b\u7c7b\u578b\u6765\u89e3\u51b3\u590d\u6742\u7684\u95ee\u9898\u3002\u4e00\u4e2a C++ \u7684\u975e\u5e38\u6709\u7528\u7684\u7279\u6027\u5c31\u662f\u5b9a\u4e49\u4f60\u81ea\u5df1\u7684\u6570\u636e\u7c7b\u578b\uff0c\u80fd\u591f\u7b26\u5408\u9700\u8981\u89e3\u51b3\u7684\u95ee\u9898\u3002\u4f60\u65e9\u5c31\u5b66\u8fc7\u4e86\u5982\u4f55\u679a\u4e3e\u7c7b\u578b\u548c\u7ed3\u6784\uff0c\u7528\u540c\u6837\u7684\u65b9\u6cd5\uff0c\u4f60\u4e5f\u53ef\u4ee5\u521b\u5efa\u81ea\u5df1\u7684\u7c7b\u578b\u3002 \u8fd9\u6709\u4e00\u4e2a\u7ed3\u6784\u6301\u6709\u65e5\u671f\u7684\u4f8b\u5b50 struct DateStruct { int year {}; int month {}; int day {}; }; \u679a\u4e3e\u7c7b\u578b\u548c\u7eaf\u6570\u636e\u7684\u7ed3\u6784\uff08\u4ec5\u4ec5\u5305\u542b\u53d8\u91cf\u7684\u7ed3\u6784\uff09\u4ec5\u4ee3\u8868\u7740\u4f20\u7edf\u7684\u975e OOP \u7f16\u7a0b\u7684\u4e16\u754c\uff0c\u56e0\u4e3a\u4ed6\u4eec\u53ea\u80fd\u7528\u6765\u4ece\u6301\u6709\u6570\u636e\uff0c\u5728 C++11 \u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u50cf\u4e0b\u65b9\u8fd9\u6837\u521b\u5efa\u5e76\u4e14\u521d\u59cb\u5316\u5bf9\u8c61\u3002 DateStruct today { 2020 , 10 , 14 }; // use uniform initialization \u73b0\u5728\uff0c\u5982\u679c\u4f60\u60f3\u6253\u5370\u8fd9\u4e2a\u65e5\u671f\u5230\u5c4f\u5e55\uff08\u8fd8\u6709\u5f88\u591a\u591a\u6211\u4eec\u60f3\u505a\u7684\u7c7b\u4f3c\u7684\u4e8b\u60c5\uff09\uff0c\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u505a\u8fd9\u4ef6\u4e8b\u662f\u53ef\u4ee5\u7684\uff1a #include <iostream> struct DateStruct { int year {}; int month {}; int day {}; }; void print ( const DateStruct & date ) { std :: cout << date . year << '/' << date . month << '/' << date . day ; } int main () { DateStruct today { 2020 , 10 , 14 }; // use uniform initialization today . day = 16 ; // use member selection operator to select a member of the struct print ( today ); return 0 ; } \u7a0b\u5e8f\u6253\u5370\uff1a 2020 / 10 / 16 \u7c7b \u00b6 \u5728\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u7684\u4e16\u754c\u4e2d\uff0c\u6211\u4eec\u901a\u8336\u624d\u80fd\u591f\u60f3\u8981\u6211\u4eec\u7684\u7c7b\u578b\u4e0d\u4ec5\u4ec5\u6301\u6709\u6570\u636e\uff0c\u5e76\u4e14\u4e5f\u63d0\u4f9b\u4e00\u4e9b\u51fd\u6570\u6765\u5904\u7406\u6570\u636e\u3002\u5728 C++ \u4e2d\uff0c\u8fd9\u901a\u5e38\u901a\u8fc7 class \u5173\u952e\u8bcd\u6765\u5b8c\u6210\u3002\u7c7b\u5173\u952e\u8bcd\u5b9a\u4e49\u4e86\u4e00\u4e9b\u7528\u6237\u5b9a\u4e49\u7c7b\u578b\u53eb\u505a class\u3002 \u5728 C++ \u4e2d\uff0c\u7c7b\u578b\u548c\u7ed3\u6784\u662f\u57fa\u672c\u76f8\u540c\u7684\uff0c\u4e8b\u5b9e\u4e0a\uff0c\u4e0b\u5217\u7ed3\u6784\u548c\u7c7b\u662f\u7b49\u6548\u7684\uff1a struct DateStruct { int year {}; int month {}; int day {}; }; class DateClass { public : int m_year {}; int m_month {}; int m_day {}; }; \u6ce8\u610f\u552f\u4e00\u4e0d\u540c\u7684\u5c31\u662f\u7c7b\u4e2d\u7684 public \u5173\u952e\u8bcd\u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u8ba8\u8bba\u8fd9\u4e2a\u5173\u952e\u8bcd\u3002 \u5c31\u50cf\u4e00\u4e2a\u7ed3\u6784\u7684\u5b9a\u4e49\u90a3\u6837\uff0c\u4e00\u4e2a\u7c7b\u7684\u5b9a\u4e49\u4e0d\u5206\u914d\u4efb\u4f55\u5185\u5b58\uff0c\u4ed6\u4ec5\u4ec5\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7c7b\u6a21\u6837\u800c\u5df2\u3002 Warning \u00b6 \u5c31\u50cf\u5bf9\u5f85\u7ed3\u6784\u90a3\u6837\uff0c\u5728 C++ \u4e2d\u6700\u5bb9\u6613\u72af\u7684\u9519\u8bef\u4e4b\u4e00\u5c31\u662f\u5fd8\u4e86\u5199\u7c7b\u578b\u5b9a\u4e49\u7ed3\u5c3e\u7684\u5206\u53f7\u3002\u8fd9\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u53d8\u5f02\u9519\u8bef\uff0c\u5728\u4e0b\u4e00\u884c\u3002\u73b0\u4ee3\u7684\u7f16\u8bd1\u5668\uff0c\u4f8b\u5982 Visual Studio 2010 \u4f1a\u7ed9\u4f60\u4e00\u4e2a\u6307\u793a\u544a\u8bc9\u4f60\u4f60\u6709\u53ef\u80fd\u5df2\u7ecf\u5fd8\u4e86\u4e00\u4e2a\u5206\u53f7\uff0c\u4f46\u662f\u66f4\u8001\u7684\u6216\u8005\u66f4\u529f\u80fd\u66f4\u7b80\u5355\u7684\u7f16\u8bd1\u5668\u4e0d\u4f1a\u90a3\u4e48\u505a\uff0c\u8fd9\u4f1a\u8ba9\u4f60\u5f88\u96be\u53d1\u73b0\u8fd9\u4e2a\u9519\u8bef \u7c7b\uff08\u548c\u7ed3\u6784\uff09\u5b9a\u4e49\u5c31\u50cf\u4e00\u4e2a blueprint \u2014\u2014 \u4ed6\u4eec\u63cf\u8ff0\u4e86\u5bf9\u8c61\u770b\u8d77\u6765\u5c06\u4f1a\u50cf\u4ec0\u4e48\uff0c\u4f46\u662f\u4ed6\u4eec\u4e0d\u4f1a\u5b9e\u9645\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002\u60f3\u8981\u521b\u5efa\u4e00\u4e2a\u7c7b\u7684\u5bf9\u8c61\uff0c\u4e00\u4e2a\u7c7b\u7684\u53d8\u91cf\u4e00\u5b9a\u8981\u88ab\u5b9a\u4e49\u51fa\u6765\u624d\u884c\uff1a DateClass today { 2020 , 10 , 14 }; // declare a variable of class DateClass \u6210\u5458\u51fd\u6570 \u00b6 \u9664\u4e86\u6301\u6709\u6570\u636e\uff0c\u7c7b\uff08\u548c\u7ed3\u6784\uff09\u4e5f\u53ef\u4ee5\u5305\u542b\u51fd\u6570\uff01\u5728\u7c7b\u4e2d\u5b9a\u4e49\u7684\u51fd\u6570\u88ab\u53eb\u505a\u6210\u5458\u51fd\u6570\uff08\u6709\u65f6\u5019\u53eb\u2019\u65b9\u6cd5\u2018\uff09\u3002\u6210\u5458\u51fd\u6570\u53ef\u4ee5\u88ab\u5b9a\u4e49\u5728\u7c7b\u5185\u6216\u8005\u7c7b\u5916\uff0c\u6211\u4eec\u5c06\u4f1a\u5b9a\u4e49\u4ed6\u4eec\u5728\u7c7b\u5185\uff08\u4e3a\u4e86\u7b80\u5355\uff09\uff0c\u4e4b\u540e\u5c55\u793a\u5982\u4f55\u5728\u7c7b\u5916\u5b9a\u4e49\u3002 \u8fd9\u662f\u6211\u4eec\u7684\u5e26\u6709\u4e00\u4e2a\u6210\u5458\u51fd\u6570\u6765\u6253\u5370\u65e5\u671f\u7684\u7c7b\uff1a class DateClass { public : int m_year {}; int m_month {}; int m_day {}; void print () // defines a member function named print() { std :: cout << m_year << '/' << m_month << '/' << m_day ; } }; Just like members of a struct, members (variables and functions) of a class are accessed using the member selector operator (.): \u5c31\u50cf\u7ed3\u6784\u7684\u6210\u5458\uff0c\u7c7b\u7684\u6210\u5458\u4e5f\u53ef\u4ee5\u4f7f\u7528\u6210\u5458\u9009\u62e9\u64cd\u4f5c\u7b26\uff08.\uff09\u6765\u8bbf\u95ee\u6210\u5458\u3002 # include <iostream> class DateClass { public : int m_year {}; int m_month {}; int m_day {}; void print () { std :: cout << m_year << '/' << m_month << '/' << m_day ; } }; int main () { DateClass today { 2020 , 10 , 14 }; today . m_day = 16 ; // use member selection operator to select a member variable of the class today . print (); // use member selection operator to call a member function of the class return 0 ; } \u6253\u5370\uff1a 2020 / 10 / 16 \u6ce8\u610f\u8fd9\u4e2a\u7a0b\u5e8f\u8981\u6bd4\u6211\u4eec\u4e0a\u65b9\u4f7f\u7528 struct \u5b9e\u73b0\u7684\u7b80\u5355\u591a\u4e86\u3002 \u7136\u800c\uff0c\u6709\u4e00\u4e9b\u4e0d\u540c\u70b9\u3002\u5728\u4e0a\u65b9 DataStruct \u7248\u672c\u7684\u4f8b\u5b50\u4e2d\u7684 print() \u6211\u4eec\u4f20\u5165\u4e86\u7ed3\u6784\u672c\u8eab\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u8fdb\u5165 print() \u51fd\u6570\u3002\u5426\u5219\uff0cprint() \u4e0d\u4f1a\u77e5\u9053\u54ea\u6211\u4eec\u60f3\u6253\u5370\u54ea\u4e2a\u5bf9\u8c61\u3002\u6211\u4eec\u7d27\u63a5\u7740\u4e0d\u5f97\u4e0d\u4f7f\u7528\u8fd9\u4e2a\u53c2\u6570\uff0c\u5728\u51fd\u6570\u5185\u90e8\u3002 \u6210\u5458\u51fd\u6570\u5de5\u4f5c\u8d77\u6765\u6709\u8f7b\u5fae\u7684\u4e0d\u540c\uff1a\u6240\u6709\u7684\u6210\u5458\u51fd\u6570\u8c03\u7528\u5fc5\u987b\u548c\u8fd9\u4e2a\u7c7b\u7684\u5bf9\u8c61\u5173\u8054\u3002\u5f53\u6211\u4eec\u8c03\u7528 today.print() \u7684\u65f6\u5019\uff0c\u6211\u4eec\u544a\u8bc9\u7f16\u8bd1\u5668\u6211\u4eec\u8981\u8c03\u7528\u548c today \u8fd9\u4e2a\u5bf9\u8c61\u5173\u8054\u7684 print \u6210\u5458\u51fd\u6570\u3002 \u73b0\u5728\u8ba9\u6211\u4eec\u518d\u770b\u4e00\u904d\u6210\u5458\u51fd\u6570\u7684\u5b9a\u4e49 void print () // defines a member function named print() { std :: cout << m_year << '/' << m_month << '/' << m_day ; } m_year, m_month, m_day \u5b9e\u9645\u4e0a\u5206\u522b\u6307\u5411\u54ea\u91cc\uff1f\u4ed6\u4eec\u6307\u5411\u5173\u8054\u7684\u5bf9\u8c61\uff08\u7531\u8c03\u7528\u8005\u51b3\u5b9a\uff09\u3002 \u56e0\u6b64\u5f53\u6211\u4eec\u8c03\u7528 today.print() \u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u89e3\u91ca m_day \u4e3a today.m_today\uff0cm_month \u548c m_year\u4e5f\u5206\u522b\u89e3\u91ca\u4e3a today.m_month \u548c today.m_year \uff0c\u5982\u679c\u6211\u4eec\u8c03\u7528 tomorrow.print() \uff0c m_day \u5c31\u4f1a\u88ab tomorrow.m_day \u6307\u4ee3\u3002 \u4ee5\u8fd9\u79cd\u65b9\u5f0f\uff0c\u672c\u8d28\u4e0a\u9690\u5f0f\u7684\u4f20\u9001\u4e86\u4e00\u4e2a\u7c7b\u7684\u5b9e\u4f8b\u5230\u6210\u5458\u51fd\u6570\u3002\u56e0\u4e3a\u8fd9\u6837\uff0c\u4ed6\u624d\u80fd\u88ab\u9690\u5f0f\u7684\u8c03\u7528\u3002 \u6211\u4eec\u5c06\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\uff0c\u8ba8\u8bba\u66f4\u591a\u7684\u8fd9\u4e2a\u9690\u5f0f\u5bf9\u8c61\u5982\u4f55\u4f20\u5165\u5e76\u4e14\u8d77\u4f5c\u7528\u3002 \u5173\u952e\u5355\u662f\uff0c\u5f53\u6211\u4eec\u8c03\u7528\u975e\u6210\u5458\u51fd\u6570\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u4f20\u5165\u4e00\u4e2a\u5bf9\u8c61\u5230\u51fd\u6570\u3002\u800c\u5f53\u6211\u4eec\u8c03\u7528\u6210\u5458\u51fd\u6570\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe\u6211\u4eec\u603b\u662f\u6709\u4e00\u4e2a\u9690\u5f0f\u7684\u7c7b\u5bf9\u8c61\u53ef\u4ee5\u88ab\u4f7f\u7528\u3002 \u7ed9\u6210\u5458\u53d8\u91cf\u4f7f\u7528 \u201dm_\u201c \u524d\u7f00\u53ef\u4ee5\u5e2e\u52a9\u5c06\u6210\u5458\u53d8\u91cf\u3001\u6210\u5458\u51fd\u6570\u548c\u5728\u6210\u5458\u51fd\u6570\u4e2d\u4f7f\u7528\u7684\u5916\u90e8\u53d8\u91cf\u533a\u5206\u5f00\u3002\u8fd9\u662f\u975e\u5e38\u6709\u7528\u7684\uff0c\u8fd8\u6709\u5f88\u591a\u539f\u56e0\u3002 \u7b2c\u4e00\uff0c\u5f53\u6211\u4eec\u770b\u5230\u64cd\u4f5c\u4e00\u4e2a\u5e26 m_ \u524d\u7f00\u7684\u53d8\u91cf\u65f6\uff0c\u6211\u4eec\u5c31\u77e5\u9053\u6211\u4eec\u6b63\u5728\u6539\u53d8\u7c7b\u5b9e\u4f8b\u7684\u72b6\u6001\u3002 \u7b2c\u4e8c\uff0c\u4e0d\u50cf\u51fd\u6570\u6210\u5458\u548c\u5c40\u90e8\u53d8\u91cf\uff0c\u53ef\u4ee5\u88ab\u5b9a\u4e49\u5728\u51fd\u6570\u4e2d\uff0c\u6210\u5458\u53d8\u91cf\u88ab\u5b9a\u4e49\u5728\u7c7b\u58f0\u660e\u4e2d\u3002\u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u77e5\u9053\u4e00\u4e2a m_ \u524d\u7f00\u7684\u53d8\u91cf\u5982\u4f55\u88ab\u58f0\u660e\uff0c\u6211\u4eec\u77e5\u9053\u5e94\u8be5\u5b83\u88ab\u5b9a\u4e49\u5728\u7c7b\u4e2d\u5b9a\u4e49\u800c\u4e0d\u662f\u51fd\u6570\u4e2d\u3002 \u4e3a\u4e86\u65b9\u4fbf\uff0c\u7c7b\u540d\u5e94\u8be5\u4ee5\u4e00\u4e2a\u5927\u5199\u7684\u5b57\u6bcd\u5f00\u59cb\u3002 \u89c4\u5219\uff1a\u7c7b\u7684\u540d\u5b57\u4ee5\u5927\u5199\u5b57\u6bcd\u5f00\u59cb \u8fd9\u662f\u53e6\u4e00\u4e2a\u7c7b\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <string> class Employee { public : std :: string m_name {}; int m_id {}; double m_wage {}; // Print employee information to the screen void print () { std :: cout << \"Name: \" << m_name << \" Id: \" << m_id << \" Wage: $\" << m_wage << '\\n' ; } }; int main () { // Declare two employees Employee alex { \"Alex\" , 1 , 25.00 }; Employee joe { \"Joe\" , 2 , 22.25 }; // Print out the employee information alex . print (); joe . print (); return 0 ; } \u8f93\u51fa\u4e86\u7ed3\u679c\uff1a Name : Alex Id : 1 Wage : $25 Name : Joe Id : 2 Wage : $22 .25 \u5728\u666e\u901a\u7684\u975e\u6210\u5458\u51fd\u6570\u4e0b\uff0c\u4e00\u4e2a\u51fd\u6570\u4e0d\u53ef\u80fd\u8c03\u7528\u5728 \u201d\u4e0b\u65b9\u201c \u5b9a\u4e49\u7684\u51fd\u6570\uff08\u6ca1\u6709\u524d\u7f6e\u58f0\u660e\uff09 void x () { // You can't call y() from here unless the compiler has already seen a forward declaration for y() } void y () { } \u5728\u6210\u5458\u51fd\u6570\u4e2d\uff0c\u8fd9\u4e2a\u9650\u5236\u6ca1\u6709\u88ab\u5e94\u7528\uff1a class foo { public : void x () { y (); } // okay to call y() here, even though y() isn't defined until later in this class void y () { }; }; \u6210\u5458\u7c7b\u578b \u00b6 \u9664\u4e86\u6210\u5458\u53d8\u91cf\u548c\u6210\u5458\u51fd\u6570\uff0c\u7c7b\u53ef\u4ee5\u53c8\u6210\u5458\u7c7b\u578b\u6216\u8005\u5d4c\u5957\u7c7b\u578b\uff08\u5305\u62ec\u7c7b\u578b\u522b\u540d\uff09\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u8ba1\u7b97\u5668\uff0c\u6211\u4eec\u53ef\u4ee5\u5feb\u901f\u7684\u6539\u53d8\u6570\u5b57\u7684\u7c7b\u578b\u5982\u679c\u9700\u8981\u3002\uff08we can swiftly change the type of number it\u2019s using if we ever need to.\uff09 # include <iostream> # include <vector> class Calculator { public : using number_t = int ; // this is a nested type alias std :: vector < number_t > m_resultHistory {}; number_t add ( number_t a , number_t b ) { auto result { a + b }; m_resultHistory . push_back ( result ); return result ; } }; int main () { Calculator calculator {}; std :: cout << calculator . add ( 3 , 4 ) << '\\n' ; // 7 std :: cout << calculator . add ( 99 , 24 ) << '\\n' ; // 123 for ( Calculator :: number_t result : calculator . m_resultHistory ) { std :: cout << result << '\\n' ; } return 0 ; } \u8f93\u51fa 7 123 7 123 \u5728\u8fd9\u6837\u7684\u4e0a\u4e0b\u6587\u4e2d\uff0c\u7c7b\u540d\u9ad8\u6548\u7684\u7ed9\u5185\u5d4c\u7c7b\u578b\u626e\u6f14\u4e86\u4e00\u4e2a\u547d\u540d\u7a7a\u95f4\u7684\u89d2\u8272\u3002\u5728\u7c7b\u4e2d\uff0c\u6211\u4eec\u53ea\u9700\u8981\u53c2\u7167 number_t\u3002\u5728\u7c7b\u5916\u9762\uff0c\u6211\u4eec\u53ef\u4ee5\u963f\u8bbf\u95ee\u7c7b\u578b\u901a\u8fc7 Calculator::number_t . \u5f53\u6211\u4eec\u51b3\u5b9a\u4e00\u4e2a\u6574\u578b\u4e0d\u518d TODO\u7ffb\u8bd1\u4e2d When we decide that an int no longer fulfills our needs and we want to use a double, we only need to update the type alias, rather than having to replace every occurrence of int with double. Type alias members make code easier to maintain and can reduce typing. Template classes, which we\u2019ll cover later, often make use of type alias members. You\u2019ve already seen this as std::vector::size_type, where size_type is an alias for an unsigned integer. Nested types cannot be forward declared. Generally, nested types should only be used when the nested type is used exclusively within that class. Note that since classes are types, it\u2019s possible to nest classes inside other classes -- this is uncommon and is typically only done by advanced programmers. A note about structs in C++ In C, structs can only hold data, and do not have associated member functions. In C++, after designing classes (using the class keyword), Bjarne Stroustrup spent some amount of time considering whether structs (which were inherited from C) should be granted the ability to have member functions. Upon consideration, he determined that they should, in part to have a unified ruleset for both. So although we wrote the above programs using the class keyword, we could have used the struct keyword instead. Many developers (including myself) feel this was the incorrect decision to be made, as it can lead to dangerous assumptions. For example, it\u2019s fair to assume a class will clean up after itself (e.g. a class that allocates memory will deallocate it before being destroyed), but it\u2019s not safe to assume a struct will. Consequently, we recommend using the struct keyword for data-only structures, and the class keyword for defining objects that require both data and functions to be bundled together. Rule Use the struct keyword for data-only structures. Use the class keyword for objects that have both data and functions. You have already been using classes without knowing it It turns out that the C++ standard library is full of classes that have been created for your benefit. std::string, std::vector, and std::array are all class types! So when you create an object of any of these types, you\u2019re instantiating a class object. And when you call invoke a function using these objects, you\u2019re calling a member function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 include \u00b6 include \u00b6 include \u00b6 include \u00b6 int main() { std::string s { \"Hello, world!\" }; // instantiate a string class object std::array<int, 3> a { 1, 2, 3 }; // instantiate an array class object std::vector<double> v { 1.1, 2.2, 3.3 }; // instantiate a vector class object std::cout << \"length: \" << s.length() << '\\n'; // call a member function return 0; } Conclusion The class keyword lets us create a custom type in C++ that can contain both member variables and member functions. Classes form the basis for Object-oriented programming, and we\u2019ll spend the rest of this chapter and many of the future chapters exploring all they have to offer!","title":"8.2 \u7c7b\u548c\u7c7b\u6210\u5458 (Classes and class member)"},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#82-classes-and-class-member","text":"\u5f53 C++ \u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u57fa\u672c\u7c7b\u578b\uff08\u4f8b\u5982\uff1achar\uff0cint\uff0clong\uff0cfloat\uff0cdouble\u7b49\u7b49\uff09\u5e38\u5e38\u80fd\u591f\u89e3\u51b3\u4e00\u4e9b\u7b80\u5355\u95ee\u9898\uff0c\u5f88\u96be\u7528\u5b83\u4ec5\u4ec5\u7528\u8fd9\u4e9b\u7c7b\u578b\u6765\u89e3\u51b3\u590d\u6742\u7684\u95ee\u9898\u3002\u4e00\u4e2a C++ \u7684\u975e\u5e38\u6709\u7528\u7684\u7279\u6027\u5c31\u662f\u5b9a\u4e49\u4f60\u81ea\u5df1\u7684\u6570\u636e\u7c7b\u578b\uff0c\u80fd\u591f\u7b26\u5408\u9700\u8981\u89e3\u51b3\u7684\u95ee\u9898\u3002\u4f60\u65e9\u5c31\u5b66\u8fc7\u4e86\u5982\u4f55\u679a\u4e3e\u7c7b\u578b\u548c\u7ed3\u6784\uff0c\u7528\u540c\u6837\u7684\u65b9\u6cd5\uff0c\u4f60\u4e5f\u53ef\u4ee5\u521b\u5efa\u81ea\u5df1\u7684\u7c7b\u578b\u3002 \u8fd9\u6709\u4e00\u4e2a\u7ed3\u6784\u6301\u6709\u65e5\u671f\u7684\u4f8b\u5b50 struct DateStruct { int year {}; int month {}; int day {}; }; \u679a\u4e3e\u7c7b\u578b\u548c\u7eaf\u6570\u636e\u7684\u7ed3\u6784\uff08\u4ec5\u4ec5\u5305\u542b\u53d8\u91cf\u7684\u7ed3\u6784\uff09\u4ec5\u4ee3\u8868\u7740\u4f20\u7edf\u7684\u975e OOP \u7f16\u7a0b\u7684\u4e16\u754c\uff0c\u56e0\u4e3a\u4ed6\u4eec\u53ea\u80fd\u7528\u6765\u4ece\u6301\u6709\u6570\u636e\uff0c\u5728 C++11 \u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u50cf\u4e0b\u65b9\u8fd9\u6837\u521b\u5efa\u5e76\u4e14\u521d\u59cb\u5316\u5bf9\u8c61\u3002 DateStruct today { 2020 , 10 , 14 }; // use uniform initialization \u73b0\u5728\uff0c\u5982\u679c\u4f60\u60f3\u6253\u5370\u8fd9\u4e2a\u65e5\u671f\u5230\u5c4f\u5e55\uff08\u8fd8\u6709\u5f88\u591a\u591a\u6211\u4eec\u60f3\u505a\u7684\u7c7b\u4f3c\u7684\u4e8b\u60c5\uff09\uff0c\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u505a\u8fd9\u4ef6\u4e8b\u662f\u53ef\u4ee5\u7684\uff1a #include <iostream> struct DateStruct { int year {}; int month {}; int day {}; }; void print ( const DateStruct & date ) { std :: cout << date . year << '/' << date . month << '/' << date . day ; } int main () { DateStruct today { 2020 , 10 , 14 }; // use uniform initialization today . day = 16 ; // use member selection operator to select a member of the struct print ( today ); return 0 ; } \u7a0b\u5e8f\u6253\u5370\uff1a 2020 / 10 / 16","title":"8.2 \u7c7b\u548c\u7c7b\u6210\u5458 (Classes and class member)"},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#_1","text":"\u5728\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u7684\u4e16\u754c\u4e2d\uff0c\u6211\u4eec\u901a\u8336\u624d\u80fd\u591f\u60f3\u8981\u6211\u4eec\u7684\u7c7b\u578b\u4e0d\u4ec5\u4ec5\u6301\u6709\u6570\u636e\uff0c\u5e76\u4e14\u4e5f\u63d0\u4f9b\u4e00\u4e9b\u51fd\u6570\u6765\u5904\u7406\u6570\u636e\u3002\u5728 C++ \u4e2d\uff0c\u8fd9\u901a\u5e38\u901a\u8fc7 class \u5173\u952e\u8bcd\u6765\u5b8c\u6210\u3002\u7c7b\u5173\u952e\u8bcd\u5b9a\u4e49\u4e86\u4e00\u4e9b\u7528\u6237\u5b9a\u4e49\u7c7b\u578b\u53eb\u505a class\u3002 \u5728 C++ \u4e2d\uff0c\u7c7b\u578b\u548c\u7ed3\u6784\u662f\u57fa\u672c\u76f8\u540c\u7684\uff0c\u4e8b\u5b9e\u4e0a\uff0c\u4e0b\u5217\u7ed3\u6784\u548c\u7c7b\u662f\u7b49\u6548\u7684\uff1a struct DateStruct { int year {}; int month {}; int day {}; }; class DateClass { public : int m_year {}; int m_month {}; int m_day {}; }; \u6ce8\u610f\u552f\u4e00\u4e0d\u540c\u7684\u5c31\u662f\u7c7b\u4e2d\u7684 public \u5173\u952e\u8bcd\u3002\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u8ba8\u8bba\u8fd9\u4e2a\u5173\u952e\u8bcd\u3002 \u5c31\u50cf\u4e00\u4e2a\u7ed3\u6784\u7684\u5b9a\u4e49\u90a3\u6837\uff0c\u4e00\u4e2a\u7c7b\u7684\u5b9a\u4e49\u4e0d\u5206\u914d\u4efb\u4f55\u5185\u5b58\uff0c\u4ed6\u4ec5\u4ec5\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7c7b\u6a21\u6837\u800c\u5df2\u3002","title":"\u7c7b"},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#warning","text":"\u5c31\u50cf\u5bf9\u5f85\u7ed3\u6784\u90a3\u6837\uff0c\u5728 C++ \u4e2d\u6700\u5bb9\u6613\u72af\u7684\u9519\u8bef\u4e4b\u4e00\u5c31\u662f\u5fd8\u4e86\u5199\u7c7b\u578b\u5b9a\u4e49\u7ed3\u5c3e\u7684\u5206\u53f7\u3002\u8fd9\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u53d8\u5f02\u9519\u8bef\uff0c\u5728\u4e0b\u4e00\u884c\u3002\u73b0\u4ee3\u7684\u7f16\u8bd1\u5668\uff0c\u4f8b\u5982 Visual Studio 2010 \u4f1a\u7ed9\u4f60\u4e00\u4e2a\u6307\u793a\u544a\u8bc9\u4f60\u4f60\u6709\u53ef\u80fd\u5df2\u7ecf\u5fd8\u4e86\u4e00\u4e2a\u5206\u53f7\uff0c\u4f46\u662f\u66f4\u8001\u7684\u6216\u8005\u66f4\u529f\u80fd\u66f4\u7b80\u5355\u7684\u7f16\u8bd1\u5668\u4e0d\u4f1a\u90a3\u4e48\u505a\uff0c\u8fd9\u4f1a\u8ba9\u4f60\u5f88\u96be\u53d1\u73b0\u8fd9\u4e2a\u9519\u8bef \u7c7b\uff08\u548c\u7ed3\u6784\uff09\u5b9a\u4e49\u5c31\u50cf\u4e00\u4e2a blueprint \u2014\u2014 \u4ed6\u4eec\u63cf\u8ff0\u4e86\u5bf9\u8c61\u770b\u8d77\u6765\u5c06\u4f1a\u50cf\u4ec0\u4e48\uff0c\u4f46\u662f\u4ed6\u4eec\u4e0d\u4f1a\u5b9e\u9645\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002\u60f3\u8981\u521b\u5efa\u4e00\u4e2a\u7c7b\u7684\u5bf9\u8c61\uff0c\u4e00\u4e2a\u7c7b\u7684\u53d8\u91cf\u4e00\u5b9a\u8981\u88ab\u5b9a\u4e49\u51fa\u6765\u624d\u884c\uff1a DateClass today { 2020 , 10 , 14 }; // declare a variable of class DateClass","title":"Warning"},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#_2","text":"\u9664\u4e86\u6301\u6709\u6570\u636e\uff0c\u7c7b\uff08\u548c\u7ed3\u6784\uff09\u4e5f\u53ef\u4ee5\u5305\u542b\u51fd\u6570\uff01\u5728\u7c7b\u4e2d\u5b9a\u4e49\u7684\u51fd\u6570\u88ab\u53eb\u505a\u6210\u5458\u51fd\u6570\uff08\u6709\u65f6\u5019\u53eb\u2019\u65b9\u6cd5\u2018\uff09\u3002\u6210\u5458\u51fd\u6570\u53ef\u4ee5\u88ab\u5b9a\u4e49\u5728\u7c7b\u5185\u6216\u8005\u7c7b\u5916\uff0c\u6211\u4eec\u5c06\u4f1a\u5b9a\u4e49\u4ed6\u4eec\u5728\u7c7b\u5185\uff08\u4e3a\u4e86\u7b80\u5355\uff09\uff0c\u4e4b\u540e\u5c55\u793a\u5982\u4f55\u5728\u7c7b\u5916\u5b9a\u4e49\u3002 \u8fd9\u662f\u6211\u4eec\u7684\u5e26\u6709\u4e00\u4e2a\u6210\u5458\u51fd\u6570\u6765\u6253\u5370\u65e5\u671f\u7684\u7c7b\uff1a class DateClass { public : int m_year {}; int m_month {}; int m_day {}; void print () // defines a member function named print() { std :: cout << m_year << '/' << m_month << '/' << m_day ; } }; Just like members of a struct, members (variables and functions) of a class are accessed using the member selector operator (.): \u5c31\u50cf\u7ed3\u6784\u7684\u6210\u5458\uff0c\u7c7b\u7684\u6210\u5458\u4e5f\u53ef\u4ee5\u4f7f\u7528\u6210\u5458\u9009\u62e9\u64cd\u4f5c\u7b26\uff08.\uff09\u6765\u8bbf\u95ee\u6210\u5458\u3002 # include <iostream> class DateClass { public : int m_year {}; int m_month {}; int m_day {}; void print () { std :: cout << m_year << '/' << m_month << '/' << m_day ; } }; int main () { DateClass today { 2020 , 10 , 14 }; today . m_day = 16 ; // use member selection operator to select a member variable of the class today . print (); // use member selection operator to call a member function of the class return 0 ; } \u6253\u5370\uff1a 2020 / 10 / 16 \u6ce8\u610f\u8fd9\u4e2a\u7a0b\u5e8f\u8981\u6bd4\u6211\u4eec\u4e0a\u65b9\u4f7f\u7528 struct \u5b9e\u73b0\u7684\u7b80\u5355\u591a\u4e86\u3002 \u7136\u800c\uff0c\u6709\u4e00\u4e9b\u4e0d\u540c\u70b9\u3002\u5728\u4e0a\u65b9 DataStruct \u7248\u672c\u7684\u4f8b\u5b50\u4e2d\u7684 print() \u6211\u4eec\u4f20\u5165\u4e86\u7ed3\u6784\u672c\u8eab\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u8fdb\u5165 print() \u51fd\u6570\u3002\u5426\u5219\uff0cprint() \u4e0d\u4f1a\u77e5\u9053\u54ea\u6211\u4eec\u60f3\u6253\u5370\u54ea\u4e2a\u5bf9\u8c61\u3002\u6211\u4eec\u7d27\u63a5\u7740\u4e0d\u5f97\u4e0d\u4f7f\u7528\u8fd9\u4e2a\u53c2\u6570\uff0c\u5728\u51fd\u6570\u5185\u90e8\u3002 \u6210\u5458\u51fd\u6570\u5de5\u4f5c\u8d77\u6765\u6709\u8f7b\u5fae\u7684\u4e0d\u540c\uff1a\u6240\u6709\u7684\u6210\u5458\u51fd\u6570\u8c03\u7528\u5fc5\u987b\u548c\u8fd9\u4e2a\u7c7b\u7684\u5bf9\u8c61\u5173\u8054\u3002\u5f53\u6211\u4eec\u8c03\u7528 today.print() \u7684\u65f6\u5019\uff0c\u6211\u4eec\u544a\u8bc9\u7f16\u8bd1\u5668\u6211\u4eec\u8981\u8c03\u7528\u548c today \u8fd9\u4e2a\u5bf9\u8c61\u5173\u8054\u7684 print \u6210\u5458\u51fd\u6570\u3002 \u73b0\u5728\u8ba9\u6211\u4eec\u518d\u770b\u4e00\u904d\u6210\u5458\u51fd\u6570\u7684\u5b9a\u4e49 void print () // defines a member function named print() { std :: cout << m_year << '/' << m_month << '/' << m_day ; } m_year, m_month, m_day \u5b9e\u9645\u4e0a\u5206\u522b\u6307\u5411\u54ea\u91cc\uff1f\u4ed6\u4eec\u6307\u5411\u5173\u8054\u7684\u5bf9\u8c61\uff08\u7531\u8c03\u7528\u8005\u51b3\u5b9a\uff09\u3002 \u56e0\u6b64\u5f53\u6211\u4eec\u8c03\u7528 today.print() \u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u89e3\u91ca m_day \u4e3a today.m_today\uff0cm_month \u548c m_year\u4e5f\u5206\u522b\u89e3\u91ca\u4e3a today.m_month \u548c today.m_year \uff0c\u5982\u679c\u6211\u4eec\u8c03\u7528 tomorrow.print() \uff0c m_day \u5c31\u4f1a\u88ab tomorrow.m_day \u6307\u4ee3\u3002 \u4ee5\u8fd9\u79cd\u65b9\u5f0f\uff0c\u672c\u8d28\u4e0a\u9690\u5f0f\u7684\u4f20\u9001\u4e86\u4e00\u4e2a\u7c7b\u7684\u5b9e\u4f8b\u5230\u6210\u5458\u51fd\u6570\u3002\u56e0\u4e3a\u8fd9\u6837\uff0c\u4ed6\u624d\u80fd\u88ab\u9690\u5f0f\u7684\u8c03\u7528\u3002 \u6211\u4eec\u5c06\u4f1a\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\uff0c\u8ba8\u8bba\u66f4\u591a\u7684\u8fd9\u4e2a\u9690\u5f0f\u5bf9\u8c61\u5982\u4f55\u4f20\u5165\u5e76\u4e14\u8d77\u4f5c\u7528\u3002 \u5173\u952e\u5355\u662f\uff0c\u5f53\u6211\u4eec\u8c03\u7528\u975e\u6210\u5458\u51fd\u6570\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u4f20\u5165\u4e00\u4e2a\u5bf9\u8c61\u5230\u51fd\u6570\u3002\u800c\u5f53\u6211\u4eec\u8c03\u7528\u6210\u5458\u51fd\u6570\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe\u6211\u4eec\u603b\u662f\u6709\u4e00\u4e2a\u9690\u5f0f\u7684\u7c7b\u5bf9\u8c61\u53ef\u4ee5\u88ab\u4f7f\u7528\u3002 \u7ed9\u6210\u5458\u53d8\u91cf\u4f7f\u7528 \u201dm_\u201c \u524d\u7f00\u53ef\u4ee5\u5e2e\u52a9\u5c06\u6210\u5458\u53d8\u91cf\u3001\u6210\u5458\u51fd\u6570\u548c\u5728\u6210\u5458\u51fd\u6570\u4e2d\u4f7f\u7528\u7684\u5916\u90e8\u53d8\u91cf\u533a\u5206\u5f00\u3002\u8fd9\u662f\u975e\u5e38\u6709\u7528\u7684\uff0c\u8fd8\u6709\u5f88\u591a\u539f\u56e0\u3002 \u7b2c\u4e00\uff0c\u5f53\u6211\u4eec\u770b\u5230\u64cd\u4f5c\u4e00\u4e2a\u5e26 m_ \u524d\u7f00\u7684\u53d8\u91cf\u65f6\uff0c\u6211\u4eec\u5c31\u77e5\u9053\u6211\u4eec\u6b63\u5728\u6539\u53d8\u7c7b\u5b9e\u4f8b\u7684\u72b6\u6001\u3002 \u7b2c\u4e8c\uff0c\u4e0d\u50cf\u51fd\u6570\u6210\u5458\u548c\u5c40\u90e8\u53d8\u91cf\uff0c\u53ef\u4ee5\u88ab\u5b9a\u4e49\u5728\u51fd\u6570\u4e2d\uff0c\u6210\u5458\u53d8\u91cf\u88ab\u5b9a\u4e49\u5728\u7c7b\u58f0\u660e\u4e2d\u3002\u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u77e5\u9053\u4e00\u4e2a m_ \u524d\u7f00\u7684\u53d8\u91cf\u5982\u4f55\u88ab\u58f0\u660e\uff0c\u6211\u4eec\u77e5\u9053\u5e94\u8be5\u5b83\u88ab\u5b9a\u4e49\u5728\u7c7b\u4e2d\u5b9a\u4e49\u800c\u4e0d\u662f\u51fd\u6570\u4e2d\u3002 \u4e3a\u4e86\u65b9\u4fbf\uff0c\u7c7b\u540d\u5e94\u8be5\u4ee5\u4e00\u4e2a\u5927\u5199\u7684\u5b57\u6bcd\u5f00\u59cb\u3002 \u89c4\u5219\uff1a\u7c7b\u7684\u540d\u5b57\u4ee5\u5927\u5199\u5b57\u6bcd\u5f00\u59cb \u8fd9\u662f\u53e6\u4e00\u4e2a\u7c7b\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <string> class Employee { public : std :: string m_name {}; int m_id {}; double m_wage {}; // Print employee information to the screen void print () { std :: cout << \"Name: \" << m_name << \" Id: \" << m_id << \" Wage: $\" << m_wage << '\\n' ; } }; int main () { // Declare two employees Employee alex { \"Alex\" , 1 , 25.00 }; Employee joe { \"Joe\" , 2 , 22.25 }; // Print out the employee information alex . print (); joe . print (); return 0 ; } \u8f93\u51fa\u4e86\u7ed3\u679c\uff1a Name : Alex Id : 1 Wage : $25 Name : Joe Id : 2 Wage : $22 .25 \u5728\u666e\u901a\u7684\u975e\u6210\u5458\u51fd\u6570\u4e0b\uff0c\u4e00\u4e2a\u51fd\u6570\u4e0d\u53ef\u80fd\u8c03\u7528\u5728 \u201d\u4e0b\u65b9\u201c \u5b9a\u4e49\u7684\u51fd\u6570\uff08\u6ca1\u6709\u524d\u7f6e\u58f0\u660e\uff09 void x () { // You can't call y() from here unless the compiler has already seen a forward declaration for y() } void y () { } \u5728\u6210\u5458\u51fd\u6570\u4e2d\uff0c\u8fd9\u4e2a\u9650\u5236\u6ca1\u6709\u88ab\u5e94\u7528\uff1a class foo { public : void x () { y (); } // okay to call y() here, even though y() isn't defined until later in this class void y () { }; };","title":"\u6210\u5458\u51fd\u6570"},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#_3","text":"\u9664\u4e86\u6210\u5458\u53d8\u91cf\u548c\u6210\u5458\u51fd\u6570\uff0c\u7c7b\u53ef\u4ee5\u53c8\u6210\u5458\u7c7b\u578b\u6216\u8005\u5d4c\u5957\u7c7b\u578b\uff08\u5305\u62ec\u7c7b\u578b\u522b\u540d\uff09\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u8ba1\u7b97\u5668\uff0c\u6211\u4eec\u53ef\u4ee5\u5feb\u901f\u7684\u6539\u53d8\u6570\u5b57\u7684\u7c7b\u578b\u5982\u679c\u9700\u8981\u3002\uff08we can swiftly change the type of number it\u2019s using if we ever need to.\uff09 # include <iostream> # include <vector> class Calculator { public : using number_t = int ; // this is a nested type alias std :: vector < number_t > m_resultHistory {}; number_t add ( number_t a , number_t b ) { auto result { a + b }; m_resultHistory . push_back ( result ); return result ; } }; int main () { Calculator calculator {}; std :: cout << calculator . add ( 3 , 4 ) << '\\n' ; // 7 std :: cout << calculator . add ( 99 , 24 ) << '\\n' ; // 123 for ( Calculator :: number_t result : calculator . m_resultHistory ) { std :: cout << result << '\\n' ; } return 0 ; } \u8f93\u51fa 7 123 7 123 \u5728\u8fd9\u6837\u7684\u4e0a\u4e0b\u6587\u4e2d\uff0c\u7c7b\u540d\u9ad8\u6548\u7684\u7ed9\u5185\u5d4c\u7c7b\u578b\u626e\u6f14\u4e86\u4e00\u4e2a\u547d\u540d\u7a7a\u95f4\u7684\u89d2\u8272\u3002\u5728\u7c7b\u4e2d\uff0c\u6211\u4eec\u53ea\u9700\u8981\u53c2\u7167 number_t\u3002\u5728\u7c7b\u5916\u9762\uff0c\u6211\u4eec\u53ef\u4ee5\u963f\u8bbf\u95ee\u7c7b\u578b\u901a\u8fc7 Calculator::number_t . \u5f53\u6211\u4eec\u51b3\u5b9a\u4e00\u4e2a\u6574\u578b\u4e0d\u518d TODO\u7ffb\u8bd1\u4e2d When we decide that an int no longer fulfills our needs and we want to use a double, we only need to update the type alias, rather than having to replace every occurrence of int with double. Type alias members make code easier to maintain and can reduce typing. Template classes, which we\u2019ll cover later, often make use of type alias members. You\u2019ve already seen this as std::vector::size_type, where size_type is an alias for an unsigned integer. Nested types cannot be forward declared. Generally, nested types should only be used when the nested type is used exclusively within that class. Note that since classes are types, it\u2019s possible to nest classes inside other classes -- this is uncommon and is typically only done by advanced programmers. A note about structs in C++ In C, structs can only hold data, and do not have associated member functions. In C++, after designing classes (using the class keyword), Bjarne Stroustrup spent some amount of time considering whether structs (which were inherited from C) should be granted the ability to have member functions. Upon consideration, he determined that they should, in part to have a unified ruleset for both. So although we wrote the above programs using the class keyword, we could have used the struct keyword instead. Many developers (including myself) feel this was the incorrect decision to be made, as it can lead to dangerous assumptions. For example, it\u2019s fair to assume a class will clean up after itself (e.g. a class that allocates memory will deallocate it before being destroyed), but it\u2019s not safe to assume a struct will. Consequently, we recommend using the struct keyword for data-only structures, and the class keyword for defining objects that require both data and functions to be bundled together. Rule Use the struct keyword for data-only structures. Use the class keyword for objects that have both data and functions. You have already been using classes without knowing it It turns out that the C++ standard library is full of classes that have been created for your benefit. std::string, std::vector, and std::array are all class types! So when you create an object of any of these types, you\u2019re instantiating a class object. And when you call invoke a function using these objects, you\u2019re calling a member function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15","title":"\u6210\u5458\u7c7b\u578b"},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#include","text":"","title":"include "},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#include_1","text":"","title":"include "},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#include_2","text":"","title":"include "},{"location":"08-basic-object-oriented-programming/8.2-classes-and-class-member/#include_3","text":"int main() { std::string s { \"Hello, world!\" }; // instantiate a string class object std::array<int, 3> a { 1, 2, 3 }; // instantiate an array class object std::vector<double> v { 1.1, 2.2, 3.3 }; // instantiate a vector class object std::cout << \"length: \" << s.length() << '\\n'; // call a member function return 0; } Conclusion The class keyword lets us create a custom type in C++ that can contain both member variables and member functions. Classes form the basis for Object-oriented programming, and we\u2019ll spend the rest of this chapter and many of the future chapters exploring all they have to offer!","title":"include "},{"location":"14-exceptions/","text":"14 \u5f02\u5e38 \u00b6 14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406 14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00 14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26 14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f 14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa 14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757 14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9","title":"14 \u5f02\u5e38"},{"location":"14-exceptions/#14","text":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406 14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00 14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26 14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f 14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa 14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757 14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9","title":"14 \u5f02\u5e38"},{"location":"14-exceptions/14.1-the-need-for-exceptions/","text":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 \u00b6 By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6709\u5173\u9519\u8bef\u5904\u7406\u65f6\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528 assert() \uff0c cerr() \u548c exit() \u6765\u5904\u7406\u9519\u8bef\u7684\u65b9\u6cd5\u3002\u90a3\u65f6\u6211\u4eec\u63d0\u5230\u4e86\u4e00\u4e2a\u5c06\u4f1a\u8bb2\u7684\u8bdd\u9898\uff0c\u7136\u540e\u6211\u4eec\u73b0\u5728\u5c31\u8981\u5f00\u59cb\u8bb2\uff1a \u5f02\u5e38 \u3002 \u5931\u8d25\u65f6\u8fd4\u56de\u72b6\u6001\u7801 \u00b6 \u5f53\u6211\u4eec\u7f16\u5199\u53ef\u590d\u7528\u7684\u4ee3\u7801\u65f6\uff0c\u9519\u8bef\u5904\u7406\u662f\u4e00\u4e2a\u5fc5\u9009\u9879\u3002\u6700\u5e38\u89c1\u7684\u5904\u7406\u9519\u8bef\u7684\u65b9\u5f0f\u4e4b\u4e00\u662f\u901a\u8fc7\u8fd4\u56de\u72b6\u6001\u7801\uff0c\u4f8b\u5982\uff1a int findFirstChar ( const char * string , char ch ) { const std :: size_t stringlength { strlen ( string ) }; // \u9010\u4e2a\u8c03\u8bd5\u6240\u6709\u5b57\u7b26\u4e32 for ( std :: size_t index = 0 ; index < stringlength ; ++ index ) // \u5982\u679c\u5339\u914d\u8fd4\u56de\u4e0b\u6807\u5bf9\u5e94\u7d22\u5f15... if ( string [ index ] == ch ) return index ; // \u5982\u679c\u6ca1\u6709\u5339\u914d\u4e0a\uff0c\u8fd4\u56de-1 return -1 ; } \u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u7b2c\u4e00\u4e2a\u9996\u5b57\u7b26\u5339\u914d\u7684\u5b57\u7b26\u4e32\u7d22\u5f15\uff0c\u5982\u679c\u5b57\u7b26\u6ca1\u6709\u88ab\u627e\u5230\uff0c\u51fd\u6570\u8fd4\u56de -1 \u7528\u4f5c\u9519\u8bef\u6307\u793a\u3002 \u8fd9\u4e2a\u57fa\u7840\u7684\u65b9\u6cd5\u662f\u76f8\u5f53\u7684\u7b80\u5355\uff0c\u7136\u800c\uff0c\u4f7f\u7528\u8fd4\u56de\u72b6\u6001\u7801\u6709\u4e00\u4e9b\u7f3a\u70b9\uff0c\u7136\u800c\u8fd9\u4e9b\u7f3a\u70b9\u53ef\u80fd\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\u53d8\u5f97\u5c24\u5176\u660e\u663e\uff1a \u7b2c\u4e00\uff1a \u8fd4\u56de\u503c\u542b\u4e49\u6a21\u7cca\u2014\u2014\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de -1 \uff0c\u5b83\u5c1d\u8bd5\u8868\u660e\u4e00\u4e2a\u9519\u8bef\uff0c\u800c\u6216\u8005\u90a3\u5c31\u662f\u4e00\u4e2a\u6b63\u5e38\u7684\u8fd4\u56de\u503c\uff1f\u5982\u679c\u4e0d\u8fdb\u5165\u4e00\u4e2a\u51fd\u6570\u67e5\u770b\u5177\u4f53\u5b9e\u73b0\uff0c\u901a\u5e38\u5f88\u96be\u77e5\u9053\u3002 \u7b2c\u4e8c\uff1a \u51fd\u53ea\u80fd\u6709\u4e00\u4e2a\u8fd4\u56de\u503c\uff0c\u56e0\u6b64\u5982\u679c\u4f60\u9700\u8981\u540c\u65f6\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u7ed3\u679c\u548c\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570\uff1a double divide ( int x , int y ) { return static_cast < double > ( x ) / y ; } \u8fd9\u4e2a\u51fd\u6570\u80af\u5b9a\u9700\u8981\u4e00\u4e9b\u9519\u8bef\u5904\u7406\uff0c\u56e0\u4e3a\u5982\u679c\u7528\u6237\u4f20\u5165\u4e00\u4e2a 0 \u4f5c\u4e3a\u53d8\u91cf y \uff0c\u5b83\u5c06\u4f1a\u5d29\u6e83\u3002\u7136\u800c\uff0c\u5b83\u4e5f\u9700\u8981\u8fd4\u56de x/y \u7684\u7ed3\u679c\u3002\u5b83\u5982\u4f55\u624d\u80fd\u517c\u987e\uff1f\u6700\u5e38\u89c1\u7684\u7b54\u6848\u5c31\u662f\u5c06\u7ed3\u679c\u6216\u8005\u9519\u8bef\u5904\u7406\u503c\u4f20\u5165\u4f5c\u4e3a\u4e00\u4e2a\u5f15\u7528\u53d8\u91cf\u3002\u90a3\u6837\u7684\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u7cdf\u7cd5\uff0c\u4e5f\u4e0d\u65b9\u4fbf\u4f7f\u7528\uff0c\u4f8b\u5982\uff1a #include <iostream> double divide ( int x , int y , bool & success ) { if ( y == 0 ) { success = false ; return 0.0 ; } success = true ; return static_cast < double > ( x ) / y ; } int main () { bool success ; // \u6211\u4eec\u5fc5\u987b\u4f20\u5165\u4e00\u4e2a bool \u6765\u770b\u51fd\u6570\u662f\u5426\u6267\u884c\u6210\u529f\u3002 double result = divide ( 5 , 3 , success ); if ( ! success ) // \u5728\u4f7f\u7528\u503c\u4e4b\u524d\u8981\u5148\u68c0\u67e5\u662f\u5426\u6210\u529f std :: cerr << \"An error occurred\" << std :: endl ; else cout << \"The answer is \" << result << '\\n' ; } \u7b2c\u4e09\uff1a \u5728\u4e00\u5806\u4ee3\u7801\u4e2d\u53ef\u80fd\u6709\u8bb8\u591a\u4e8b\u60c5\u53ef\u80fd\u4f1a\u62a5\u9519\uff0c\u9519\u8bef\u72b6\u6001\u7801\u4f1a\u88ab\u4e0d\u65ad\u7684\u68c0\u67e5\u3002 \u601d\u8003\u4e0b\u9762\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u8be5\u7247\u6bb5\u6d89\u53ca\u5230\u89e3\u6790\u4e00\u4e2a\u6587\u5b57\u6587\u4ef6\uff0c\u7528\u6765\u83b7\u53d6\u4e00\u4e9b\u5b58\u5728\u6587\u4ef6\u4e2d\u7684\u503c\uff1a std :: ifstream setupIni ( \"setup.ini\" ); // open setup.ini for reading // \u6253\u5f00 \u5e76\u8bfb\u53d6 setup.ini // If the file couldn't be opened (e.g. because it was missing) return some error enum // \u5982\u679c\u4e0d\u80fd\u88ab\u6253\u5f00\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u5b83\u4e22\u5931\u4e86\uff09\uff0c\u8fd4\u56de\u4e86\u4e00\u4e9b\u9519\u8bef\u679a\u4e3e if ( ! setupIni ) return ERROR_OPENING_FILE ; // Now read a bunch of values from a file // \u73b0\u5728\u4ece\u6587\u4ef6\u4e2d\u8bfb\u51fa\u4e00\u5806\u503c if ( ! readIntegerFromFile ( setupIni , m_firstParameter )) // try to read an integer from the file // \u5c1d\u8bd5\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u6574\u578b return ERROR_READING_VALUE ; // Return enum value indicating value couldn't be read // \u8fd4\u56de\u4e00\u4e2a\u679a\u4e3e\u503c\u8868\u793a\u503c\u4e0d\u80fd\u88ab\u8bfb\u53d6 if ( ! readDoubleFromFile ( setupIni , m_secondParameter )) // try to read a double from the file return ERROR_READING_VALUE ; if ( ! readFloatFromFile ( setupIni , m_thirdParameter )) // try to read a float from the file return ERROR_READING_VALUE ; \u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u8fd8\u6ca1\u6709\u8bb2\u8fc7\u6587\u4ef6\u8bbf\u95ee\uff0c\u5982\u679c\u4f60\u4e0d\u77e5\u9053\u4e0a\u9762\u7684\u4ee3\u7801\u65f6\u5982\u4f55\u5de5\u4f5c\u7684\uff0c\u4e0d\u8981\u56e0\u6b64\u62c5\u5fc3\u3002 \u6ce8\u610f\u6bcf\u6b21\u90fd\u8c03\u7528\u9700\u8981\u4e00\u4e2a\u9519\u8bef\u68c0\u67e5\u5e76\u4e14\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\u3002\u73b0\u5728\u60f3\u8c61\u5982\u679c\u670920\u4e2a\u4e0d\u540c\u7684\u7c7b\u578b\u2014\u2014\u4f60\u5c06\u68c0\u67e5\u4e00\u4e2a\u9519\u8bef\uff0c\u5e76\u4e14\u8fd4\u56de ERROR_READING_VALUE \u4e8c\u5341\u6b21\uff01\u6240\u6709\u8fd9\u4e9b\u4e0d\u540c\u7684\u9519\u8bef\u68c0\u67e5\u548c\u8fd4\u56de\u503c\u4f7f\u5f97\u786e\u5b9a\u51fd\u6570\u8981\u505a\u7684\u4e8b\u60c5\u53d8\u5f97\u66f4\u52a0\u96be\u4ee5\u8bc6\u522b\u3002 \uff08All of this error checking and returning values makes determining what the function is trying to do much harder to discern.\uff09 \u7b2c\u56db\uff1a \u8fd4\u56de\u9519\u8bef\u7801\u4e0d\u80fd\u548c\u6784\u9020\u51fd\u6570\u5f88\u597d\u7684\u642d\u914d\u3002\u5982\u679c\u4f60\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\u6784\u9020\u51fd\u6570\u53d1\u751f\u4e0d\u53ef\u6062\u590d\u7684\u9519\u8bef\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u6784\u9020\u51fd\u6570\u6ca1\u6709\u8fd4\u56de\u503c\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u6307\u793a\uff0c\u6216\u8bb8\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f20\u5165\u5f15\u7528\u6765\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u7801\uff0c\u4f46\u8fd9\u6837\u4f1a\u5f88\u6df7\u4e71\uff0c\u5e76\u4e14\u5fc5\u987b\u88ab\u663e\u5f0f\u7684\u68c0\u67e5\u3002\u6b64\u5916\uff0c\u5373\u4fbf\u4f60\u8fd9\u6837\u505a\u4e86\uff0c\u5bf9\u8c61\u4ecd\u7136\u4f1a\u88ab\u521b\u5efa\u5e76\u4e14\u7d27\u63a5\u4e0d\u5f97\u4e0d\u88ab\u5904\u7406 \uff08 the object will still be created and then has to be dealt with or disposed of.\uff09 \u3002 \u6700\u540e\uff1a \u5f53\u4e00\u4e2a\u9519\u8bef\u7801\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\uff0c\u8c03\u7528\u8005\u53ef\u80fd\u4e0d\u5177\u6709\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\u7684\u80fd\u529b\u3002\u5982\u679c\u8c03\u7528\u8005\u4e0d\u80fd\u6216\u8005\u4e0d\u60f3\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\uff0c\u8c03\u7528\u8005\u53ef\u4ee5\u5ffd\u7565\u9519\u8bef\uff08\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u9519\u8bef\u5c06\u4f1a\u6c38\u8fdc\u4e22\u5931\uff09\uff0c\u6216\u8005\u8fd4\u56de\u51fa\u9519\u8bef\u5230\u8c03\u7528\u8be5\u51fd\u6570\u7684\u51fd\u6570\u3002\u8fd9\u53ef\u80fd\u5f88\u4e71\u5e76\u4e14\u5f15\u8d77\u5f88\u591a\u4ee5\u4e0a\u63d0\u5230\u7684\u540c\u6837\u7684\u95ee\u9898\u3002 \u603b\u7684\u6765\u8bf4\uff0c\u8fd4\u56de\u72b6\u6001\u7801\u7684\u57fa\u672c\u95ee\u9898\u5c31\u662f\u9519\u8bef\u7801\u9519\u7efc\u590d\u6742\u7684\u548c\u4ee3\u7801\u4e2d\u7684\u5e38\u89c4\u63a7\u5236\u6d41\u6df7\u5408\u5728\u4e00\u8d77\u3002\u8fd9\u4e9b\u6700\u7ec8\u53cd\u8fc7\u6765\u4e0d\u4ec5\u9650\u5236\u4e86\u4ee3\u7801\u5982\u4f55\u7f16\u5199\uff0c\u540c\u65f6\u8fd8\u9650\u5236\u4e86\u9519\u8bef\u5982\u4f55\u80fd\u88ab\u5408\u7406\u7684\u5904\u7406\u3002 \u5f02\u5e38 \u00b6 \u5f02\u5e38\u5904\u7406\u63d0\u4f9b\u4e86\u4e00\u4e2a\u673a\u5236\uff0c\u5c06\u5904\u7406\u9519\u8bef\u4e0e\u4f60\u4ee3\u7801\u91cc\u5e38\u89c4\u63a7\u5236\u6d41\u4e2d\u51fa\u73b0\u7684\u5f02\u5e38\u60c5\u51b5\u89e3\u8026\u3002\u8fd9\u53ef\u4ee5\u7ed9\u6211\u4eec\u66f4\u591a\u7684\u81ea\u7531\u6765\u51b3\u5b9a\u5728\u5f53\u524d\u60c5\u51b5\u4e0b\uff0c\u4f55\u65f6\u6216\u8005\u5982\u4f55\u5904\u7406\u9519\u8bef\uff0c\u51cf\u8f7b\u4e86\u8bb8\u591a\uff08\u6216\u8bb8\u4e0d\u662f\u6240\u6709\uff09\u8fd4\u56de\u9519\u8bef\u7801\u65f6\u7684\u6df7\u4e71\u3002 In the next lesson, we\u2019ll take a look at how exceptions work in C++. \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u770b\u770b\u5f02\u5e38\u5728C++\u4e2d\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002","title":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38"},{"location":"14-exceptions/14.1-the-need-for-exceptions/#141","text":"By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6709\u5173\u9519\u8bef\u5904\u7406\u65f6\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528 assert() \uff0c cerr() \u548c exit() \u6765\u5904\u7406\u9519\u8bef\u7684\u65b9\u6cd5\u3002\u90a3\u65f6\u6211\u4eec\u63d0\u5230\u4e86\u4e00\u4e2a\u5c06\u4f1a\u8bb2\u7684\u8bdd\u9898\uff0c\u7136\u540e\u6211\u4eec\u73b0\u5728\u5c31\u8981\u5f00\u59cb\u8bb2\uff1a \u5f02\u5e38 \u3002","title":"14.1 \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38"},{"location":"14-exceptions/14.1-the-need-for-exceptions/#_1","text":"\u5f53\u6211\u4eec\u7f16\u5199\u53ef\u590d\u7528\u7684\u4ee3\u7801\u65f6\uff0c\u9519\u8bef\u5904\u7406\u662f\u4e00\u4e2a\u5fc5\u9009\u9879\u3002\u6700\u5e38\u89c1\u7684\u5904\u7406\u9519\u8bef\u7684\u65b9\u5f0f\u4e4b\u4e00\u662f\u901a\u8fc7\u8fd4\u56de\u72b6\u6001\u7801\uff0c\u4f8b\u5982\uff1a int findFirstChar ( const char * string , char ch ) { const std :: size_t stringlength { strlen ( string ) }; // \u9010\u4e2a\u8c03\u8bd5\u6240\u6709\u5b57\u7b26\u4e32 for ( std :: size_t index = 0 ; index < stringlength ; ++ index ) // \u5982\u679c\u5339\u914d\u8fd4\u56de\u4e0b\u6807\u5bf9\u5e94\u7d22\u5f15... if ( string [ index ] == ch ) return index ; // \u5982\u679c\u6ca1\u6709\u5339\u914d\u4e0a\uff0c\u8fd4\u56de-1 return -1 ; } \u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u7b2c\u4e00\u4e2a\u9996\u5b57\u7b26\u5339\u914d\u7684\u5b57\u7b26\u4e32\u7d22\u5f15\uff0c\u5982\u679c\u5b57\u7b26\u6ca1\u6709\u88ab\u627e\u5230\uff0c\u51fd\u6570\u8fd4\u56de -1 \u7528\u4f5c\u9519\u8bef\u6307\u793a\u3002 \u8fd9\u4e2a\u57fa\u7840\u7684\u65b9\u6cd5\u662f\u76f8\u5f53\u7684\u7b80\u5355\uff0c\u7136\u800c\uff0c\u4f7f\u7528\u8fd4\u56de\u72b6\u6001\u7801\u6709\u4e00\u4e9b\u7f3a\u70b9\uff0c\u7136\u800c\u8fd9\u4e9b\u7f3a\u70b9\u53ef\u80fd\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\u53d8\u5f97\u5c24\u5176\u660e\u663e\uff1a \u7b2c\u4e00\uff1a \u8fd4\u56de\u503c\u542b\u4e49\u6a21\u7cca\u2014\u2014\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de -1 \uff0c\u5b83\u5c1d\u8bd5\u8868\u660e\u4e00\u4e2a\u9519\u8bef\uff0c\u800c\u6216\u8005\u90a3\u5c31\u662f\u4e00\u4e2a\u6b63\u5e38\u7684\u8fd4\u56de\u503c\uff1f\u5982\u679c\u4e0d\u8fdb\u5165\u4e00\u4e2a\u51fd\u6570\u67e5\u770b\u5177\u4f53\u5b9e\u73b0\uff0c\u901a\u5e38\u5f88\u96be\u77e5\u9053\u3002 \u7b2c\u4e8c\uff1a \u51fd\u53ea\u80fd\u6709\u4e00\u4e2a\u8fd4\u56de\u503c\uff0c\u56e0\u6b64\u5982\u679c\u4f60\u9700\u8981\u540c\u65f6\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u7ed3\u679c\u548c\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570\uff1a double divide ( int x , int y ) { return static_cast < double > ( x ) / y ; } \u8fd9\u4e2a\u51fd\u6570\u80af\u5b9a\u9700\u8981\u4e00\u4e9b\u9519\u8bef\u5904\u7406\uff0c\u56e0\u4e3a\u5982\u679c\u7528\u6237\u4f20\u5165\u4e00\u4e2a 0 \u4f5c\u4e3a\u53d8\u91cf y \uff0c\u5b83\u5c06\u4f1a\u5d29\u6e83\u3002\u7136\u800c\uff0c\u5b83\u4e5f\u9700\u8981\u8fd4\u56de x/y \u7684\u7ed3\u679c\u3002\u5b83\u5982\u4f55\u624d\u80fd\u517c\u987e\uff1f\u6700\u5e38\u89c1\u7684\u7b54\u6848\u5c31\u662f\u5c06\u7ed3\u679c\u6216\u8005\u9519\u8bef\u5904\u7406\u503c\u4f20\u5165\u4f5c\u4e3a\u4e00\u4e2a\u5f15\u7528\u53d8\u91cf\u3002\u90a3\u6837\u7684\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u7cdf\u7cd5\uff0c\u4e5f\u4e0d\u65b9\u4fbf\u4f7f\u7528\uff0c\u4f8b\u5982\uff1a #include <iostream> double divide ( int x , int y , bool & success ) { if ( y == 0 ) { success = false ; return 0.0 ; } success = true ; return static_cast < double > ( x ) / y ; } int main () { bool success ; // \u6211\u4eec\u5fc5\u987b\u4f20\u5165\u4e00\u4e2a bool \u6765\u770b\u51fd\u6570\u662f\u5426\u6267\u884c\u6210\u529f\u3002 double result = divide ( 5 , 3 , success ); if ( ! success ) // \u5728\u4f7f\u7528\u503c\u4e4b\u524d\u8981\u5148\u68c0\u67e5\u662f\u5426\u6210\u529f std :: cerr << \"An error occurred\" << std :: endl ; else cout << \"The answer is \" << result << '\\n' ; } \u7b2c\u4e09\uff1a \u5728\u4e00\u5806\u4ee3\u7801\u4e2d\u53ef\u80fd\u6709\u8bb8\u591a\u4e8b\u60c5\u53ef\u80fd\u4f1a\u62a5\u9519\uff0c\u9519\u8bef\u72b6\u6001\u7801\u4f1a\u88ab\u4e0d\u65ad\u7684\u68c0\u67e5\u3002 \u601d\u8003\u4e0b\u9762\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u8be5\u7247\u6bb5\u6d89\u53ca\u5230\u89e3\u6790\u4e00\u4e2a\u6587\u5b57\u6587\u4ef6\uff0c\u7528\u6765\u83b7\u53d6\u4e00\u4e9b\u5b58\u5728\u6587\u4ef6\u4e2d\u7684\u503c\uff1a std :: ifstream setupIni ( \"setup.ini\" ); // open setup.ini for reading // \u6253\u5f00 \u5e76\u8bfb\u53d6 setup.ini // If the file couldn't be opened (e.g. because it was missing) return some error enum // \u5982\u679c\u4e0d\u80fd\u88ab\u6253\u5f00\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u5b83\u4e22\u5931\u4e86\uff09\uff0c\u8fd4\u56de\u4e86\u4e00\u4e9b\u9519\u8bef\u679a\u4e3e if ( ! setupIni ) return ERROR_OPENING_FILE ; // Now read a bunch of values from a file // \u73b0\u5728\u4ece\u6587\u4ef6\u4e2d\u8bfb\u51fa\u4e00\u5806\u503c if ( ! readIntegerFromFile ( setupIni , m_firstParameter )) // try to read an integer from the file // \u5c1d\u8bd5\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u6574\u578b return ERROR_READING_VALUE ; // Return enum value indicating value couldn't be read // \u8fd4\u56de\u4e00\u4e2a\u679a\u4e3e\u503c\u8868\u793a\u503c\u4e0d\u80fd\u88ab\u8bfb\u53d6 if ( ! readDoubleFromFile ( setupIni , m_secondParameter )) // try to read a double from the file return ERROR_READING_VALUE ; if ( ! readFloatFromFile ( setupIni , m_thirdParameter )) // try to read a float from the file return ERROR_READING_VALUE ; \u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u8fd8\u6ca1\u6709\u8bb2\u8fc7\u6587\u4ef6\u8bbf\u95ee\uff0c\u5982\u679c\u4f60\u4e0d\u77e5\u9053\u4e0a\u9762\u7684\u4ee3\u7801\u65f6\u5982\u4f55\u5de5\u4f5c\u7684\uff0c\u4e0d\u8981\u56e0\u6b64\u62c5\u5fc3\u3002 \u6ce8\u610f\u6bcf\u6b21\u90fd\u8c03\u7528\u9700\u8981\u4e00\u4e2a\u9519\u8bef\u68c0\u67e5\u5e76\u4e14\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\u3002\u73b0\u5728\u60f3\u8c61\u5982\u679c\u670920\u4e2a\u4e0d\u540c\u7684\u7c7b\u578b\u2014\u2014\u4f60\u5c06\u68c0\u67e5\u4e00\u4e2a\u9519\u8bef\uff0c\u5e76\u4e14\u8fd4\u56de ERROR_READING_VALUE \u4e8c\u5341\u6b21\uff01\u6240\u6709\u8fd9\u4e9b\u4e0d\u540c\u7684\u9519\u8bef\u68c0\u67e5\u548c\u8fd4\u56de\u503c\u4f7f\u5f97\u786e\u5b9a\u51fd\u6570\u8981\u505a\u7684\u4e8b\u60c5\u53d8\u5f97\u66f4\u52a0\u96be\u4ee5\u8bc6\u522b\u3002 \uff08All of this error checking and returning values makes determining what the function is trying to do much harder to discern.\uff09 \u7b2c\u56db\uff1a \u8fd4\u56de\u9519\u8bef\u7801\u4e0d\u80fd\u548c\u6784\u9020\u51fd\u6570\u5f88\u597d\u7684\u642d\u914d\u3002\u5982\u679c\u4f60\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\u6784\u9020\u51fd\u6570\u53d1\u751f\u4e0d\u53ef\u6062\u590d\u7684\u9519\u8bef\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u6784\u9020\u51fd\u6570\u6ca1\u6709\u8fd4\u56de\u503c\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u6307\u793a\uff0c\u6216\u8bb8\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f20\u5165\u5f15\u7528\u6765\u4f20\u56de\u4e00\u4e2a\u72b6\u6001\u7801\uff0c\u4f46\u8fd9\u6837\u4f1a\u5f88\u6df7\u4e71\uff0c\u5e76\u4e14\u5fc5\u987b\u88ab\u663e\u5f0f\u7684\u68c0\u67e5\u3002\u6b64\u5916\uff0c\u5373\u4fbf\u4f60\u8fd9\u6837\u505a\u4e86\uff0c\u5bf9\u8c61\u4ecd\u7136\u4f1a\u88ab\u521b\u5efa\u5e76\u4e14\u7d27\u63a5\u4e0d\u5f97\u4e0d\u88ab\u5904\u7406 \uff08 the object will still be created and then has to be dealt with or disposed of.\uff09 \u3002 \u6700\u540e\uff1a \u5f53\u4e00\u4e2a\u9519\u8bef\u7801\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\uff0c\u8c03\u7528\u8005\u53ef\u80fd\u4e0d\u5177\u6709\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\u7684\u80fd\u529b\u3002\u5982\u679c\u8c03\u7528\u8005\u4e0d\u80fd\u6216\u8005\u4e0d\u60f3\u5904\u7406\u8fd9\u4e2a\u9519\u8bef\uff0c\u8c03\u7528\u8005\u53ef\u4ee5\u5ffd\u7565\u9519\u8bef\uff08\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u9519\u8bef\u5c06\u4f1a\u6c38\u8fdc\u4e22\u5931\uff09\uff0c\u6216\u8005\u8fd4\u56de\u51fa\u9519\u8bef\u5230\u8c03\u7528\u8be5\u51fd\u6570\u7684\u51fd\u6570\u3002\u8fd9\u53ef\u80fd\u5f88\u4e71\u5e76\u4e14\u5f15\u8d77\u5f88\u591a\u4ee5\u4e0a\u63d0\u5230\u7684\u540c\u6837\u7684\u95ee\u9898\u3002 \u603b\u7684\u6765\u8bf4\uff0c\u8fd4\u56de\u72b6\u6001\u7801\u7684\u57fa\u672c\u95ee\u9898\u5c31\u662f\u9519\u8bef\u7801\u9519\u7efc\u590d\u6742\u7684\u548c\u4ee3\u7801\u4e2d\u7684\u5e38\u89c4\u63a7\u5236\u6d41\u6df7\u5408\u5728\u4e00\u8d77\u3002\u8fd9\u4e9b\u6700\u7ec8\u53cd\u8fc7\u6765\u4e0d\u4ec5\u9650\u5236\u4e86\u4ee3\u7801\u5982\u4f55\u7f16\u5199\uff0c\u540c\u65f6\u8fd8\u9650\u5236\u4e86\u9519\u8bef\u5982\u4f55\u80fd\u88ab\u5408\u7406\u7684\u5904\u7406\u3002","title":"\u5931\u8d25\u65f6\u8fd4\u56de\u72b6\u6001\u7801"},{"location":"14-exceptions/14.1-the-need-for-exceptions/#_2","text":"\u5f02\u5e38\u5904\u7406\u63d0\u4f9b\u4e86\u4e00\u4e2a\u673a\u5236\uff0c\u5c06\u5904\u7406\u9519\u8bef\u4e0e\u4f60\u4ee3\u7801\u91cc\u5e38\u89c4\u63a7\u5236\u6d41\u4e2d\u51fa\u73b0\u7684\u5f02\u5e38\u60c5\u51b5\u89e3\u8026\u3002\u8fd9\u53ef\u4ee5\u7ed9\u6211\u4eec\u66f4\u591a\u7684\u81ea\u7531\u6765\u51b3\u5b9a\u5728\u5f53\u524d\u60c5\u51b5\u4e0b\uff0c\u4f55\u65f6\u6216\u8005\u5982\u4f55\u5904\u7406\u9519\u8bef\uff0c\u51cf\u8f7b\u4e86\u8bb8\u591a\uff08\u6216\u8bb8\u4e0d\u662f\u6240\u6709\uff09\u8fd4\u56de\u9519\u8bef\u7801\u65f6\u7684\u6df7\u4e71\u3002 In the next lesson, we\u2019ll take a look at how exceptions work in C++. \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u770b\u770b\u5f02\u5e38\u5728C++\u4e2d\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002","title":"\u5f02\u5e38"},{"location":"14-exceptions/14.2-basic-exception-handloing/","text":"14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406 \u00b6 By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 \u4e2d\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528\u8fd4\u56de\u503c\u72b6\u6001\u7801\u4e3a\u4f55\u4f1a\u4f7f\u5f97\u4f60\u7684\u63a7\u5236\u6d41\u548c\u9519\u8bef\u5904\u7406\u88ab\u6df7\u5408\uff0c\u4f7f\u5f97\u4e24\u8005\u76f8\u4e92\u7ea6\u675f\u3002\u5f02\u5e38\u5728C++\u4e2d\u7684\u5b9e\u73b0\u4f7f\u7528\u4e86\u4e09\u4e2a\u5173\u952e\u8bcd\uff0c\u6765\u76f8\u4e92\u8fde\u63a5\uff1a throw , try , catch \u3002 \u629b\u51fa\u5f02\u5e38 \u00b6 \u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u6765\u8bb0\u5f55\u5df2\u7ecf\u53d1\u751f\u7684\u7279\u5b9a\u7684\u4e8b\u60c5\u3002\u4f8b\u5982\u5728\u7f8e\u56fd\u8db3\u7403\u6bd4\u8d5b\u4e2d\uff0c\u5982\u679c\u4e00\u4e2a\u8fd0\u52a8\u5458\u72af\u89c4\u4e86\uff0c\u88c1\u5224\u5c06\u4f1a\u62ff\u51fa\u4e00\u4e2aflag\u5e76\u4e14\u5439\u54e8\u8868\u793a\u6e38\u620f\u6682\u505c\u3002\u60e9\u7f5a\u5c31\u662f\u7d27\u63a5\u7740\u8bc4\u4f30\u548c\u6267\u884c\u3002\u60e9\u7f5a\u88ab\u6267\u884c\u540e\uff0c\u6e38\u620f\u7167\u65e7\u7ee7\u7eed\u3002 \u5728 C++ \u4e2d\uff0c\u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u6216\u8005\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff08\u53ef\u4ee5\u8ba4\u4e3a\u662f\u629b\u51fa\u4e86\u4e00\u4e2a\u60e9\u7f5a\u7684flag\uff09\u3002\u53d1\u51fa\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u5df2\u7ecf\u53d1\u751f\uff0c\u8005\u901a\u5e38\u88ab\u53eb\u505a\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\u3002 \u4e3a\u4e86\u4f7f\u7528\u4e00\u4e2a\u5f02\u5e38\u4e00\u53e5\uff0c\u7b80\u5355\u7684\u4f7f\u7528 throw \u5173\u952e\u8bcd\uff0c\u7d27\u8ddf\u7740\u4e00\u4e2a\u4f60\u5e0c\u671b\u4f7f\u7528\u7684\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u6765\u901a\u77e5\u4e00\u4e2a\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff0c\u901a\u5e38\u8fd9\u548c\u503c\u5c06\u4f1a\u662f\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u4e00\u4e2a\u95ee\u9898\u7684\u63cf\u8ff0\uff0c\u6216\u8005\u4e00\u4e2a\u81ea\u5b9a\u4e49\u5f02\u5e38\u7c7b\u3002 \u8fd9\u91cc\u662f\u4e00\u4e9b\u4f8b\u5b50\uff1a throw -1 ; // throw a literal integer value throw ENUM_INVALID_INDEX ; // throw an enum value throw \"Can not take square root of negative number\" ; // throw a literal C-style (const char*) string throw dX ; // throw a double variable that was previously defined throw MyException ( \"Fatal Error\" ); // Throw an object of class MyException \u8fd9\u91cc\u7684\u6bcf\u4e00\u4e2a\u8bed\u53e5\u90fd\u5f53\u505a\u4e00\u4e2a\u4fe1\u53f7\uff0c\u8868\u793a\u67d0\u79cd\u7c7b\u578b\u7684\u9700\u8981\u88ab\u89e3\u51b3\u7684\u95ee\u9898\u5df2\u7ecf\u53d1\u751f\u4e86\u3002 \u5bfb\u627e\u5f02\u5e38 \u00b6 \u629b\u51fa\u5f02\u5e38\u53ea\u662f\u5f02\u5e38\u5904\u7406\u8fdb\u7a0b\u7684\u4e00\u90e8\u5206\u3002\u8ba9\u6211\u4eec\u56de\u5230\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\u4e2d\uff1a\u4e00\u65e6\u88c1\u5224\u629b\u51fa\u4e00\u4e2a\u4e00\u4e2a\u60e9\u7f5aflag\uff0c\u63a5\u4e0b\u6765\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u53c2\u8d5b\u8005\u4eec\u4e3b\u8981\u5230\u4e00\u4e2a\u60e9\u7f5a\u53d1\u751f\uff0c\u5e76\u4e14\u505c\u6b62\u6e38\u620f\u3002\u4e00\u4e2a\u666e\u901a\u7684\u8db3\u7403\u6bd4\u8d5b\u6d41\u7a0b\u4e2d\u65ad\u3002 \u5728C++\u4e2d\uff0c\u6211\u4eec\u7528 try \u5173\u952e\u8bcd\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a try \u8bed\u53e5\u5757\uff09\uff0ctry \u8bed\u53e5\u5757\u4f5c\u4e3a\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0c\u5bfb\u627e\u4efb\u4f55\u7c7b\u578b\u88ab\u629b\u51fa\u7684\u5f02\u5e38\u5728 try \u8bed\u53e5\u7684block\u4e2d\u3002 Here\u2019s an example of a try block: try { // Statements that may throw exceptions you want to handle go here // \u5230\u90a3\u513f\uff0c\u53ef\u80fd\u629b\u51fa\u4f60\u9700\u8981\u5904\u7406\u7684\u5f02\u5e38\u7684\u8bed\u53e5\u3002 throw -1 ; // here's a trivial throw statement // \u4e00\u4e2a\u5e38\u8bc6\u629b\u51fa\u7684\u8bed\u53e5 } \u6ce8\u610f\uff0ctry \u8bed\u53e5\u5757\u6ca1\u6709\u5b9a\u4e49\u5982\u4f55\u5904\u7406\u5f02\u5e38\u3002\u4ed6\u4ec5\u4ec5\u544a\u8bc9\u7a0b\u5e8f\uff0c\u201c\u563f\uff0c\u5982\u679c\u4efb\u4f55\u8bed\u53e5\u5728\u8fd9\u4e2a try \u8bed\u53e5\u5757\u4e2d\u629b\u51fa\uff0c\u6293\u4f4f\u5b83\uff01\u201d\u3002 \u5f02\u5e38\u5904\u7406 \u00b6 \u6700\u540e\uff0c\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\uff1a\u5728\u60e9\u7f5a\u88ab\u8c03\u7528\uff0c\u6e38\u620f\u5df2\u7ecf\u505c\u6b62\uff0c\u88c1\u5224\u8bc4\u4f30\u60e9\u7f5a\u5e76\u4e14\u6267\u884c\u5b83\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u60e9\u7f5a\u5fc5\u987b\u88ab\u5904\u7406\u5728\u7ee7\u7eed\u6e38\u620f\u4e4b\u524d\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u5f02\u5e38\u5904\u7406\u662f catch \u8bed\u53e5\u5757\u7684\u5de5\u4f5c\u3002 catch \u5173\u952e\u8bcd\u88ab\u7528\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a catch \u8bed\u53e5\u5757\uff09\u5904\u7406\u5355\u4e2a\u6570\u636e\u7c7b\u578b\u7684\u7684\u5f02\u5e38\u3002 \u8fd9\u6709\u4e00\u4e2a catch \u8bed\u53e5\u5757\u7684\u4f8b\u5b50\uff0c\u5b83\u4f1a\u6355\u83b7\u4e00\u4e2a\u6574\u578b\u5f02\u5e38\uff1a catch ( int x ) { // Handle an exception of type int here // \u5904\u7406\u4e00\u4e2a\u6574\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an int exception with value\" << x << '\\n' ; } try \u8bed\u53e5\u5757\u548c catch \u8bed\u53e5\u5757\u4e00\u8d77\u5de5\u4f5c\u2014\u2014 \u4e00\u4e2a try \u8bed\u53e5\u5757\u68c0\u6d4b try \u8bed\u53e5\u5757\u4e2d\u7684\u4efb\u4f55\u8bed\u53e5\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u5e76\u4e14\u53d1\u9001\u5b83\u4eec\u5230\uff0c\u5408\u9002\u7684 catch \u8bed\u53e5\u5757\u6765\u8fdb\u884c\u5904\u7406\u3002\u4e00\u4e2a try \u8bed\u53e5\u5757\u5fc5\u987b\u6709\u81f3\u5c11\u4e00\u4e2a catch \u8bed\u53e5\u5757\uff0c\u7d27\u8ddf\u7740 try \u8bed\u53e5\uff0c\u4e5f\u8bb8\u6709\u5f88\u591a\u4e2a\u6355\u83b7\u8bed\u53e5\u5feb\u6309\u987a\u5e8f\u6392\u5217\u3002 \u4e00\u65e6\u4e00\u4e2a\u5f02\u5e38\u5728 try \u8bed\u53e5\u4e2d\u88ab\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u4e00\u4e2a catch \u8bed\u53e5\u5757\u6765\u5904\u7406\uff0c\u5f02\u5e38\u88ab\u8ba4\u4e3a\u5904\u7406\uff0c\u5e76\u4e14\u5728 catch \u8bed\u53e5\u540e\u6267\u884c\u5c06\u4f1a\u50cf\u5f80\u5e38\u4e00\u6837\u7ee7\u7eed\u3002 \u6355\u83b7\u53c2\u6570\u5c31\u50cf\u51fd\u6570\u53c2\u6570\u90a3\u6837\u5de5\u4f5c\uff0c\u53c2\u6570\u5728\u540e\u7eed\u7684 try \u8bed\u53e5\u5757\u4e2d\u53ef\u7528\u3002\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u53ef\u4ee5\u88ab\u6355\u83b7\u4ee5\u503c\u7684\u5f62\u5f0f\uff0c\u4f46\u662f\u975e\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u5e94\u8be5\u88ab\u6355\u83b7\uff0c\u4ee5\u5e38\u5f15\u7528\u7684\u65b9\u5f0f\uff0c\u6765\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c31\u50cf\u7528\u51fd\u6570\u90a3\u6837\uff0c\u5982\u679c\u53c2\u6570\u6ca1\u6709\u5728\u8bed\u53e5\u4e2d\u88ab\u4f7f\u7528\uff0c\u53d8\u91cf\u540d\u53ef\u4ee5\u88ab\u7701\u7565 catch ( double ) // note: no variable name since we don't use it in the catch block below // \u6ce8\u610f\uff1a\u65e0\u53d8\u91cf\u540d\uff0c\u56e0\u4e3a\u6211\u4eec\u4e0d\u4f1a\u518dcatch\u8bed\u53e5\u5757\u4e2d\u4f7f\u7528\u5b83 { // Handle exception of type double here // \u5904\u7406 double \u7c7b\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an exception of type double\" << '\\n' ; } \u8fd9\u53ef\u4ee5\u9632\u6b62\u7f16\u8bd1\u5668\u505a\u6709\u5173\u672a\u4f7f\u7528\u53d8\u91cf\u7684\u8b66\u544a\u3002 \u629b\u51fa(throw)\uff0ctry\uff0c\u6355\u83b7(catch) \u00b6 \u8fd9\u6709\u4e00\u6574\u4e2a\u7a0b\u5e8f\uff0c\u4f7f\u7528\u4e86 throw, try \u548c\u8bb8\u591a catch \u8bed\u53e5\u5757\u3002 #include <iostream> #include <string> int main () { try { // Statements that may throw exceptions you want to handle go here throw -1 ; // here's a trivial example } catch ( int x ) { // Any exceptions of type int thrown within the above try block get sent here std :: cerr << \"We caught an int exception with value: \" << x << '\\n' ; } catch ( double ) // no variable name since we don't use the exception itself in the catch block below { // Any exceptions of type double thrown within the above try block get sent here std :: cerr << \"We caught an exception of type double\" << '\\n' ; } catch ( const std :: string & str ) // catch classes by const reference { // Any exceptions of type std::string thrown within the above try block get sent here std :: cerr << \"We caught an exception of type std::string\" << '\\n' ; } std :: cout << \"Continuing on our merry way \\n \" ; return 0 ; } \u8fd0\u884c\u4ee5\u4e0a\u7684 try/catch \u8bed\u53e5\u5757\u5c06\u4f1a\u4ea7\u751f\u5982\u4e0b\u7ed3\u679c\uff1a We caught an int exception with value -1 Continuing on our merry way \u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u901a\u8fc7 -1 \u8fd9\u4e2a\u503c\uff0c\u7c7b\u578b\u4e3a int \u3002 throw \u8bed\u53e5\u4f1a\u88ab\u7d27\u63a5\u7740\u7684\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u5408\u9002\u7684\u5904\u7406\u6574\u578b\u5f02\u5e38\u7684 catch \u8bed\u53e5\u5757\u3002\u8fd9\u4e2a catch \u8bed\u53e5\u5757\u6253\u5370\u4e86\u5408\u9002\u7684\u9519\u8bef\u4fe1\u606f\u3002 \u4e00\u65e6\u5f02\u5e38\u88ab\u5904\u7406\uff0c\u7a0b\u5e8f\u5c31\u4f1a\u4ece catch \u8bed\u53e5\u5757\u7ed3\u675f\u7684\u5730\u65b9\u5f00\u59cb\u6b63\u5e38\u8fd0\u884c\uff0c\u5e76\u4e14\u6253\u5370 \u201cContinuing on our merry way\u201d\u3002 \u518d\u590d\u4e60\u5f02\u5e38\u5904\u7406 \u00b6 \u5f02\u5e38\u5904\u7406\u5b9e\u9645\u4e0a\u975e\u5e38\u7b80\u5355\uff0c\u4e0b\u9762\u4e24\u6bb5\u8bdd\u8986\u76d6\u4e86\u5927\u591a\u6570\u4f60\u9700\u8981\u8bb0\u5f97\u7684\u6709\u5173\u5f02\u5e38\u7684\u4e8b\u60c5\uff1a \u5f53\u4e00\u4e2a\u5f02\u5e38\u88ab\u4f7f\u7528 throw \u629b\u51fa\uff0c\u7a0b\u5e8f\u7684\u6267\u884c\u4f1a\u7acb\u5373\u8df3\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\uff08\u5411\u4e0a\u4f20\u64ad\u5806\u6808\uff0c\u5982\u679c\u6709\u5fc5\u8981\u627e\u5230\u4e00\u4e2a\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u2014\u2014\u6211\u4eec\u5c06\u5728\u4e0b\u8282\u8bfe\u8ba8\u8bba\u66f4\u52a0\u8be6\u7ec6\u7684\u5185\u5bb9\uff09\u3002\u5982\u679c\u4efb\u4f55\u5f02\u5e38\u51fd\u6570\u53ef\u4ee5\u5904\u7406\u4e4b\u524d try \u8bed\u53e5\u5feb\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u90a3\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u6267\u884c\uff0c\u5f02\u5e38\u4e5f\u4f1a\u88ab\u8ba4\u4e3a\u5904\u7406\u4e86\u3002 \u5982\u679c\u6ca1\u6709\u5408\u9002\u7684\u5904\u7406\u51fd\u6570\u5b58\u5728\uff0c\u6267\u884c\u7684\u7a0b\u5e8f\u4f1a\u8df3\u51fa\u5230\u4e0b\u4e00\u4e2a try \u95ed\u5408\u8bed\u53e5\uff0c\u5982\u679c\u6ca1\u6709\u5408\u9002\u7684 catch \u8bed\u53e5\u53ef\u4ee5\u88ab\u627e\u5230\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\uff0c\u7a0b\u5e8f\u5c06\u4f1a\u5e26\u7740\u5f02\u5e38\u9519\u8bef\u5931\u8d25\u3002 \u6ce8\u610f\uff0c\u7f16\u8bd1\u5668\u4e0d\u4f1a\u6267\u884c\u4e00\u4e2a\u9690\u5f0f\u8f6c\u5316 (implicit conversions) \u6216\u8005\u5347\u7ea7 (promotions) \u5f53\u4f7f\u7528 catch \u8bed\u53e5\u6765\u6355\u83b7\u5f02\u5e38\u65f6\uff01\u4f8b\u5982\uff0c\u4e00\u4e2a char \u7c7b\u578b\u7684\u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a int \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u4e00\u4e2a int \u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a float \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u7136\u800c\uff0c\u4ece\u6d3e\u751f\u7c7b\u5230\u7236\u7c7b\u4e4b\u4e00\u5c06\u4f1a\u6267\u884c\u3002 \u8fd9\u5c31\u662f\u5168\u90e8\uff0c\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u5c06\u4f1a\u5c3d\u91cf\u5c55\u793a\u6240\u6709\u8fd9\u4e9b\u539f\u5219\u7684\u4f8b\u5b50\u3002 \u5f02\u5e38\u88ab\u7acb\u5373\u5904\u7406 \u00b6 \u8fd9\u662f\u4e00\u4e2a\u77ed\u5c0f\u7684\u7a0b\u5e8f\uff0c\u5c55\u793a\u4e86\u5f02\u5e38\u5982\u4f55\u88ab\u7acb\u523b\u5904\u7406\uff1a #include <iostream> int main () { try { throw 4.5 ; // throw exception of type double std :: cout << \"This never prints \\n \" ; } catch ( double x ) // handle exception of type double { std :: cerr << \"We caught a double of value: \" << x << '\\n' ; } return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u975e\u5e38\u7b80\u5355\u3002\u8fd9\u5c31\u662f\u5177\u4f53\u53d1\u751f\u7684\u7684\u4e8b\u60c5\uff1a\u629b\u51fa\u8bed\u53e5\u662f\u7b2c\u4e00\u6267\u884c\u7684\u8bed\u53e5 \u2014\u2014 \u8fd9\u5f15\u8d77\u4e86\u4e00\u4e2a double \u7c7b\u578b\u7684\u5f02\u5e38\u88ab\u629b\u51fa\u3002\u6267\u884c\u6d41\u7a0b\u4e00\u9897\u79fb\u52a8\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\u95ed\u5408\u5904\uff0c\u4e5f\u662f\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\u552f\u4e00\u7684 try block\u3002 catch \u8bed\u53e5\u5c06\u4f1a\u7d27\u63a5\u7740\u68c0\u67e5\u662f\u5426\u6709 handler \u5339\u914d\u3002\u6211\u4eec\u7684\u5f02\u5e38\u5c31\u662f double \u7c7b\u578b\u7684\u3002\u800c\u4e14\u6211\u4eec\u6b63\u5728\u5bfb\u627e\u4e00\u4e2a double \u7c7b\u578b\u7684 catch \u8bed\u53e5\uff0c\u6211\u4eec\u521a\u597d\u6709\u4e00\u4e2a\uff0c\u7d27\u63a5\u7740\u5b83\u5c31\u4f1a\u6267\u884c\u3002 \u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\u5982\u4e0b\uff1a We caught a double of value: 4.5 \u6ce8\u610f\u5230 \"this never prints\" \u662f\u4ece\u6ca1\u88ab\u6253\u5370\u7684\uff0c\u56e0\u4e3a\u5f02\u5e38\u9020\u6210\u6267\u884c\u8def\u5f84\u7acb\u523b\u8df3\u5230 double \u7684\u5f02\u5e38\u5904\u7406\u3002 \u4e00\u4e2a\u66f4\u52a0\u771f\u5b9e\u7684\u4f8b\u5b50 \u00b6 \u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u4e0d\u662f\u90a3\u4e48\u7406\u8bba\u7684\u4f8b\u5b50\uff1a #include \"math.h\" // for sqrt() function #include <iostream> int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* // Otherwise, print the answer std :: cout << \"The sqrt of \" << x << \" is \" << sqrt ( x ) << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << '\\n' ; } } In this code, the user is asked to enter a number. If they enter a positive number, the if statement does not execute, no exception is thrown, and the square root of the number is printed. Because no exception is thrown in this case, the code inside the catch block never executes. The result is something like this: \u5728\u8fd9\u6bb5\u4ee3\u7801\u4e2d\uff0c\u7528\u6237\u88ab\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u4ed6\u4eec\u8f93\u5165\u4e00\u4e2a\u6b63\u6570\uff0c\u90a3\u4e48 if \u8bed\u53e5\u4e0d\u4f1a\u6267\u884c\uff0c\u6ca1\u6709\u5f02\u5e38\u629b\u51fa\uff0c\u5e76\u4e14\u8f93\u5165\u6570\u5b57\u7684\u5e73\u65b9\u6839\u5c06\u4f1a\u88ab\u6253\u5370\u3002\u56e0\u4e3a\u6ca1\u6709\u5f02\u5e38\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u88ab\u629b\u51fa\uff0c catch \u8bed\u53e5\u5757\u4e2d\u7684\u4ee3\u7801\u4ece\u4e0d\u4f1a\u6267\u884c\uff0c\u7ed3\u679c\u5982\u4e0b\uff1a Enter a number: 9 The sqrt of 9 is 3 If the user enters a negative number, we throw an exception of type const char*. Because we\u2019re within a try block and a matching exception handler is found, control immediately transfers to the const char* exception handler. The result is: Enter a number: -4 Error: Can not take sqrt of negative number By now, you should be getting the basic idea behind exceptions. In the next lesson, we\u2019ll do quite a few more examples to show how flexible exceptions are. What catch blocks typically do If an exception is routed to a catch block, it is considered \u201chandled\u201d even if the catch block is empty. However, typically you\u2019ll want your catch blocks to do something useful. There are three common things that catch blocks do when they catch an exception: First, catch blocks may print an error (either to the console, or a log file). Second, catch blocks may return a value or error code back to the caller. Third, a catch block may throw another exception. Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block -- it\u2019s handled by the next enclosing try block.","title":"14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#142","text":"By Alex on October 4 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.13 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b \u4e3a\u4ec0\u4e48\u9700\u8981\u5f02\u5e38 \u4e2d\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5173\u4e8e\u4f7f\u7528\u8fd4\u56de\u503c\u72b6\u6001\u7801\u4e3a\u4f55\u4f1a\u4f7f\u5f97\u4f60\u7684\u63a7\u5236\u6d41\u548c\u9519\u8bef\u5904\u7406\u88ab\u6df7\u5408\uff0c\u4f7f\u5f97\u4e24\u8005\u76f8\u4e92\u7ea6\u675f\u3002\u5f02\u5e38\u5728C++\u4e2d\u7684\u5b9e\u73b0\u4f7f\u7528\u4e86\u4e09\u4e2a\u5173\u952e\u8bcd\uff0c\u6765\u76f8\u4e92\u8fde\u63a5\uff1a throw , try , catch \u3002","title":"14.2 \u57fa\u672c\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_1","text":"\u5728\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4fe1\u53f7\u6765\u8bb0\u5f55\u5df2\u7ecf\u53d1\u751f\u7684\u7279\u5b9a\u7684\u4e8b\u60c5\u3002\u4f8b\u5982\u5728\u7f8e\u56fd\u8db3\u7403\u6bd4\u8d5b\u4e2d\uff0c\u5982\u679c\u4e00\u4e2a\u8fd0\u52a8\u5458\u72af\u89c4\u4e86\uff0c\u88c1\u5224\u5c06\u4f1a\u62ff\u51fa\u4e00\u4e2aflag\u5e76\u4e14\u5439\u54e8\u8868\u793a\u6e38\u620f\u6682\u505c\u3002\u60e9\u7f5a\u5c31\u662f\u7d27\u63a5\u7740\u8bc4\u4f30\u548c\u6267\u884c\u3002\u60e9\u7f5a\u88ab\u6267\u884c\u540e\uff0c\u6e38\u620f\u7167\u65e7\u7ee7\u7eed\u3002 \u5728 C++ \u4e2d\uff0c\u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u6216\u8005\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff08\u53ef\u4ee5\u8ba4\u4e3a\u662f\u629b\u51fa\u4e86\u4e00\u4e2a\u60e9\u7f5a\u7684flag\uff09\u3002\u53d1\u51fa\u4fe1\u53f7\u8868\u793a\u4e00\u4e2a\u5f02\u5e38\u5df2\u7ecf\u53d1\u751f\uff0c\u8005\u901a\u5e38\u88ab\u53eb\u505a\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\u3002 \u4e3a\u4e86\u4f7f\u7528\u4e00\u4e2a\u5f02\u5e38\u4e00\u53e5\uff0c\u7b80\u5355\u7684\u4f7f\u7528 throw \u5173\u952e\u8bcd\uff0c\u7d27\u8ddf\u7740\u4e00\u4e2a\u4f60\u5e0c\u671b\u4f7f\u7528\u7684\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u6765\u901a\u77e5\u4e00\u4e2a\u9519\u8bef\u5df2\u7ecf\u53d1\u751f\uff0c\u901a\u5e38\u8fd9\u548c\u503c\u5c06\u4f1a\u662f\u4e00\u4e2a\u9519\u8bef\u7801\uff0c\u4e00\u4e2a\u95ee\u9898\u7684\u63cf\u8ff0\uff0c\u6216\u8005\u4e00\u4e2a\u81ea\u5b9a\u4e49\u5f02\u5e38\u7c7b\u3002 \u8fd9\u91cc\u662f\u4e00\u4e9b\u4f8b\u5b50\uff1a throw -1 ; // throw a literal integer value throw ENUM_INVALID_INDEX ; // throw an enum value throw \"Can not take square root of negative number\" ; // throw a literal C-style (const char*) string throw dX ; // throw a double variable that was previously defined throw MyException ( \"Fatal Error\" ); // Throw an object of class MyException \u8fd9\u91cc\u7684\u6bcf\u4e00\u4e2a\u8bed\u53e5\u90fd\u5f53\u505a\u4e00\u4e2a\u4fe1\u53f7\uff0c\u8868\u793a\u67d0\u79cd\u7c7b\u578b\u7684\u9700\u8981\u88ab\u89e3\u51b3\u7684\u95ee\u9898\u5df2\u7ecf\u53d1\u751f\u4e86\u3002","title":"\u629b\u51fa\u5f02\u5e38"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_2","text":"\u629b\u51fa\u5f02\u5e38\u53ea\u662f\u5f02\u5e38\u5904\u7406\u8fdb\u7a0b\u7684\u4e00\u90e8\u5206\u3002\u8ba9\u6211\u4eec\u56de\u5230\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\u4e2d\uff1a\u4e00\u65e6\u88c1\u5224\u629b\u51fa\u4e00\u4e2a\u4e00\u4e2a\u60e9\u7f5aflag\uff0c\u63a5\u4e0b\u6765\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u53c2\u8d5b\u8005\u4eec\u4e3b\u8981\u5230\u4e00\u4e2a\u60e9\u7f5a\u53d1\u751f\uff0c\u5e76\u4e14\u505c\u6b62\u6e38\u620f\u3002\u4e00\u4e2a\u666e\u901a\u7684\u8db3\u7403\u6bd4\u8d5b\u6d41\u7a0b\u4e2d\u65ad\u3002 \u5728C++\u4e2d\uff0c\u6211\u4eec\u7528 try \u5173\u952e\u8bcd\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a try \u8bed\u53e5\u5757\uff09\uff0ctry \u8bed\u53e5\u5757\u4f5c\u4e3a\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0c\u5bfb\u627e\u4efb\u4f55\u7c7b\u578b\u88ab\u629b\u51fa\u7684\u5f02\u5e38\u5728 try \u8bed\u53e5\u7684block\u4e2d\u3002 Here\u2019s an example of a try block: try { // Statements that may throw exceptions you want to handle go here // \u5230\u90a3\u513f\uff0c\u53ef\u80fd\u629b\u51fa\u4f60\u9700\u8981\u5904\u7406\u7684\u5f02\u5e38\u7684\u8bed\u53e5\u3002 throw -1 ; // here's a trivial throw statement // \u4e00\u4e2a\u5e38\u8bc6\u629b\u51fa\u7684\u8bed\u53e5 } \u6ce8\u610f\uff0ctry \u8bed\u53e5\u5757\u6ca1\u6709\u5b9a\u4e49\u5982\u4f55\u5904\u7406\u5f02\u5e38\u3002\u4ed6\u4ec5\u4ec5\u544a\u8bc9\u7a0b\u5e8f\uff0c\u201c\u563f\uff0c\u5982\u679c\u4efb\u4f55\u8bed\u53e5\u5728\u8fd9\u4e2a try \u8bed\u53e5\u5757\u4e2d\u629b\u51fa\uff0c\u6293\u4f4f\u5b83\uff01\u201d\u3002","title":"\u5bfb\u627e\u5f02\u5e38"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_3","text":"\u6700\u540e\uff0c\u7f8e\u56fd\u8db3\u7403\u7684\u6bd4\u55bb\uff1a\u5728\u60e9\u7f5a\u88ab\u8c03\u7528\uff0c\u6e38\u620f\u5df2\u7ecf\u505c\u6b62\uff0c\u88c1\u5224\u8bc4\u4f30\u60e9\u7f5a\u5e76\u4e14\u6267\u884c\u5b83\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u60e9\u7f5a\u5fc5\u987b\u88ab\u5904\u7406\u5728\u7ee7\u7eed\u6e38\u620f\u4e4b\u524d\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u5f02\u5e38\u5904\u7406\u662f catch \u8bed\u53e5\u5757\u7684\u5de5\u4f5c\u3002 catch \u5173\u952e\u8bcd\u88ab\u7528\u6765\u5b9a\u4e49\u4e00\u4e2a\u8bed\u53e5\u5757\uff08\u88ab\u53eb\u505a catch \u8bed\u53e5\u5757\uff09\u5904\u7406\u5355\u4e2a\u6570\u636e\u7c7b\u578b\u7684\u7684\u5f02\u5e38\u3002 \u8fd9\u6709\u4e00\u4e2a catch \u8bed\u53e5\u5757\u7684\u4f8b\u5b50\uff0c\u5b83\u4f1a\u6355\u83b7\u4e00\u4e2a\u6574\u578b\u5f02\u5e38\uff1a catch ( int x ) { // Handle an exception of type int here // \u5904\u7406\u4e00\u4e2a\u6574\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an int exception with value\" << x << '\\n' ; } try \u8bed\u53e5\u5757\u548c catch \u8bed\u53e5\u5757\u4e00\u8d77\u5de5\u4f5c\u2014\u2014 \u4e00\u4e2a try \u8bed\u53e5\u5757\u68c0\u6d4b try \u8bed\u53e5\u5757\u4e2d\u7684\u4efb\u4f55\u8bed\u53e5\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u5e76\u4e14\u53d1\u9001\u5b83\u4eec\u5230\uff0c\u5408\u9002\u7684 catch \u8bed\u53e5\u5757\u6765\u8fdb\u884c\u5904\u7406\u3002\u4e00\u4e2a try \u8bed\u53e5\u5757\u5fc5\u987b\u6709\u81f3\u5c11\u4e00\u4e2a catch \u8bed\u53e5\u5757\uff0c\u7d27\u8ddf\u7740 try \u8bed\u53e5\uff0c\u4e5f\u8bb8\u6709\u5f88\u591a\u4e2a\u6355\u83b7\u8bed\u53e5\u5feb\u6309\u987a\u5e8f\u6392\u5217\u3002 \u4e00\u65e6\u4e00\u4e2a\u5f02\u5e38\u5728 try \u8bed\u53e5\u4e2d\u88ab\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u4e00\u4e2a catch \u8bed\u53e5\u5757\u6765\u5904\u7406\uff0c\u5f02\u5e38\u88ab\u8ba4\u4e3a\u5904\u7406\uff0c\u5e76\u4e14\u5728 catch \u8bed\u53e5\u540e\u6267\u884c\u5c06\u4f1a\u50cf\u5f80\u5e38\u4e00\u6837\u7ee7\u7eed\u3002 \u6355\u83b7\u53c2\u6570\u5c31\u50cf\u51fd\u6570\u53c2\u6570\u90a3\u6837\u5de5\u4f5c\uff0c\u53c2\u6570\u5728\u540e\u7eed\u7684 try \u8bed\u53e5\u5757\u4e2d\u53ef\u7528\u3002\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u53ef\u4ee5\u88ab\u6355\u83b7\u4ee5\u503c\u7684\u5f62\u5f0f\uff0c\u4f46\u662f\u975e\u57fa\u7840\u7c7b\u578b\u7684\u5f02\u5e38\u5e94\u8be5\u88ab\u6355\u83b7\uff0c\u4ee5\u5e38\u5f15\u7528\u7684\u65b9\u5f0f\uff0c\u6765\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c31\u50cf\u7528\u51fd\u6570\u90a3\u6837\uff0c\u5982\u679c\u53c2\u6570\u6ca1\u6709\u5728\u8bed\u53e5\u4e2d\u88ab\u4f7f\u7528\uff0c\u53d8\u91cf\u540d\u53ef\u4ee5\u88ab\u7701\u7565 catch ( double ) // note: no variable name since we don't use it in the catch block below // \u6ce8\u610f\uff1a\u65e0\u53d8\u91cf\u540d\uff0c\u56e0\u4e3a\u6211\u4eec\u4e0d\u4f1a\u518dcatch\u8bed\u53e5\u5757\u4e2d\u4f7f\u7528\u5b83 { // Handle exception of type double here // \u5904\u7406 double \u7c7b\u578b\u7684\u5f02\u5e38 std :: cerr << \"We caught an exception of type double\" << '\\n' ; } \u8fd9\u53ef\u4ee5\u9632\u6b62\u7f16\u8bd1\u5668\u505a\u6709\u5173\u672a\u4f7f\u7528\u53d8\u91cf\u7684\u8b66\u544a\u3002","title":"\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#throwtrycatch","text":"\u8fd9\u6709\u4e00\u6574\u4e2a\u7a0b\u5e8f\uff0c\u4f7f\u7528\u4e86 throw, try \u548c\u8bb8\u591a catch \u8bed\u53e5\u5757\u3002 #include <iostream> #include <string> int main () { try { // Statements that may throw exceptions you want to handle go here throw -1 ; // here's a trivial example } catch ( int x ) { // Any exceptions of type int thrown within the above try block get sent here std :: cerr << \"We caught an int exception with value: \" << x << '\\n' ; } catch ( double ) // no variable name since we don't use the exception itself in the catch block below { // Any exceptions of type double thrown within the above try block get sent here std :: cerr << \"We caught an exception of type double\" << '\\n' ; } catch ( const std :: string & str ) // catch classes by const reference { // Any exceptions of type std::string thrown within the above try block get sent here std :: cerr << \"We caught an exception of type std::string\" << '\\n' ; } std :: cout << \"Continuing on our merry way \\n \" ; return 0 ; } \u8fd0\u884c\u4ee5\u4e0a\u7684 try/catch \u8bed\u53e5\u5757\u5c06\u4f1a\u4ea7\u751f\u5982\u4e0b\u7ed3\u679c\uff1a We caught an int exception with value -1 Continuing on our merry way \u4e00\u4e2a\u629b\u51fa\u8bed\u53e5\u88ab\u7528\u6765\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u901a\u8fc7 -1 \u8fd9\u4e2a\u503c\uff0c\u7c7b\u578b\u4e3a int \u3002 throw \u8bed\u53e5\u4f1a\u88ab\u7d27\u63a5\u7740\u7684\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u6355\u83b7\uff0c\u5e76\u4e14\u53d1\u9001\u5230\u5408\u9002\u7684\u5904\u7406\u6574\u578b\u5f02\u5e38\u7684 catch \u8bed\u53e5\u5757\u3002\u8fd9\u4e2a catch \u8bed\u53e5\u5757\u6253\u5370\u4e86\u5408\u9002\u7684\u9519\u8bef\u4fe1\u606f\u3002 \u4e00\u65e6\u5f02\u5e38\u88ab\u5904\u7406\uff0c\u7a0b\u5e8f\u5c31\u4f1a\u4ece catch \u8bed\u53e5\u5757\u7ed3\u675f\u7684\u5730\u65b9\u5f00\u59cb\u6b63\u5e38\u8fd0\u884c\uff0c\u5e76\u4e14\u6253\u5370 \u201cContinuing on our merry way\u201d\u3002","title":"\u629b\u51fa(throw)\uff0ctry\uff0c\u6355\u83b7(catch)"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_4","text":"\u5f02\u5e38\u5904\u7406\u5b9e\u9645\u4e0a\u975e\u5e38\u7b80\u5355\uff0c\u4e0b\u9762\u4e24\u6bb5\u8bdd\u8986\u76d6\u4e86\u5927\u591a\u6570\u4f60\u9700\u8981\u8bb0\u5f97\u7684\u6709\u5173\u5f02\u5e38\u7684\u4e8b\u60c5\uff1a \u5f53\u4e00\u4e2a\u5f02\u5e38\u88ab\u4f7f\u7528 throw \u629b\u51fa\uff0c\u7a0b\u5e8f\u7684\u6267\u884c\u4f1a\u7acb\u5373\u8df3\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\uff08\u5411\u4e0a\u4f20\u64ad\u5806\u6808\uff0c\u5982\u679c\u6709\u5fc5\u8981\u627e\u5230\u4e00\u4e2a\u5c01\u95ed\u7684 try \u8bed\u53e5\u5757\u2014\u2014\u6211\u4eec\u5c06\u5728\u4e0b\u8282\u8bfe\u8ba8\u8bba\u66f4\u52a0\u8be6\u7ec6\u7684\u5185\u5bb9\uff09\u3002\u5982\u679c\u4efb\u4f55\u5f02\u5e38\u51fd\u6570\u53ef\u4ee5\u5904\u7406\u4e4b\u524d try \u8bed\u53e5\u5feb\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u90a3\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u6267\u884c\uff0c\u5f02\u5e38\u4e5f\u4f1a\u88ab\u8ba4\u4e3a\u5904\u7406\u4e86\u3002 \u5982\u679c\u6ca1\u6709\u5408\u9002\u7684\u5904\u7406\u51fd\u6570\u5b58\u5728\uff0c\u6267\u884c\u7684\u7a0b\u5e8f\u4f1a\u8df3\u51fa\u5230\u4e0b\u4e00\u4e2a try \u95ed\u5408\u8bed\u53e5\uff0c\u5982\u679c\u6ca1\u6709\u5408\u9002\u7684 catch \u8bed\u53e5\u53ef\u4ee5\u88ab\u627e\u5230\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\uff0c\u7a0b\u5e8f\u5c06\u4f1a\u5e26\u7740\u5f02\u5e38\u9519\u8bef\u5931\u8d25\u3002 \u6ce8\u610f\uff0c\u7f16\u8bd1\u5668\u4e0d\u4f1a\u6267\u884c\u4e00\u4e2a\u9690\u5f0f\u8f6c\u5316 (implicit conversions) \u6216\u8005\u5347\u7ea7 (promotions) \u5f53\u4f7f\u7528 catch \u8bed\u53e5\u6765\u6355\u83b7\u5f02\u5e38\u65f6\uff01\u4f8b\u5982\uff0c\u4e00\u4e2a char \u7c7b\u578b\u7684\u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a int \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u4e00\u4e2a int \u5f02\u5e38\u5c06\u4e0d\u4f1a\u5339\u914d\u4e00\u4e2a float \u7c7b\u578b\u7684 catch \u8bed\u53e5\u5757\u3002\u7136\u800c\uff0c\u4ece\u6d3e\u751f\u7c7b\u5230\u7236\u7c7b\u4e4b\u4e00\u5c06\u4f1a\u6267\u884c\u3002 \u8fd9\u5c31\u662f\u5168\u90e8\uff0c\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u5c06\u4f1a\u5c3d\u91cf\u5c55\u793a\u6240\u6709\u8fd9\u4e9b\u539f\u5219\u7684\u4f8b\u5b50\u3002","title":"\u518d\u590d\u4e60\u5f02\u5e38\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_5","text":"\u8fd9\u662f\u4e00\u4e2a\u77ed\u5c0f\u7684\u7a0b\u5e8f\uff0c\u5c55\u793a\u4e86\u5f02\u5e38\u5982\u4f55\u88ab\u7acb\u523b\u5904\u7406\uff1a #include <iostream> int main () { try { throw 4.5 ; // throw exception of type double std :: cout << \"This never prints \\n \" ; } catch ( double x ) // handle exception of type double { std :: cerr << \"We caught a double of value: \" << x << '\\n' ; } return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u975e\u5e38\u7b80\u5355\u3002\u8fd9\u5c31\u662f\u5177\u4f53\u53d1\u751f\u7684\u7684\u4e8b\u60c5\uff1a\u629b\u51fa\u8bed\u53e5\u662f\u7b2c\u4e00\u6267\u884c\u7684\u8bed\u53e5 \u2014\u2014 \u8fd9\u5f15\u8d77\u4e86\u4e00\u4e2a double \u7c7b\u578b\u7684\u5f02\u5e38\u88ab\u629b\u51fa\u3002\u6267\u884c\u6d41\u7a0b\u4e00\u9897\u79fb\u52a8\u5230\u6700\u8fd1\u7684 try \u8bed\u53e5\u5757\u95ed\u5408\u5904\uff0c\u4e5f\u662f\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\u552f\u4e00\u7684 try block\u3002 catch \u8bed\u53e5\u5c06\u4f1a\u7d27\u63a5\u7740\u68c0\u67e5\u662f\u5426\u6709 handler \u5339\u914d\u3002\u6211\u4eec\u7684\u5f02\u5e38\u5c31\u662f double \u7c7b\u578b\u7684\u3002\u800c\u4e14\u6211\u4eec\u6b63\u5728\u5bfb\u627e\u4e00\u4e2a double \u7c7b\u578b\u7684 catch \u8bed\u53e5\uff0c\u6211\u4eec\u521a\u597d\u6709\u4e00\u4e2a\uff0c\u7d27\u63a5\u7740\u5b83\u5c31\u4f1a\u6267\u884c\u3002 \u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\u5982\u4e0b\uff1a We caught a double of value: 4.5 \u6ce8\u610f\u5230 \"this never prints\" \u662f\u4ece\u6ca1\u88ab\u6253\u5370\u7684\uff0c\u56e0\u4e3a\u5f02\u5e38\u9020\u6210\u6267\u884c\u8def\u5f84\u7acb\u523b\u8df3\u5230 double \u7684\u5f02\u5e38\u5904\u7406\u3002","title":"\u5f02\u5e38\u88ab\u7acb\u5373\u5904\u7406"},{"location":"14-exceptions/14.2-basic-exception-handloing/#_6","text":"\u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u4e0d\u662f\u90a3\u4e48\u7406\u8bba\u7684\u4f8b\u5b50\uff1a #include \"math.h\" // for sqrt() function #include <iostream> int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* // Otherwise, print the answer std :: cout << \"The sqrt of \" << x << \" is \" << sqrt ( x ) << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << '\\n' ; } } In this code, the user is asked to enter a number. If they enter a positive number, the if statement does not execute, no exception is thrown, and the square root of the number is printed. Because no exception is thrown in this case, the code inside the catch block never executes. The result is something like this: \u5728\u8fd9\u6bb5\u4ee3\u7801\u4e2d\uff0c\u7528\u6237\u88ab\u8981\u6c42\u8f93\u5165\u4e00\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u4ed6\u4eec\u8f93\u5165\u4e00\u4e2a\u6b63\u6570\uff0c\u90a3\u4e48 if \u8bed\u53e5\u4e0d\u4f1a\u6267\u884c\uff0c\u6ca1\u6709\u5f02\u5e38\u629b\u51fa\uff0c\u5e76\u4e14\u8f93\u5165\u6570\u5b57\u7684\u5e73\u65b9\u6839\u5c06\u4f1a\u88ab\u6253\u5370\u3002\u56e0\u4e3a\u6ca1\u6709\u5f02\u5e38\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u88ab\u629b\u51fa\uff0c catch \u8bed\u53e5\u5757\u4e2d\u7684\u4ee3\u7801\u4ece\u4e0d\u4f1a\u6267\u884c\uff0c\u7ed3\u679c\u5982\u4e0b\uff1a Enter a number: 9 The sqrt of 9 is 3 If the user enters a negative number, we throw an exception of type const char*. Because we\u2019re within a try block and a matching exception handler is found, control immediately transfers to the const char* exception handler. The result is: Enter a number: -4 Error: Can not take sqrt of negative number By now, you should be getting the basic idea behind exceptions. In the next lesson, we\u2019ll do quite a few more examples to show how flexible exceptions are. What catch blocks typically do If an exception is routed to a catch block, it is considered \u201chandled\u201d even if the catch block is empty. However, typically you\u2019ll want your catch blocks to do something useful. There are three common things that catch blocks do when they catch an exception: First, catch blocks may print an error (either to the console, or a log file). Second, catch blocks may return a value or error code back to the caller. Third, a catch block may throw another exception. Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block -- it\u2019s handled by the next enclosing try block.","title":"\u4e00\u4e2a\u66f4\u52a0\u771f\u5b9e\u7684\u4f8b\u5b50"},{"location":"14-exceptions/14.3-exceptions-functions-and-stack-unwinding/","text":"14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00 \u00b6 By Alex on October 5 th , 2008 | last modified by Alex on January 23 rd , 2020 In the previous lesson on basic exception handling, we explained how throw, try, and catch work together to enable exception handling. In this lesson, we\u2019ll talk about how exception handling interacts with functions. Throwing exceptions outside of a try block In the examples in the previous lesson, the throw statements were placed directly within a try block. If this were a necessity, exception handling would be of limited use. One of the most useful properties of exception handling is that the throw statements do NOT have to be placed directly inside a try block due to the way exceptions propagate up the stack when thrown. This allows us to use exception handling in a much more modular fashion. We\u2019ll demonstrate this by rewriting the square root program from the previous lesson to use a modular function. #include <cmath> // for sqrt() function #include <iostream> // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { double d = mySqrt ( x ); std :: cout << \"The sqrt of \" << x << \" is \" << d << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << std :: endl ; } return 0 ; } In this program, we\u2019ve taken the code that checks for an exception and calculates the square root and put it inside a modular function called mySqrt(). We\u2019ve then called this mySqrt() function from inside a try block. Let\u2019s verify that it still works as expected: Enter a number: -4 Error: Can not take sqrt of negative number It does! Let\u2019s revisit for a moment what happens when an exception is raised. First, the program looks to see if the exception can be handled immediately (which means it was thrown inside a try block). If not, the current function is terminated, and the program checks to see if the function\u2019s caller will handle the exception. If not, it terminates the caller and checks the caller\u2019s caller. Each function is terminated in sequence until a handler for the exception is found, or until main() is terminated without the exception being handled. This process is called unwinding the stack (see the lesson on the stack and the heap if you need a refresher on what the call stack is). Now, let\u2019s take a detailed look at how that applies to this program when an exception is raised from within mySqrt(). First, the program checks to see if the exception was thrown from within a try block inside the function. In this case, it was not. Then, the stack begins to unwind. First, mySqrt() terminates, and control returns to main(). The program now checks to see if we\u2019re inside a try block. We are, and there\u2019s a const char* handler, so the exception is handled by the try block within main(). To summarize, mySqrt() raised the exception, but the try/catch block in main() was the one who captured and handled the exception. Or, put another way, try blocks catch exceptions not only from statements within the try block, but also from functions that are called within the try block. The most interesting part of the above program is that the mySqrt() function can throw an exception, but this exception is not immediately inside of a try block! This essentially means mySqrt is willing to say, \u201cHey, there\u2019s a problem!\u201d, but is unwilling to handle the problem itself. It is, in essence, delegating the responsibility for handling the exception to its caller (the equivalent of how using a return code passes the responsibility of handling an error back to a function\u2019s caller). At this point, some of you are probably wondering why it\u2019s a good idea to pass errors back to the caller. Why not just make MySqrt() handle its own error? The problem is that different applications may want to handle errors in different ways. A console application may want to print a text message. A windows application may want to pop up an error dialog. In one application, this may be a fatal error, and in another application it may not be. By passing the error back up the stack, each application can handle an error from mySqrt() in a way that is the most context appropriate for it! Ultimately, this keeps mySqrt() as modular as possible, and the error handling can be placed in the less-modular parts of the code. Another stack unwinding example Here\u2019s another example showing stack unwinding in practice, using a larger stack. Although this program is long, it\u2019s pretty simple: main() calls first(), first() calls second(), second() calls third(), third() calls last(), and last() throws an exception. #include <iostream> void last () // called by third() { std :: cout << \"Start last \\n \" ; std :: cout << \"last throwing int exception \\n \" ; throw -1 ; std :: cout << \"End last \\n \" ; } void third () // called by second() { std :: cout << \"Start third \\n \" ; last (); std :: cout << \"End third \\n \" ; } void second () // called by first() { std :: cout << \"Start second \\n \" ; try { third (); } catch ( double ) { std :: cerr << \"second caught double exception \\n \" ; } std :: cout << \"End second \\n \" ; } void first () // called by main() { std :: cout << \"Start first \\n \" ; try { second (); } catch ( int ) { std :: cerr << \"first caught int exception \\n \" ; } catch ( double ) { std :: cerr << \"first caught double exception \\n \" ; } std :: cout << \"End first \\n \" ; } int main () { std :: cout << \"Start main \\n \" ; try { first (); } catch ( int ) { std :: cerr << \"main caught int exception \\n \" ; } std :: cout << \"End main \\n \" ; return 0 ; } Take a look at this program in more detail, and see if you can figure out what gets printed and what doesn\u2019t when it is run. The answer follows: Start main Start first Start second Start third Start last last throwing int exception first caught int exception End first End main Let\u2019s examine what happens in this case. The printing of all the \u201cStart\u201d statements is straightforward and doesn\u2019t warrant further explanation. Function last() prints \u201clast throwing int exception\u201d and then throws an int exception. This is where things start to get interesting. Because last() doesn\u2019t handle the exception itself, the stack begins to unwind. Function last() terminates immediately and control returns to the caller, which is third(). Function third() doesn\u2019t handle any exceptions, so it terminates immediately and control returns to second(). Function second() has a try block, and the call to third() is within it, so the program attempts to match the exception with an appropriate catch block. However, there are no handlers for exceptions of type int here, so second() terminates immediately and control returns to first(). Note that the integer exception is not implicitly converted to match the catch block handling a double. Function first() also has a try block, and the call to second() is within it, so the program looks to see if there is a catch handler for int exceptions. There is! Consequently, first() handles the exception, and prints \u201cfirst caught int exception\u201d. Because the exception has now been handled, control continues normally at the end of the catch block within first(). This means first() prints \u201cEnd first\u201d and then terminates normally. Control returns to main(). Although main() has an exception handler for int, our exception has already been handled by first(), so the catch block within main() does not get executed. main() simply prints \u201cEnd main\u201d and then terminates normally. There are quite a few interesting principles illustrated by this program: First, the immediate caller of a function that throws an exception doesn\u2019t have to handle the exception if it doesn\u2019t want to. In this case, third() didn\u2019t handle the exception thrown by last(). It delegated that responsibility to one of its callers up the stack. Second, if a try block doesn\u2019t have a catch handler for the type of exception being thrown, stack unwinding occurs just as if there were no try block at all. In this case, second() didn\u2019t handle the exception either because it didn\u2019t have the right kind of catch block. Third, once an exception is handled, control flow proceeds as normal starting from the end of the catch blocks. This was demonstrated by first() handling the error and then terminating normally. By the time the program got back to main(), the exception had been thrown and handled already -- main() had no idea there even was an exception at all! As you can see, stack unwinding provides us with some very useful behavior -- if a function does not want to handle an exception, it doesn\u2019t have to. The exception will propagate up the stack until it finds someone who will! This allows us to decide where in the call stack is the most appropriate place to handle any errors that may occur. In the next lesson, we\u2019ll take a look at what happens when you don\u2019t capture an exception, and a method to prevent that from happening.","title":"14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00"},{"location":"14-exceptions/14.3-exceptions-functions-and-stack-unwinding/#143","text":"By Alex on October 5 th , 2008 | last modified by Alex on January 23 rd , 2020 In the previous lesson on basic exception handling, we explained how throw, try, and catch work together to enable exception handling. In this lesson, we\u2019ll talk about how exception handling interacts with functions. Throwing exceptions outside of a try block In the examples in the previous lesson, the throw statements were placed directly within a try block. If this were a necessity, exception handling would be of limited use. One of the most useful properties of exception handling is that the throw statements do NOT have to be placed directly inside a try block due to the way exceptions propagate up the stack when thrown. This allows us to use exception handling in a much more modular fashion. We\u2019ll demonstrate this by rewriting the square root program from the previous lesson to use a modular function. #include <cmath> // for sqrt() function #include <iostream> // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; try // Look for exceptions that occur within try block and route to attached catch block(s) { double d = mySqrt ( x ); std :: cout << \"The sqrt of \" << x << \" is \" << d << '\\n' ; } catch ( const char * exception ) // catch exceptions of type const char* { std :: cerr << \"Error: \" << exception << std :: endl ; } return 0 ; } In this program, we\u2019ve taken the code that checks for an exception and calculates the square root and put it inside a modular function called mySqrt(). We\u2019ve then called this mySqrt() function from inside a try block. Let\u2019s verify that it still works as expected: Enter a number: -4 Error: Can not take sqrt of negative number It does! Let\u2019s revisit for a moment what happens when an exception is raised. First, the program looks to see if the exception can be handled immediately (which means it was thrown inside a try block). If not, the current function is terminated, and the program checks to see if the function\u2019s caller will handle the exception. If not, it terminates the caller and checks the caller\u2019s caller. Each function is terminated in sequence until a handler for the exception is found, or until main() is terminated without the exception being handled. This process is called unwinding the stack (see the lesson on the stack and the heap if you need a refresher on what the call stack is). Now, let\u2019s take a detailed look at how that applies to this program when an exception is raised from within mySqrt(). First, the program checks to see if the exception was thrown from within a try block inside the function. In this case, it was not. Then, the stack begins to unwind. First, mySqrt() terminates, and control returns to main(). The program now checks to see if we\u2019re inside a try block. We are, and there\u2019s a const char* handler, so the exception is handled by the try block within main(). To summarize, mySqrt() raised the exception, but the try/catch block in main() was the one who captured and handled the exception. Or, put another way, try blocks catch exceptions not only from statements within the try block, but also from functions that are called within the try block. The most interesting part of the above program is that the mySqrt() function can throw an exception, but this exception is not immediately inside of a try block! This essentially means mySqrt is willing to say, \u201cHey, there\u2019s a problem!\u201d, but is unwilling to handle the problem itself. It is, in essence, delegating the responsibility for handling the exception to its caller (the equivalent of how using a return code passes the responsibility of handling an error back to a function\u2019s caller). At this point, some of you are probably wondering why it\u2019s a good idea to pass errors back to the caller. Why not just make MySqrt() handle its own error? The problem is that different applications may want to handle errors in different ways. A console application may want to print a text message. A windows application may want to pop up an error dialog. In one application, this may be a fatal error, and in another application it may not be. By passing the error back up the stack, each application can handle an error from mySqrt() in a way that is the most context appropriate for it! Ultimately, this keeps mySqrt() as modular as possible, and the error handling can be placed in the less-modular parts of the code. Another stack unwinding example Here\u2019s another example showing stack unwinding in practice, using a larger stack. Although this program is long, it\u2019s pretty simple: main() calls first(), first() calls second(), second() calls third(), third() calls last(), and last() throws an exception. #include <iostream> void last () // called by third() { std :: cout << \"Start last \\n \" ; std :: cout << \"last throwing int exception \\n \" ; throw -1 ; std :: cout << \"End last \\n \" ; } void third () // called by second() { std :: cout << \"Start third \\n \" ; last (); std :: cout << \"End third \\n \" ; } void second () // called by first() { std :: cout << \"Start second \\n \" ; try { third (); } catch ( double ) { std :: cerr << \"second caught double exception \\n \" ; } std :: cout << \"End second \\n \" ; } void first () // called by main() { std :: cout << \"Start first \\n \" ; try { second (); } catch ( int ) { std :: cerr << \"first caught int exception \\n \" ; } catch ( double ) { std :: cerr << \"first caught double exception \\n \" ; } std :: cout << \"End first \\n \" ; } int main () { std :: cout << \"Start main \\n \" ; try { first (); } catch ( int ) { std :: cerr << \"main caught int exception \\n \" ; } std :: cout << \"End main \\n \" ; return 0 ; } Take a look at this program in more detail, and see if you can figure out what gets printed and what doesn\u2019t when it is run. The answer follows: Start main Start first Start second Start third Start last last throwing int exception first caught int exception End first End main Let\u2019s examine what happens in this case. The printing of all the \u201cStart\u201d statements is straightforward and doesn\u2019t warrant further explanation. Function last() prints \u201clast throwing int exception\u201d and then throws an int exception. This is where things start to get interesting. Because last() doesn\u2019t handle the exception itself, the stack begins to unwind. Function last() terminates immediately and control returns to the caller, which is third(). Function third() doesn\u2019t handle any exceptions, so it terminates immediately and control returns to second(). Function second() has a try block, and the call to third() is within it, so the program attempts to match the exception with an appropriate catch block. However, there are no handlers for exceptions of type int here, so second() terminates immediately and control returns to first(). Note that the integer exception is not implicitly converted to match the catch block handling a double. Function first() also has a try block, and the call to second() is within it, so the program looks to see if there is a catch handler for int exceptions. There is! Consequently, first() handles the exception, and prints \u201cfirst caught int exception\u201d. Because the exception has now been handled, control continues normally at the end of the catch block within first(). This means first() prints \u201cEnd first\u201d and then terminates normally. Control returns to main(). Although main() has an exception handler for int, our exception has already been handled by first(), so the catch block within main() does not get executed. main() simply prints \u201cEnd main\u201d and then terminates normally. There are quite a few interesting principles illustrated by this program: First, the immediate caller of a function that throws an exception doesn\u2019t have to handle the exception if it doesn\u2019t want to. In this case, third() didn\u2019t handle the exception thrown by last(). It delegated that responsibility to one of its callers up the stack. Second, if a try block doesn\u2019t have a catch handler for the type of exception being thrown, stack unwinding occurs just as if there were no try block at all. In this case, second() didn\u2019t handle the exception either because it didn\u2019t have the right kind of catch block. Third, once an exception is handled, control flow proceeds as normal starting from the end of the catch blocks. This was demonstrated by first() handling the error and then terminating normally. By the time the program got back to main(), the exception had been thrown and handled already -- main() had no idea there even was an exception at all! As you can see, stack unwinding provides us with some very useful behavior -- if a function does not want to handle an exception, it doesn\u2019t have to. The exception will propagate up the stack until it finds someone who will! This allows us to decide where in the call stack is the most appropriate place to handle any errors that may occur. In the next lesson, we\u2019ll take a look at what happens when you don\u2019t capture an exception, and a method to prevent that from happening.","title":"14.3 \u5f02\u5e38\uff0c\u51fd\u6570\uff0c\u6808\u5c55\u5f00"},{"location":"14-exceptions/14.4-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/","text":"14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26 \u00b6 By Alex on October 25 th , 2008 | last modified by nascardriver on June 19 th , 2020 By now, you should have a reasonable idea of how exceptions work. In this lesson, we\u2019ll cover a few more interesting exception cases. Uncaught exceptions In the past few examples, there are quite a few cases where a function assumes its caller (or another function somewhere up the call stack) will handle the exception. In the following example, mySqrt() assumes someone will handle the exception that it throws -- but what happens if nobody actually does? Here\u2019s our square root program again, minus the try block in main(): #include <iostream> #include <cmath> // for sqrt() function // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; // Look ma, no exception handler! std :: cout << \"The sqrt of \" << x << \" is \" << mySqrt ( x ) << '\\n' ; return 0 ; } Now, let\u2019s say the user enters -4, and mySqrt(-4) raises an exception. Function mySqrt() doesn\u2019t handle the exception, so the program stack unwinds and control returns to main(). But there\u2019s no exception handler here either, so main() terminates. At this point, we just terminated our application! When main() terminates with an unhandled exception, the operating system will generally notify you that an unhandled exception error has occurred. How it does this depends on the operating system, but possibilities include printing an error message, popping up an error dialog, or simply crashing. Some OSes are less graceful than others. Generally this is something you want to avoid altogether! Catch-all handlers And now we find ourselves in a conundrum: functions can potentially throw exceptions of any data type, and if an exception is not caught, it will propagate to the top of your program and cause it to terminate. Since it\u2019s possible to call functions without knowing how they are even implemented (and thus, what type of exceptions they may throw), how can we possibly prevent this from happening? Fortunately, C++ provides us with a mechanism to catch all types of exceptions. This is known as a catch-all handler. A catch-all handler works just like a normal catch block, except that instead of using a specific type to catch, it uses the ellipses operator (\u2026) as the type to catch. If you recall from lesson 7.14 on ellipses and why to avoid them, ellipses were previously used to pass arguments of any type to a function. In this context, they represent exceptions of any data type. Here\u2019s an simple example: #include <iostream> int main () { try { throw 5 ; // throw an int exception } catch ( double x ) { std :: cout << \"We caught an exception of type double: \" << x << '\\n' ; } catch (...) // catch-all handler { std :: cout << \"We caught an exception of an undetermined type \\n \" ; } } Because there is no specific exception handler for type int, the catch-all handler catches this exception. This example produces the following result: We caught an exception of an undetermined type The catch-all handler should be placed last in the catch block chain. This is to ensure that exceptions can be caught by exception handlers tailored to specific data types if those handlers exist. Visual Studio enforces this constraint -- I am unsure if other compilers do. (Per reader Lonami in the comments below, GCC does too). Often, the catch-all handler block is left empty: catch (...) {} // ignore any unanticipated exceptions This will catch any unanticipated exceptions and prevent them from stack unwinding to the top of your program, but does no specific error handling. Using the catch-all handler to wrap main() One interesting use for the catch-all handler is to wrap the contents of main(): #include <iostream> int main () { try { runGame (); } catch (...) { std :: cerr << \"Abnormal termination \\n \" ; } saveState (); // Save user's game return 1 ; } In this case, if runGame() or any of the functions it calls throws an exception that is not caught, that exception will unwind up the stack and eventually get caught by this catch-all handler. This will prevent main() from terminating, and gives us a chance to print an error of our choosing and then save the user\u2019s state before exiting. This can be useful to catch and handle problems that may be unanticipated. Optional reading Dynamic exception specifiers This subsection should be considered optional reading because exception specifiers are rarely used in practice and have been removed from C++ in C++17 and C++20. Exception specifiers are a mechanism that allows us to use a function declaration to specify whether a function may or will not throw exceptions. This can be useful in determining whether a function call needs to be put inside a try block or not. There are three types of exception specifiers, all of which use what is called the throw (\u2026) syntax. First, we can use an empty throw statement to denote that a function does not throw any exceptions outside of itself: int doSomething () throw (); // does not throw exceptions Note that doSomething() can still use exceptions as long as they are handled internally. Any function that is declared with throw() is supposed to cause the program to terminate immediately if it does try to throw an exception outside of itself, but implementation is spotty. Second, we can use a specific throw statement to denote that a function may throw a particular type of exception: int doSomething () throw ( double ); // may throw a double Finally, we can use a catch-all throw statement to denote that a function may throw an unspecified type of exception: int doSomething () throw (...); // may throw anything Due to the incomplete compiler implementation, the fact that exception specifiers are more like statements of intent than guarantees, some incompatibility with template functions, and the fact that most C++ programmers are unaware of their existence, I recommend you do not bother using dynamic exception specifiers. They were deprecated in C++11, and have been removed from the language in later versions. noexcept C++11 added a fourth exception specifier that is actually getting some use: noexcept. Noexcept is a exception specifier that is used to indicate that a function can not throw an exception. Semantically, it allows you to see at a glance that a function will not throw an exception. It also potentially enables some compiler optimizations. Destructors are generally implicitly noexcept (as they can\u2019t throw an exception). If a noexcept function does try to throw an exception, then std::terminate is called to terminate the application. Proper application of noexcept is non-trivial, and probably warrants its own lesson, so we\u2019ll leave it here -- as a mention that it exists, but as a topic for advanced users to explore further.","title":"14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26"},{"location":"14-exceptions/14.4-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/#144","text":"By Alex on October 25 th , 2008 | last modified by nascardriver on June 19 th , 2020 By now, you should have a reasonable idea of how exceptions work. In this lesson, we\u2019ll cover a few more interesting exception cases. Uncaught exceptions In the past few examples, there are quite a few cases where a function assumes its caller (or another function somewhere up the call stack) will handle the exception. In the following example, mySqrt() assumes someone will handle the exception that it throws -- but what happens if nobody actually does? Here\u2019s our square root program again, minus the try block in main(): #include <iostream> #include <cmath> // for sqrt() function // A modular square root function double mySqrt ( double x ) { // If the user entered a negative number, this is an error condition if ( x < 0.0 ) throw \"Can not take sqrt of negative number\" ; // throw exception of type const char* return sqrt ( x ); } int main () { std :: cout << \"Enter a number: \" ; double x ; std :: cin >> x ; // Look ma, no exception handler! std :: cout << \"The sqrt of \" << x << \" is \" << mySqrt ( x ) << '\\n' ; return 0 ; } Now, let\u2019s say the user enters -4, and mySqrt(-4) raises an exception. Function mySqrt() doesn\u2019t handle the exception, so the program stack unwinds and control returns to main(). But there\u2019s no exception handler here either, so main() terminates. At this point, we just terminated our application! When main() terminates with an unhandled exception, the operating system will generally notify you that an unhandled exception error has occurred. How it does this depends on the operating system, but possibilities include printing an error message, popping up an error dialog, or simply crashing. Some OSes are less graceful than others. Generally this is something you want to avoid altogether! Catch-all handlers And now we find ourselves in a conundrum: functions can potentially throw exceptions of any data type, and if an exception is not caught, it will propagate to the top of your program and cause it to terminate. Since it\u2019s possible to call functions without knowing how they are even implemented (and thus, what type of exceptions they may throw), how can we possibly prevent this from happening? Fortunately, C++ provides us with a mechanism to catch all types of exceptions. This is known as a catch-all handler. A catch-all handler works just like a normal catch block, except that instead of using a specific type to catch, it uses the ellipses operator (\u2026) as the type to catch. If you recall from lesson 7.14 on ellipses and why to avoid them, ellipses were previously used to pass arguments of any type to a function. In this context, they represent exceptions of any data type. Here\u2019s an simple example: #include <iostream> int main () { try { throw 5 ; // throw an int exception } catch ( double x ) { std :: cout << \"We caught an exception of type double: \" << x << '\\n' ; } catch (...) // catch-all handler { std :: cout << \"We caught an exception of an undetermined type \\n \" ; } } Because there is no specific exception handler for type int, the catch-all handler catches this exception. This example produces the following result: We caught an exception of an undetermined type The catch-all handler should be placed last in the catch block chain. This is to ensure that exceptions can be caught by exception handlers tailored to specific data types if those handlers exist. Visual Studio enforces this constraint -- I am unsure if other compilers do. (Per reader Lonami in the comments below, GCC does too). Often, the catch-all handler block is left empty: catch (...) {} // ignore any unanticipated exceptions This will catch any unanticipated exceptions and prevent them from stack unwinding to the top of your program, but does no specific error handling. Using the catch-all handler to wrap main() One interesting use for the catch-all handler is to wrap the contents of main(): #include <iostream> int main () { try { runGame (); } catch (...) { std :: cerr << \"Abnormal termination \\n \" ; } saveState (); // Save user's game return 1 ; } In this case, if runGame() or any of the functions it calls throws an exception that is not caught, that exception will unwind up the stack and eventually get caught by this catch-all handler. This will prevent main() from terminating, and gives us a chance to print an error of our choosing and then save the user\u2019s state before exiting. This can be useful to catch and handle problems that may be unanticipated. Optional reading Dynamic exception specifiers This subsection should be considered optional reading because exception specifiers are rarely used in practice and have been removed from C++ in C++17 and C++20. Exception specifiers are a mechanism that allows us to use a function declaration to specify whether a function may or will not throw exceptions. This can be useful in determining whether a function call needs to be put inside a try block or not. There are three types of exception specifiers, all of which use what is called the throw (\u2026) syntax. First, we can use an empty throw statement to denote that a function does not throw any exceptions outside of itself: int doSomething () throw (); // does not throw exceptions Note that doSomething() can still use exceptions as long as they are handled internally. Any function that is declared with throw() is supposed to cause the program to terminate immediately if it does try to throw an exception outside of itself, but implementation is spotty. Second, we can use a specific throw statement to denote that a function may throw a particular type of exception: int doSomething () throw ( double ); // may throw a double Finally, we can use a catch-all throw statement to denote that a function may throw an unspecified type of exception: int doSomething () throw (...); // may throw anything Due to the incomplete compiler implementation, the fact that exception specifiers are more like statements of intent than guarantees, some incompatibility with template functions, and the fact that most C++ programmers are unaware of their existence, I recommend you do not bother using dynamic exception specifiers. They were deprecated in C++11, and have been removed from the language in later versions. noexcept C++11 added a fourth exception specifier that is actually getting some use: noexcept. Noexcept is a exception specifier that is used to indicate that a function can not throw an exception. Semantically, it allows you to see at a glance that a function will not throw an exception. It also potentially enables some compiler optimizations. Destructors are generally implicitly noexcept (as they can\u2019t throw an exception). If a noexcept function does try to throw an exception, then std::terminate is called to terminate the application. Proper application of noexcept is non-trivial, and probably warrants its own lesson, so we\u2019ll leave it here -- as a mention that it exists, but as a topic for advanced users to explore further.","title":"14.4 \u672a\u6355\u83b7\u5f02\u5e38\uff0c\u6355\u83b7\u5168\u90e8\u5f02\u5e38\u548c\u5f02\u5e38\u8bf4\u660e\u7b26"},{"location":"14-exceptions/14.5-exceptions-classes-and-inheritance/","text":"14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f \u00b6 By Alex on October 26 th , 2008 | last modified by nascardriver on May 20 th , 2020 Exceptions and member functions Up to this point in the tutorial, you\u2019ve only seen exceptions used in non-member functions. However, exceptions are equally useful in member functions, and even moreso in overloaded operators. Consider the following overloaded [] operator as part of a simple integer array class: int & IntArray :: operator []( const int index ) { return m_data [ index ]; } Although this function will work great as long as index is a valid array index, this function is sorely lacking in some good error checking. We could add an assert statement to ensure the index is valid: int & IntArray :: operator []( const int index ) { assert ( index >= 0 && index < getLength ()); return m_data [ index ]; } Now if the user passes in an invalid index, the program will cause an assertion error. While this is useful to indicate to the user that something went wrong, sometimes the better course of action is to fail silently and let the caller know something went wrong so they can deal with it as appropriate. Unfortunately, because overloaded operators have specific requirements as to the number and type of parameter(s) they can take and return, there is no flexibility for passing back error codes or boolean values to the caller. However, since exceptions do not change the signature of a function, they can be put to great use here. Here\u2019s an example: int & IntArray :: operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw index ; return m_data [ index ]; } Now, if the user passes in an invalid index, operator[] will throw an int exception. When constructors fail Constructors are another area of classes in which exceptions can be very useful. If a constructor must fail for some reason (e.g. the user passed in invalid input), simply throw an exception to indicate the object failed to create. In such a case, the object\u2019s construction is aborted, and all class members (which have already been created and initialized prior to the body of the constructor executing) are destructed as per usual. However, the class\u2019s destructor is never called (because the object never finished construction). Because the destructor never executes, you can not rely on said destructor to clean up any resources that have already been allocated. Any such cleanup can happen in the constructor prior to throwing the exception in the first place. However, even better, because the members of the class are destructed as per usual, if you do the resource allocations in the members themselves, then those members can clean up after themselves when they are destructed. Here\u2019s an example: #include <iostream> class Member { public : Member () { std :: cerr << \"Member allocated some resources \\n \" ; } ~ Member () { std :: cerr << \"Member cleaned up \\n \" ; } }; class A { private : int m_x ; Member m_member ; public : A ( int x ) : m_x { x } { if ( x <= 0 ) throw 1 ; } ~ A () { std :: cerr << \"~A \\n \" ; // should not be called } }; int main () { try { A a { 0 }; } catch ( int ) { std :: cerr << \"Oops \\n \" ; } return 0 ; } This prints: Member allocated some resources Member cleaned up Oops In the above program, when class A throws an exception, all of the members of A are destructed. This gives m_member an opportunity to clean up any resources that were allocated. This is part of the reason that RAII (reference: 8.7 -- Destructors) is advocated so highly -- even in abnormal circumstances, classes that implement RAII properly should be able to clean up after themselves. Exception classes One of the major problems with using basic data types (such as int) as exception types is that they are inherently vague. An even bigger problem is disambiguation of what an exception means when there are multiple statements or function calls within a try block. // Using the IntArray overloaded operator[] above try { int * value { new int { array [ index1 ] + array [ index2 ]} }; } catch ( int value ) { // What are we catching here? } In this example, if we were to catch an int exception, what does that really tell us? Was one of the array indexes out of bounds? Did operator+ cause integer overflow? Did operator new fail because it ran out of memory? Unfortunately, in this case, there\u2019s just no easy way to disambiguate. While we can throw const char* exceptions to solve the problem of identifying WHAT went wrong, this still does not provide us the ability to handle exceptions from various sources differently. One way to solve this problem is to use exception classes. An exception class is just a normal class that is designed specifically to be thrown as an exception. Let\u2019s design a simple exception class to be used with our IntArray class: #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } const char * getError () const { return m_error . c_str (); } }; Here\u2019s a full program using this class: #include <iostream> #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error ( error ) { } const char * getError () const { return m_error . c_str (); } }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) { std :: cerr << \"An array exception occurred (\" << exception . getError () << \") \\n \" ; } } Using such a class, we can have the exception return a description of the problem that occurred, which provides context for what went wrong. And since ArrayException is its own unique type, we can specifically catch exceptions thrown by the array class and treat them differently from other exceptions if we wish. Note that exception handlers should catch class exception objects by reference instead of by value. This prevents the compiler from making a copy of the exception, which can be expensive when the exception is a class object, and prevents object slicing when dealing with derived exception classes (which we\u2019ll talk about in a moment). Catching exceptions by pointer should generally be avoided unless you have a specific reason to do so. Exceptions and inheritance Since it\u2019s possible to throw classes as exceptions, and classes can be derived from other classes, we need to consider what happens when we use inherited classes as exceptions. As it turns out, exception handlers will not only match classes of a specific type, they\u2019ll also match classes derived from that specific type as well! Consider the following example: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } return 0 ; } In the above example we throw an exception of type Derived. However, the output of this program is: caught Base What happened? First, as mentioned above, derived classes will be caught by handlers for the base type. Because Derived is derived from Base, Derived is-a Base (they have an is-a relationship). Second, when C++ is attempting to find a handler for a raised exception, it does so sequentially. Consequently, the first thing C++ does is check whether the exception handler for Base matches the Derived exception. Because Derived is-a Base, the answer is yes, and it executes the catch block for type Base! The catch block for Derived is never even tested in this case. In order to make this example work as expected, we need to flip the order of the catch blocks: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } return 0 ; } This way, the Derived handler will get first shot at catching objects of type Derived (before the handler for Base can). Objects of type Base will not match the Derived handler (Derived is-a Base, but Base is not a Derived), and thus will \u201cfall through\u201d to the Base handler. Rule: Handlers for derived exception classes should be listed before those for base classes. The ability to use a handler to catch exceptions of derived types using a handler for the base class turns out to be exceedingly useful. std::exception Many of the classes and operators in the standard library throw exception classes on failure. For example, operator new can throw std::bad_alloc if it is unable to allocate enough memory. A failed dynamic_cast will throw std::bad_cast. And so on. As of C++17, there are 25 different exception classes that can be thrown, with more being added in each subsequent language standard. The good news is that all of these exception classes are derived from a single class called std::exception. std::exception is a small interface class designed to serve as a base class to any exception thrown by the C++ standard library. Much of the time, when an exception is thrown by the standard library, we won\u2019t care whether it\u2019s a bad allocation, a bad cast, or something else. We just care that something catastrophic went wrong and now our program is exploding. Thanks to std::exception, we can set up an exception handler to catch exceptions of type std::exception, and we\u2019ll end up catching std::exception and all (21+) of the derived exceptions together in one place. Easy! #include <iostream> #include <exception> // for std::exception #include <string> // for this example int main () { try { // Your code using standard library goes here // We'll trigger one of these exceptions intentionally for the sake of example std :: string s ; s . resize ( -1 ); // will trigger a std::length_error } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } The above program prints: Standard exception: string too long The above example should be pretty straightforward. The one thing worth noting is that std::exception has a virtual member function named what() that returns a C-style string description of the exception. Most derived classes override the what() function to change the message. Note that this string is meant to be used for descriptive text only -- do not use it for comparisons, as it is not guaranteed to be the same across compilers. Sometimes we\u2019ll want to handle a specific type of exception differently. In this case, we can add a handler for that specific type, and let all the others \u201cfall through\u201d to the base handler. Consider: try { // code using standard library goes here } // This handler will catch std::length_error (and any exceptions derived from it) here catch ( const std :: length_error & exception ) { std :: cerr << \"You ran out of memory!\" << '\\n' ; } // This handler will catch std::exception (and any exception derived from it) that fall // through here catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } In this example, exceptions of type std::length_error will be caught by the first handler and handled there. Exceptions of type std::exception and all of the other derived classes will be caught by the second handler. Such inheritance hierarchies allow us to use specific handlers to target specific derived exception classes, or to use base class handlers to catch the whole hierarchy of exceptions. This allows us a fine degree of control over what kind of exceptions we want to handle while ensuring we don\u2019t have to do too much work to catch \u201ceverything else\u201d in a hierarchy. Using the standard exceptions directly Nothing throws a std::exception directly, and neither should you. However, you should feel free to throw the other standard exception classes in the standard library if they adequately represent your needs. You can find a list of all the standard exceptions on cppreference. std::runtime_error (included as part of the stdexcept header) is a popular choice, because it has a generic name, and its constructor takes a customizable message: #include <iostream> #include <stdexcept> int main () { try { throw std :: runtime_error ( \"Bad things happened\" ); } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } This prints: Standard exception: Bad things happened Deriving your own classes from std::exception You can, of course, derive your own classes from std::exception, and override the virtual what() const member function. Here\u2019s the same program as above, with ArrayException derived from std::exception: #include <iostream> #include <string> #include <exception> // for std::exception class ArrayException : public std :: exception { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } // return the std::string as a const C-style string // const char* what() const { return m_error.c_str(); } // pre-C++11 version const char * what () const noexcept { return m_error . c_str (); } // C++11 version }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) // derived catch blocks go first { std :: cerr << \"An array exception occurred (\" << exception . what () << \") \\n \" ; } catch ( const std :: exception & exception ) { std :: cerr << \"Some other std::exception occurred (\" << exception . what () << \") \\n \" ; } } In C++11, virtual function what() was updated to have specifier noexcept (which means the function promises not to throw exceptions itself). Therefore, in C++11 and beyond, our override should also have specifier noexcept. It\u2019s up to you whether you want create your own standalone exception classes, use the standard exception classes, or derive your own exception classes from std::exception. All are valid approaches depending on your aims.","title":"14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f"},{"location":"14-exceptions/14.5-exceptions-classes-and-inheritance/#145","text":"By Alex on October 26 th , 2008 | last modified by nascardriver on May 20 th , 2020 Exceptions and member functions Up to this point in the tutorial, you\u2019ve only seen exceptions used in non-member functions. However, exceptions are equally useful in member functions, and even moreso in overloaded operators. Consider the following overloaded [] operator as part of a simple integer array class: int & IntArray :: operator []( const int index ) { return m_data [ index ]; } Although this function will work great as long as index is a valid array index, this function is sorely lacking in some good error checking. We could add an assert statement to ensure the index is valid: int & IntArray :: operator []( const int index ) { assert ( index >= 0 && index < getLength ()); return m_data [ index ]; } Now if the user passes in an invalid index, the program will cause an assertion error. While this is useful to indicate to the user that something went wrong, sometimes the better course of action is to fail silently and let the caller know something went wrong so they can deal with it as appropriate. Unfortunately, because overloaded operators have specific requirements as to the number and type of parameter(s) they can take and return, there is no flexibility for passing back error codes or boolean values to the caller. However, since exceptions do not change the signature of a function, they can be put to great use here. Here\u2019s an example: int & IntArray :: operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw index ; return m_data [ index ]; } Now, if the user passes in an invalid index, operator[] will throw an int exception. When constructors fail Constructors are another area of classes in which exceptions can be very useful. If a constructor must fail for some reason (e.g. the user passed in invalid input), simply throw an exception to indicate the object failed to create. In such a case, the object\u2019s construction is aborted, and all class members (which have already been created and initialized prior to the body of the constructor executing) are destructed as per usual. However, the class\u2019s destructor is never called (because the object never finished construction). Because the destructor never executes, you can not rely on said destructor to clean up any resources that have already been allocated. Any such cleanup can happen in the constructor prior to throwing the exception in the first place. However, even better, because the members of the class are destructed as per usual, if you do the resource allocations in the members themselves, then those members can clean up after themselves when they are destructed. Here\u2019s an example: #include <iostream> class Member { public : Member () { std :: cerr << \"Member allocated some resources \\n \" ; } ~ Member () { std :: cerr << \"Member cleaned up \\n \" ; } }; class A { private : int m_x ; Member m_member ; public : A ( int x ) : m_x { x } { if ( x <= 0 ) throw 1 ; } ~ A () { std :: cerr << \"~A \\n \" ; // should not be called } }; int main () { try { A a { 0 }; } catch ( int ) { std :: cerr << \"Oops \\n \" ; } return 0 ; } This prints: Member allocated some resources Member cleaned up Oops In the above program, when class A throws an exception, all of the members of A are destructed. This gives m_member an opportunity to clean up any resources that were allocated. This is part of the reason that RAII (reference: 8.7 -- Destructors) is advocated so highly -- even in abnormal circumstances, classes that implement RAII properly should be able to clean up after themselves. Exception classes One of the major problems with using basic data types (such as int) as exception types is that they are inherently vague. An even bigger problem is disambiguation of what an exception means when there are multiple statements or function calls within a try block. // Using the IntArray overloaded operator[] above try { int * value { new int { array [ index1 ] + array [ index2 ]} }; } catch ( int value ) { // What are we catching here? } In this example, if we were to catch an int exception, what does that really tell us? Was one of the array indexes out of bounds? Did operator+ cause integer overflow? Did operator new fail because it ran out of memory? Unfortunately, in this case, there\u2019s just no easy way to disambiguate. While we can throw const char* exceptions to solve the problem of identifying WHAT went wrong, this still does not provide us the ability to handle exceptions from various sources differently. One way to solve this problem is to use exception classes. An exception class is just a normal class that is designed specifically to be thrown as an exception. Let\u2019s design a simple exception class to be used with our IntArray class: #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } const char * getError () const { return m_error . c_str (); } }; Here\u2019s a full program using this class: #include <iostream> #include <string> class ArrayException { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error ( error ) { } const char * getError () const { return m_error . c_str (); } }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) { std :: cerr << \"An array exception occurred (\" << exception . getError () << \") \\n \" ; } } Using such a class, we can have the exception return a description of the problem that occurred, which provides context for what went wrong. And since ArrayException is its own unique type, we can specifically catch exceptions thrown by the array class and treat them differently from other exceptions if we wish. Note that exception handlers should catch class exception objects by reference instead of by value. This prevents the compiler from making a copy of the exception, which can be expensive when the exception is a class object, and prevents object slicing when dealing with derived exception classes (which we\u2019ll talk about in a moment). Catching exceptions by pointer should generally be avoided unless you have a specific reason to do so. Exceptions and inheritance Since it\u2019s possible to throw classes as exceptions, and classes can be derived from other classes, we need to consider what happens when we use inherited classes as exceptions. As it turns out, exception handlers will not only match classes of a specific type, they\u2019ll also match classes derived from that specific type as well! Consider the following example: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } return 0 ; } In the above example we throw an exception of type Derived. However, the output of this program is: caught Base What happened? First, as mentioned above, derived classes will be caught by handlers for the base type. Because Derived is derived from Base, Derived is-a Base (they have an is-a relationship). Second, when C++ is attempting to find a handler for a raised exception, it does so sequentially. Consequently, the first thing C++ does is check whether the exception handler for Base matches the Derived exception. Because Derived is-a Base, the answer is yes, and it executes the catch block for type Base! The catch block for Derived is never even tested in this case. In order to make this example work as expected, we need to flip the order of the catch blocks: class Base { public : Base () {} }; class Derived : public Base { public : Derived () {} }; int main () { try { throw Derived (); } catch ( const Derived & derived ) { std :: cerr << \"caught Derived\" ; } catch ( const Base & base ) { std :: cerr << \"caught Base\" ; } return 0 ; } This way, the Derived handler will get first shot at catching objects of type Derived (before the handler for Base can). Objects of type Base will not match the Derived handler (Derived is-a Base, but Base is not a Derived), and thus will \u201cfall through\u201d to the Base handler. Rule: Handlers for derived exception classes should be listed before those for base classes. The ability to use a handler to catch exceptions of derived types using a handler for the base class turns out to be exceedingly useful. std::exception Many of the classes and operators in the standard library throw exception classes on failure. For example, operator new can throw std::bad_alloc if it is unable to allocate enough memory. A failed dynamic_cast will throw std::bad_cast. And so on. As of C++17, there are 25 different exception classes that can be thrown, with more being added in each subsequent language standard. The good news is that all of these exception classes are derived from a single class called std::exception. std::exception is a small interface class designed to serve as a base class to any exception thrown by the C++ standard library. Much of the time, when an exception is thrown by the standard library, we won\u2019t care whether it\u2019s a bad allocation, a bad cast, or something else. We just care that something catastrophic went wrong and now our program is exploding. Thanks to std::exception, we can set up an exception handler to catch exceptions of type std::exception, and we\u2019ll end up catching std::exception and all (21+) of the derived exceptions together in one place. Easy! #include <iostream> #include <exception> // for std::exception #include <string> // for this example int main () { try { // Your code using standard library goes here // We'll trigger one of these exceptions intentionally for the sake of example std :: string s ; s . resize ( -1 ); // will trigger a std::length_error } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } The above program prints: Standard exception: string too long The above example should be pretty straightforward. The one thing worth noting is that std::exception has a virtual member function named what() that returns a C-style string description of the exception. Most derived classes override the what() function to change the message. Note that this string is meant to be used for descriptive text only -- do not use it for comparisons, as it is not guaranteed to be the same across compilers. Sometimes we\u2019ll want to handle a specific type of exception differently. In this case, we can add a handler for that specific type, and let all the others \u201cfall through\u201d to the base handler. Consider: try { // code using standard library goes here } // This handler will catch std::length_error (and any exceptions derived from it) here catch ( const std :: length_error & exception ) { std :: cerr << \"You ran out of memory!\" << '\\n' ; } // This handler will catch std::exception (and any exception derived from it) that fall // through here catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } In this example, exceptions of type std::length_error will be caught by the first handler and handled there. Exceptions of type std::exception and all of the other derived classes will be caught by the second handler. Such inheritance hierarchies allow us to use specific handlers to target specific derived exception classes, or to use base class handlers to catch the whole hierarchy of exceptions. This allows us a fine degree of control over what kind of exceptions we want to handle while ensuring we don\u2019t have to do too much work to catch \u201ceverything else\u201d in a hierarchy. Using the standard exceptions directly Nothing throws a std::exception directly, and neither should you. However, you should feel free to throw the other standard exception classes in the standard library if they adequately represent your needs. You can find a list of all the standard exceptions on cppreference. std::runtime_error (included as part of the stdexcept header) is a popular choice, because it has a generic name, and its constructor takes a customizable message: #include <iostream> #include <stdexcept> int main () { try { throw std :: runtime_error ( \"Bad things happened\" ); } // This handler will catch std::exception and all the derived exceptions too catch ( const std :: exception & exception ) { std :: cerr << \"Standard exception: \" << exception . what () << '\\n' ; } return 0 ; } This prints: Standard exception: Bad things happened Deriving your own classes from std::exception You can, of course, derive your own classes from std::exception, and override the virtual what() const member function. Here\u2019s the same program as above, with ArrayException derived from std::exception: #include <iostream> #include <string> #include <exception> // for std::exception class ArrayException : public std :: exception { private : std :: string m_error ; public : ArrayException ( std :: string error ) : m_error { error } { } // return the std::string as a const C-style string // const char* what() const { return m_error.c_str(); } // pre-C++11 version const char * what () const noexcept { return m_error . c_str (); } // C++11 version }; class IntArray { private : int m_data [ 3 ]; // assume array is length 3 for simplicity public : IntArray () {} int getLength () const { return 3 ; } int & operator []( const int index ) { if ( index < 0 || index >= getLength ()) throw ArrayException ( \"Invalid index\" ); return m_data [ index ]; } }; int main () { IntArray array ; try { int value { array [ 5 ] }; } catch ( const ArrayException & exception ) // derived catch blocks go first { std :: cerr << \"An array exception occurred (\" << exception . what () << \") \\n \" ; } catch ( const std :: exception & exception ) { std :: cerr << \"Some other std::exception occurred (\" << exception . what () << \") \\n \" ; } } In C++11, virtual function what() was updated to have specifier noexcept (which means the function promises not to throw exceptions itself). Therefore, in C++11 and beyond, our override should also have specifier noexcept. It\u2019s up to you whether you want create your own standalone exception classes, use the standard exception classes, or derive your own exception classes from std::exception. All are valid approaches depending on your aims.","title":"14.5 \u5f02\u5e38\uff0c\u7c7b\u548c\u7ee7\u627f"},{"location":"14-exceptions/14.6-rethrowing-exceptions/","text":"14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa \u00b6 By Alex on February 5 th , 2017 | last modified by Alex on January 23 rd , 2020 Occasionally you may run into a case where you want to catch an exception, but not want to (or have the ability to) fully handle it at the point where you catch it. This is common when you want to log an error, but pass the issue along to the caller to actually handle. When a function can use a return code, this is simple. Consider the following example: Database * createDatabase ( std :: string filename ) { try { Database * d = new Database ( filename ); d -> open (); // assume this throws an int exception on failure return d ; } catch ( int exception ) { // Database creation failed // Write an error to some global logfile g_log . logError ( \"Creation of Database failed\" ); } return nullptr ; } In the above code snippet, the function is tasked with creating a Database object, opening the database, and returning the Database object. In the case where something goes wrong (e.g. the wrong filename is passed in), the exception handler logs an error, and then reasonably returns a null pointer. Now consider the following function: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); // However, we haven't actually handled this error // So what do we do here? } } In the case where this function succeeds, it returns an integer value -- any integer value could be a valid value. But what about the case where something goes wrong with getIntValue()? In that case, getIntValue() will throw an integer exception, which will be caught by the catch block in getIntValueFromDatabase(), which will log the error. But then how do we tell the caller of getIntValueFromDatabase() that something went wrong? Unlike the top example, there isn\u2019t a good return code we can use here (because any integer return value could be a valid one). Throwing a new exception One obvious solution is to throw a new exception. int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw 'q' ; // throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase() } } In the example above, the program catches the int exception from getIntValue(), logs the error, and then throws a new exception with char value \u2018q\u2019. Although it may seem weird to throw an exception from a catch block, this is allowed. Remember, only exceptions thrown within a try block are eligible to be caught. This means that an exception thrown within a catch block will not be caught by the catch block it\u2019s in. Instead, it will be propagated up the stack to the caller. The exception thrown from the catch block can be an exception of any type -- it doesn\u2019t need to be the same type as the exception that was just caught. Rethrowing an exception (the wrong way) Another option is to rethrow the same exception. One way to do this is as follows: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; } } Although this works, this method has a couple of downsides. First, this doesn\u2019t throw the exact same exception as the one that is caught -- rather, it throws a copy-initialized copy of variable exception. Although the compiler is free to elide the copy, it may not, so this could be less performant. But significantly, consider what happens in the following case: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws Derived exception on failure } catch ( Base & exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; // Danger: this throws a Base object, not a Derived object } } In this case, getIntValue() throws a Derived object, but the catch block is catching a Base reference. This is fine, as we know we can have a Base reference to a Derived object. However, when we throw exception, the thrown exception is copy-initialized from variable exception. Variable exception has type Base, so the copy-initialized exception also has type Base (not Derived!). In other words, our Derived() object has been sliced! You can see this in the following program: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw b ; // the Derived object gets sliced here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Base The fact that the second line indicates that Base is actually a Base rather than a Derived proves that the Derived object was sliced. Rethrowing an exception (the right way) Fortunately, C++ provides a way to rethrow the exact same exception as the one that was just caught. To do so, simply use the throw keyword from within the catch block (with no associated variable), like so: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw ; // note: We're now rethrowing the object here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Derived This throw keyword that doesn\u2019t appear to throw anything in particular actually re-throws the exact same exception that was just caught. No copies are made, meaning we don\u2019t have to worry about performance killing copies or slicing. If rethrowing an exception is required, this method should be preferred over the alternatives. Rule: When rethrowing the same exception, use the throw keyword by itself.","title":"14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa"},{"location":"14-exceptions/14.6-rethrowing-exceptions/#146","text":"By Alex on February 5 th , 2017 | last modified by Alex on January 23 rd , 2020 Occasionally you may run into a case where you want to catch an exception, but not want to (or have the ability to) fully handle it at the point where you catch it. This is common when you want to log an error, but pass the issue along to the caller to actually handle. When a function can use a return code, this is simple. Consider the following example: Database * createDatabase ( std :: string filename ) { try { Database * d = new Database ( filename ); d -> open (); // assume this throws an int exception on failure return d ; } catch ( int exception ) { // Database creation failed // Write an error to some global logfile g_log . logError ( \"Creation of Database failed\" ); } return nullptr ; } In the above code snippet, the function is tasked with creating a Database object, opening the database, and returning the Database object. In the case where something goes wrong (e.g. the wrong filename is passed in), the exception handler logs an error, and then reasonably returns a null pointer. Now consider the following function: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); // However, we haven't actually handled this error // So what do we do here? } } In the case where this function succeeds, it returns an integer value -- any integer value could be a valid value. But what about the case where something goes wrong with getIntValue()? In that case, getIntValue() will throw an integer exception, which will be caught by the catch block in getIntValueFromDatabase(), which will log the error. But then how do we tell the caller of getIntValueFromDatabase() that something went wrong? Unlike the top example, there isn\u2019t a good return code we can use here (because any integer return value could be a valid one). Throwing a new exception One obvious solution is to throw a new exception. int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw 'q' ; // throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase() } } In the example above, the program catches the int exception from getIntValue(), logs the error, and then throws a new exception with char value \u2018q\u2019. Although it may seem weird to throw an exception from a catch block, this is allowed. Remember, only exceptions thrown within a try block are eligible to be caught. This means that an exception thrown within a catch block will not be caught by the catch block it\u2019s in. Instead, it will be propagated up the stack to the caller. The exception thrown from the catch block can be an exception of any type -- it doesn\u2019t need to be the same type as the exception that was just caught. Rethrowing an exception (the wrong way) Another option is to rethrow the same exception. One way to do this is as follows: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws int exception on failure } catch ( int exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; } } Although this works, this method has a couple of downsides. First, this doesn\u2019t throw the exact same exception as the one that is caught -- rather, it throws a copy-initialized copy of variable exception. Although the compiler is free to elide the copy, it may not, so this could be less performant. But significantly, consider what happens in the following case: int getIntValueFromDatabase ( Database * d , std :: string table , std :: string key ) { assert ( d ); try { return d -> getIntValue ( table , key ); // throws Derived exception on failure } catch ( Base & exception ) { // Write an error to some global logfile g_log . logError ( \"doSomethingImportant failed\" ); throw exception ; // Danger: this throws a Base object, not a Derived object } } In this case, getIntValue() throws a Derived object, but the catch block is catching a Base reference. This is fine, as we know we can have a Base reference to a Derived object. However, when we throw exception, the thrown exception is copy-initialized from variable exception. Variable exception has type Base, so the copy-initialized exception also has type Base (not Derived!). In other words, our Derived() object has been sliced! You can see this in the following program: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw b ; // the Derived object gets sliced here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Base The fact that the second line indicates that Base is actually a Base rather than a Derived proves that the Derived object was sliced. Rethrowing an exception (the right way) Fortunately, C++ provides a way to rethrow the exact same exception as the one that was just caught. To do so, simply use the throw keyword from within the catch block (with no associated variable), like so: #include <iostream> class Base { public : Base () {} virtual void print () { std :: cout << \"Base\" ; } }; class Derived : public Base { public : Derived () {} virtual void print () { std :: cout << \"Derived\" ; } }; int main () { try { try { throw Derived (); } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; throw ; // note: We're now rethrowing the object here } } catch ( Base & b ) { std :: cout << \"Caught Base b, which is actually a \" ; b . print (); std :: cout << \" \\n \" ; } return 0 ; } This prints: Caught Base b, which is actually a Derived Caught Base b, which is actually a Derived This throw keyword that doesn\u2019t appear to throw anything in particular actually re-throws the exact same exception that was just caught. No copies are made, meaning we don\u2019t have to worry about performance killing copies or slicing. If rethrowing an exception is required, this method should be preferred over the alternatives. Rule: When rethrowing the same exception, use the throw keyword by itself.","title":"14.6 \u5f02\u5e38\u7684\u518d\u629b\u51fa"},{"location":"14-exceptions/14.7-function-try-blocks/","text":"14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757 \u00b6 By Alex on February 6 th , 2017 | last modified by Alex on January 23 rd , 2020 Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example: class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) : A ( x ) { // What happens if creation of A fails and we want to handle it here? } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } In the above example, derived class B calls base class constructor A, which can throw an exception. Because the creation of object b has been placed inside a try block (in function main()), if A throws an exception, main\u2019s try block will catch it. Consequently, this program prints: Oops But what if we want to catch the exception inside of B? The call to base constructor A happens via the member initialization list, before the B constructor\u2019s body is called. There\u2019s no way to wrap a standard try block around it. In this situation, we have to use a slightly modified try block called a function try block. Function try blocks Function try blocks are designed to allow you to establish an exception handler around the body of an entire function, rather than around a block of code. The syntax for function try blocks is a little hard to describe, so we\u2019ll show by example: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { } catch (...) // note this is at same level of indentation as the function itself { // Exceptions from member initializer list or constructor body are caught here std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } When this program is run, it produces the output: Exception caught Oops Let\u2019s examine this program in more detail. First, note the addition of the \u201ctry\u201d keyword before the member initializer list. This indicates that everything after that point (until the end of the function) should be considered inside of the try block. Second, note that the associated catch block is at the same level of indentation as the entire function. Any exception thrown between the try keyword and the end of the function body will be eligible to be caught here. Finally, unlike normal catch blocks, which allow you to either resolve an exception, throw a new exception, or rethrow an existing exception, with function-level try blocks, you must throw or rethrow an exception. If you do not explicitly throw a new exception, or rethrow the current exception (using the throw keyword by itself), the exception will be implicitly rethrown up the stack. In the program above, because we did not explicitly throw an exception from the function-level catch block, the exception was implicitly rethrown, and was caught by the catch block in main(). This is the reason why the above program prints \u201cOops\u201d! Although function level try blocks can be used with non-member functions as well, they typically aren\u2019t because there\u2019s rarely a case where this would be needed. They are almost exclusively used with constructors! Function try blocks can catch both base and the current class exceptions In the above example, if either A or B\u2019s constructor throw an exception, it will be caught by the try block around B\u2019s constructor. We can see that in the following example, where we\u2019re throwing an exception from class B instead of class A: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { if ( x <= 0 ) // moved this from A to B throw 1 ; // and this too } catch (...) { std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } We get the same output: Exception caught Oops Don\u2019t use function try to clean up resources When construction of an object fails, the destructor of the class is not called. Consequently, you may be tempted to use a function try block as a way to clean up a class that had partially allocated resources before failing. However, referring to members of the failed object is considered undefined behavior since the object is \u201cdead\u201d before the catch block executes. This means that you can\u2019t use function try to clean up after a class. If you want to clean up after a class, follow the standard rules for cleaning up classes that throw exceptions (see the \u201cWhen constructor fail\u201d subsection of lesson 14.5 -- Exceptions, classes, and inheritance). Function try is useful primarily for either logging failures before passing the exception up the stack, or for changing the type of exception thrown","title":"14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757"},{"location":"14-exceptions/14.7-function-try-blocks/#147-try","text":"By Alex on February 6 th , 2017 | last modified by Alex on January 23 rd , 2020 Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example: class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) : A ( x ) { // What happens if creation of A fails and we want to handle it here? } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } In the above example, derived class B calls base class constructor A, which can throw an exception. Because the creation of object b has been placed inside a try block (in function main()), if A throws an exception, main\u2019s try block will catch it. Consequently, this program prints: Oops But what if we want to catch the exception inside of B? The call to base constructor A happens via the member initialization list, before the B constructor\u2019s body is called. There\u2019s no way to wrap a standard try block around it. In this situation, we have to use a slightly modified try block called a function try block. Function try blocks Function try blocks are designed to allow you to establish an exception handler around the body of an entire function, rather than around a block of code. The syntax for function try blocks is a little hard to describe, so we\u2019ll show by example: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { if ( x <= 0 ) throw 1 ; } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { } catch (...) // note this is at same level of indentation as the function itself { // Exceptions from member initializer list or constructor body are caught here std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } When this program is run, it produces the output: Exception caught Oops Let\u2019s examine this program in more detail. First, note the addition of the \u201ctry\u201d keyword before the member initializer list. This indicates that everything after that point (until the end of the function) should be considered inside of the try block. Second, note that the associated catch block is at the same level of indentation as the entire function. Any exception thrown between the try keyword and the end of the function body will be eligible to be caught here. Finally, unlike normal catch blocks, which allow you to either resolve an exception, throw a new exception, or rethrow an existing exception, with function-level try blocks, you must throw or rethrow an exception. If you do not explicitly throw a new exception, or rethrow the current exception (using the throw keyword by itself), the exception will be implicitly rethrown up the stack. In the program above, because we did not explicitly throw an exception from the function-level catch block, the exception was implicitly rethrown, and was caught by the catch block in main(). This is the reason why the above program prints \u201cOops\u201d! Although function level try blocks can be used with non-member functions as well, they typically aren\u2019t because there\u2019s rarely a case where this would be needed. They are almost exclusively used with constructors! Function try blocks can catch both base and the current class exceptions In the above example, if either A or B\u2019s constructor throw an exception, it will be caught by the try block around B\u2019s constructor. We can see that in the following example, where we\u2019re throwing an exception from class B instead of class A: #include <iostream> class A { private : int m_x ; public : A ( int x ) : m_x ( x ) { } }; class B : public A { public : B ( int x ) try : A ( x ) // note addition of try keyword here { if ( x <= 0 ) // moved this from A to B throw 1 ; // and this too } catch (...) { std :: cerr << \"Exception caught \\n \" ; // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown } }; int main () { try { B b ( 0 ); } catch ( int ) { std :: cout << \"Oops \\n \" ; } } We get the same output: Exception caught Oops Don\u2019t use function try to clean up resources When construction of an object fails, the destructor of the class is not called. Consequently, you may be tempted to use a function try block as a way to clean up a class that had partially allocated resources before failing. However, referring to members of the failed object is considered undefined behavior since the object is \u201cdead\u201d before the catch block executes. This means that you can\u2019t use function try to clean up after a class. If you want to clean up after a class, follow the standard rules for cleaning up classes that throw exceptions (see the \u201cWhen constructor fail\u201d subsection of lesson 14.5 -- Exceptions, classes, and inheritance). Function try is useful primarily for either logging failures before passing the exception up the stack, or for changing the type of exception thrown","title":"14.7 \u51fd\u6570\u7ea7\u7684 try \u4ee3\u7801\u5757"},{"location":"14-exceptions/14.8-exception-dangers-and-downsides/","text":"14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9 \u00b6 By Alex on October 26 th , 2008 | last modified by nascardriver on July 2 nd , 2020 As with almost everything that has benefits, there are some potential downsides to exceptions as well. This article is not meant to be comprehensive, but just to point out some of the major issues that should be considered when using exceptions (or deciding whether to use them). Cleaning up resources One of the biggest problems that new programmers run into when using exceptions is the issue of cleaning up resources when an exception occurs. Consider the following example: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } What happens if WriteFile() fails and throws a FileException? At this point, we\u2019ve already opened the file, and now control flow jumps to the FileException handler, which prints an error and exits. Note that the file was never closed! This example should be rewritten as follows: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { // Make sure file is closed closeFile ( filename ); // Then write error std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } This kind of error often crops up in another form when dealing with dynamically allocated memory: try { auto * john { new Person { \"John\" , 18 , PERSON_MALE } }; processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } If processPerson() throws an exception, control flow jumps to the catch handler. As a result, john is never deallocated! This example is a little more tricky than the previous one -- because john is local to the try block, it goes out of scope when the try block exits. That means the exception handler can not access john at all (its been destroyed already), so there\u2019s no way for it to deallocate the memory. However, there are two relatively easy ways to fix this. First, declare john outside of the try block so it does not go out of scope when the try block exits: Person * john { nullptr }; try { john = new Person ( \"John\" , 18 , PERSON_MALE ); processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { delete john ; std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } Because john is declared outside the try block, it is accessible both within the try block and the catch handlers. This means the catch handler can do cleanup properly. The second way is to use a local variable of a class that knows how to cleanup itself when it goes out of scope (often called a \u201csmart pointer\u201d). The standard library provides a class called std::unique_ptr that can be used for this purpose. std::unique_ptr is a template class that holds a pointer, and deallocates it when it goes out of scope. #include <memory> // for std::unique_ptr try { auto * john { new Person ( \"John\" , 18 , PERSON_MALE ) }; std :: unique_ptr < Person > upJohn { john }; // upJohn now owns john ProcessPerson ( john ); // when upJohn goes out of scope, it will delete john } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } We\u2019ll talk more about smart pointers in the next chapter. Exceptions and destructors Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation did not succeed, exceptions should never be thrown in destructors. The problem occurs when an exception is thrown from a destructor during the stack unwinding process. If that happens, the compiler is put in a situation where it doesn\u2019t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately. Consequently, the best course of action is just to abstain from using exceptions in destructors altogether. Write a message to a log file instead. Performance concerns Exceptions do come with a small performance price to pay. They increase the size of your executable, and they may also cause it to run slower due to the additional checking that has to be performed. However, the main performance penalty for exceptions happens when an exception is actually thrown. In this case, the stack must be unwound and an appropriate exception handler found, which is a relatively expensive operation. As a note, some modern computer architectures support an exception model called zero-cost exceptions. Zero-cost exceptions, if supported, have no additional runtime cost in the non-error case (which is the case we most care about performance). However, they incur an even larger penalty in the case where an exception is found. So when should I use exceptions? Exception handling is best used when all of the following are true: The error being handled is likely to occur only infrequently. The error is serious and execution could not continue otherwise. The error cannot be handled at the place where it occurs. There isn\u2019t a good alternative way to return an error code back to the caller. As an example, let\u2019s consider the case where you\u2019ve written a function that expects the user to pass in the name of a file on disk. Your function will open this file, read some data, close the file, and pass back some result to the caller. Now, let\u2019s say the user passes in the name of a file that doesn\u2019t exist, or a null string. Is this a good candidate for an exception? In this case, the first two bullets above are trivially met -- this isn\u2019t something that\u2019s going to happen often, and your function can\u2019t calculate a result when it doesn\u2019t have any data to work with. The function can\u2019t handle the error either -- it\u2019s not the job of the function to re-prompt the user for a new filename, and that might not even be appropriate, depending on how your program is designed. The fourth bullet is the key -- is there a good alternative way to return an error code back to the caller? It depends on the details of your program. If so (e.g. you can return a null pointer, or a status code to indicate failure), that\u2019s probably the better choice. If not, then an exception would be reasonable.","title":"14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9"},{"location":"14-exceptions/14.8-exception-dangers-and-downsides/#148","text":"By Alex on October 26 th , 2008 | last modified by nascardriver on July 2 nd , 2020 As with almost everything that has benefits, there are some potential downsides to exceptions as well. This article is not meant to be comprehensive, but just to point out some of the major issues that should be considered when using exceptions (or deciding whether to use them). Cleaning up resources One of the biggest problems that new programmers run into when using exceptions is the issue of cleaning up resources when an exception occurs. Consider the following example: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } What happens if WriteFile() fails and throws a FileException? At this point, we\u2019ve already opened the file, and now control flow jumps to the FileException handler, which prints an error and exits. Note that the file was never closed! This example should be rewritten as follows: try { openFile ( filename ); writeFile ( filename , data ); closeFile ( filename ); } catch ( const FileException & exception ) { // Make sure file is closed closeFile ( filename ); // Then write error std :: cerr << \"Failed to write to file: \" << exception . what () << '\\n' ; } This kind of error often crops up in another form when dealing with dynamically allocated memory: try { auto * john { new Person { \"John\" , 18 , PERSON_MALE } }; processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } If processPerson() throws an exception, control flow jumps to the catch handler. As a result, john is never deallocated! This example is a little more tricky than the previous one -- because john is local to the try block, it goes out of scope when the try block exits. That means the exception handler can not access john at all (its been destroyed already), so there\u2019s no way for it to deallocate the memory. However, there are two relatively easy ways to fix this. First, declare john outside of the try block so it does not go out of scope when the try block exits: Person * john { nullptr }; try { john = new Person ( \"John\" , 18 , PERSON_MALE ); processPerson ( john ); delete john ; } catch ( const PersonException & exception ) { delete john ; std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } Because john is declared outside the try block, it is accessible both within the try block and the catch handlers. This means the catch handler can do cleanup properly. The second way is to use a local variable of a class that knows how to cleanup itself when it goes out of scope (often called a \u201csmart pointer\u201d). The standard library provides a class called std::unique_ptr that can be used for this purpose. std::unique_ptr is a template class that holds a pointer, and deallocates it when it goes out of scope. #include <memory> // for std::unique_ptr try { auto * john { new Person ( \"John\" , 18 , PERSON_MALE ) }; std :: unique_ptr < Person > upJohn { john }; // upJohn now owns john ProcessPerson ( john ); // when upJohn goes out of scope, it will delete john } catch ( const PersonException & exception ) { std :: cerr << \"Failed to process person: \" << exception . what () << '\\n' ; } We\u2019ll talk more about smart pointers in the next chapter. Exceptions and destructors Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation did not succeed, exceptions should never be thrown in destructors. The problem occurs when an exception is thrown from a destructor during the stack unwinding process. If that happens, the compiler is put in a situation where it doesn\u2019t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately. Consequently, the best course of action is just to abstain from using exceptions in destructors altogether. Write a message to a log file instead. Performance concerns Exceptions do come with a small performance price to pay. They increase the size of your executable, and they may also cause it to run slower due to the additional checking that has to be performed. However, the main performance penalty for exceptions happens when an exception is actually thrown. In this case, the stack must be unwound and an appropriate exception handler found, which is a relatively expensive operation. As a note, some modern computer architectures support an exception model called zero-cost exceptions. Zero-cost exceptions, if supported, have no additional runtime cost in the non-error case (which is the case we most care about performance). However, they incur an even larger penalty in the case where an exception is found. So when should I use exceptions? Exception handling is best used when all of the following are true: The error being handled is likely to occur only infrequently. The error is serious and execution could not continue otherwise. The error cannot be handled at the place where it occurs. There isn\u2019t a good alternative way to return an error code back to the caller. As an example, let\u2019s consider the case where you\u2019ve written a function that expects the user to pass in the name of a file on disk. Your function will open this file, read some data, close the file, and pass back some result to the caller. Now, let\u2019s say the user passes in the name of a file that doesn\u2019t exist, or a null string. Is this a good candidate for an exception? In this case, the first two bullets above are trivially met -- this isn\u2019t something that\u2019s going to happen often, and your function can\u2019t calculate a result when it doesn\u2019t have any data to work with. The function can\u2019t handle the error either -- it\u2019s not the job of the function to re-prompt the user for a new filename, and that might not even be appropriate, depending on how your program is designed. The fourth bullet is the key -- is there a good alternative way to return an error code back to the caller? It depends on the details of your program. If so (e.g. you can return a null pointer, or a status code to indicate failure), that\u2019s probably the better choice. If not, then an exception would be reasonable.","title":"14.8 \u5f02\u5e38\u7684\u5371\u9669\u548c\u7f3a\u70b9"},{"location":"15-move-semantics-and-smart-pointers/","text":"15 \u79fb\u52a8\u8bed\u4e49\u548c\u667a\u80fd\u6307\u9488 \u00b6 15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49 15.2 \u53f3\u503c\u5f15\u7528 15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8bed\u4e49 15.4 std::move 15.5 std::unique_ptr 15.6 std::shared_ptr 15.7 std::weak_ptr 15.8 15.x-chapter15-comprehensive-review","title":"15 \u79fb\u52a8\u8bed\u4e49\u548c\u667a\u80fd\u6307\u9488"},{"location":"15-move-semantics-and-smart-pointers/#15","text":"15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49 15.2 \u53f3\u503c\u5f15\u7528 15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8bed\u4e49 15.4 std::move 15.5 std::unique_ptr 15.6 std::shared_ptr 15.7 std::weak_ptr 15.8 15.x-chapter15-comprehensive-review","title":"15 \u79fb\u52a8\u8bed\u4e49\u548c\u667a\u80fd\u6307\u9488"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/","text":"15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd \u00b6 By Alex on February 17 th , 2017 | last modified by nascardriver on April 25 th , 2020 \u7ffb\u8bd1by dashjay 2020.7.14 \u601d\u8003\u4e0b\u5217\u51fd\u6570\uff0c\u5728\u8fd9\u4e2a\u51fd\u6570\u4e2d\u6211\u4eec\u52a8\u6001\u5206\u914d\u4e86\u4e00\u4e2a\u503c void someFunction () { Resource * ptr = new Resource ; // Resource is a struct or class \u3010\u8d44\u6e90\u662f\u4e00\u4e2a\u7ed3\u6784\u6216\u8005\u7c7b\u3011 // do stuff with ptr here \u3010\u4f7f\u7528\u6307\u9488\u5728\u8fd9\u91cc\u505a\u4e00\u4e9b\u4e8b\u3011 delete ptr ; } \u7ecf\u7ba1\u4ee5\u4e0a\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u76f4\u63a5\u7b80\u5355\uff0c\u4f46\u662f\u4e5f\u76f8\u5f53\u5bb9\u6613\u5fd8\u8bb0\u53bb\u91ca\u653e\u6307\u9488\u3002\u5373\u4fbf\u4f60\u786e\u5b9e\u8bb0\u5f97\u5728\u51fd\u6570\u672b\u5c3e\u91ca\u653e\u6307\u9488\uff0c\u4e5f\u6709\u65e0\u6570\u79cd\u60c5\u51b5\u5bfc\u81f4\u6307\u9488\u6ca1\u6709\u88ab\u5220\u9664\uff0c\u5982\u679c\u51fd\u6570\u63d0\u524d\u9000\u51fa\u7684\u8bdd\u3002\u8fd9\u5f88\u53ef\u80fd\u53d1\u751f\u901a\u8fc7\u4e00\u4e2a early return : # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u6216\u8005\u901a\u8fc7\u4e00\u4e2a\u5f02\u5e38\u7684\u629b\u51fa # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u5728\u4ee5\u4e0a\u7684\u4e24\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u63d0\u524d\u9000\u51fa\u6216\u8005\u629b\u51fa\u8bed\u53e5\u6267\u884c\u90fd\u4f1a\u9020\u6210\u51fd\u6570\u7ec8\u6b62\uff0c\u5e76\u4e14\u672a\u91ca\u653e ptr \u6307\u9488\u3002\u56e0\u6b64\uff0c\u4e3a\u53d8\u91cf ptr \u5206\u914d\u7684\u5185\u5b58\u5c31\u4f1a\u91ca\u653e\uff08\u5e76\u4e14\u5c06\u6bcf\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u65f6\uff0c\u6cc4\u9732\u4e00\u6b21\uff0c\u5982\u679c\u63d0\u524d\u9000\u51fa\u7684\u8bdd\uff09\u3002 \u672c\u6307\u4e0a\uff0c\u8fd9\u4e9b\u79cd\u7c7b\u7684\u95ee\u9898\u4e4b\u6240\u4ee5\u4f1a\u53d1\u751f\uff0c\u662f\u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u6ca1\u6709\u56fa\u6709\u7684\u673a\u5236\u6765\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002 \u667a\u80fd\u6307\u9488\u80fd\u62ef\u6551\u4e00\u5207\u4e48 \u00b6 \u5199\u4ee3\u7801\u6700\u68d2\u7684\u4e8b\u5c31\u662f\u4f7f\u7528\u7684\u7c7b\u5305\u542b\u4e00\u4e2a\u89e3\u6784\u51fd\u6570\u4f1a\u81ea\u52a8\u6267\u884c\uff0c\u5f53\u8fd9\u4e2a\u7c7b\u5bf9\u8c61\u8131\u79bb\u4f5c\u7528\u57df\u540e\u3002\u56e0\u6b64\u5982\u679c\u4f60\u5206\u914d\uff08\u6216\u5f97\u5230\uff09\u5185\u5b58\u5728\u4f60\u7684\u6784\u9020\u51fd\u6570\u4e2d\uff0c\u4f60\u53ef\u4ee5\u91ca\u653e\u4ed6\u4eec\u5728\u4f60\u7684\u6790\u6784\u51fd\u6570\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5185\u5b58\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u8fd9\u4e2a\u5bf9\u8c61\u88ab\u9500\u6bc1\uff08\u53ef\u4ee5\u662f\u79bb\u5f00\u4f5c\u7528\u4e8e\u6216\u8005\u663e\u5f0f\u7684\u5220\u9664\uff0c\u7b49\u7b49\u2026\u2026\uff09\u3002\u8fd9\u662f RAII \u7f16\u7a0b\u7684\u6838\u5fc3\uff0c\u6211\u4eec\u5728 8.7 \u8bfe\u8ba8\u8bba\u8fc7\u7684 \u2014\u2014 \u7ed3\u6784\u51fd\u6570 \u3002 \u8fd9\u6837\u8bf4\u6765\uff0c\u6211\u4eec\u662f\u5426\u80fd\u7528\u4e00\u4e2a\u7c7b\u6765\u5e2e\u52a9\u6211\u4eec\u7ba1\u7406\u6216\u8005\u6e05\u7406\u6211\u4eec\u7684\u6307\u9488\uff1f\u5f53\u7136\u53ef\u4ee5\uff01 \u601d\u8003\u5982\u679c\u6709\u8fd9\u6837\u4e00\u4e2a\u7c7b\uff0c\u5b83\u6240\u6709\u7684\u5de5\u4f5c\u5c31\u662f\u6301\u6709\u548c\u201d\u62e5\u6709\u201c\u4e00\u4e2a\u4f20\u7ed9\u4ed6\u7684\u6307\u9488\uff0c\u5e76\u4e14\u5f53\u8be5\u7c7b\u7684\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5c31\u4f1a\u91ca\u653e\u90a3\u4e2a\u6301\u6709\u7684\u6307\u9488\u3002\u53ea\u8981\u90a3\u4e2a\u7c7b\u7684\u5bf9\u8c61\u4ec5\u4ec5\u88ab\u521b\u5efa\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\uff0c\u6211\u4eec\u53ef\u4ee5\u4fdd\u8bc1\u8be5\u7c7b\u5c06\u4f1a\u4ee5\u6070\u5f53\u7684\u65b9\u5f0f\uff08properly\uff09\u7684\u79bb\u5f00\u4f5c\u7528\u57df\uff08\u53ef\u4ee5\u89c6\u4e3a\u6211\u4eec\u7684\u51fd\u6570\u4f55\u65f6\u6216\u8005\u5982\u4f55\u7ec8\u6b62\uff09\uff0c\u7136\u540e\u6301\u6709\u8be5\u6307\u9488\u7684\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u662f\u8fd9\u4e2a\u60f3\u6cd5\u7684\u7b2c\u4e00\u4e2a\u8349\u7a3f # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res ( new Resource ); // Note the allocation of memory here // ... but no explicit delete needed // Also note that the Resource in angled braces doesn't need a * symbol, since that's supplied by the template return 0 ; } // res goes out of scope here, and destroys the allocated Resource for us \u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\uff1a Resource acquired Resource destroyed \u601d\u8003\u8fd9\u4e2a\u7a0b\u5e8f\u548c\u7c7b\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002\u9996\u5148\uff0c\u6211\u4eec\u52a8\u6001\u7684\u521b\u5efa\u4e00\u4e2a Resource \uff0c\u5e76\u4e14\u4f5c\u4e3a\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9\u6211\u4eec\u7684\u6a21\u677f\u7c7b Auto_ptr1 \u3002\u4ece\u90a3\u4e2a\u70b9\u5f00\u59cb\u5f80\u540e\u8d70\uff0c\u6211\u4eec\u7684 Auto_ptr \u53d8\u91cf res \u6301\u6709\u8fd9\u4e2a Resource \u5bf9\u8c61\uff08 Auto_ptr1 \u548c m_ptr \u6709\u7ec4\u6210\u7684\u5173\u7cfb\uff09\u3002\u56e0\u4e3a res \u88ab\u58f0\u660e\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6709\u4f5c\u7528\u57df\u3002\u5f53\u524d\u8bed\u53e5\u5757\u7ed3\u675f\u540e\uff0c\u5b83\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\uff08\u4e0d\u7528\u518d\u4f46\u56e0\u5fd8\u4e86\u91ca\u653e\u5b83\uff09\u3002\u5e76\u4e14\u56e0\u4e3a\u5b83\u662f\u4e00\u4e2a\u7c7b\uff0c\u5f53\u5b83\u88ab\u9500\u6bc1\u65f6\uff0c Auto_ptr1 \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u3002\uff08Auto_ptr1\uff09\u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u786e\u4fdd\u5b83\u6301\u6709\u7684 Resource \u6307\u9488\u88ab\u5220\u9664\uff01 \u53ea\u8981 Auto_ptr1 \u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff08\u81ea\u52a8\u7684\u751f\u547d\u5468\u671f\uff0c\u56e0\u6b64 Auto \u624d\u4f5c\u4e3a\u7c7b\u540d\u7684\u4e00\u90e8\u5206\uff09\uff0c Resouce \u5c06\u5728\u88ab\u5b9a\u4e49\u7684\u8bed\u53e5\u672b\u5c3e\u4f1a\u88ab\u5220\u9664\u8fd9\u4ef6\u4e8b\u5f97\u5230\u4e86\u4fdd\u8bc1\uff0c\u4e0d\u7ba1\u51fd\u6570\u4f55\u65f6\u7ed3\u675f\uff08\u5373\u4fbf\u5b83\u63d0\u524d\u7ed3\u675f\uff09\u3002 \u8fd9\u6837\u7684\u7c7b\u88ab\u53eb\u505a\u667a\u80fd\u6307\u9488(Smart Pointer)\u3002\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u662f\u4e00\u4e2a\u590d\u5408\u7c7b\uff08composition class\uff09\uff0c\u4e13\u95e8\u88ab\u8bbe\u8ba1\u51fa\u6765\u7ba1\u7406\u7684\u52a8\u6001\u5185\u5b58\u7684\u5206\u914d\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5f53\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5185\u5b58\u88ab\u91ca\u653e\u3002\uff08\u4e8e\u6b64\u76f8\u5173\u7684\uff0c\u5185\u7f6e\u7684\u6307\u9488\u6709\u65f6\u5019\u4f1a\u88ab\u53eb\u505a\u201d\u7b28\u6307\u9488(dumb pointers)\u201c\uff0c\u56e0\u4e3a\u4ed6\u4eec\u4e0d\u80fd\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002\uff09 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u56de\u5230\u6211\u4eec\u4e0a\u65b9\u7684\u7684 someFunction() \u4f8b\u5b50\uff0c\u5e76\u4e14\u5c55\u793a\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5982\u4f55\u6211\u4eec\u9047\u5230\u7684\u56f0\u96be\uff1a # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor // \u901a\u8fc7\u6784\u9020\u51fd\u6570\u4f20\u5165\u4e00\u4e2a\u6307\u9488\u8ba9\u5b83\u201c\u6240\u6709\u201c Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated // \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u4fdd\u8bc1\u5b83\u88ab\u9500\u6bc1 ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. // \u91cd\u8f7d\u5f15\u7528\u548c -> \u64cd\u4f5c\u7b26\uff0c\u4ee5\u4fbf\u4e8e\u6211\u4eec\u53ef\u4ee5\u50cf m_ptr \u90a3\u6837\u4f7f\u7528 Auto_ptr1 T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works // \u4e00\u4e2a\u7b80\u5355\u7684\u7c7b\u6765\u8bc1\u660e\u4e0a\u9762\u7684\u4ee3\u7801\u5de5\u4f5c class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } void sayHi () { std :: cout << \"Hi! \\n \" ; } }; void someFunction () { Auto_ptr1 < Resource > ptr ( new Resource ); // ptr now owns the Resource // \u6307\u9488\u73b0\u5728\u62e5\u6709\u4e86 Resource int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early // \u51fd\u6570\u63d0\u524d\u8fd4\u56de // do stuff with ptr here // \u4f7f\u7528\u6307\u9488 ptr -> sayHi (); } int main () { someFunction (); return 0 ; } \u5982\u679c\u7528\u6237\u4f20\u5165\u4e86\u4e00\u4e2a\u975e\u96f6\u6574\u6570\uff0c\u4e0a\u9762\u7684\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370\uff1a Resource acquired Hi! Resource destroyed \u5982\u679c\u7528\u6237\u8f93\u51650\uff0c\u4e0a\u9762\u7684\u7684\u7a0b\u5e8f\u5c06\u4f1a\u63d0\u524d\u7ec8\u6b62\uff0c\u9000\u51fa\uff0c\u5e76\u4e14\u6253\u5370\uff1a Resource acquired Resource destroyed \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5373\u4fbf\u7528\u6237\u8f93\u51650\u5bfc\u81f4\u7a0b\u5e8f\u63d0\u524d\u9000\u51fa\uff0c Resource \u4e5f\u4f1a\u5f97\u5230\u5408\u7406\u7684\u91ca\u653e\u3002 \u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6307\u9488\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u51fd\u6570\u7ec8\u6b62\uff08\u4e0d\u7ba1\u5b83\u5982\u4f55\u505c\u6b62\uff09\u3002\u5e76\u4e14\u56e0\u4e3a Auto_ptr1 \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u6e05\u7406 Resouce \uff0c\u6211\u4eec\u4fdd\u8bc1 Rresouce \u5c06\u4f1a\u88ab\u5408\u7406\u7684\u6e05\u7406\u3002 \u4e00\u4e2a\u5f88\u5173\u952e\u7684\u7f3a\u9677 \u00b6 Auto_ptr1 \u7c7b\u6709\u4e00\u4e2a\u81f4\u547d\u7684\u7f3a\u9677\u9690\u85cf\u5728\u4e00\u4e9b \u81ea\u52a8\u751f\u6210 \u7684\u4ee3\u7801\u91cc\u3002\u5728\u8fdb\u4e00\u6b65\u9605\u8bfb\u4e4b\u524d\uff0c\u770b\u770b\u4f60\u662f\u5426\u80fd\u627e\u5230\u7b54\u6848\uff0c\u5feb\u60f3\u60f3\u5427\u2026\u2026 \uff08\u63d0\u793a\uff1a\u601d\u8003\u7c7b\u4e2d\u7684\u54ea\u4e2a\u90e8\u5206\u4f1a\u88ab\u81ea\u52a8\u751f\u6210\uff0c\u5982\u679c\u4f60\u4e0d\u63d0\u4f9b\uff09 \uff08\u7d27\u5f20\u7684\u97f3\u4e50\uff09 Okay, time\u2019s up. \u597d\u4e86\uff0c\u65f6\u95f4\u5230\u4e86\u3002 \u76f8\u6bd4\u8bb2\u7ed9\u4f60\u542c\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5411\u4f60\u5c55\u793a\uff0c\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a # include <iostream> // Same as above template < class T > class Auto_ptr1 { T * m_ptr ; public : Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr1 () { delete m_ptr ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res1 ( new Resource ); Auto_ptr1 < Resource > res2 ( res1 ); // Alternatively, don't initialize res2 and then assign res2 = res1; return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370 Resource acquired Resource destroyed Resource destroyed \u53ef\u80fd\uff08\u4f46\u4e0d\u662f\u4e00\u5b9a\uff09\u4f60\u7684\u7a0b\u5e8f\u5c06\u4f1a\u5728\u8fd9\u65f6\u9000\u51fa\u3002\u770b\u5230\u95ee\u9898\u4e86\u4e48\uff1f\u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0cC++ \u7ed9\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u3002\u5e76\u4e14\u8be5\u51fd\u6570\u8fdb\u884c\u4e86\u6d45\u62f7\u8d1d\uff0c\u56e0\u6b64\u5f53\u6211\u4eec\u7528 res1 \u521d\u59cb\u5316 res2 \u65f6\uff0c \u4e24\u4e2a Auto_ptr1 \u53d8\u91cf\u901a\u77e5\u6307\u5411\u4e86\u540c\u6837\u7684 Resource \u3002\u5f53 res2 \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u4ed6\u5c31\u4f1a\u5220\u9664 resouce \uff0c\u8ba9 res1 \u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\uff0c\u5f53 res1 \u5220\u9664\u4ed6\u7684\uff08\u65e9\u5c31\u88ab\u5220\u9664\uff09\u7684 Resouce \u65f6\uff0c\u7a0b\u5e8f\u5d29\u6e83\uff01 \u4f60\u5b9e\u73b0\u53e6\u4e00\u4e2a\u7b80\u5355\u7684\u95ee\u9898\uff0c\u5f53\u50cf\u8fd9\u6837\u8c03\u7528\u51fd\u6570\u65f6\uff1a void passByValue ( Auto_ptr1 < Resource > res ) { } int main () { Auto_ptr1 < Resource > res1 ( new Resource ); passByValue ( res1 ) return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c res1 \u5c06\u4f1a\u88ab\u503c\u62f7\u8d1d\u8fdb passByValue() \u7684\u53c2\u6570 res \uff0c\u5bfc\u81f4\u590d\u5236\u4e86\u4e00\u4efd Resouce \u6307\u9488\uff0c\u6700\u540e\u56e0\u4e3a\u540c\u6837\u7684\u95ee\u9898\u5d29\u6e83\u3002 \u597d\u7684\uff0c\u6211\u4eec\u6e05\u695a\u8fd9\u4e2a\u95ee\u9898\u4e86\u3002\u6211\u4eec\u5982\u4f55\u89e3\u51b3\u5b83\uff1f \u80fd\u591f\u89e3\u51b3\u7684\u65b9\u6cd5\u4e4b\u4e00\u5c31\u662f\u663e\u5f0f\u7684\u5b9a\u4e49\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0c\u4ece\u800c\u963b\u6b62\u4e86\u4efb\u4f55\u62f7\u8d1d\u4ece\u539f\u59cb\u5bf9\u8c61\u590d\u5236\u51fa\u6765\uff0c\u90a3\u4f1a\u963b\u6b62\u503c\u4f20\u503c\uff08\u90a3\u65f6\u5f88\u68d2\u7684\uff0c\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u4e0d\u5e94\u8be5\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\u4f7f\u7528\u503c\u4f20\u503c\uff09\u3002 \u4f46\u662f\u7d27\u63a5\u7740\u8fd4\u56de\u4e00\u4e2a Auto_ptr1 \u4ece\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f ??? generateResource () { Resource * r = new Resource ; return Auto_ptr1 ( r ); } \u6211\u4eec\u4e0d\u80fd\u901a\u8fc7\u5f15\u7528\u8fd4\u56de Auto_ptr1 \uff0c\u56e0\u4e3a\u5c40\u90e8\u53d8\u91cf Auto_ptr1 \u5c06\u4f1a\u5728\u51fd\u6570\u7684\u672b\u5c3e\u88ab\u5220\u9664\uff0c\u5e76\u4e14\u8c03\u7528\u8005\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u60ac\u7a7a\u7684\u5f15\u7528\u3002\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6709\u540c\u6837\u7684\u95ee\u9898\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6307\u9488 r \uff0c\u4f46\u662f\u6211\u4eec\u4e5f\u8bb8\u4f1a\u5fd8\u4e86\u4e4b\u540e\u5220\u9664 r \uff0c\u8fd9\u4e5f\u662f\u6211\u4eec\u4e4b\u6240\u4ee5\u4f7f\u7528\u667a\u80fd\u6307\u9488\u7684\u539f\u56e0\u3002\u56e0\u6b64\u90a3\u6beb\u65e0\u7591\u95ee\uff0c\u901a\u8fc7\u503c\u8fd4\u56de Auto_ptr1 \u662f\u552f\u4e00\u6709\u610f\u4e49\u7684\u9009\u9879 \u2014\u2014 \u4f46\u662f\u7d27\u63a5\u7740\u6211\u4eec\u5c31\u4f1a\u4ee5\u6d45\u62f7\u8d1d\uff0c\u590d\u5236\u6307\u9488\uff0c\u6700\u540e\u5d29\u6e83\u3002 \u53e6\u4e00\u4e2a\u9009\u9879\u5c31\u662f\u91cd\u5199\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u4fdd\u8bc1\u6df1\u62f7\u8d1d\u3002\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u6211\u4eec\u81f3\u5c11\u80fd\u4fdd\u8bc1\u907f\u514d\u590d\u5236\u6307\u5411\u5171\u4e00\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\u3002\u4f46\u662f\u6df1\u62f7\u8d1d\u662f\u6602\u8d35\u7684\uff08\u5e76\u4e14\u4e5f\u8bb8\u662f\u4e0d\u53ef\u53d6\u7684\u6216\u8005\u751a\u81f3\u662f\u4e0d\u53ef\u80fd\u7684\uff09\uff0c\u5e76\u4e14\u6211\u4eec\u4e0d\u60f3\u4e3a\u4e86\u4ece\u51fd\u6570\u4e2d\u8fd4\u56de Auto-ptr1 \u4ece\u800c\u5bf9\u5bf9\u8c61\u8fdb\u884c\u4e0d\u5fc5\u8981\u7684\u590d\u5236\u3002\u53e6\u5916\uff0c\u5206\u914d\u6216\u521d\u59cb\u5316\u4e00\u4e2a\u7b28\u6307\u9488\u5e76\u4e0d\u4f1a\u590d\u5236\u6240\u6307\u5411\u7684\u5bf9\u8c61\uff0c\u90a3\u4e48\u4e3a\u4ec0\u4e48\u6211\u4eec\u5e0c\u671b\u667a\u80fd\u6307\u9488\u7684\u884c\u4e3a\u6709\u6240\u4e0d\u540c\u5462\uff1f \u6211\u4eec\u8be5\u600e\u4e48\u529e\uff1f \u79fb\u52a8\u8bed\u4e49 \u00b6 \u5982\u679c\u4e0d\u662f\u8ba9\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u590d\u5236\u6307\u9488\uff08\u201c\u590d\u5236\u8bed\u4e49\u201d\uff09\uff0c\u800c\u662f\u5c06\u6307\u9488\u7684\u6240\u6709\u6743\u4ece\u6e90\u5bf9\u8c61\u8f6c\u79fb/\u79fb\u52a8\u5230\u76ee\u6807\u5bf9\u8c61\u5462\uff1f\u8fd9\u662fmove\u8bed\u4e49\u80cc\u540e\u7684\u6838\u5fc3\u601d\u60f3\u3002\u79fb\u52a8\u8bed\u4e49\u610f\u5473\u7740\u7c7b\u5c06\u8f6c\u79fb\u5bf9\u8c61\u7684\u6240\u6709\u6743\uff0c\u800c\u4e0d\u662f\u8fdb\u884c\u590d\u5236\u3002 \u8ba9\u6211\u4eec\u4f60\u66f4\u65b0\u6211\u4eec\u7684 Auto_ptr1 \u7c7b\u6765\u5c55\u793a\u8fd9\u5982\u4f55\u5b8c\u6210\uff1a # include <iostream> template < class T > class Auto_ptr2 { T * m_ptr ; public : Auto_ptr2 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr2 () { delete m_ptr ; } // A copy constructor that implements move semantics Auto_ptr2 ( Auto_ptr2 & a ) // note: not const { m_ptr = a . m_ptr ; // transfer our dumb pointer from the source to our local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer } // An assignment operator that implements move semantics Auto_ptr2 & operator = ( Auto_ptr2 & a ) // note: not const { if ( & a == this ) return * this ; delete m_ptr ; // make sure we deallocate any pointer the destination is already holding first m_ptr = a . m_ptr ; // then transfer our dumb pointer from the source to the local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr2 < Resource > res1 ( new Resource ); Auto_ptr2 < Resource > res2 ; // Start as nullptr std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); res2 = res1 ; // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); return 0 ; } \u8fd9\u4e2a\u6253\u5370\u51fa\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u6ce8\u610f\u6211\u4eec\u91cd\u8f7d\u4e86 operator= \u5c06 m_ptr \u7684\u6240\u6709\u6743\u4ece res1 \u9012\u4ea4\u7ed9 res2 \uff01\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u590d\u5236\u6307\u9488\u7684\u62f7\u8d1d\uff0c\u5e76\u4e14\u6240\u6709\u4e8b\u90fd\u88ab\u6574\u9f50\u7684\u6e05\u7406\u5e72\u51c0\u3002 std::auto_ptr \u548c\u4e3a\u4f55\u907f\u514d\u4f7f\u7528 \u00b6 \u73b0\u5728\u662f\u5408\u9002\u7684\u5b9e\u673a\u6765\u8bb2 std::auto_ptr \u4e86\uff0c std::auto_ptr \uff0c\u5728 C++98 \u4e2d\u5f15\u8fdb\uff0c\u662f C++ \u7684\u7b2c\u4e00\u6b21\u5c1d\u8bd5\u5b9e\u73b0\u4e00\u4e2a\u6807\u51c6\u7684\u53ea\u80fd\u6307\u9488\u3002 std::auto_ptr \u9009\u62e9\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u5c31\u50cf Auto_ptr2 \u7c7b\u505a\u7684\u90a3\u6837\u3002 \u7136\u800c\uff0c std::auto_ptr \uff08\u548c\u6211\u4eec\u7684 Auto_ptr2 \u7c7b\u4e00\u6837\uff09\u6709\u4e00\u5927\u5806\u95ee\u9898\uff0c\u4f7f\u5f97\u7528\u8d77\u6765\u975e\u5e38\u7684\u5371\u9669\u3002 \u9996\u5148\uff1a \u7531\u4e8e std::auto_ptr \u901a\u8fc7copy\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49(move semantics)\uff0c\u56e0\u6b64\u6309\u503c\u5411\u51fd\u6570\u4f20\u9012 std::auto_ptr \u5c06\u5bfc\u81f4\u8d44\u6e90\u79fb\u52a8\u5230\u51fd\u6570\u53c2\u6570\uff08\u5f53\u51fd\u6570\u53c2\u6570\u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u53c2\u6570\u5728\u51fd\u6570\u672b\u5c3e\u9500\u6bc1\uff09\u3002\u7136\u540e\u5f53\u4f60\u4ece\u8c03\u7528\u8005\u90a3\u91cc\u8bbf\u95ee\u4f60\u7684 auto_ptr \u53c2\u6570\u65f6\uff08\u6ca1\u6709\u610f\u8bc6\u5230\u5b83\u5df2\u7ecf\u88ab\u8f6c\u79fb\u548c\u5220\u9664\uff09\uff0c\u4f60\u7a81\u7136\u5bf9\u7a7a\u6307\u9488\u7684\u53d6\u503c\u3002\u5bfc\u81f4\u5d29\u6e83 \u7b2c\u4e8c\uff1a std::auto_ptr \u603b\u662f\u7528\u975e\u6570\u7ec4\u5220\u9664\u5b83\u7684\u5185\u5bb9\u3002\u8fd9\u610f\u5473\u8fd9 auto_ptr \u5728\u52a8\u6001\u5206\u914d\u6570\u7ec4\u5185\u5b58\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0d\u80fd\u6b63\u786e\u7684\u5de5\u4f5c\uff0c\u56e0\u4e3a\u5b83\u4f7f\u7528\u4e86\u9519\u8bef\u7684\u91ca\u653e\u7b26\u53f7\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u5b83\u4e0d\u5141\u8bb8\u4f60\u4f20\u4e00\u4e2a\u52a8\u6001\u7684\u6570\u7ec4\uff0c\u56e0\u4e3a\u8fd9\u6837\u505a\u5b83\u5c31\u4f1a\u5931\u53bb\u7ba1\u7406\uff0c\u5bfc\u81f4\u5185\u5b58\u6cc4\u9732\u3002 \u6700\u540e\uff1a std::auto_ptr \u4e0d\u80fd\u548c\u5176\u4ed6\u6807\u51c6\u5e93\u4e2d\u7684\u7c7b\u642d\u914d\u4f7f\u7528\uff0c\u5305\u62ec\u5927\u91cf\u7684\u5bb9\u5668\u548c\u7b97\u6cd5\u3002\u8fd9\u4f1a\u53d1\u751f\u5c31\u662f\u56e0\u4e3a\u90a3\u4e9b\u6807\u51c6\u5e93\u5047\u8bbe\u5f53\u4ed6\u4eec\u62f7\u8d1d\u4e00\u4e2a\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5b9e\u9645\u4e0a\u662f\u62f7\u8d1d\u800c\u4e0d\u662f\u79fb\u52a8\u3002 \u56e0\u4e3a\u4ee5\u4e0a\u63d0\u5230\u7684\u7f3a\u70b9\uff0c std::auto_ptr \u5728 C++11 \u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\u4e8b\u5b9e\u4e0a std::auto_ptr \u5728 C++17 \u4e2d\u624d\u88ab\u4ece\u6807\u51c6\u5e93\u4e2d\u5b8c\u5168\u79fb\u9664\u3002 Rule: std::auto_ptr is deprecated and should not be used. (Use std::unique_ptr or std::shared_ptr instead).. \u89c4\u5219\uff1a std::auto_ptr \u662f\u88ab\u629b\u5f03\u7684\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\uff08\u4f7f\u7528 std::unique_ptr or std::shared_ptr \u66ff\u6362\u4ed6\uff09\u2026\u2026 \u5411\u524d\u770b \u00b6 \u5728 C++11 \u4e4b\u524d std::auto_ptr \u7684\u6838\u5fc3\u8bbe\u8ba1\u95ee\u9898\uff0c\u662f C++ \u8bed\u8a00\u6ca1\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u673a\u5236\u6765\u5206\u8fa8\u62f7\u8d1d\u8bed\u4e49\u548c\u79fb\u52a8\u8bed\u4e49\u3002\u91cd\u5199\u62f7\u8d1d\u8bed\u4e49\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u65e0\u610f\u4e2d\u5f15\u8d77\u4e86\u95ee\u9898\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u5199 res1 = res2 \u5e76\u4e14\u6ca1\u529e\u6cd5\u77e5\u9053 res2 \u662f\u5426\u4f1a\u88ab\u6539\u53d8\uff01 \u56e0\u4e3a\u8fd9\u4e2a\uff0c\u5728 C++11\u4e2d\uff0c\u201d\u79fb\u52a8\u201d\u8fd9\u4e2a\u6982\u5ff5\u88ab\u6b63\u5f0f\u7684\u5b9a\u4e49\uff0c\u5e76\u4e14\u201d\u79fb\u52a8\u8bed\u4e49\u201c\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\u6765\u5408\u9002\u7684\u5206\u8fa8\u62f7\u8d1d(copying)\u548c\u79fb\u52a8(moving)\u3002\u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u4e3a\"\u4e3a\u4f55\u79fb\u52a8\u8bed\u4e49\u662f\u6709\u7528\u7684\"\u505a\u597d\u4e86\u51c6\u5907\uff0c\u6211\u4eec\u5c06\u5728\u672c\u7ae0\u7684\u5176\u4f59\u90e8\u5206\u4e2d\u63a2\u8ba8\"\u79fb\u52a8\u8bed\u4e49\"\u7684\u4e3b\u9898\u3002\u6211\u4eec\u8fd8\u5c06\u4f7f\u7528move\u8bed\u4e49\u4fee\u590dAuto ptr2\u7c7b\u3002 \u5728 C++11\u4e2d\uff0c std::auto_ptr \u5df2\u7ecf\u88ab\u4e00\u5806\u5176\u4ed6\u7c7b\u578b\u7684\u201cmove-aware\u201d\u53ea\u80fd\u6307\u6b63\u6240\u66ff\u6362\uff1a std::unique_ptr \uff0c std::weak_ptr \uff0c\u548c std::shared_ptr \u3002\u6211\u4eec\u5c06\u4e5f\u63a2\u7d22\u8fd9\u4e9b\u4e2d\u6700\u8457\u540d\u7684\u4e24\u4e2a\uff1a unique_ptr (\u76f4\u63a5\u7528\u6765\u66ff\u6362 std::auto_ptr \u7684) \u548c shared_ptr .","title":"15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#151","text":"By Alex on February 17 th , 2017 | last modified by nascardriver on April 25 th , 2020 \u7ffb\u8bd1by dashjay 2020.7.14 \u601d\u8003\u4e0b\u5217\u51fd\u6570\uff0c\u5728\u8fd9\u4e2a\u51fd\u6570\u4e2d\u6211\u4eec\u52a8\u6001\u5206\u914d\u4e86\u4e00\u4e2a\u503c void someFunction () { Resource * ptr = new Resource ; // Resource is a struct or class \u3010\u8d44\u6e90\u662f\u4e00\u4e2a\u7ed3\u6784\u6216\u8005\u7c7b\u3011 // do stuff with ptr here \u3010\u4f7f\u7528\u6307\u9488\u5728\u8fd9\u91cc\u505a\u4e00\u4e9b\u4e8b\u3011 delete ptr ; } \u7ecf\u7ba1\u4ee5\u4e0a\u4ee3\u7801\u770b\u8d77\u6765\u5f88\u76f4\u63a5\u7b80\u5355\uff0c\u4f46\u662f\u4e5f\u76f8\u5f53\u5bb9\u6613\u5fd8\u8bb0\u53bb\u91ca\u653e\u6307\u9488\u3002\u5373\u4fbf\u4f60\u786e\u5b9e\u8bb0\u5f97\u5728\u51fd\u6570\u672b\u5c3e\u91ca\u653e\u6307\u9488\uff0c\u4e5f\u6709\u65e0\u6570\u79cd\u60c5\u51b5\u5bfc\u81f4\u6307\u9488\u6ca1\u6709\u88ab\u5220\u9664\uff0c\u5982\u679c\u51fd\u6570\u63d0\u524d\u9000\u51fa\u7684\u8bdd\u3002\u8fd9\u5f88\u53ef\u80fd\u53d1\u751f\u901a\u8fc7\u4e00\u4e2a early return : # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u6216\u8005\u901a\u8fc7\u4e00\u4e2a\u5f02\u5e38\u7684\u629b\u51fa # include <iostream> void someFunction () { Resource * ptr = new Resource ; int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u5728\u4ee5\u4e0a\u7684\u4e24\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u63d0\u524d\u9000\u51fa\u6216\u8005\u629b\u51fa\u8bed\u53e5\u6267\u884c\u90fd\u4f1a\u9020\u6210\u51fd\u6570\u7ec8\u6b62\uff0c\u5e76\u4e14\u672a\u91ca\u653e ptr \u6307\u9488\u3002\u56e0\u6b64\uff0c\u4e3a\u53d8\u91cf ptr \u5206\u914d\u7684\u5185\u5b58\u5c31\u4f1a\u91ca\u653e\uff08\u5e76\u4e14\u5c06\u6bcf\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u65f6\uff0c\u6cc4\u9732\u4e00\u6b21\uff0c\u5982\u679c\u63d0\u524d\u9000\u51fa\u7684\u8bdd\uff09\u3002 \u672c\u6307\u4e0a\uff0c\u8fd9\u4e9b\u79cd\u7c7b\u7684\u95ee\u9898\u4e4b\u6240\u4ee5\u4f1a\u53d1\u751f\uff0c\u662f\u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u6ca1\u6709\u56fa\u6709\u7684\u673a\u5236\u6765\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002","title":"15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_1","text":"\u5199\u4ee3\u7801\u6700\u68d2\u7684\u4e8b\u5c31\u662f\u4f7f\u7528\u7684\u7c7b\u5305\u542b\u4e00\u4e2a\u89e3\u6784\u51fd\u6570\u4f1a\u81ea\u52a8\u6267\u884c\uff0c\u5f53\u8fd9\u4e2a\u7c7b\u5bf9\u8c61\u8131\u79bb\u4f5c\u7528\u57df\u540e\u3002\u56e0\u6b64\u5982\u679c\u4f60\u5206\u914d\uff08\u6216\u5f97\u5230\uff09\u5185\u5b58\u5728\u4f60\u7684\u6784\u9020\u51fd\u6570\u4e2d\uff0c\u4f60\u53ef\u4ee5\u91ca\u653e\u4ed6\u4eec\u5728\u4f60\u7684\u6790\u6784\u51fd\u6570\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5185\u5b58\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u8fd9\u4e2a\u5bf9\u8c61\u88ab\u9500\u6bc1\uff08\u53ef\u4ee5\u662f\u79bb\u5f00\u4f5c\u7528\u4e8e\u6216\u8005\u663e\u5f0f\u7684\u5220\u9664\uff0c\u7b49\u7b49\u2026\u2026\uff09\u3002\u8fd9\u662f RAII \u7f16\u7a0b\u7684\u6838\u5fc3\uff0c\u6211\u4eec\u5728 8.7 \u8bfe\u8ba8\u8bba\u8fc7\u7684 \u2014\u2014 \u7ed3\u6784\u51fd\u6570 \u3002 \u8fd9\u6837\u8bf4\u6765\uff0c\u6211\u4eec\u662f\u5426\u80fd\u7528\u4e00\u4e2a\u7c7b\u6765\u5e2e\u52a9\u6211\u4eec\u7ba1\u7406\u6216\u8005\u6e05\u7406\u6211\u4eec\u7684\u6307\u9488\uff1f\u5f53\u7136\u53ef\u4ee5\uff01 \u601d\u8003\u5982\u679c\u6709\u8fd9\u6837\u4e00\u4e2a\u7c7b\uff0c\u5b83\u6240\u6709\u7684\u5de5\u4f5c\u5c31\u662f\u6301\u6709\u548c\u201d\u62e5\u6709\u201c\u4e00\u4e2a\u4f20\u7ed9\u4ed6\u7684\u6307\u9488\uff0c\u5e76\u4e14\u5f53\u8be5\u7c7b\u7684\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5c31\u4f1a\u91ca\u653e\u90a3\u4e2a\u6301\u6709\u7684\u6307\u9488\u3002\u53ea\u8981\u90a3\u4e2a\u7c7b\u7684\u5bf9\u8c61\u4ec5\u4ec5\u88ab\u521b\u5efa\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\uff0c\u6211\u4eec\u53ef\u4ee5\u4fdd\u8bc1\u8be5\u7c7b\u5c06\u4f1a\u4ee5\u6070\u5f53\u7684\u65b9\u5f0f\uff08properly\uff09\u7684\u79bb\u5f00\u4f5c\u7528\u57df\uff08\u53ef\u4ee5\u89c6\u4e3a\u6211\u4eec\u7684\u51fd\u6570\u4f55\u65f6\u6216\u8005\u5982\u4f55\u7ec8\u6b62\uff09\uff0c\u7136\u540e\u6301\u6709\u8be5\u6307\u9488\u7684\u5bf9\u8c61\u5c06\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u662f\u8fd9\u4e2a\u60f3\u6cd5\u7684\u7b2c\u4e00\u4e2a\u8349\u7a3f # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res ( new Resource ); // Note the allocation of memory here // ... but no explicit delete needed // Also note that the Resource in angled braces doesn't need a * symbol, since that's supplied by the template return 0 ; } // res goes out of scope here, and destroys the allocated Resource for us \u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\uff1a Resource acquired Resource destroyed \u601d\u8003\u8fd9\u4e2a\u7a0b\u5e8f\u548c\u7c7b\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002\u9996\u5148\uff0c\u6211\u4eec\u52a8\u6001\u7684\u521b\u5efa\u4e00\u4e2a Resource \uff0c\u5e76\u4e14\u4f5c\u4e3a\u4e00\u4e2a\u53c2\u6570\u4f20\u7ed9\u6211\u4eec\u7684\u6a21\u677f\u7c7b Auto_ptr1 \u3002\u4ece\u90a3\u4e2a\u70b9\u5f00\u59cb\u5f80\u540e\u8d70\uff0c\u6211\u4eec\u7684 Auto_ptr \u53d8\u91cf res \u6301\u6709\u8fd9\u4e2a Resource \u5bf9\u8c61\uff08 Auto_ptr1 \u548c m_ptr \u6709\u7ec4\u6210\u7684\u5173\u7cfb\uff09\u3002\u56e0\u4e3a res \u88ab\u58f0\u660e\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6709\u4f5c\u7528\u57df\u3002\u5f53\u524d\u8bed\u53e5\u5757\u7ed3\u675f\u540e\uff0c\u5b83\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\uff08\u4e0d\u7528\u518d\u4f46\u56e0\u5fd8\u4e86\u91ca\u653e\u5b83\uff09\u3002\u5e76\u4e14\u56e0\u4e3a\u5b83\u662f\u4e00\u4e2a\u7c7b\uff0c\u5f53\u5b83\u88ab\u9500\u6bc1\u65f6\uff0c Auto_ptr1 \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u3002\uff08Auto_ptr1\uff09\u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u786e\u4fdd\u5b83\u6301\u6709\u7684 Resource \u6307\u9488\u88ab\u5220\u9664\uff01 \u53ea\u8981 Auto_ptr1 \u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff08\u81ea\u52a8\u7684\u751f\u547d\u5468\u671f\uff0c\u56e0\u6b64 Auto \u624d\u4f5c\u4e3a\u7c7b\u540d\u7684\u4e00\u90e8\u5206\uff09\uff0c Resouce \u5c06\u5728\u88ab\u5b9a\u4e49\u7684\u8bed\u53e5\u672b\u5c3e\u4f1a\u88ab\u5220\u9664\u8fd9\u4ef6\u4e8b\u5f97\u5230\u4e86\u4fdd\u8bc1\uff0c\u4e0d\u7ba1\u51fd\u6570\u4f55\u65f6\u7ed3\u675f\uff08\u5373\u4fbf\u5b83\u63d0\u524d\u7ed3\u675f\uff09\u3002 \u8fd9\u6837\u7684\u7c7b\u88ab\u53eb\u505a\u667a\u80fd\u6307\u9488(Smart Pointer)\u3002\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u662f\u4e00\u4e2a\u590d\u5408\u7c7b\uff08composition class\uff09\uff0c\u4e13\u95e8\u88ab\u8bbe\u8ba1\u51fa\u6765\u7ba1\u7406\u7684\u52a8\u6001\u5185\u5b58\u7684\u5206\u914d\uff0c\u5e76\u4e14\u4fdd\u8bc1\u5f53\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u540e\u5185\u5b58\u88ab\u91ca\u653e\u3002\uff08\u4e8e\u6b64\u76f8\u5173\u7684\uff0c\u5185\u7f6e\u7684\u6307\u9488\u6709\u65f6\u5019\u4f1a\u88ab\u53eb\u505a\u201d\u7b28\u6307\u9488(dumb pointers)\u201c\uff0c\u56e0\u4e3a\u4ed6\u4eec\u4e0d\u80fd\u6e05\u7406\u4ed6\u4eec\u81ea\u5df1\u3002\uff09 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u56de\u5230\u6211\u4eec\u4e0a\u65b9\u7684\u7684 someFunction() \u4f8b\u5b50\uff0c\u5e76\u4e14\u5c55\u793a\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5982\u4f55\u6211\u4eec\u9047\u5230\u7684\u56f0\u96be\uff1a # include <iostream> template < class T > class Auto_ptr1 { T * m_ptr ; public : // Pass in a pointer to \"own\" via the constructor // \u901a\u8fc7\u6784\u9020\u51fd\u6570\u4f20\u5165\u4e00\u4e2a\u6307\u9488\u8ba9\u5b83\u201c\u6240\u6709\u201c Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } // The destructor will make sure it gets deallocated // \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u4fdd\u8bc1\u5b83\u88ab\u9500\u6bc1 ~ Auto_ptr1 () { delete m_ptr ; } // Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr. // \u91cd\u8f7d\u5f15\u7528\u548c -> \u64cd\u4f5c\u7b26\uff0c\u4ee5\u4fbf\u4e8e\u6211\u4eec\u53ef\u4ee5\u50cf m_ptr \u90a3\u6837\u4f7f\u7528 Auto_ptr1 T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; // A sample class to prove the above works // \u4e00\u4e2a\u7b80\u5355\u7684\u7c7b\u6765\u8bc1\u660e\u4e0a\u9762\u7684\u4ee3\u7801\u5de5\u4f5c class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } void sayHi () { std :: cout << \"Hi! \\n \" ; } }; void someFunction () { Auto_ptr1 < Resource > ptr ( new Resource ); // ptr now owns the Resource // \u6307\u9488\u73b0\u5728\u62e5\u6709\u4e86 Resource int x ; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) return ; // the function returns early // \u51fd\u6570\u63d0\u524d\u8fd4\u56de // do stuff with ptr here // \u4f7f\u7528\u6307\u9488 ptr -> sayHi (); } int main () { someFunction (); return 0 ; } \u5982\u679c\u7528\u6237\u4f20\u5165\u4e86\u4e00\u4e2a\u975e\u96f6\u6574\u6570\uff0c\u4e0a\u9762\u7684\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370\uff1a Resource acquired Hi! Resource destroyed \u5982\u679c\u7528\u6237\u8f93\u51650\uff0c\u4e0a\u9762\u7684\u7684\u7a0b\u5e8f\u5c06\u4f1a\u63d0\u524d\u7ec8\u6b62\uff0c\u9000\u51fa\uff0c\u5e76\u4e14\u6253\u5370\uff1a Resource acquired Resource destroyed \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5373\u4fbf\u7528\u6237\u8f93\u51650\u5bfc\u81f4\u7a0b\u5e8f\u63d0\u524d\u9000\u51fa\uff0c Resource \u4e5f\u4f1a\u5f97\u5230\u5408\u7406\u7684\u91ca\u653e\u3002 \u56e0\u4e3a\u6307\u9488\u53d8\u91cf\u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6307\u9488\u5c06\u4f1a\u88ab\u91ca\u653e\u5f53\u51fd\u6570\u7ec8\u6b62\uff08\u4e0d\u7ba1\u5b83\u5982\u4f55\u505c\u6b62\uff09\u3002\u5e76\u4e14\u56e0\u4e3a Auto_ptr1 \u6790\u6784\u51fd\u6570\u5c06\u4f1a\u6e05\u7406 Resouce \uff0c\u6211\u4eec\u4fdd\u8bc1 Rresouce \u5c06\u4f1a\u88ab\u5408\u7406\u7684\u6e05\u7406\u3002","title":"\u667a\u80fd\u6307\u9488\u80fd\u62ef\u6551\u4e00\u5207\u4e48"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_2","text":"Auto_ptr1 \u7c7b\u6709\u4e00\u4e2a\u81f4\u547d\u7684\u7f3a\u9677\u9690\u85cf\u5728\u4e00\u4e9b \u81ea\u52a8\u751f\u6210 \u7684\u4ee3\u7801\u91cc\u3002\u5728\u8fdb\u4e00\u6b65\u9605\u8bfb\u4e4b\u524d\uff0c\u770b\u770b\u4f60\u662f\u5426\u80fd\u627e\u5230\u7b54\u6848\uff0c\u5feb\u60f3\u60f3\u5427\u2026\u2026 \uff08\u63d0\u793a\uff1a\u601d\u8003\u7c7b\u4e2d\u7684\u54ea\u4e2a\u90e8\u5206\u4f1a\u88ab\u81ea\u52a8\u751f\u6210\uff0c\u5982\u679c\u4f60\u4e0d\u63d0\u4f9b\uff09 \uff08\u7d27\u5f20\u7684\u97f3\u4e50\uff09 Okay, time\u2019s up. \u597d\u4e86\uff0c\u65f6\u95f4\u5230\u4e86\u3002 \u76f8\u6bd4\u8bb2\u7ed9\u4f60\u542c\uff0c\u6211\u4eec\u5c06\u76f4\u63a5\u5411\u4f60\u5c55\u793a\uff0c\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a # include <iostream> // Same as above template < class T > class Auto_ptr1 { T * m_ptr ; public : Auto_ptr1 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr1 () { delete m_ptr ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr1 < Resource > res1 ( new Resource ); Auto_ptr1 < Resource > res2 ( res1 ); // Alternatively, don't initialize res2 and then assign res2 = res1; return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u4f1a\u6253\u5370 Resource acquired Resource destroyed Resource destroyed \u53ef\u80fd\uff08\u4f46\u4e0d\u662f\u4e00\u5b9a\uff09\u4f60\u7684\u7a0b\u5e8f\u5c06\u4f1a\u5728\u8fd9\u65f6\u9000\u51fa\u3002\u770b\u5230\u95ee\u9898\u4e86\u4e48\uff1f\u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0cC++ \u7ed9\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u3002\u5e76\u4e14\u8be5\u51fd\u6570\u8fdb\u884c\u4e86\u6d45\u62f7\u8d1d\uff0c\u56e0\u6b64\u5f53\u6211\u4eec\u7528 res1 \u521d\u59cb\u5316 res2 \u65f6\uff0c \u4e24\u4e2a Auto_ptr1 \u53d8\u91cf\u901a\u77e5\u6307\u5411\u4e86\u540c\u6837\u7684 Resource \u3002\u5f53 res2 \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u4ed6\u5c31\u4f1a\u5220\u9664 resouce \uff0c\u8ba9 res1 \u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\uff0c\u5f53 res1 \u5220\u9664\u4ed6\u7684\uff08\u65e9\u5c31\u88ab\u5220\u9664\uff09\u7684 Resouce \u65f6\uff0c\u7a0b\u5e8f\u5d29\u6e83\uff01 \u4f60\u5b9e\u73b0\u53e6\u4e00\u4e2a\u7b80\u5355\u7684\u95ee\u9898\uff0c\u5f53\u50cf\u8fd9\u6837\u8c03\u7528\u51fd\u6570\u65f6\uff1a void passByValue ( Auto_ptr1 < Resource > res ) { } int main () { Auto_ptr1 < Resource > res1 ( new Resource ); passByValue ( res1 ) return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c res1 \u5c06\u4f1a\u88ab\u503c\u62f7\u8d1d\u8fdb passByValue() \u7684\u53c2\u6570 res \uff0c\u5bfc\u81f4\u590d\u5236\u4e86\u4e00\u4efd Resouce \u6307\u9488\uff0c\u6700\u540e\u56e0\u4e3a\u540c\u6837\u7684\u95ee\u9898\u5d29\u6e83\u3002 \u597d\u7684\uff0c\u6211\u4eec\u6e05\u695a\u8fd9\u4e2a\u95ee\u9898\u4e86\u3002\u6211\u4eec\u5982\u4f55\u89e3\u51b3\u5b83\uff1f \u80fd\u591f\u89e3\u51b3\u7684\u65b9\u6cd5\u4e4b\u4e00\u5c31\u662f\u663e\u5f0f\u7684\u5b9a\u4e49\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\uff0c\u4ece\u800c\u963b\u6b62\u4e86\u4efb\u4f55\u62f7\u8d1d\u4ece\u539f\u59cb\u5bf9\u8c61\u590d\u5236\u51fa\u6765\uff0c\u90a3\u4f1a\u963b\u6b62\u503c\u4f20\u503c\uff08\u90a3\u65f6\u5f88\u68d2\u7684\uff0c\u65e0\u8bba\u5982\u4f55\u6211\u4eec\u90fd\u4e0d\u5e94\u8be5\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\u4f7f\u7528\u503c\u4f20\u503c\uff09\u3002 \u4f46\u662f\u7d27\u63a5\u7740\u8fd4\u56de\u4e00\u4e2a Auto_ptr1 \u4ece\u4e00\u4e2a\u51fd\u6570\u8fd4\u56de\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f ??? generateResource () { Resource * r = new Resource ; return Auto_ptr1 ( r ); } \u6211\u4eec\u4e0d\u80fd\u901a\u8fc7\u5f15\u7528\u8fd4\u56de Auto_ptr1 \uff0c\u56e0\u4e3a\u5c40\u90e8\u53d8\u91cf Auto_ptr1 \u5c06\u4f1a\u5728\u51fd\u6570\u7684\u672b\u5c3e\u88ab\u5220\u9664\uff0c\u5e76\u4e14\u8c03\u7528\u8005\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u60ac\u7a7a\u7684\u5f15\u7528\u3002\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6709\u540c\u6837\u7684\u95ee\u9898\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5730\u5740\u8fd4\u56de\u6307\u9488 r \uff0c\u4f46\u662f\u6211\u4eec\u4e5f\u8bb8\u4f1a\u5fd8\u4e86\u4e4b\u540e\u5220\u9664 r \uff0c\u8fd9\u4e5f\u662f\u6211\u4eec\u4e4b\u6240\u4ee5\u4f7f\u7528\u667a\u80fd\u6307\u9488\u7684\u539f\u56e0\u3002\u56e0\u6b64\u90a3\u6beb\u65e0\u7591\u95ee\uff0c\u901a\u8fc7\u503c\u8fd4\u56de Auto_ptr1 \u662f\u552f\u4e00\u6709\u610f\u4e49\u7684\u9009\u9879 \u2014\u2014 \u4f46\u662f\u7d27\u63a5\u7740\u6211\u4eec\u5c31\u4f1a\u4ee5\u6d45\u62f7\u8d1d\uff0c\u590d\u5236\u6307\u9488\uff0c\u6700\u540e\u5d29\u6e83\u3002 \u53e6\u4e00\u4e2a\u9009\u9879\u5c31\u662f\u91cd\u5199\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u4fdd\u8bc1\u6df1\u62f7\u8d1d\u3002\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u6211\u4eec\u81f3\u5c11\u80fd\u4fdd\u8bc1\u907f\u514d\u590d\u5236\u6307\u5411\u5171\u4e00\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\u3002\u4f46\u662f\u6df1\u62f7\u8d1d\u662f\u6602\u8d35\u7684\uff08\u5e76\u4e14\u4e5f\u8bb8\u662f\u4e0d\u53ef\u53d6\u7684\u6216\u8005\u751a\u81f3\u662f\u4e0d\u53ef\u80fd\u7684\uff09\uff0c\u5e76\u4e14\u6211\u4eec\u4e0d\u60f3\u4e3a\u4e86\u4ece\u51fd\u6570\u4e2d\u8fd4\u56de Auto-ptr1 \u4ece\u800c\u5bf9\u5bf9\u8c61\u8fdb\u884c\u4e0d\u5fc5\u8981\u7684\u590d\u5236\u3002\u53e6\u5916\uff0c\u5206\u914d\u6216\u521d\u59cb\u5316\u4e00\u4e2a\u7b28\u6307\u9488\u5e76\u4e0d\u4f1a\u590d\u5236\u6240\u6307\u5411\u7684\u5bf9\u8c61\uff0c\u90a3\u4e48\u4e3a\u4ec0\u4e48\u6211\u4eec\u5e0c\u671b\u667a\u80fd\u6307\u9488\u7684\u884c\u4e3a\u6709\u6240\u4e0d\u540c\u5462\uff1f \u6211\u4eec\u8be5\u600e\u4e48\u529e\uff1f","title":"\u4e00\u4e2a\u5f88\u5173\u952e\u7684\u7f3a\u9677"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_3","text":"\u5982\u679c\u4e0d\u662f\u8ba9\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u590d\u5236\u6307\u9488\uff08\u201c\u590d\u5236\u8bed\u4e49\u201d\uff09\uff0c\u800c\u662f\u5c06\u6307\u9488\u7684\u6240\u6709\u6743\u4ece\u6e90\u5bf9\u8c61\u8f6c\u79fb/\u79fb\u52a8\u5230\u76ee\u6807\u5bf9\u8c61\u5462\uff1f\u8fd9\u662fmove\u8bed\u4e49\u80cc\u540e\u7684\u6838\u5fc3\u601d\u60f3\u3002\u79fb\u52a8\u8bed\u4e49\u610f\u5473\u7740\u7c7b\u5c06\u8f6c\u79fb\u5bf9\u8c61\u7684\u6240\u6709\u6743\uff0c\u800c\u4e0d\u662f\u8fdb\u884c\u590d\u5236\u3002 \u8ba9\u6211\u4eec\u4f60\u66f4\u65b0\u6211\u4eec\u7684 Auto_ptr1 \u7c7b\u6765\u5c55\u793a\u8fd9\u5982\u4f55\u5b8c\u6210\uff1a # include <iostream> template < class T > class Auto_ptr2 { T * m_ptr ; public : Auto_ptr2 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr2 () { delete m_ptr ; } // A copy constructor that implements move semantics Auto_ptr2 ( Auto_ptr2 & a ) // note: not const { m_ptr = a . m_ptr ; // transfer our dumb pointer from the source to our local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer } // An assignment operator that implements move semantics Auto_ptr2 & operator = ( Auto_ptr2 & a ) // note: not const { if ( & a == this ) return * this ; delete m_ptr ; // make sure we deallocate any pointer the destination is already holding first m_ptr = a . m_ptr ; // then transfer our dumb pointer from the source to the local object a . m_ptr = nullptr ; // make sure the source no longer owns the pointer return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Auto_ptr2 < Resource > res1 ( new Resource ); Auto_ptr2 < Resource > res2 ; // Start as nullptr std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); res2 = res1 ; // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( res1 . isNull () ? \"null \\n \" : \"not null \\n \" ); std :: cout << \"res2 is \" << ( res2 . isNull () ? \"null \\n \" : \"not null \\n \" ); return 0 ; } \u8fd9\u4e2a\u6253\u5370\u51fa\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u6ce8\u610f\u6211\u4eec\u91cd\u8f7d\u4e86 operator= \u5c06 m_ptr \u7684\u6240\u6709\u6743\u4ece res1 \u9012\u4ea4\u7ed9 res2 \uff01\u56e0\u6b64\u6211\u4eec\u4e0d\u4f1a\u590d\u5236\u6307\u9488\u7684\u62f7\u8d1d\uff0c\u5e76\u4e14\u6240\u6709\u4e8b\u90fd\u88ab\u6574\u9f50\u7684\u6e05\u7406\u5e72\u51c0\u3002","title":"\u79fb\u52a8\u8bed\u4e49"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#stdauto_ptr","text":"\u73b0\u5728\u662f\u5408\u9002\u7684\u5b9e\u673a\u6765\u8bb2 std::auto_ptr \u4e86\uff0c std::auto_ptr \uff0c\u5728 C++98 \u4e2d\u5f15\u8fdb\uff0c\u662f C++ \u7684\u7b2c\u4e00\u6b21\u5c1d\u8bd5\u5b9e\u73b0\u4e00\u4e2a\u6807\u51c6\u7684\u53ea\u80fd\u6307\u9488\u3002 std::auto_ptr \u9009\u62e9\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u5c31\u50cf Auto_ptr2 \u7c7b\u505a\u7684\u90a3\u6837\u3002 \u7136\u800c\uff0c std::auto_ptr \uff08\u548c\u6211\u4eec\u7684 Auto_ptr2 \u7c7b\u4e00\u6837\uff09\u6709\u4e00\u5927\u5806\u95ee\u9898\uff0c\u4f7f\u5f97\u7528\u8d77\u6765\u975e\u5e38\u7684\u5371\u9669\u3002 \u9996\u5148\uff1a \u7531\u4e8e std::auto_ptr \u901a\u8fc7copy\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49(move semantics)\uff0c\u56e0\u6b64\u6309\u503c\u5411\u51fd\u6570\u4f20\u9012 std::auto_ptr \u5c06\u5bfc\u81f4\u8d44\u6e90\u79fb\u52a8\u5230\u51fd\u6570\u53c2\u6570\uff08\u5f53\u51fd\u6570\u53c2\u6570\u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u53c2\u6570\u5728\u51fd\u6570\u672b\u5c3e\u9500\u6bc1\uff09\u3002\u7136\u540e\u5f53\u4f60\u4ece\u8c03\u7528\u8005\u90a3\u91cc\u8bbf\u95ee\u4f60\u7684 auto_ptr \u53c2\u6570\u65f6\uff08\u6ca1\u6709\u610f\u8bc6\u5230\u5b83\u5df2\u7ecf\u88ab\u8f6c\u79fb\u548c\u5220\u9664\uff09\uff0c\u4f60\u7a81\u7136\u5bf9\u7a7a\u6307\u9488\u7684\u53d6\u503c\u3002\u5bfc\u81f4\u5d29\u6e83 \u7b2c\u4e8c\uff1a std::auto_ptr \u603b\u662f\u7528\u975e\u6570\u7ec4\u5220\u9664\u5b83\u7684\u5185\u5bb9\u3002\u8fd9\u610f\u5473\u8fd9 auto_ptr \u5728\u52a8\u6001\u5206\u914d\u6570\u7ec4\u5185\u5b58\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0d\u80fd\u6b63\u786e\u7684\u5de5\u4f5c\uff0c\u56e0\u4e3a\u5b83\u4f7f\u7528\u4e86\u9519\u8bef\u7684\u91ca\u653e\u7b26\u53f7\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u5b83\u4e0d\u5141\u8bb8\u4f60\u4f20\u4e00\u4e2a\u52a8\u6001\u7684\u6570\u7ec4\uff0c\u56e0\u4e3a\u8fd9\u6837\u505a\u5b83\u5c31\u4f1a\u5931\u53bb\u7ba1\u7406\uff0c\u5bfc\u81f4\u5185\u5b58\u6cc4\u9732\u3002 \u6700\u540e\uff1a std::auto_ptr \u4e0d\u80fd\u548c\u5176\u4ed6\u6807\u51c6\u5e93\u4e2d\u7684\u7c7b\u642d\u914d\u4f7f\u7528\uff0c\u5305\u62ec\u5927\u91cf\u7684\u5bb9\u5668\u548c\u7b97\u6cd5\u3002\u8fd9\u4f1a\u53d1\u751f\u5c31\u662f\u56e0\u4e3a\u90a3\u4e9b\u6807\u51c6\u5e93\u5047\u8bbe\u5f53\u4ed6\u4eec\u62f7\u8d1d\u4e00\u4e2a\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5b9e\u9645\u4e0a\u662f\u62f7\u8d1d\u800c\u4e0d\u662f\u79fb\u52a8\u3002 \u56e0\u4e3a\u4ee5\u4e0a\u63d0\u5230\u7684\u7f3a\u70b9\uff0c std::auto_ptr \u5728 C++11 \u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\u4e8b\u5b9e\u4e0a std::auto_ptr \u5728 C++17 \u4e2d\u624d\u88ab\u4ece\u6807\u51c6\u5e93\u4e2d\u5b8c\u5168\u79fb\u9664\u3002 Rule: std::auto_ptr is deprecated and should not be used. (Use std::unique_ptr or std::shared_ptr instead).. \u89c4\u5219\uff1a std::auto_ptr \u662f\u88ab\u629b\u5f03\u7684\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u4f7f\u7528\u3002\uff08\u4f7f\u7528 std::unique_ptr or std::shared_ptr \u66ff\u6362\u4ed6\uff09\u2026\u2026","title":"std::auto_ptr \u548c\u4e3a\u4f55\u907f\u514d\u4f7f\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/#_4","text":"\u5728 C++11 \u4e4b\u524d std::auto_ptr \u7684\u6838\u5fc3\u8bbe\u8ba1\u95ee\u9898\uff0c\u662f C++ \u8bed\u8a00\u6ca1\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u673a\u5236\u6765\u5206\u8fa8\u62f7\u8d1d\u8bed\u4e49\u548c\u79fb\u52a8\u8bed\u4e49\u3002\u91cd\u5199\u62f7\u8d1d\u8bed\u4e49\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u65e0\u610f\u4e2d\u5f15\u8d77\u4e86\u95ee\u9898\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u5199 res1 = res2 \u5e76\u4e14\u6ca1\u529e\u6cd5\u77e5\u9053 res2 \u662f\u5426\u4f1a\u88ab\u6539\u53d8\uff01 \u56e0\u4e3a\u8fd9\u4e2a\uff0c\u5728 C++11\u4e2d\uff0c\u201d\u79fb\u52a8\u201d\u8fd9\u4e2a\u6982\u5ff5\u88ab\u6b63\u5f0f\u7684\u5b9a\u4e49\uff0c\u5e76\u4e14\u201d\u79fb\u52a8\u8bed\u4e49\u201c\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\u6765\u5408\u9002\u7684\u5206\u8fa8\u62f7\u8d1d(copying)\u548c\u79fb\u52a8(moving)\u3002\u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u4e3a\"\u4e3a\u4f55\u79fb\u52a8\u8bed\u4e49\u662f\u6709\u7528\u7684\"\u505a\u597d\u4e86\u51c6\u5907\uff0c\u6211\u4eec\u5c06\u5728\u672c\u7ae0\u7684\u5176\u4f59\u90e8\u5206\u4e2d\u63a2\u8ba8\"\u79fb\u52a8\u8bed\u4e49\"\u7684\u4e3b\u9898\u3002\u6211\u4eec\u8fd8\u5c06\u4f7f\u7528move\u8bed\u4e49\u4fee\u590dAuto ptr2\u7c7b\u3002 \u5728 C++11\u4e2d\uff0c std::auto_ptr \u5df2\u7ecf\u88ab\u4e00\u5806\u5176\u4ed6\u7c7b\u578b\u7684\u201cmove-aware\u201d\u53ea\u80fd\u6307\u6b63\u6240\u66ff\u6362\uff1a std::unique_ptr \uff0c std::weak_ptr \uff0c\u548c std::shared_ptr \u3002\u6211\u4eec\u5c06\u4e5f\u63a2\u7d22\u8fd9\u4e9b\u4e2d\u6700\u8457\u540d\u7684\u4e24\u4e2a\uff1a unique_ptr (\u76f4\u63a5\u7528\u6765\u66ff\u6362 std::auto_ptr \u7684) \u548c shared_ptr .","title":"\u5411\u524d\u770b"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/","text":"15.2 \u53f3\u503c\u5f15\u7528 \u00b6 By Alex on February 20 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 7-17 \u56de\u5230 \u7b2c\u4e00\u7ae0 \u6211\u4eec\u8ba8\u8bba\u4e86\u5de6\u503c\u548c\u53f3\u503c\uff0c\u7136\u540e\u544a\u8bc9\u4f60\u4e0d\u8981\u592a\u62c5\u5fc3\u4ed6\u4eec\u3002\u5728 C++11 \u4e4b\u524d\uff0c\u8fd9\u662f\u4e00\u4e2a\u516c\u5e73\u7684\u5efa\u8bae\u3002\u4f46\u662f\u7406\u89e3 C++11 \u4e2d\u7684\u79fb\u52a8\u8bed\u4e49\u9700\u8981\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u91cd\u65b0\u5b66\u4e60\u3002\u6240\u4ee5\u73b0\u5728\u5c31\u5f00\u59cb\u5427\u3002 \u5de6\u503c\u548c\u53f3\u503c \u00b6 \u5c3d\u7ba1\u540d\u79f0\u4e2d\u6709 \u201c\u503c\u201d \u4e00\u8bcd\uff0c\u4f46 \u5de6\u503c \u548c \u53f3\u503c \u5b9e\u9645\u4e0a\u4e0d\u662f \u503c \u7684\u5c5e\u6027\uff0c\u800c\u662f\u8868\u8fbe\u5f0f\u7684\u5c5e\u6027\u3002 C++\u4e2d\u7684\u6bcf\u4e2a\u8868\u8fbe\u5f0f\u90fd\u6709\u4e24\u4e2a\u5c5e\u6027\uff1a\u4e00\u4e2a\u7c7b\u578b\uff08\u7528\u4e8e\u7c7b\u578b\u68c0\u67e5\uff09\u548c\u4e00\u4e2a\u503c\u7c7b\u522b\uff08\u7528\u4e8e\u67d0\u4e9b\u7c7b\u578b\u7684\u8bed\u6cd5\u68c0\u67e5\uff0c\u4f8b\u5982\u8868\u8fbe\u5f0f\u7684\u7ed3\u679c\u662f\u5426\u53ef\u4ee5\u5206\u914d\uff09\u3002\u5728C++ 03\u548c\u66f4\u65e9\u7684\u65f6\u5019\uff0c\u5de6\u503c\u548c\u53f3\u503c\u662f\u4ec5\u6709\u7684\u4e24\u4e2a\u53ef\u7528\u7684\u503c\u7c7b\u522b\u3002 \u5bf9\u4e8e\u54ea\u4e9b\u8868\u8fbe\u5f0f\u662f\u5de6\u503c\uff0c\u54ea\u4e9b\u662f\u53f3\u503c\u7684\u5b9e\u9645\u5b9a\u4e49\u975e\u5e38\u590d\u6742\uff0c\u56e0\u6b64\u6211\u4eec\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u91c7\u53d6\u7b80\u5316\u7684\u89c2\u70b9\uff0c\u8fd9\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u6ee1\u8db3\u4e86\u6211\u4eec\u7684\u76ee\u7684\u3002 \u7b80\u5355\u70b9\u53ef\u4ee5\u8ba4\u4e3a\u5de6\u503c\uff08\u4e5f\u79f0\u4e3a\u5b9a\u4f4d\u5668\u503c[locator value]\uff09\u662f\u51fd\u6570\u6216\u5bf9\u8c61\uff08\u6216\u8ba1\u7b97\u4e3a\u51fd\u6570\u6216\u5bf9\u8c61\u7684\u8868\u8fbe\u5f0f\uff09\u6240\u6709\u5de6\u503c\u90fd\u5206\u914d\u4e86\u5185\u5b58\u5730\u5740\u3002 \u5f53\u5de6\u503c\u6700\u521d\u88ab\u5b9a\u4e49\u65f6\uff0c\u5b83\u4eec\u88ab\u5b9a\u4e49\u4e3a\u201c\u9002\u5408\u4f4d\u4e8e\u8d4b\u503c\u8868\u8fbe\u5f0f\u5de6\u4fa7\u7684\u503c\u201d\u3002\u7136\u800c\uff0c\u540e\u6765\uff0cconst\u5173\u952e\u5b57\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\uff0c\u5e76\u4e14\u5de6\u503c\u88ab\u5206\u4e3a\u4e24\u4e2a\u5b50\u7c7b\uff1a\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08\u53ef\u4ee5\u66f4\u6539\uff09\u548c\u4e0d\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08const\uff09\u3002 \u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u628a\u53f3\u503c\u770b\u4f5c\u201c\u4e0d\u662fl\u503c\u7684\u6240\u6709\u4e1c\u897f\u201d\u3002\u8fd9\u7279\u522b\u5305\u62ec\u5b57\u9762\u503c\uff08\u4f8b\u5982 5 \uff09\u3001\u4e34\u65f6\u503c\uff08\u4f8b\u5982 x+1 \uff09\u548c\u533f\u540d\u5bf9\u8c61\uff08\u4f8b\u5982 Fraction(5, 2) \uff09\u3002\u53f3\u503c\u901a\u5e38\u662f\u9488\u5bf9\u5176\u503c\u8fdb\u884c\u6c42\u503c\u7684\uff0c\u5177\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff08\u5b83\u4eec\u5728\u5176\u6240\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\u5904\u6d88\u4ea1\uff09\uff0c\u5e76\u4e14\u4e0d\u80fd\u88ab\u8d4b\u503c\u3002\u8fd9\u4e2a\u975e\u8d4b\u503c\u89c4\u5219\u662f\u6709\u610f\u4e49\u7684\uff0c\u56e0\u4e3a\u8d4b\u503c\u4f1a\u7ed9\u5bf9\u8c61\u5e26\u6765\u526f\u4f5c\u7528\u3002\u56e0\u4e3a\u53f3\u503c\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff0c\u5982\u679c\u6211\u4eec\u8981\u7ed9\u53f3\u503c\u8d4b\u503c\uff0c\u90a3\u4e48\u53f3\u503c\u4f1a\u5728\u6211\u4eec\u6709\u673a\u4f1a\u5728\u4e0b\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u4f7f\u7528\u4e0a\u6b21\u8d4b\u503c\u4e4b\u524d\u5c31\u8d85\u51fa\u4e86\u8303\u56f4\uff08\u8fd9\u4f7f\u5f97\u8d4b\u503c\u6beb\u65e0\u7528\u5904\uff09\uff0c\u8981\u4e48\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cf\uff0c\u5728\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u591a\u6b21\u5e94\u7528\u4e00\u4e2a\u526f\u4f5c\u7528\uff08\u73b0\u5728\u60a8\u5e94\u8be5\u77e5\u9053\u8fd9\u4f1a\u5bfc\u81f4\u672a\u5b9a\u4e49\u7684\u884c\u4e3a\uff01\uff09\u3002 \u4e3a\u4e86\u652f\u6301\u79fb\u52a8\u8bed\u4e49\uff0cC++ \u5f15\u5165\u4e86\u4e09\u4e2a\u65b0\u7684\u503c\u7c7b\u578b\uff1apr-values\uff0cx-values \u548c gl-values. \u6211\u4eec\u5927\u6982\u7387\u4f1a\u5ffd\u7565\u8fd9\u4e9b\u77e5\u8bc6\uff0c\u56e0\u4e3a\u9ad8\u6548\u7684\u5b66\u4e60\u548c\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\u5e76\u4e0d\u9700\u8981\u7406\u89e3\u4ed6\u4eec\u3002\u5982\u679c\u4f60\u611f\u5174\u8da3\uff0c cppreference.com \u6709\u4e00\u4e2a\u5e7f\u6cdb\u7684\u8868\u8fbe\u7ed9\u6bcf\u4e00\u4e2a\u53d8\u91cf\u7c7b\u578b\uff0c\u540c\u65f6\u6709\u66f4\u591a\u5173\u4e8e\u4ed6\u4eec\u7684\u7ec6\u8282 L-value references \u5728 C++ \u4e4b\u524d\uff0cC++ \u4e2d\u53ea\u6709\u4e00\u4e2a\u7c7b\u578b\u7684\u5f15\u7528\uff0c\u5e76\u4e14\u56e0\u6b64\u5b83\u4ec5\u4ec5\u88ab\u53eb\u505a\u5f15\u7528\u3002\u7136\u800c\uff0c\u5728 C++11 \u4e2d\uff0c\u5b83\u6709\u65f6\u5019\u4e5f\u88ab\u53eb\u505a l-value \u5f15\u7528\u3002L-value \u5f15\u7528\u53ea\u80fd\u7531\u53ef\u4fee\u6539\u7684\u5de6\u503c\u6765\u521d\u59cb\u5316\u3002 L-value reference Can be initialized with Can modify Modifiable l-values Yes Yes Non-modifiable l-values No No R-values No No \u6307\u5411\u5e38\u5bf9\u8c61\u7684 l-value \u53ef\u4ee5\u88ab\u4f7f\u7528 l-value \u548c r-value \u6765\u521d\u59cb\u5316\uff0c\u7136\u800c\uff0c\u8fd9\u4e9b\u503c\u4e0d\u80fd\u88ab\u4fee\u6539\u3002 L-value reference to const Can be initialized with Can modify Modifiable l-values Yes No Non-modifiable l-values Yes No R-values Yes No \u5e38\u5bf9\u8c61\u7684\u5de6\u503c\u5f15\u7528\u975e\u5e38\u6709\u7528\uff0c\u56e0\u4e3a\u4ed6\u4eec\u5141\u8bb8\u4f60\u4f20\u4efb\u4f55\u7c7b\u578b\u7684\u53c2\u6570\uff08l-value \u6216 r-value\uff09\u8fdb\u5165\u4e00\u4e2a\u51fd\u6570\uff0c\u800c\u65e0\u9700\u62f7\u8d1d\u4e00\u4efd\u3002 R-value \u5f15\u7528 \u00b6 C++ \u6dfb\u52a0\u4e86\u4e00\u4e2a\u65b0\u7684\u53eb\u505a\u53f3\u503c\u5f15\u7528\uff08r-value reference\uff09\u3002\u53f3\u503c\u5f15\u7528\u662f\u88ab\u8bbe\u8ba1\u6765\u53ea\u80fd\u4f7f\u7528\u53f3\u503c\u521d\u59cb\u5316\u7684\u3002\u5de6\u503c\u662f\u5f15\u7528\u4f7f\u7528\u4e00\u4e2a & \u521b\u5efa\u7684\uff0c\u800c\u53f3\u503c\u5f15\u7528\u4f7f\u7528\u4e24\u4e2a & \u6765\u521b\u5efa\u3002 int x { 5 }; int & lref { x }; // l-value reference initialized with l-value x int && rref { 5 }; // r-value reference initialized with r-value 5 R-value reference Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes Yes R-value reference to const Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes No \u53f3\u503c\u5f15\u7528\u6709\u4e24\u4e2a\u5f88\u6709\u7528\u7684\u6027\u8d28\u3002\u7b2c\u4e00\uff0c\u53f3\u503c\u5f15\u7528\u6269\u5c55\u4e86\u539f\u521d\u59cb\u5316\u503c\u7684\u751f\u547d\u5468\u671f\u5230\u53f3\u503c\u5f15\u7528\u7684\u751f\u547d\u5468\u671f\uff08\u6307\u5411\u5e38\u5bf9\u8c61\u7684\u5de6\u503c\u5f15\u7528\u4e5f\u53ef\u4ee5\u505a\u5230\uff09\u3002\u7b2c\u4e8c\uff0c\u975e\u5e38\u91cf\u5f15\u7528\u5141\u8bb8\u4f60\u4fee\u6539\u53f3\u503c\u3002 \u8ba9\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50\uff1a # include <iostream> class Fraction { private : int m_numerator ; int m_denominator ; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { auto && rref { Fraction { 3 , 5 } }; // r-value reference to temporary Fraction // f1 of operator<< binds to the temporary, no copies are created. std :: cout << rref << '\\n' ; return 0 ; } // rref (and the temporary Fraction) goes out of scope here \u7a0b\u5e8f\u6253\u5370 3/5 \u4f5c\u4e3a\u4e00\u4e2a\u533f\u540d\u5bf9\u8c61\uff0c Fraction(w3, 5) \u5c06\u4f1a\u6b63\u5e38\u7684\u5728\u5b9a\u4e49\u5b83\u8bed\u53e5\u7ed3\u675f\u65f6\u79bb\u5f00\u4f5c\u7528\u57df\u3002\u7136\u800c\uff0c\u56e0\u4e3a\u6211\u4eec\u4ee5\u5b83\u6765\u521d\u59cb\u5316\u4e86\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\uff0c\u4ed6\u7684\u58f0\u660e\u5468\u671f\u5c31\u6301\u7eed\u5230\u4e86\u8bed\u53e5\u5757\u7ed3\u675f\u3002\u6211\u4eec\u7d27\u63a5\u7740\u53ef\u4ee5\u4f7f\u7528\u53f3\u503c\u5f15\u7528\u6765\u6253\u5370 Fraction \u7684\u503c\u3002 \u597d\u7684\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u66f4\u52a0\u76f4\u89c2\u7684\u4f8b\u5b50\uff1a # include <iostream> int main () { int && rref { 5 }; // because we're initializing an r-value reference with a literal, a temporary with value 5 is created here rref = 10 ; std :: cout << rref << '\\n' ; return 0 ; } \u7a0b\u5e8f\u6253\u5370 10 \u4f7f\u7528\u4e00\u4e2a\u5b57\u9762\u503c\u6765\u521d\u59cb\u5316\u4e00\u4e2a\u53f3\u503c\uff0c\u7136\u540e\u80fd\u591f\u6539\u53d8\u90a3\u4e2a\u53f3\u503c\u3002\u8fd9\u662f\u56e0\u4e3a\uff0c\u5f53\u4f7f\u7528\u5b57\u9762\u503c\u6765\u521d\u59cb\u5316\u53f3\u503c\uff0c\u4f1a\u521b\u5efa\u4e00\u5757\u4e34\u65f6\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u5f15\u7528\u662f\u4e00\u5757\u4e34\u65f6\u7a7a\u95f4\u7684\u5f15\u7528\uff0c\u800c\u4e0d\u662f\u5b57\u9762\u503c\u7684\u5f15\u7528\u3002 \u53f3\u503c\u5f15\u7528\u5728\u4ee5\u4e0a\u7684\u4ee3\u7801\u4f8b\u5b50\u4e2d\u7684\u4f7f\u7528\u65b9\u5f0f\u5e76\u4e0d\u5f88\u5e38\u89c1\u3002 \u53f3\u503c\u5f15\u7528\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570 \u00b6 \u53f3\u503c\u5f15\u7528\u7ecf\u5e38\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u6765\u4f7f\u7528\u3002\u6700\u6709\u7528\u7684\u65b9\u5f0f\u5c31\u662f\u5f53\u51fd\u6570\u91cd\u8f7d\u7684\u65f6\u5019\u4f60\u5e0c\u671b\u5bf9\u5f85\u5de6\u503c\u548c\u53f3\u503c\u7684\u65f6\u5019\u6709\u4e0d\u540c\u7684\u8868\u73b0\u3002 void fun ( const int & lref ) // l-value arguments will select this function { std :: cout << \"l-value reference to const \\n \" ; } void fun ( int && rref ) // r-value arguments will select this function { std :: cout << \"r-value reference \\n \" ; } int main () { int x { 5 }; fun ( x ); // l-value argument calls l-value version of function fun ( 5 ); // r-value argument calls r-value version of function return 0 ; } \u8fd9\u4f1a\u6253\u5370\uff1a l - value reference to const r - value reference \u5982\u4f60\u6240\u89c1\uff0c\u5f53\u4f20\u5165\u4e00\u4e2a\u5de6\u503c\u7684\u65f6\u5019\uff0c\u91cd\u8f7d\u51fd\u6570\u89e3\u6790\u5230\u4e86\u5de6\u503c\u5f15\u7528\u7684\u7248\u672c\u3002\u5f53\u4f20\u5165\u53f3\u503c\u7684\u65f6\u5019\uff0c\u91cd\u8f7d\u51fd\u6570\u89e3\u6790\u5230\u4e86\u53f3\u503c\u5f15\u7528\u7684\u7248\u672c\uff08\u8fd9\u662f\u6bd4\u5de6\u503c\u5e38\u5f15\u7528\u66f4\u597d\u7684\u4e00\u4e2a\u529e\u6cd5\uff09 \u4e3a\u4ec0\u4e48\u4f60\u4f1a\u60f3\u8981\u8fd9\u6837\u505a\u5462\uff1f\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u8be6\u7ec6\u8ba8\u8bba\uff0c\u4e0d\u5f97\u4e0d\u8bf4\uff0c\u8fd9\u662f\u79fb\u52a8\u8bed\u4e49\u7684\u91cd\u8981\u90e8\u5206\u3002 \u4e00\u4e2a\u6709\u8da3\u7684\u7b14\u8bb0\uff1a int && ref { 5 }; fun ( ref ); \u4e8b\u5b9e\u4e0a\uff0c\u8c03\u7528\u7684\u662f\u5de6\u503c\u7248\u672c\u7684\u51fd\u6570\uff01\u5c3d\u7ba1\u53d8\u91cf ref \u6709\u4e00\u4e2a\u6574\u578b\u7684\u53f3\u503c\u5f15\u7528\uff0c\u4f46\u662f\u5b83\u672c\u8eab\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u5de6\u503c\uff08\u6240\u6709\u7684\u547d\u540d\u53d8\u91cf\u90fd\u662f\u5982\u6b64\uff09\u3002\u6df7\u6dc6\u7684\u539f\u56e0\u662f\u53f3\u503c\u8fd9\u4e2a\u8bcd\u5728\u4e0d\u540c\u7684\u4e0a\u4e0b\u6587\u4e2d\u4f7f\u7528\u3002\u4f60\u53ef\u4ee5\u8fd9\u6837\u60f3\uff1a\u547d\u540d\u7684\u5bf9\u8c61\u662f\u5de6\u503c\uff0c\u533f\u540d\u7684\u5bf9\u8c61\u662f\u53f3\u503c\u3002\u547d\u540d\u5bf9\u8c61\u548c\u533f\u540d\u5bf9\u8c61\u4e0d\u4f9d\u8d56\u4e8e\u5b83\u662f\u5de6\u503c\u6216\u8005\u53f3\u503c\u3002\u6216\u8005\uff0c\u8fd9\u6837\u8bf4\uff0c\u5982\u679c\u53f3\u503c\u5f15\u7528\u88ab\u53eb\u505a\u4efb\u4f55\u5176\u4ed6\u7684\u540d\u5b57\uff0c\u8fd9\u4e2a\u7591\u60d1\u5c31\u4e0d\u4f1a\u5b58\u5728\u3002 \u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528 \u00b6 \u4f60\u5e94\u8be5\u51e0\u4e4e\u4e0d\u4f1a\u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\uff0c\u540c\u6837\u4f60\u4e5f\u5e94\u8be5\u51e0\u4e4e\u4e0d\u8fd4\u56de\u4e00\u4e2a\u5de6\u503c\u5f15\u7528\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4f1a\u8fd4\u56de\u4e00\u4e2a\u60ac\u7a7a\u5f15\u7528\u5f53\u5f15\u7528\u5bf9\u8c61\u79bb\u5f00\u51fd\u6570\u7684\u4f5c\u7528\u57df\u65f6 Quiz time \u00b6 1) \u6807\u8bb0\u54ea\u4e00\u4e2a\u5b57\u6bcd\u5bf9\u5e94\u7684\u8bed\u53e5\u7f16\u8bd1\u5931\u8d25\uff1a int main () { int x {}; // l-value references int & ref1 { x }; // A int & ref2 { 5 }; // B const int & ref3 { x }; // C const int & ref4 { 5 }; // D // r-value references int && ref5 { x }; // E int && ref6 { 5 }; // F const int && ref7 { x }; // G const int && ref8 { 5 }; // H return 0 ; } B, E, and G \u4f1a\u7f16\u8bd1\u5931\u8d25","title":"15.2 \u53f3\u503c\u5f15\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#152","text":"By Alex on February 20 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 7-17 \u56de\u5230 \u7b2c\u4e00\u7ae0 \u6211\u4eec\u8ba8\u8bba\u4e86\u5de6\u503c\u548c\u53f3\u503c\uff0c\u7136\u540e\u544a\u8bc9\u4f60\u4e0d\u8981\u592a\u62c5\u5fc3\u4ed6\u4eec\u3002\u5728 C++11 \u4e4b\u524d\uff0c\u8fd9\u662f\u4e00\u4e2a\u516c\u5e73\u7684\u5efa\u8bae\u3002\u4f46\u662f\u7406\u89e3 C++11 \u4e2d\u7684\u79fb\u52a8\u8bed\u4e49\u9700\u8981\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u91cd\u65b0\u5b66\u4e60\u3002\u6240\u4ee5\u73b0\u5728\u5c31\u5f00\u59cb\u5427\u3002","title":"15.2 \u53f3\u503c\u5f15\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#_1","text":"\u5c3d\u7ba1\u540d\u79f0\u4e2d\u6709 \u201c\u503c\u201d \u4e00\u8bcd\uff0c\u4f46 \u5de6\u503c \u548c \u53f3\u503c \u5b9e\u9645\u4e0a\u4e0d\u662f \u503c \u7684\u5c5e\u6027\uff0c\u800c\u662f\u8868\u8fbe\u5f0f\u7684\u5c5e\u6027\u3002 C++\u4e2d\u7684\u6bcf\u4e2a\u8868\u8fbe\u5f0f\u90fd\u6709\u4e24\u4e2a\u5c5e\u6027\uff1a\u4e00\u4e2a\u7c7b\u578b\uff08\u7528\u4e8e\u7c7b\u578b\u68c0\u67e5\uff09\u548c\u4e00\u4e2a\u503c\u7c7b\u522b\uff08\u7528\u4e8e\u67d0\u4e9b\u7c7b\u578b\u7684\u8bed\u6cd5\u68c0\u67e5\uff0c\u4f8b\u5982\u8868\u8fbe\u5f0f\u7684\u7ed3\u679c\u662f\u5426\u53ef\u4ee5\u5206\u914d\uff09\u3002\u5728C++ 03\u548c\u66f4\u65e9\u7684\u65f6\u5019\uff0c\u5de6\u503c\u548c\u53f3\u503c\u662f\u4ec5\u6709\u7684\u4e24\u4e2a\u53ef\u7528\u7684\u503c\u7c7b\u522b\u3002 \u5bf9\u4e8e\u54ea\u4e9b\u8868\u8fbe\u5f0f\u662f\u5de6\u503c\uff0c\u54ea\u4e9b\u662f\u53f3\u503c\u7684\u5b9e\u9645\u5b9a\u4e49\u975e\u5e38\u590d\u6742\uff0c\u56e0\u6b64\u6211\u4eec\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u91c7\u53d6\u7b80\u5316\u7684\u89c2\u70b9\uff0c\u8fd9\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u6ee1\u8db3\u4e86\u6211\u4eec\u7684\u76ee\u7684\u3002 \u7b80\u5355\u70b9\u53ef\u4ee5\u8ba4\u4e3a\u5de6\u503c\uff08\u4e5f\u79f0\u4e3a\u5b9a\u4f4d\u5668\u503c[locator value]\uff09\u662f\u51fd\u6570\u6216\u5bf9\u8c61\uff08\u6216\u8ba1\u7b97\u4e3a\u51fd\u6570\u6216\u5bf9\u8c61\u7684\u8868\u8fbe\u5f0f\uff09\u6240\u6709\u5de6\u503c\u90fd\u5206\u914d\u4e86\u5185\u5b58\u5730\u5740\u3002 \u5f53\u5de6\u503c\u6700\u521d\u88ab\u5b9a\u4e49\u65f6\uff0c\u5b83\u4eec\u88ab\u5b9a\u4e49\u4e3a\u201c\u9002\u5408\u4f4d\u4e8e\u8d4b\u503c\u8868\u8fbe\u5f0f\u5de6\u4fa7\u7684\u503c\u201d\u3002\u7136\u800c\uff0c\u540e\u6765\uff0cconst\u5173\u952e\u5b57\u88ab\u6dfb\u52a0\u5230\u8bed\u8a00\u4e2d\uff0c\u5e76\u4e14\u5de6\u503c\u88ab\u5206\u4e3a\u4e24\u4e2a\u5b50\u7c7b\uff1a\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08\u53ef\u4ee5\u66f4\u6539\uff09\u548c\u4e0d\u53ef\u4fee\u6539\u7684\u5de6\u503c\uff08const\uff09\u3002 \u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u628a\u53f3\u503c\u770b\u4f5c\u201c\u4e0d\u662fl\u503c\u7684\u6240\u6709\u4e1c\u897f\u201d\u3002\u8fd9\u7279\u522b\u5305\u62ec\u5b57\u9762\u503c\uff08\u4f8b\u5982 5 \uff09\u3001\u4e34\u65f6\u503c\uff08\u4f8b\u5982 x+1 \uff09\u548c\u533f\u540d\u5bf9\u8c61\uff08\u4f8b\u5982 Fraction(5, 2) \uff09\u3002\u53f3\u503c\u901a\u5e38\u662f\u9488\u5bf9\u5176\u503c\u8fdb\u884c\u6c42\u503c\u7684\uff0c\u5177\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff08\u5b83\u4eec\u5728\u5176\u6240\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\u5904\u6d88\u4ea1\uff09\uff0c\u5e76\u4e14\u4e0d\u80fd\u88ab\u8d4b\u503c\u3002\u8fd9\u4e2a\u975e\u8d4b\u503c\u89c4\u5219\u662f\u6709\u610f\u4e49\u7684\uff0c\u56e0\u4e3a\u8d4b\u503c\u4f1a\u7ed9\u5bf9\u8c61\u5e26\u6765\u526f\u4f5c\u7528\u3002\u56e0\u4e3a\u53f3\u503c\u6709\u8868\u8fbe\u5f0f\u8303\u56f4\uff0c\u5982\u679c\u6211\u4eec\u8981\u7ed9\u53f3\u503c\u8d4b\u503c\uff0c\u90a3\u4e48\u53f3\u503c\u4f1a\u5728\u6211\u4eec\u6709\u673a\u4f1a\u5728\u4e0b\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u4f7f\u7528\u4e0a\u6b21\u8d4b\u503c\u4e4b\u524d\u5c31\u8d85\u51fa\u4e86\u8303\u56f4\uff08\u8fd9\u4f7f\u5f97\u8d4b\u503c\u6beb\u65e0\u7528\u5904\uff09\uff0c\u8981\u4e48\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cf\uff0c\u5728\u4e00\u4e2a\u8868\u8fbe\u5f0f\u4e2d\u591a\u6b21\u5e94\u7528\u4e00\u4e2a\u526f\u4f5c\u7528\uff08\u73b0\u5728\u60a8\u5e94\u8be5\u77e5\u9053\u8fd9\u4f1a\u5bfc\u81f4\u672a\u5b9a\u4e49\u7684\u884c\u4e3a\uff01\uff09\u3002 \u4e3a\u4e86\u652f\u6301\u79fb\u52a8\u8bed\u4e49\uff0cC++ \u5f15\u5165\u4e86\u4e09\u4e2a\u65b0\u7684\u503c\u7c7b\u578b\uff1apr-values\uff0cx-values \u548c gl-values. \u6211\u4eec\u5927\u6982\u7387\u4f1a\u5ffd\u7565\u8fd9\u4e9b\u77e5\u8bc6\uff0c\u56e0\u4e3a\u9ad8\u6548\u7684\u5b66\u4e60\u548c\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\u5e76\u4e0d\u9700\u8981\u7406\u89e3\u4ed6\u4eec\u3002\u5982\u679c\u4f60\u611f\u5174\u8da3\uff0c cppreference.com \u6709\u4e00\u4e2a\u5e7f\u6cdb\u7684\u8868\u8fbe\u7ed9\u6bcf\u4e00\u4e2a\u53d8\u91cf\u7c7b\u578b\uff0c\u540c\u65f6\u6709\u66f4\u591a\u5173\u4e8e\u4ed6\u4eec\u7684\u7ec6\u8282 L-value references \u5728 C++ \u4e4b\u524d\uff0cC++ \u4e2d\u53ea\u6709\u4e00\u4e2a\u7c7b\u578b\u7684\u5f15\u7528\uff0c\u5e76\u4e14\u56e0\u6b64\u5b83\u4ec5\u4ec5\u88ab\u53eb\u505a\u5f15\u7528\u3002\u7136\u800c\uff0c\u5728 C++11 \u4e2d\uff0c\u5b83\u6709\u65f6\u5019\u4e5f\u88ab\u53eb\u505a l-value \u5f15\u7528\u3002L-value \u5f15\u7528\u53ea\u80fd\u7531\u53ef\u4fee\u6539\u7684\u5de6\u503c\u6765\u521d\u59cb\u5316\u3002 L-value reference Can be initialized with Can modify Modifiable l-values Yes Yes Non-modifiable l-values No No R-values No No \u6307\u5411\u5e38\u5bf9\u8c61\u7684 l-value \u53ef\u4ee5\u88ab\u4f7f\u7528 l-value \u548c r-value \u6765\u521d\u59cb\u5316\uff0c\u7136\u800c\uff0c\u8fd9\u4e9b\u503c\u4e0d\u80fd\u88ab\u4fee\u6539\u3002 L-value reference to const Can be initialized with Can modify Modifiable l-values Yes No Non-modifiable l-values Yes No R-values Yes No \u5e38\u5bf9\u8c61\u7684\u5de6\u503c\u5f15\u7528\u975e\u5e38\u6709\u7528\uff0c\u56e0\u4e3a\u4ed6\u4eec\u5141\u8bb8\u4f60\u4f20\u4efb\u4f55\u7c7b\u578b\u7684\u53c2\u6570\uff08l-value \u6216 r-value\uff09\u8fdb\u5165\u4e00\u4e2a\u51fd\u6570\uff0c\u800c\u65e0\u9700\u62f7\u8d1d\u4e00\u4efd\u3002","title":"\u5de6\u503c\u548c\u53f3\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#r-value","text":"C++ \u6dfb\u52a0\u4e86\u4e00\u4e2a\u65b0\u7684\u53eb\u505a\u53f3\u503c\u5f15\u7528\uff08r-value reference\uff09\u3002\u53f3\u503c\u5f15\u7528\u662f\u88ab\u8bbe\u8ba1\u6765\u53ea\u80fd\u4f7f\u7528\u53f3\u503c\u521d\u59cb\u5316\u7684\u3002\u5de6\u503c\u662f\u5f15\u7528\u4f7f\u7528\u4e00\u4e2a & \u521b\u5efa\u7684\uff0c\u800c\u53f3\u503c\u5f15\u7528\u4f7f\u7528\u4e24\u4e2a & \u6765\u521b\u5efa\u3002 int x { 5 }; int & lref { x }; // l-value reference initialized with l-value x int && rref { 5 }; // r-value reference initialized with r-value 5 R-value reference Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes Yes R-value reference to const Can be initialized with Can modify Modifiable l-values No No Non-modifiable l-values No No R-values Yes No \u53f3\u503c\u5f15\u7528\u6709\u4e24\u4e2a\u5f88\u6709\u7528\u7684\u6027\u8d28\u3002\u7b2c\u4e00\uff0c\u53f3\u503c\u5f15\u7528\u6269\u5c55\u4e86\u539f\u521d\u59cb\u5316\u503c\u7684\u751f\u547d\u5468\u671f\u5230\u53f3\u503c\u5f15\u7528\u7684\u751f\u547d\u5468\u671f\uff08\u6307\u5411\u5e38\u5bf9\u8c61\u7684\u5de6\u503c\u5f15\u7528\u4e5f\u53ef\u4ee5\u505a\u5230\uff09\u3002\u7b2c\u4e8c\uff0c\u975e\u5e38\u91cf\u5f15\u7528\u5141\u8bb8\u4f60\u4fee\u6539\u53f3\u503c\u3002 \u8ba9\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50\uff1a # include <iostream> class Fraction { private : int m_numerator ; int m_denominator ; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { auto && rref { Fraction { 3 , 5 } }; // r-value reference to temporary Fraction // f1 of operator<< binds to the temporary, no copies are created. std :: cout << rref << '\\n' ; return 0 ; } // rref (and the temporary Fraction) goes out of scope here \u7a0b\u5e8f\u6253\u5370 3/5 \u4f5c\u4e3a\u4e00\u4e2a\u533f\u540d\u5bf9\u8c61\uff0c Fraction(w3, 5) \u5c06\u4f1a\u6b63\u5e38\u7684\u5728\u5b9a\u4e49\u5b83\u8bed\u53e5\u7ed3\u675f\u65f6\u79bb\u5f00\u4f5c\u7528\u57df\u3002\u7136\u800c\uff0c\u56e0\u4e3a\u6211\u4eec\u4ee5\u5b83\u6765\u521d\u59cb\u5316\u4e86\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\uff0c\u4ed6\u7684\u58f0\u660e\u5468\u671f\u5c31\u6301\u7eed\u5230\u4e86\u8bed\u53e5\u5757\u7ed3\u675f\u3002\u6211\u4eec\u7d27\u63a5\u7740\u53ef\u4ee5\u4f7f\u7528\u53f3\u503c\u5f15\u7528\u6765\u6253\u5370 Fraction \u7684\u503c\u3002 \u597d\u7684\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u66f4\u52a0\u76f4\u89c2\u7684\u4f8b\u5b50\uff1a # include <iostream> int main () { int && rref { 5 }; // because we're initializing an r-value reference with a literal, a temporary with value 5 is created here rref = 10 ; std :: cout << rref << '\\n' ; return 0 ; } \u7a0b\u5e8f\u6253\u5370 10 \u4f7f\u7528\u4e00\u4e2a\u5b57\u9762\u503c\u6765\u521d\u59cb\u5316\u4e00\u4e2a\u53f3\u503c\uff0c\u7136\u540e\u80fd\u591f\u6539\u53d8\u90a3\u4e2a\u53f3\u503c\u3002\u8fd9\u662f\u56e0\u4e3a\uff0c\u5f53\u4f7f\u7528\u5b57\u9762\u503c\u6765\u521d\u59cb\u5316\u53f3\u503c\uff0c\u4f1a\u521b\u5efa\u4e00\u5757\u4e34\u65f6\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5\u5f15\u7528\u662f\u4e00\u5757\u4e34\u65f6\u7a7a\u95f4\u7684\u5f15\u7528\uff0c\u800c\u4e0d\u662f\u5b57\u9762\u503c\u7684\u5f15\u7528\u3002 \u53f3\u503c\u5f15\u7528\u5728\u4ee5\u4e0a\u7684\u4ee3\u7801\u4f8b\u5b50\u4e2d\u7684\u4f7f\u7528\u65b9\u5f0f\u5e76\u4e0d\u5f88\u5e38\u89c1\u3002","title":"R-value \u5f15\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#_2","text":"\u53f3\u503c\u5f15\u7528\u7ecf\u5e38\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u6765\u4f7f\u7528\u3002\u6700\u6709\u7528\u7684\u65b9\u5f0f\u5c31\u662f\u5f53\u51fd\u6570\u91cd\u8f7d\u7684\u65f6\u5019\u4f60\u5e0c\u671b\u5bf9\u5f85\u5de6\u503c\u548c\u53f3\u503c\u7684\u65f6\u5019\u6709\u4e0d\u540c\u7684\u8868\u73b0\u3002 void fun ( const int & lref ) // l-value arguments will select this function { std :: cout << \"l-value reference to const \\n \" ; } void fun ( int && rref ) // r-value arguments will select this function { std :: cout << \"r-value reference \\n \" ; } int main () { int x { 5 }; fun ( x ); // l-value argument calls l-value version of function fun ( 5 ); // r-value argument calls r-value version of function return 0 ; } \u8fd9\u4f1a\u6253\u5370\uff1a l - value reference to const r - value reference \u5982\u4f60\u6240\u89c1\uff0c\u5f53\u4f20\u5165\u4e00\u4e2a\u5de6\u503c\u7684\u65f6\u5019\uff0c\u91cd\u8f7d\u51fd\u6570\u89e3\u6790\u5230\u4e86\u5de6\u503c\u5f15\u7528\u7684\u7248\u672c\u3002\u5f53\u4f20\u5165\u53f3\u503c\u7684\u65f6\u5019\uff0c\u91cd\u8f7d\u51fd\u6570\u89e3\u6790\u5230\u4e86\u53f3\u503c\u5f15\u7528\u7684\u7248\u672c\uff08\u8fd9\u662f\u6bd4\u5de6\u503c\u5e38\u5f15\u7528\u66f4\u597d\u7684\u4e00\u4e2a\u529e\u6cd5\uff09 \u4e3a\u4ec0\u4e48\u4f60\u4f1a\u60f3\u8981\u8fd9\u6837\u505a\u5462\uff1f\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u8be6\u7ec6\u8ba8\u8bba\uff0c\u4e0d\u5f97\u4e0d\u8bf4\uff0c\u8fd9\u662f\u79fb\u52a8\u8bed\u4e49\u7684\u91cd\u8981\u90e8\u5206\u3002 \u4e00\u4e2a\u6709\u8da3\u7684\u7b14\u8bb0\uff1a int && ref { 5 }; fun ( ref ); \u4e8b\u5b9e\u4e0a\uff0c\u8c03\u7528\u7684\u662f\u5de6\u503c\u7248\u672c\u7684\u51fd\u6570\uff01\u5c3d\u7ba1\u53d8\u91cf ref \u6709\u4e00\u4e2a\u6574\u578b\u7684\u53f3\u503c\u5f15\u7528\uff0c\u4f46\u662f\u5b83\u672c\u8eab\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u5de6\u503c\uff08\u6240\u6709\u7684\u547d\u540d\u53d8\u91cf\u90fd\u662f\u5982\u6b64\uff09\u3002\u6df7\u6dc6\u7684\u539f\u56e0\u662f\u53f3\u503c\u8fd9\u4e2a\u8bcd\u5728\u4e0d\u540c\u7684\u4e0a\u4e0b\u6587\u4e2d\u4f7f\u7528\u3002\u4f60\u53ef\u4ee5\u8fd9\u6837\u60f3\uff1a\u547d\u540d\u7684\u5bf9\u8c61\u662f\u5de6\u503c\uff0c\u533f\u540d\u7684\u5bf9\u8c61\u662f\u53f3\u503c\u3002\u547d\u540d\u5bf9\u8c61\u548c\u533f\u540d\u5bf9\u8c61\u4e0d\u4f9d\u8d56\u4e8e\u5b83\u662f\u5de6\u503c\u6216\u8005\u53f3\u503c\u3002\u6216\u8005\uff0c\u8fd9\u6837\u8bf4\uff0c\u5982\u679c\u53f3\u503c\u5f15\u7528\u88ab\u53eb\u505a\u4efb\u4f55\u5176\u4ed6\u7684\u540d\u5b57\uff0c\u8fd9\u4e2a\u7591\u60d1\u5c31\u4e0d\u4f1a\u5b58\u5728\u3002","title":"\u53f3\u503c\u5f15\u7528\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#_3","text":"\u4f60\u5e94\u8be5\u51e0\u4e4e\u4e0d\u4f1a\u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\uff0c\u540c\u6837\u4f60\u4e5f\u5e94\u8be5\u51e0\u4e4e\u4e0d\u8fd4\u56de\u4e00\u4e2a\u5de6\u503c\u5f15\u7528\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4f1a\u8fd4\u56de\u4e00\u4e2a\u60ac\u7a7a\u5f15\u7528\u5f53\u5f15\u7528\u5bf9\u8c61\u79bb\u5f00\u51fd\u6570\u7684\u4f5c\u7528\u57df\u65f6","title":"\u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.2-r-value-reference/#quiz-time","text":"1) \u6807\u8bb0\u54ea\u4e00\u4e2a\u5b57\u6bcd\u5bf9\u5e94\u7684\u8bed\u53e5\u7f16\u8bd1\u5931\u8d25\uff1a int main () { int x {}; // l-value references int & ref1 { x }; // A int & ref2 { 5 }; // B const int & ref3 { x }; // C const int & ref4 { 5 }; // D // r-value references int && ref5 { x }; // E int && ref6 { 5 }; // F const int && ref7 { x }; // G const int && ref8 { 5 }; // H return 0 ; } B, E, and G \u4f1a\u7f16\u8bd1\u5931\u8d25","title":"Quiz time"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/","text":"15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c \u00b6 By Alex on February 26 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.17 \u5728\u8bfe\u7a0b 15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd \u4e2d, \u6211\u4eec\u4e86\u89e3\u5230\u4e86 std::auto ptr \uff0c\u8ba8\u8bba\u4e86\u5bf9\u79fb\u52a8\u8bed\u4e49\u7684\u9700\u6c42\uff0c\u5e76\u7814\u7a76\u4e86\u4e3a\u590d\u5236\u8bed\u4e49\u8bbe\u8ba1\u7684\u51fd\u6570\uff08\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u590d\u5236\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u4ee5\u53ca\u88ab\u91cd\u65b0\u5b9a\u4e49\u4e3a\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u65f6\u51fa\u73b0\u7684\u4e00\u4e9b\u7f3a\u70b9\u3002 \u5728\u8fd9\u5802\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u6df1\u5165\u4e86\u89e3 C++11 \u662f\u5982\u4f55\u901a\u8fc7 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97 \u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002 \u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c \u00b6 \u9996\u5148\uff0c\u8ba9\u6211\u4eec\u590d\u4e60\u4e00\u4e0b\u62f7\u8d1d\u8bed\u4e49( copy semantics )\u3002 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \u901a\u8fc7\u521b\u5efa\u4e00\u4efd\u8be5\u7c7b\u7684\u62f7\u8d1d\u6765\u521d\u59cb\u5316\u4e00\u4e2a\u7c7b\u3002 \u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26 \u901a\u8fc7\u62f7\u8d1d\u4e00\u4e2a\u5df2\u5b58\u5728\u7c7b\u5bf9\u8c61\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u4e00\u4e2a\u7c7b\u6ca1\u6709\u663e\u5f0f\u7684\u63d0\u4f9b\uff0cC++ \u5c06\u4f1a\u9ed8\u8ba4\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002\u8fd9\u4e9b\u7531\u7f16\u8bd1\u5668\u63d0\u4f9b\u7684\u51fd\u6570\u4ec5\u5b9e\u73b0\u4e86\u6d45\u62f7\u8d1d\uff0c\u5728\u8fdb\u884c\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u7c7b\u5bf9\u8c61\u4e0a\u4f7f\u7528\u53ef\u80fd\u9020\u6210\u95ee\u9898\u3002\u56e0\u6b64\u5728\u6d89\u53ca\u52a8\u6001\u5185\u5b58\u5206\u914d\u7684\u7c7b\u5fc5\u987b\u901a\u8fc7\u91cd\u5199\u8fd9\u4e9b\u51fd\u6570\u6765\u8fdb\u884c\u6df1\u62f7\u8d1d\u3002 \u56de\u5230\u6211\u4eec\u672c\u7ae0\u7684\u524d\u4e9b\u8bfe\u4e2d\u63d0\u5230\u7684 Auto_ptr \u667a\u80fd\u6307\u9488\u7c7b\u7684\u4f8b\u5b50\uff0c\u8ba9\u6211\u4eec\u770b\u4e00\u773c\u5b9e\u73b0\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u8fd8\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u6765\u6d4b\u8bd5\u4ed6\u4eec\uff1a template < class T > class Auto_ptr3 { T * m_ptr ; public : Auto_ptr3 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr3 () { delete m_ptr ; } // Copy constructor \u62f7\u8d1d\u6784\u9020\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 ( const Auto_ptr3 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Copy assignment // \u62f7\u8d1d\u8d4b\u503c\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 & operator = ( const Auto_ptr3 & a ) { // Self-assignment detection // \u81ea\u8d4b\u503c\u68c0\u6d4b if ( & a == this ) return * this ; // \u91ca\u653e\u6240\u6709\u6301\u6709\u7684\u8d44\u6e90 // Release any resource we're holding delete m_ptr ; // \u62f7\u8d1d\u8d44\u6e90 // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr3 < Resource > generateResource () { Auto_ptr3 < Resource > res ( new Resource ); return res ; // this return value will invoke the copy constructor // \u8fd9\u4e2a\u8fd4\u56de\u503c\u5c06\u4f1a\u89e6\u53d1\u62f7\u8d1d\u6784\u9020\u51fd\u6570 } int main () { Auto_ptr3 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the copy assignment // \u8fd9\u4e2a\u8d4b\u503c\u5c06\u4f1a\u89e6\u53d1\u8d4b\u503c\u8d4b\u503c\u51fd\u6570 return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u53eb\u505a generateResource() \u7684\u51fd\u6570\u6765\u521b\u5efa\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5c01\u88c5\u7684 Resource \uff0c\u5e76\u4e14\u5c06\u5b83\u4f20\u56de\u5230 main \u51fd\u6570\u4e2d\u3002 main \u51fd\u6570\u7d27\u63a5\u7740\u5c06\u5176\u8d4b\u503c\u7ed9\u5df2\u7ecf\u5b58\u5728\u7684 Auto_ptr3 \u5bf9\u8c61 mainres \u3002 \u5f53\u8fd9\u4e2a\u7a0b\u5e8f\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6253\u5370\uff1a Resource acquired Resource acquired Resource destroyed Resource acquired Resource destroyed Resource destroyed \uff08\u6ce8\u610f\uff1a\u4f60\u53ef\u80fd\u53ea\u5f97\u52304\u4e2a\u8f93\u51fa\uff0c\u5982\u679c\u4f60\u7684\u7f16\u8bd1\u5668 \u7701\u7565\\\u4f18\u5316 \u4e86 generateResource() \u7684\u8fd4\u56de\u503c\uff09 \u90a3\u4f1a\u6709\u5f88\u591a\u6b21\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u4ec5\u4ec5\u4e3a\u4e86\u8fd9\u6837\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u8ba9\u6211\u4eec\u4ed4\u7ec6\u770b\u770b\uff0c\u7a0b\u5e8f\u91cc\u6709 6 \u4e2a\u5173\u952e\u6b65\u9aa4\uff08\u6bcf\u6b21\u6253\u5370\u90fd\u53d1\u751f\u4e00\u4ef6\uff09\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u521b\u5efa\u5e76\u7528\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684 Resource \u3002 2; Res \u503c\u8fd4\u56de\u5230 main() \u3002\u901a\u8fc7\u503c\u8fd4\u56de\u7684\u539f\u56e0\u662f\uff0c res \u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf \u2014\u2014 \u5b83\u4e0d\u80fd\u88ab\u901a\u8fc7\u5730\u5740\u6216\u5f15\u7528\u8fd4\u56de\uff0c\u56e0\u4e3a res \u5c06\u4f1a\u5728 generateResource() \u51fd\u6570\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \u7ed3\u675f\u3002\u56e0\u4e3a res \u662f\u62f7\u8d1d\u6784\u9020\uff0c\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Resource \u5728\u8fd9\u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u7b2c\u4e8c\u6b21 \"Resource acquired\"\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u9500\u6bc1\u4e4b\u524d\u521b\u5efa\u7684 Resource \uff0c\u8fd9\u89e6\u53d1\u4e86\u7b2c\u4e00\u4e2a \"Resource destroyed\"\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u8d4b\u503c\u8fdb mainres \u901a\u8fc7\u62f7\u8d1d\u8d4b\u503c\u3002\u56e0\u4e3a\u6211\u4eec\u7684\u62f7\u8d1d\u8d4b\u503c\u4e5f\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Reource \u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u53e6\u4e00\u4e2a \"Resource acquired\"\u3002 5; \u8d4b\u503c\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u9500\u6bc1\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a \"Resource acquired\"\u3002 6; \u5728 main() \u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \"Resource destroyed\"\u3002 \u56e0\u6b64\uff0c\u7b80\u800c\u8a00\u4e4b\uff0c\u56e0\u4e3a\u6211\u4eec\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6765\u62f7\u8d1d\u6784\u9020 res \u6210\u4e00\u4e2a\u4e34\u65f6\u53d8\u91cf\uff0c\u5e76\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u62f7\u8d1d\u4e34\u65f6\u53d8\u91cf\u8fdb\u5165 mainres \uff0c\u6211\u4eec\u6700\u7ec8\u5206\u914d\u548c\u9500\u6bc1\u4e863\u4e2a\u72ec\u7acb\u7684 objects \u603b\u8ba1\u3002 \u8fd9\u662f\u4f4e\u6548\u7684\uff0c\u4f46\u662f\u5b83\u81f3\u5c11\u4e0d\u4f1a\u5d29\u6e83\u3002 \u7136\u800c\u5982\u679c\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u505a\u7684\u66f4\u597d\u3002 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c \u00b6 C++ \u5b9a\u4e49\u4e86\u4e24\u4e2a\u65b0\u7684\u51fd\u6570\u6765\u5b9e\u73b0 \u201c\u79fb\u52a8\u8bed\u4e49\u201d \uff1a\u4e00\u4e2a\u662f \u79fb\u52a8\u6784\u9020\u51fd\u6570 \uff0c\u4e00\u4e2a\u662f \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u3002\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u7684\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u7684\u76ee\u6807\u662f\u521b\u5efa\u4e00\u4efd\u5bf9\u8c61\u7684\u62f7\u8d1d\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8d4b\u503c\u8fd0\u7b97\u7b26\u662f\u6765\u79fb\u52a8\u8d44\u6e90\u7684 \u6240\u6709\u6743(ownership) \uff0c\u4ece\u4e00\u4e2a\u5bf9\u8c61\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff08\u8fd9\u6837\u505a\u6d88\u8017\u7684\u8d44\u6e90\u5c11\u5f88\u591a\uff09\u3002 \u5b9a\u4e49\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u548c\u62f7\u8d1d\u7684\u540c\u7c7b\u51fd\u6570\u6240\u5b9e\u73b0\u7684\u76ee\u7684\u76f8\u4f3c\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u590d\u5236\u51fd\u6570\u7684\u98ce\u683c\u91c7\u7528 \u5e38\u91cf\u5de6\u503c\u5f15\u7528 \u53c2\u6570\uff0c\u79fb\u52a8\u51fd\u6570\u7684\u98ce\u683c\u4f7f\u7528\u4e86 \u975e\u5e38\u91cf\u53f3\u503c\u5f15\u7528 \u53c2\u6570\u3002 \u6709\u4e00\u4e2a\u548c\u4e4b\u524d\u7684 Auto_ptr3 \u76f8\u540c\u7684\u7c7b\uff0c\u6dfb\u52a0\u4e86\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u4e1c\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002\u6211\u4eec\u7559\u4e0b\u4e86\u8fdb\u884c \u6df1\u62f7\u8d1d \u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u4ec5\u4ec5\u4e3a\u4e86\u4f5c\u6bd4\u8f83\u3002 # include <iostream> template < class T > class Auto_ptr4 { T * m_ptr ; public : Auto_ptr4 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr4 () { delete m_ptr ; } // Copy constructor // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 ( const Auto_ptr4 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 ( Auto_ptr4 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; // we'll talk more about this line below } // Copy assignment // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 & operator = ( const Auto_ptr4 & a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 & operator = ( Auto_ptr4 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; // we'll talk more about this line below return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr4 < Resource > generateResource () { Auto_ptr4 < Resource > res ( new Resource ); return res ; // this return value will invoke the move constructor } int main () { Auto_ptr4 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the move assignment return 0 ; } \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u975e\u5e38\u7b80\u5355\u3002\u4e0d\u518d\u5bf9\u539f\u5bf9\u8c61\u8fdb\u884c\u6df1\u62f7\u8d1d\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\uff0c\u4ec5\u4ec5\u7b80\u5355\u5730\u4ece\u6e90\u5bf9\u8c61 \u79fb\u52a8\uff08\u5077\uff09 \u5230\u76ee\u6807\u5bf9\u8c61\u3002\u5176\u5b9e\u5c31\u662f\u6d89\u53ca\u4e86\u4ece\u539f\u6307\u9488\u5230\u76ee\u5bf9\u8c61\u7684\u6d45\u62f7\u8d1d\uff0c\u7136\u540e\u539f\u6307\u9488\u8bbe\u5b9a\u4e3a null \u3002 \u6211\u4eec\u8fd0\u884c\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u6253\u5370\uff1a Resource acquired Resource destroyed \u90a3\u597d\u5f97\u591a\uff1a \u7a0b\u5e8f\u7684\u6d41\u7a0b\u548c\u4ee5\u524d\u76f8\u4f3c\uff0c\u7136\u800c\uff0c\u4e0d\u518d\u8c03\u7528\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u800c\u8fd9\u4e2a\u7a0b\u5e8f\u8c03\u7528\u4e86\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u8ba9\u6211\u4eec\u6df1\u5165\u6765\u770b\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u7528\u52a8\u6001\u5206\u914d\u521b\u5efa\u548c\u521d\u59cb\u5316\u3002 2; Res \u901a\u8fc7\u503c\u8fd4\u56de\u5230 main() \u3002 Res \u88ab\u79fb\u52a8\u6784\u9020\u8fdb\u4e00\u4e2a\u4e34\u65f6\u5bf9\u8c61\uff0c\u8f6c\u4e49\u8fd9\u4e2a\u5728 res \u4e2d\u52a8\u6001\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u65b9\u8ba8\u8bba\u4e3a\u4f55\u8fd9\u6837\u505a\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u56e0\u4e3a res \u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e34\u65f6\u533a\uff09\uff0c\u6ca1\u4ec0\u4e48\u5176\u4ed6\u7684\u53d1\u751f\uff08delete nullptr \u4e0d\u4f1a\u53d1\u751f\u4ec0\u4e48\uff09\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u79fb\u52a8\u8d4b\u503c\u7ed9 mainres \u3002\u8fd9\u6b21\u8f6c\u79fb\u4e86\u52a8\u6001\u521b\u5efa\u5e76\u50a8\u5b58\u5728\u4e34\u65f6\u533a\u7684\u5bf9\u8c61\u7ed9 mainres \u3002 5; \u5728\u590d\u5236\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u7684\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u4e8e\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\u3002\u7136\u800c\u56e0\u4e3a\u4e34\u65f6\u533a\u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u88ab\u79fb\u52a8\u5230\u4e86 mainres \u4e0a\uff09\uff0c\u56e0\u6b64\u8fd9\u4e00\u6b65\u4e5f\u4ec0\u4e48\u90fd\u4e0d\u4f1a\u53d1\u751f\u3002 6; \u5728 main() \u51fd\u6570\u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u4e8e\uff0c\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \u201cResource destroyed\u201d \u6253\u5370\u5728\u5c4f\u5e55\u4e0a\u3002 \u56e0\u6b64\uff0c\u4e0d\u518d\u62f7\u8d1d Resource \u4e24\u6b21\uff08\u4e00\u6b21\u4e3a\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6b21\u4e3a\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u6211\u4eec\u79fb\u52a8\u4e86\u5b83\u4e24\u6b21\u3002\u8fd9\u66f4\u9ad8\u6548\uff0c\u56e0\u4e3a Resource \u4ec5\u4ec5\u88ab\u6784\u9020\u548c\u9500\u6bc1\u4e00\u6b21\uff0c\u800c\u4e0d\u662f\u4e09\u6b21\u3002 \u4f55\u65f6\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \u00b6 \u5f53\u90a3\u4e9b\u51fd\u6570\u88ab\u8c03\u7528\uff0c\u5e76\u4e14\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u8fd0\u7b97\u7b26\u7684\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u65f6\uff0c\u4f1a\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u6700\u5178\u578b\u7684\u662f\uff0c\u53f3\u503c\u4f1a\u662f\u4e00\u4e2a\u5b57\u9762\u91cf(literal)\u6216\u4e00\u4e2a\u4e34\u65f6\u503c\u3002 \u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u4e0d\u4f1a\u88ab\u9ed8\u8ba4\u63d0\u4f9b\uff0c\u9664\u975e\u8be5\u7c7b\u6ca1\u6709\u5b9a\u4e49\u4efb\u4f55 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \uff0c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff0c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \uff0c\u6216\u8005**\u6790\u6784\u51fd\u6570** \u3002\u7136\u800c\uff0c\u9ed8\u8ba4\u7684 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \u53ea\u4f1a\u505a\u548c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u76f8\u4f3c\u7684\u4e8b\u60c5\uff08\u5236\u4f5c\u62f7\u8d1d\uff0c\u4e0d\u79fb\u52a8\uff09\u3002 \u89c4\u5b9a\uff1a\u5982\u679c\u4f60\u60f3\u8981\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\u4e00\u4e2a\u3002 \u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u8fdb\u56e0\u7d20 \u00b6 \u4f60\u73b0\u5728\u4e86\u89e3\u4e86\u8db3\u591f\u591a\u7684\u4e0a\u4e0b\u6587\uff0c\u7406\u89e3\u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u952e\u56e0\u7d20\u3002 \u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u8fdb\u884c\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u5de6\u503c\uff0c\u6211\u4eec\u552f\u4e00\u80fd\u505a\u7684\u5c31\u662f\u62f7\u8d1d\u8fd9\u4e2a\u5de6\u503c\u3002\u6211\u4eec\u4e0d\u80fd\u5047\u8bbe\u4fee\u6539\u5b83\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u5728\u4e4b\u540e\u7684\u7a0b\u5e8f\u4e2d\u88ab\u4f7f\u7528\u3002\u5c31\u597d\u50cf\u5982\u679c\u6709\u4e00\u4e2a\u8868\u8fbe\u5f0f a = b \uff0c \u6211\u4eec\u65e0\u8bba\u5982\u4f55\u4e0d\u4f1a\u671f\u5f85b\u88ab\u6539\u53d8 \u3002 \u7136\u800c\uff0c\u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u505a\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\uff0c\u6211\u4eec\u77e5\u9053\u53f3\u503c\u4ec5\u4ec5\u662f\u4e00\u4e2a\u67d0\u4e2a\u7c7b\u578b\u7684\u4e34\u65f6\u503c\u3002\u76f8\u6bd4\u62f7\u8d1d\u4ed6\uff08\u82b1\u8d39\u66f4\u591a\u8d44\u6e90\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u79fb\u52a8\u5b83\u7684\u8d44\u6e90\uff08\u82b1\u8d39\u975e\u5e38\u5c11\uff09\u7ed9\u6211\u4eec\u6b63\u5728\u521b\u5efa\u6216\u8005\u8d4b\u503c\u7684\u8d44\u6e90\u3002\u8fd9\u662f\u5b9e\u73b0\u8d77\u6765\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u4e34\u65f6\u503c\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\uff0c\u56e0\u6b64\u6211\u4eec\u77e5\u9053\u5b83\u5c06\u6c38\u8fdc\u4e0d\u4f1a\u518d\u88ab\u518d\u6b21\u4f7f\u7528\uff01 C++11\uff0c\u901a\u8fc7\u53f3\u503c\u5f15\u7528\uff0c\u7ed9\u6211\u4eec\u80fd\u529b\u6765\u63d0\u4f9b\u4e00\u4e2a\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u6216\u4e00\u4e2a\u5de6\u503c\uff0c\u6709\u4e86\u8fd9\u4e2a\u80fd\u529b\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u66f4\u7b80\u5355\uff0c\u66f4\u9ad8\u6548\u7684\u51b3\u5b9a\u6211\u4eec\u7f16\u5199\u7684\u5bf9\u8c61\u7684\u884c\u4e3a\u3002 \u79fb\u52a8\u51fd\u6570\u5e94\u59cb\u7ec8\u4f7f\u4e24\u4e2a\u5bf9\u8c61\u5904\u4e8e\u5b9a\u4e49\u826f\u597d\u7684\u72b6\u6001 \u00b6 \u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u8bbe\u7f6e a.m_ptr \u4e3a nullptr \u3002\u8fd9\u662f\u770b\u8d77\u6765\u4f3c\u4e4e\u662f\u6ca1\u4ec0\u4e48\u7528\u2014\u2014\u2014\u2014\u6bd5\u7adf\uff0c\u5982\u679c \u201ca\u201d \u662f\u4e00\u4e2a\u4e34\u65f6\u53f3\u503c\uff0c\u4e3a\u4ec0\u4e48\u963b\u6b62\u201c\u6e05\u7406\u201d\uff0c\u5982\u679c \u201ca\u201d \u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u4e2a\u95ee\u9898\u7684\u7b54\u6848\u5f88\u7b80\u5355\uff1a\u5f53 \u201ca\u201d \u79bb\u5f00\u4f5c\u7528\u57df\uff0c \"a\" \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\uff0c\u5e76\u4e14 a.m_ptr \u5c06\u4f1a\u88ab\u5220\u9664\u3002\u5982\u679c\u5728\u90a3\u65f6 a.m_ptr \u4ecd\u7136\u6307\u7740\u548c m_ptr \u76f8\u540c\u7684\u7684\u8d44\u6e90\uff0c m_ptr \u5c31\u4f1a\u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\u3002\u5f53\u5bf9\u8c61\u5bf9\u8c61\u5305\u542b\u7684 m_ptr \u6700\u7ec8\u88ab\u4f7f\u7528\uff08\u6216\u8005\u9500\u6bc1\uff09\uff0c\u5c06\u4f1a\u53d1\u751f\u672a\u5b9a\u4e49\u64cd\u4f5c(undefiend behavior)\u3002 \u53e6\u5916\uff0c\u5728\u4e0b\u8282\u8bfe\u4e2d\u6211\u4eec\u5c06\u4f1a\u770b\u5230\u4e00\u4e9b\u4f8b\u5b50\u5f53 a \u53ef\u4ee5\u662f\u4e00\u4e2a\u5de6\u503c\u65f6\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c a \u5c06\u4e0d\u4f1a\u88ab\u7acb\u5373\u9500\u6bc1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u58f0\u660e\u5468\u671f\u7ed3\u675f\u524d\u67e5\u8be2\u3002 \u5de6\u503c\u901a\u8fc7\u79fb\u52a8\u503c\u8fd4\u56de\uff0c\u66ff\u4ee3\u590d\u5236\u8fd4\u56de \u00b6 \u5728 \u4e4b\u524d\u7684\u4f8b\u5b50\u91cc\uff0c Auto_ptr4 \u4e2d\u7684 generateResource() \uff0c\u5f53\u53d8\u91cf res \u88ab\u901a\u8fc7\u503c\u8fd4\u56de\uff0c\u5b83\u88ab\u79fb\u52a8\u800c\u4e0d\u662f\u62f7\u8d1d\uff0c\u5373\u4fbf res \u59cb\u7ec8\u662f\u4e00\u4e2a\u5de6\u503c\u3002C++ \u89c4\u8303\u4e2d\u6709\u4e00\u4e2a\u7279\u4f8b\u8fd9\u6837\u63cf\u8ff0\uff1a\u901a\u8fc7\u503c\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5bf9\u8c61\u5c06\u81ea\u52a8\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u5373\u4fbf\u4ed6\u4eec\u662f\u4e00\u4e2a\u5de6\u503c\u3002\u8fd9\u5f88\u6709\u610f\u4e49\uff0c\u56e0\u4e3a res \u65e0\u8bba\u5982\u4f55\u5373\u5c06\u88ab\u9500\u6bc1\u5728\u51fd\u6570\u7684\u672b\u5c3e\uff01\u6211\u4eec\u53ef\u4ee5\u4e5f\u5077\u8d70\u5b83\u7684\u8d44\u6e90\u800c\u4e0d\u662f\u505a\u6ca1\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c3d\u7ba1\u7f16\u8bd1\u5668\u53ef\u4ee5\u79fb\u52a8\u5de6\u503c\u4f5c\u4e3a\u51fd\u6570\u7684\u8fd4\u56de\u503c\uff08Although the compiler can move l-value return values\uff09\uff0c\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\uff0c\u53ef\u4ee5\u505a\u7684\u66f4\u597d\uff0c\u901a\u8fc7\u7b80\u5355\u7684\u6dd8\u6c70\u5b8c\u5168\u62f7\u8d1d\uff08\u907f\u514d\u62f7\u8d1d\u800c\u6216\u5168\u90e8\u4f7f\u7528\u79fb\u52a8\uff09\u3002\u5728\u8fd9\u6837\u7684\u4f8b\u5b50\u4e2d\uff0c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u90fd\u4e0d\u4f1a\u88ab\u8c03\u7528\u3002 \u7981\u7528\u62f7\u8d1d \u00b6 \u5728 \u4e0a\u65b9\u7684 Auto_ptr4 \u7c7b\u4e2d\uff0c\u6211\u4eec\u7559\u4e0b\u4e86 copy \u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u4e3a\u4e86\u6bd4\u8f83\u7684\u76ee\u7684\u3002\u4f46\u5728\u5f00\u542f\u79fb\u52a8(mode-enabled)\u66f4\u613f\u610f\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u786e\u4fdd\u62f7\u8d1d\u4e0d\u4f1a\u53d1\u751f\u3002\u5728\u63a5\u4e0b\u6765\u7684\u4f8b\u5b50\u4e2d Auto_ptr \u7c7b\uff0c\u6211\u4eec\u60f3\u8981\u62f7\u8d1d\u6211\u4eec\u7684 templated \u5bf9\u8c61 T \u2014\u2014\u2014\u2014 \u4e0d\u4ec5\u56e0\u4e3a\u5b83\u7684\u5f00\u9500\u5f88\u5927\uff0c\u800c\u4e14 T \u7c7b\u53ef\u80fd\u751a\u81f3\u4e0d\u652f\u6301\u62f7\u8d1d\uff01 \u8fd9\u662f Auto_ptr \u652f\u6301\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4e0d\u652f\u6301\u62f7\u8d1d\u8bed\u4e49\u7684\u7248\u672c\u3002 # include <iostream> template < class T > class Auto_ptr5 { T * m_ptr ; public : Auto_ptr5 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr5 () { delete m_ptr ; } // Copy constructor -- no copying allowed! Auto_ptr5 ( const Auto_ptr5 & a ) = delete ; // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 ( Auto_ptr5 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; } // Copy assignment -- no copying allowed! Auto_ptr5 & operator = ( const Auto_ptr5 & a ) = delete ; // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 & operator = ( Auto_ptr5 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; \u5982\u679c\u4f60\u5c1d\u8bd5\u901a\u8fc7\u5de6\u503c\u4f20\u4e00\u4e2a Auto_ptr5 \u5230\u4e00\u4e2a\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c06\u4f1a\u62a5\u9519\u544a\u8bc9\u4f60\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u662f\u5fc5\u987b\u7684\uff0c\u7528\u6765\u521d\u59cb\u5316\u62f7\u8d1d\u6784\u9020\u53c2\u6570\u5df2\u7ecf\u88ab\u5220\u9664\u3002\u8fd9\u5c31\u5bf9\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5e94\u8be5\u901a\u8fc7\u5e38\u5de6\u503c\u5f15\u7528\u4f20\u9012 Auto_ptr5 \uff01 Auto_ptr5 \u662f\uff08\u7ec8\u6781\uff09\u4e00\u4e2a\u5f88\u597d\u7684\u53ea\u80fd\u6307\u6b63\u7c7b\u3002\u5e76\u4e14\u4e8b\u5b9e\u4e0a\uff0c\u6807\u51c6\u5e93\u5305\u542b\u7684\u7c7b\u5df2\u7ecf\u975e\u5e38\u50cf\u8fd9\u4e2a\uff08\u4f60\u5e94\u8be5\u7528\u6807\u51c6\uff09\uff0c\u88ab\u53eb\u505a std::unique_ptr \u3002\u6211\u4eec\u5c06\u8ba8\u8bba\u66f4\u591a\u6709\u5173 std::unique_ptr \u5728\u7a0d\u540e\u7684\u7ae0\u8282\u4e2d\u3002 \u53e6\u4e00\u4e2a\u4f8b\u5b50 \u00b6 \u8ba9\u6211\u4eec\u770b\u4e00\u773c\u53e6\u4e00\u4e2a\u7c7b\u4f7f\u7528\u4e86\u52a8\u6001\u5185\u5b58\u5206\u914d\uff1a\u4e00\u4e2a\u7b80\u5355\u7684\u52a8\u6001\u6a21\u677f\u6570\u7ec4\u3002\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002 # include <iostream> template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) : m_length ( arr . m_length ) { m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; } // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u8fd9\u4e2a\u7c7b\u3002\u4e3a\u4e86\u5411\u4f60\u5c55\u793a\u8fd9\u4e2a\u7c7b\u7684\u6027\u80fd\uff0c\u6211\u4eec\u5728\u5806\u4e0a\u5206\u914d\u4e86\u4e00\u767e\u4e07\u4e2a\u6574\u578b\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u6211\u4eec\u5728 lesson 8.16 -- Timing your code \u4e2d\u5f00\u53d1\u7684\u8ba1\u65f6\u5668\u7c7b\u3002\u6211\u4eec\u5c06\u4f7f\u7528\u8fd9\u4e2a\u8ba1\u65f6\u5668\u7c7b\u6765\u5c55\u793a\u6211\u4eec\u7684\u4ee3\u7801\u8fd0\u884c\u6709\u591a\u5feb\uff0c\u5411\u4f60\u5c55\u793a\u62f7\u8d1d\u548c\u79fb\u52a8\u4e4b\u95f4\u7684\u6027\u80fd\u5dee\u8ddd\u3002 # include <iostream> # include <chrono> // for std::chrono functions // Uses the above DynamicArray class class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u4f5c\u8005\u4e4b\u4e00\u7684\u673a\u5668\u4e0a\uff0c\u5728\u53d1\u5e03\u6a21\u5f0f\u4e0b\uff0c\u8fd9\u6bb5\u7a0b\u5e8f\u5728 0.00825559 \u79d2\u5185\u6267\u884c\u5b8c\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u540c\u6837\u7684\u7a0b\u5e8f\uff0c\u4f7f\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u6765\u66ff\u6362\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002 template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) = delete ; // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) = delete ; // Move constructor DynamicArray ( DynamicArray && arr ) : m_length ( arr . m_length ), m_array ( arr . m_array ) { arr . m_length = 0 ; arr . m_array = nullptr ; } // Move assignment DynamicArray & operator = ( DynamicArray && arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = arr . m_array ; arr . m_length = 0 ; arr . m_array = nullptr ; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; # include <iostream> # include <chrono> // for std::chrono functions class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u540c\u6837\u7684\u673a\u5668\u4e0a\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5728 0.0056 \u79d2\u5185\u6267\u884c\u5b8c\u6bd5\u3002 \u6bd4\u8f83\u4e24\u4e2a\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u95f4\uff0c 0.0056 / 0.00825559 = 67.8% \u3002\u201c\u79fb\u52a8\u8bed\u4e49\u201d\u7684\u7248\u672c\u51e0\u4e4e\u5feb\u4e8633%","title":"15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#153","text":"By Alex on February 26 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.17 \u5728\u8bfe\u7a0b 15.1 \u667a\u80fd\u6307\u9488\u548c\u79fb\u52a8\u8bed\u4e49\u7684\u4ecb\u7ecd \u4e2d, \u6211\u4eec\u4e86\u89e3\u5230\u4e86 std::auto ptr \uff0c\u8ba8\u8bba\u4e86\u5bf9\u79fb\u52a8\u8bed\u4e49\u7684\u9700\u6c42\uff0c\u5e76\u7814\u7a76\u4e86\u4e3a\u590d\u5236\u8bed\u4e49\u8bbe\u8ba1\u7684\u51fd\u6570\uff08\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u590d\u5236\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u4ee5\u53ca\u88ab\u91cd\u65b0\u5b9a\u4e49\u4e3a\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u65f6\u51fa\u73b0\u7684\u4e00\u4e9b\u7f3a\u70b9\u3002 \u5728\u8fd9\u5802\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u6df1\u5165\u4e86\u89e3 C++11 \u662f\u5982\u4f55\u901a\u8fc7 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97 \u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002","title":"15.3 \u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_1","text":"\u9996\u5148\uff0c\u8ba9\u6211\u4eec\u590d\u4e60\u4e00\u4e0b\u62f7\u8d1d\u8bed\u4e49( copy semantics )\u3002 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \u901a\u8fc7\u521b\u5efa\u4e00\u4efd\u8be5\u7c7b\u7684\u62f7\u8d1d\u6765\u521d\u59cb\u5316\u4e00\u4e2a\u7c7b\u3002 \u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26 \u901a\u8fc7\u62f7\u8d1d\u4e00\u4e2a\u5df2\u5b58\u5728\u7c7b\u5bf9\u8c61\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u4e00\u4e2a\u7c7b\u6ca1\u6709\u663e\u5f0f\u7684\u63d0\u4f9b\uff0cC++ \u5c06\u4f1a\u9ed8\u8ba4\u63d0\u4f9b\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002\u8fd9\u4e9b\u7531\u7f16\u8bd1\u5668\u63d0\u4f9b\u7684\u51fd\u6570\u4ec5\u5b9e\u73b0\u4e86\u6d45\u62f7\u8d1d\uff0c\u5728\u8fdb\u884c\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u7c7b\u5bf9\u8c61\u4e0a\u4f7f\u7528\u53ef\u80fd\u9020\u6210\u95ee\u9898\u3002\u56e0\u6b64\u5728\u6d89\u53ca\u52a8\u6001\u5185\u5b58\u5206\u914d\u7684\u7c7b\u5fc5\u987b\u901a\u8fc7\u91cd\u5199\u8fd9\u4e9b\u51fd\u6570\u6765\u8fdb\u884c\u6df1\u62f7\u8d1d\u3002 \u56de\u5230\u6211\u4eec\u672c\u7ae0\u7684\u524d\u4e9b\u8bfe\u4e2d\u63d0\u5230\u7684 Auto_ptr \u667a\u80fd\u6307\u9488\u7c7b\u7684\u4f8b\u5b50\uff0c\u8ba9\u6211\u4eec\u770b\u4e00\u773c\u5b9e\u73b0\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u8fd8\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u6765\u6d4b\u8bd5\u4ed6\u4eec\uff1a template < class T > class Auto_ptr3 { T * m_ptr ; public : Auto_ptr3 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr3 () { delete m_ptr ; } // Copy constructor \u62f7\u8d1d\u6784\u9020\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 ( const Auto_ptr3 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Copy assignment // \u62f7\u8d1d\u8d4b\u503c\u51fd\u6570 // Do deep copy of a.m_ptr to m_ptr // \u4ece a.m_ptr \u5230 m_ptr \u8fdb\u884c\u6df1\u62f7\u8d1d Auto_ptr3 & operator = ( const Auto_ptr3 & a ) { // Self-assignment detection // \u81ea\u8d4b\u503c\u68c0\u6d4b if ( & a == this ) return * this ; // \u91ca\u653e\u6240\u6709\u6301\u6709\u7684\u8d44\u6e90 // Release any resource we're holding delete m_ptr ; // \u62f7\u8d1d\u8d44\u6e90 // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr3 < Resource > generateResource () { Auto_ptr3 < Resource > res ( new Resource ); return res ; // this return value will invoke the copy constructor // \u8fd9\u4e2a\u8fd4\u56de\u503c\u5c06\u4f1a\u89e6\u53d1\u62f7\u8d1d\u6784\u9020\u51fd\u6570 } int main () { Auto_ptr3 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the copy assignment // \u8fd9\u4e2a\u8d4b\u503c\u5c06\u4f1a\u89e6\u53d1\u8d4b\u503c\u8d4b\u503c\u51fd\u6570 return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u53eb\u505a generateResource() \u7684\u51fd\u6570\u6765\u521b\u5efa\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u5c01\u88c5\u7684 Resource \uff0c\u5e76\u4e14\u5c06\u5b83\u4f20\u56de\u5230 main \u51fd\u6570\u4e2d\u3002 main \u51fd\u6570\u7d27\u63a5\u7740\u5c06\u5176\u8d4b\u503c\u7ed9\u5df2\u7ecf\u5b58\u5728\u7684 Auto_ptr3 \u5bf9\u8c61 mainres \u3002 \u5f53\u8fd9\u4e2a\u7a0b\u5e8f\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6253\u5370\uff1a Resource acquired Resource acquired Resource destroyed Resource acquired Resource destroyed Resource destroyed \uff08\u6ce8\u610f\uff1a\u4f60\u53ef\u80fd\u53ea\u5f97\u52304\u4e2a\u8f93\u51fa\uff0c\u5982\u679c\u4f60\u7684\u7f16\u8bd1\u5668 \u7701\u7565\\\u4f18\u5316 \u4e86 generateResource() \u7684\u8fd4\u56de\u503c\uff09 \u90a3\u4f1a\u6709\u5f88\u591a\u6b21\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u4ec5\u4ec5\u4e3a\u4e86\u8fd9\u6837\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u8ba9\u6211\u4eec\u4ed4\u7ec6\u770b\u770b\uff0c\u7a0b\u5e8f\u91cc\u6709 6 \u4e2a\u5173\u952e\u6b65\u9aa4\uff08\u6bcf\u6b21\u6253\u5370\u90fd\u53d1\u751f\u4e00\u4ef6\uff09\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u521b\u5efa\u5e76\u7528\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684 Resource \u3002 2; Res \u503c\u8fd4\u56de\u5230 main() \u3002\u901a\u8fc7\u503c\u8fd4\u56de\u7684\u539f\u56e0\u662f\uff0c res \u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf \u2014\u2014 \u5b83\u4e0d\u80fd\u88ab\u901a\u8fc7\u5730\u5740\u6216\u5f15\u7528\u8fd4\u56de\uff0c\u56e0\u4e3a res \u5c06\u4f1a\u5728 generateResource() \u51fd\u6570\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \u7ed3\u675f\u3002\u56e0\u4e3a res \u662f\u62f7\u8d1d\u6784\u9020\uff0c\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Resource \u5728\u8fd9\u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u7b2c\u4e8c\u6b21 \"Resource acquired\"\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u9500\u6bc1\u4e4b\u524d\u521b\u5efa\u7684 Resource \uff0c\u8fd9\u89e6\u53d1\u4e86\u7b2c\u4e00\u4e2a \"Resource destroyed\"\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u8d4b\u503c\u8fdb mainres \u901a\u8fc7\u62f7\u8d1d\u8d4b\u503c\u3002\u56e0\u4e3a\u6211\u4eec\u7684\u62f7\u8d1d\u8d4b\u503c\u4e5f\u505a\u4e86\u4e00\u6b21\u6df1\u62f7\u8d1d\uff0c\u4e00\u4e2a\u65b0\u7684 Reource \u88ab\u5206\u914d\uff0c\u89e6\u53d1\u4e86\u53e6\u4e00\u4e2a \"Resource acquired\"\u3002 5; \u8d4b\u503c\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u9500\u6bc1\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a \"Resource acquired\"\u3002 6; \u5728 main() \u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \"Resource destroyed\"\u3002 \u56e0\u6b64\uff0c\u7b80\u800c\u8a00\u4e4b\uff0c\u56e0\u4e3a\u6211\u4eec\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u6765\u62f7\u8d1d\u6784\u9020 res \u6210\u4e00\u4e2a\u4e34\u65f6\u53d8\u91cf\uff0c\u5e76\u8c03\u7528\u4e86\u4e00\u6b21\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u62f7\u8d1d\u4e34\u65f6\u53d8\u91cf\u8fdb\u5165 mainres \uff0c\u6211\u4eec\u6700\u7ec8\u5206\u914d\u548c\u9500\u6bc1\u4e863\u4e2a\u72ec\u7acb\u7684 objects \u603b\u8ba1\u3002 \u8fd9\u662f\u4f4e\u6548\u7684\uff0c\u4f46\u662f\u5b83\u81f3\u5c11\u4e0d\u4f1a\u5d29\u6e83\u3002 \u7136\u800c\u5982\u679c\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u505a\u7684\u66f4\u597d\u3002","title":"\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_2","text":"C++ \u5b9a\u4e49\u4e86\u4e24\u4e2a\u65b0\u7684\u51fd\u6570\u6765\u5b9e\u73b0 \u201c\u79fb\u52a8\u8bed\u4e49\u201d \uff1a\u4e00\u4e2a\u662f \u79fb\u52a8\u6784\u9020\u51fd\u6570 \uff0c\u4e00\u4e2a\u662f \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u3002\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u7684\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u7684\u76ee\u6807\u662f\u521b\u5efa\u4e00\u4efd\u5bf9\u8c61\u7684\u62f7\u8d1d\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8d4b\u503c\u8fd0\u7b97\u7b26\u662f\u6765\u79fb\u52a8\u8d44\u6e90\u7684 \u6240\u6709\u6743(ownership) \uff0c\u4ece\u4e00\u4e2a\u5bf9\u8c61\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff08\u8fd9\u6837\u505a\u6d88\u8017\u7684\u8d44\u6e90\u5c11\u5f88\u591a\uff09\u3002 \u5b9a\u4e49\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u548c\u62f7\u8d1d\u7684\u540c\u7c7b\u51fd\u6570\u6240\u5b9e\u73b0\u7684\u76ee\u7684\u76f8\u4f3c\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u590d\u5236\u51fd\u6570\u7684\u98ce\u683c\u91c7\u7528 \u5e38\u91cf\u5de6\u503c\u5f15\u7528 \u53c2\u6570\uff0c\u79fb\u52a8\u51fd\u6570\u7684\u98ce\u683c\u4f7f\u7528\u4e86 \u975e\u5e38\u91cf\u53f3\u503c\u5f15\u7528 \u53c2\u6570\u3002 \u6709\u4e00\u4e2a\u548c\u4e4b\u524d\u7684 Auto_ptr3 \u76f8\u540c\u7684\u7c7b\uff0c\u6dfb\u52a0\u4e86\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u4e1c\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002\u6211\u4eec\u7559\u4e0b\u4e86\u8fdb\u884c \u6df1\u62f7\u8d1d \u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u4ec5\u4ec5\u4e3a\u4e86\u4f5c\u6bd4\u8f83\u3002 # include <iostream> template < class T > class Auto_ptr4 { T * m_ptr ; public : Auto_ptr4 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr4 () { delete m_ptr ; } // Copy constructor // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 ( const Auto_ptr4 & a ) { m_ptr = new T ; * m_ptr = * a . m_ptr ; } // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 ( Auto_ptr4 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; // we'll talk more about this line below } // Copy assignment // Do deep copy of a.m_ptr to m_ptr Auto_ptr4 & operator = ( const Auto_ptr4 & a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Copy the resource m_ptr = new T ; * m_ptr = * a . m_ptr ; return * this ; } // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr4 & operator = ( Auto_ptr4 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; // we'll talk more about this line below return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; Auto_ptr4 < Resource > generateResource () { Auto_ptr4 < Resource > res ( new Resource ); return res ; // this return value will invoke the move constructor } int main () { Auto_ptr4 < Resource > mainres ; mainres = generateResource (); // this assignment will invoke the move assignment return 0 ; } \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26 \u975e\u5e38\u7b80\u5355\u3002\u4e0d\u518d\u5bf9\u539f\u5bf9\u8c61\u8fdb\u884c\u6df1\u62f7\u8d1d\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\uff0c\u4ec5\u4ec5\u7b80\u5355\u5730\u4ece\u6e90\u5bf9\u8c61 \u79fb\u52a8\uff08\u5077\uff09 \u5230\u76ee\u6807\u5bf9\u8c61\u3002\u5176\u5b9e\u5c31\u662f\u6d89\u53ca\u4e86\u4ece\u539f\u6307\u9488\u5230\u76ee\u5bf9\u8c61\u7684\u6d45\u62f7\u8d1d\uff0c\u7136\u540e\u539f\u6307\u9488\u8bbe\u5b9a\u4e3a null \u3002 \u6211\u4eec\u8fd0\u884c\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5c06\u6253\u5370\uff1a Resource acquired Resource destroyed \u90a3\u597d\u5f97\u591a\uff1a \u7a0b\u5e8f\u7684\u6d41\u7a0b\u548c\u4ee5\u524d\u76f8\u4f3c\uff0c\u7136\u800c\uff0c\u4e0d\u518d\u8c03\u7528\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\uff0c\u800c\u8fd9\u4e2a\u7a0b\u5e8f\u8c03\u7528\u4e86\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u8ba9\u6211\u4eec\u6df1\u5165\u6765\u770b\uff1a 1; \u5728 generateResource() \u4e2d\uff0c\u5c40\u90e8\u53d8\u91cf res \u88ab\u7528\u52a8\u6001\u5206\u914d\u521b\u5efa\u548c\u521d\u59cb\u5316\u3002 2; Res \u901a\u8fc7\u503c\u8fd4\u56de\u5230 main() \u3002 Res \u88ab\u79fb\u52a8\u6784\u9020\u8fdb\u4e00\u4e2a\u4e34\u65f6\u5bf9\u8c61\uff0c\u8f6c\u4e49\u8fd9\u4e2a\u5728 res \u4e2d\u52a8\u6001\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u65b9\u8ba8\u8bba\u4e3a\u4f55\u8fd9\u6837\u505a\u3002 3; Res \u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u56e0\u4e3a res \u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e34\u65f6\u533a\uff09\uff0c\u6ca1\u4ec0\u4e48\u5176\u4ed6\u7684\u53d1\u751f\uff08delete nullptr \u4e0d\u4f1a\u53d1\u751f\u4ec0\u4e48\uff09\u3002 4; \u4e34\u65f6\u5bf9\u8c61\u88ab\u79fb\u52a8\u8d4b\u503c\u7ed9 mainres \u3002\u8fd9\u6b21\u8f6c\u79fb\u4e86\u52a8\u6001\u521b\u5efa\u5e76\u50a8\u5b58\u5728\u4e34\u65f6\u533a\u7684\u5bf9\u8c61\u7ed9 mainres \u3002 5; \u5728\u590d\u5236\u8868\u8fbe\u5f0f\u7ed3\u5c3e\uff0c\u4e34\u65f6\u7684\u5bf9\u8c61\u79bb\u5f00\u4e86\u8868\u8fbe\u5f0f\u4f5c\u7528\u4e8e\uff0c\u5e76\u4e14\u88ab\u9500\u6bc1\u3002\u7136\u800c\u56e0\u4e3a\u4e34\u65f6\u533a\u4e0d\u518d\u7ba1\u7406\u6307\u9488\uff08\u88ab\u79fb\u52a8\u5230\u4e86 mainres \u4e0a\uff09\uff0c\u56e0\u6b64\u8fd9\u4e00\u6b65\u4e5f\u4ec0\u4e48\u90fd\u4e0d\u4f1a\u53d1\u751f\u3002 6; \u5728 main() \u51fd\u6570\u7684\u672b\u5c3e\uff0c mainres \u79bb\u5f00\u4e86\u4f5c\u7528\u4e8e\uff0c\u89e6\u53d1\u4e86\u6700\u540e\u4e00\u4e2a \u201cResource destroyed\u201d \u6253\u5370\u5728\u5c4f\u5e55\u4e0a\u3002 \u56e0\u6b64\uff0c\u4e0d\u518d\u62f7\u8d1d Resource \u4e24\u6b21\uff08\u4e00\u6b21\u4e3a\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6b21\u4e3a\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff09\uff0c\u6211\u4eec\u79fb\u52a8\u4e86\u5b83\u4e24\u6b21\u3002\u8fd9\u66f4\u9ad8\u6548\uff0c\u56e0\u4e3a Resource \u4ec5\u4ec5\u88ab\u6784\u9020\u548c\u9500\u6bc1\u4e00\u6b21\uff0c\u800c\u4e0d\u662f\u4e09\u6b21\u3002","title":"\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_3","text":"\u5f53\u90a3\u4e9b\u51fd\u6570\u88ab\u8c03\u7528\uff0c\u5e76\u4e14\u6784\u9020\u51fd\u6570\u6216\u8005\u8d4b\u503c\u8fd0\u7b97\u7b26\u7684\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u65f6\uff0c\u4f1a\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u6700\u5178\u578b\u7684\u662f\uff0c\u53f3\u503c\u4f1a\u662f\u4e00\u4e2a\u5b57\u9762\u91cf(literal)\u6216\u4e00\u4e2a\u4e34\u65f6\u503c\u3002 \u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u4e0d\u4f1a\u88ab\u9ed8\u8ba4\u63d0\u4f9b\uff0c\u9664\u975e\u8be5\u7c7b\u6ca1\u6709\u5b9a\u4e49\u4efb\u4f55 \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \uff0c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\uff0c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \uff0c\u6216\u8005**\u6790\u6784\u51fd\u6570** \u3002\u7136\u800c\uff0c\u9ed8\u8ba4\u7684 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u548c \u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26 \u53ea\u4f1a\u505a\u548c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u76f8\u4f3c\u7684\u4e8b\u60c5\uff08\u5236\u4f5c\u62f7\u8d1d\uff0c\u4e0d\u79fb\u52a8\uff09\u3002 \u89c4\u5b9a\uff1a\u5982\u679c\u4f60\u60f3\u8981\u4e00\u4e2a\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\u4e00\u4e2a\u3002","title":"\u4f55\u65f6\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_4","text":"\u4f60\u73b0\u5728\u4e86\u89e3\u4e86\u8db3\u591f\u591a\u7684\u4e0a\u4e0b\u6587\uff0c\u7406\u89e3\u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u952e\u56e0\u7d20\u3002 \u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u8fdb\u884c\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u5de6\u503c\uff0c\u6211\u4eec\u552f\u4e00\u80fd\u505a\u7684\u5c31\u662f\u62f7\u8d1d\u8fd9\u4e2a\u5de6\u503c\u3002\u6211\u4eec\u4e0d\u80fd\u5047\u8bbe\u4fee\u6539\u5b83\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u5728\u4e4b\u540e\u7684\u7a0b\u5e8f\u4e2d\u88ab\u4f7f\u7528\u3002\u5c31\u597d\u50cf\u5982\u679c\u6709\u4e00\u4e2a\u8868\u8fbe\u5f0f a = b \uff0c \u6211\u4eec\u65e0\u8bba\u5982\u4f55\u4e0d\u4f1a\u671f\u5f85b\u88ab\u6539\u53d8 \u3002 \u7136\u800c\uff0c\u5982\u679c\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u505a\u4e00\u6b21\u8d4b\u503c\u65f6\uff0c\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\uff0c\u6211\u4eec\u77e5\u9053\u53f3\u503c\u4ec5\u4ec5\u662f\u4e00\u4e2a\u67d0\u4e2a\u7c7b\u578b\u7684\u4e34\u65f6\u503c\u3002\u76f8\u6bd4\u62f7\u8d1d\u4ed6\uff08\u82b1\u8d39\u66f4\u591a\u8d44\u6e90\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u79fb\u52a8\u5b83\u7684\u8d44\u6e90\uff08\u82b1\u8d39\u975e\u5e38\u5c11\uff09\u7ed9\u6211\u4eec\u6b63\u5728\u521b\u5efa\u6216\u8005\u8d4b\u503c\u7684\u8d44\u6e90\u3002\u8fd9\u662f\u5b9e\u73b0\u8d77\u6765\u662f\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u4e34\u65f6\u503c\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728\u8868\u8fbe\u5f0f\u7684\u7ed3\u5c3e\uff0c\u56e0\u6b64\u6211\u4eec\u77e5\u9053\u5b83\u5c06\u6c38\u8fdc\u4e0d\u4f1a\u518d\u88ab\u518d\u6b21\u4f7f\u7528\uff01 C++11\uff0c\u901a\u8fc7\u53f3\u503c\u5f15\u7528\uff0c\u7ed9\u6211\u4eec\u80fd\u529b\u6765\u63d0\u4f9b\u4e00\u4e2a\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u5f53\u53c2\u6570\u662f\u4e00\u4e2a\u53f3\u503c\u6216\u4e00\u4e2a\u5de6\u503c\uff0c\u6709\u4e86\u8fd9\u4e2a\u80fd\u529b\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u66f4\u7b80\u5355\uff0c\u66f4\u9ad8\u6548\u7684\u51b3\u5b9a\u6211\u4eec\u7f16\u5199\u7684\u5bf9\u8c61\u7684\u884c\u4e3a\u3002","title":"\u79fb\u52a8\u8bed\u4e49\u80cc\u540e\u7684\u5173\u8fdb\u56e0\u7d20"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_5","text":"\u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u8bbe\u7f6e a.m_ptr \u4e3a nullptr \u3002\u8fd9\u662f\u770b\u8d77\u6765\u4f3c\u4e4e\u662f\u6ca1\u4ec0\u4e48\u7528\u2014\u2014\u2014\u2014\u6bd5\u7adf\uff0c\u5982\u679c \u201ca\u201d \u662f\u4e00\u4e2a\u4e34\u65f6\u53f3\u503c\uff0c\u4e3a\u4ec0\u4e48\u963b\u6b62\u201c\u6e05\u7406\u201d\uff0c\u5982\u679c \u201ca\u201d \u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u88ab\u9500\u6bc1\u3002 \u8fd9\u4e2a\u95ee\u9898\u7684\u7b54\u6848\u5f88\u7b80\u5355\uff1a\u5f53 \u201ca\u201d \u79bb\u5f00\u4f5c\u7528\u57df\uff0c \"a\" \u7684\u6790\u6784\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\uff0c\u5e76\u4e14 a.m_ptr \u5c06\u4f1a\u88ab\u5220\u9664\u3002\u5982\u679c\u5728\u90a3\u65f6 a.m_ptr \u4ecd\u7136\u6307\u7740\u548c m_ptr \u76f8\u540c\u7684\u7684\u8d44\u6e90\uff0c m_ptr \u5c31\u4f1a\u6210\u4e3a\u4e00\u4e2a\u60ac\u7a7a\u6307\u9488\u3002\u5f53\u5bf9\u8c61\u5bf9\u8c61\u5305\u542b\u7684 m_ptr \u6700\u7ec8\u88ab\u4f7f\u7528\uff08\u6216\u8005\u9500\u6bc1\uff09\uff0c\u5c06\u4f1a\u53d1\u751f\u672a\u5b9a\u4e49\u64cd\u4f5c(undefiend behavior)\u3002 \u53e6\u5916\uff0c\u5728\u4e0b\u8282\u8bfe\u4e2d\u6211\u4eec\u5c06\u4f1a\u770b\u5230\u4e00\u4e9b\u4f8b\u5b50\u5f53 a \u53ef\u4ee5\u662f\u4e00\u4e2a\u5de6\u503c\u65f6\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c a \u5c06\u4e0d\u4f1a\u88ab\u7acb\u5373\u9500\u6bc1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5176\u58f0\u660e\u5468\u671f\u7ed3\u675f\u524d\u67e5\u8be2\u3002","title":"\u79fb\u52a8\u51fd\u6570\u5e94\u59cb\u7ec8\u4f7f\u4e24\u4e2a\u5bf9\u8c61\u5904\u4e8e\u5b9a\u4e49\u826f\u597d\u7684\u72b6\u6001"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_6","text":"\u5728 \u4e4b\u524d\u7684\u4f8b\u5b50\u91cc\uff0c Auto_ptr4 \u4e2d\u7684 generateResource() \uff0c\u5f53\u53d8\u91cf res \u88ab\u901a\u8fc7\u503c\u8fd4\u56de\uff0c\u5b83\u88ab\u79fb\u52a8\u800c\u4e0d\u662f\u62f7\u8d1d\uff0c\u5373\u4fbf res \u59cb\u7ec8\u662f\u4e00\u4e2a\u5de6\u503c\u3002C++ \u89c4\u8303\u4e2d\u6709\u4e00\u4e2a\u7279\u4f8b\u8fd9\u6837\u63cf\u8ff0\uff1a\u901a\u8fc7\u503c\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5bf9\u8c61\u5c06\u81ea\u52a8\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u5373\u4fbf\u4ed6\u4eec\u662f\u4e00\u4e2a\u5de6\u503c\u3002\u8fd9\u5f88\u6709\u610f\u4e49\uff0c\u56e0\u4e3a res \u65e0\u8bba\u5982\u4f55\u5373\u5c06\u88ab\u9500\u6bc1\u5728\u51fd\u6570\u7684\u672b\u5c3e\uff01\u6211\u4eec\u53ef\u4ee5\u4e5f\u5077\u8d70\u5b83\u7684\u8d44\u6e90\u800c\u4e0d\u662f\u505a\u6ca1\u5fc5\u8981\u7684\u62f7\u8d1d\u3002 \u5c3d\u7ba1\u7f16\u8bd1\u5668\u53ef\u4ee5\u79fb\u52a8\u5de6\u503c\u4f5c\u4e3a\u51fd\u6570\u7684\u8fd4\u56de\u503c\uff08Although the compiler can move l-value return values\uff09\uff0c\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\uff0c\u53ef\u4ee5\u505a\u7684\u66f4\u597d\uff0c\u901a\u8fc7\u7b80\u5355\u7684\u6dd8\u6c70\u5b8c\u5168\u62f7\u8d1d\uff08\u907f\u514d\u62f7\u8d1d\u800c\u6216\u5168\u90e8\u4f7f\u7528\u79fb\u52a8\uff09\u3002\u5728\u8fd9\u6837\u7684\u4f8b\u5b50\u4e2d\uff0c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u79fb\u52a8\u6784\u9020\u51fd\u6570\u90fd\u4e0d\u4f1a\u88ab\u8c03\u7528\u3002","title":"\u5de6\u503c\u901a\u8fc7\u79fb\u52a8\u503c\u8fd4\u56de\uff0c\u66ff\u4ee3\u590d\u5236\u8fd4\u56de"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_7","text":"\u5728 \u4e0a\u65b9\u7684 Auto_ptr4 \u7c7b\u4e2d\uff0c\u6211\u4eec\u7559\u4e0b\u4e86 copy \u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u4e3a\u4e86\u6bd4\u8f83\u7684\u76ee\u7684\u3002\u4f46\u5728\u5f00\u542f\u79fb\u52a8(mode-enabled)\u66f4\u613f\u610f\u5220\u9664\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u6765\u786e\u4fdd\u62f7\u8d1d\u4e0d\u4f1a\u53d1\u751f\u3002\u5728\u63a5\u4e0b\u6765\u7684\u4f8b\u5b50\u4e2d Auto_ptr \u7c7b\uff0c\u6211\u4eec\u60f3\u8981\u62f7\u8d1d\u6211\u4eec\u7684 templated \u5bf9\u8c61 T \u2014\u2014\u2014\u2014 \u4e0d\u4ec5\u56e0\u4e3a\u5b83\u7684\u5f00\u9500\u5f88\u5927\uff0c\u800c\u4e14 T \u7c7b\u53ef\u80fd\u751a\u81f3\u4e0d\u652f\u6301\u62f7\u8d1d\uff01 \u8fd9\u662f Auto_ptr \u652f\u6301\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4e0d\u652f\u6301\u62f7\u8d1d\u8bed\u4e49\u7684\u7248\u672c\u3002 # include <iostream> template < class T > class Auto_ptr5 { T * m_ptr ; public : Auto_ptr5 ( T * ptr = nullptr ) : m_ptr ( ptr ) { } ~ Auto_ptr5 () { delete m_ptr ; } // Copy constructor -- no copying allowed! Auto_ptr5 ( const Auto_ptr5 & a ) = delete ; // Move constructor // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 ( Auto_ptr5 && a ) : m_ptr ( a . m_ptr ) { a . m_ptr = nullptr ; } // Copy assignment -- no copying allowed! Auto_ptr5 & operator = ( const Auto_ptr5 & a ) = delete ; // Move assignment // Transfer ownership of a.m_ptr to m_ptr Auto_ptr5 & operator = ( Auto_ptr5 && a ) { // Self-assignment detection if ( & a == this ) return * this ; // Release any resource we're holding delete m_ptr ; // Transfer ownership of a.m_ptr to m_ptr m_ptr = a . m_ptr ; a . m_ptr = nullptr ; return * this ; } T & operator * () const { return * m_ptr ; } T * operator -> () const { return m_ptr ; } bool isNull () const { return m_ptr == nullptr ; } }; \u5982\u679c\u4f60\u5c1d\u8bd5\u901a\u8fc7\u5de6\u503c\u4f20\u4e00\u4e2a Auto_ptr5 \u5230\u4e00\u4e2a\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c06\u4f1a\u62a5\u9519\u544a\u8bc9\u4f60\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u662f\u5fc5\u987b\u7684\uff0c\u7528\u6765\u521d\u59cb\u5316\u62f7\u8d1d\u6784\u9020\u53c2\u6570\u5df2\u7ecf\u88ab\u5220\u9664\u3002\u8fd9\u5c31\u5bf9\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5e94\u8be5\u901a\u8fc7\u5e38\u5de6\u503c\u5f15\u7528\u4f20\u9012 Auto_ptr5 \uff01 Auto_ptr5 \u662f\uff08\u7ec8\u6781\uff09\u4e00\u4e2a\u5f88\u597d\u7684\u53ea\u80fd\u6307\u6b63\u7c7b\u3002\u5e76\u4e14\u4e8b\u5b9e\u4e0a\uff0c\u6807\u51c6\u5e93\u5305\u542b\u7684\u7c7b\u5df2\u7ecf\u975e\u5e38\u50cf\u8fd9\u4e2a\uff08\u4f60\u5e94\u8be5\u7528\u6807\u51c6\uff09\uff0c\u88ab\u53eb\u505a std::unique_ptr \u3002\u6211\u4eec\u5c06\u8ba8\u8bba\u66f4\u591a\u6709\u5173 std::unique_ptr \u5728\u7a0d\u540e\u7684\u7ae0\u8282\u4e2d\u3002","title":"\u7981\u7528\u62f7\u8d1d"},{"location":"15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/#_8","text":"\u8ba9\u6211\u4eec\u770b\u4e00\u773c\u53e6\u4e00\u4e2a\u7c7b\u4f7f\u7528\u4e86\u52a8\u6001\u5185\u5b58\u5206\u914d\uff1a\u4e00\u4e2a\u7b80\u5355\u7684\u52a8\u6001\u6a21\u677f\u6570\u7ec4\u3002\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u6df1\u62f7\u8d1d\u7684\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002 # include <iostream> template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) : m_length ( arr . m_length ) { m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; } // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = new T [ m_length ]; for ( int i = 0 ; i < m_length ; ++ i ) m_array [ i ] = arr . m_array [ i ]; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u8fd9\u4e2a\u7c7b\u3002\u4e3a\u4e86\u5411\u4f60\u5c55\u793a\u8fd9\u4e2a\u7c7b\u7684\u6027\u80fd\uff0c\u6211\u4eec\u5728\u5806\u4e0a\u5206\u914d\u4e86\u4e00\u767e\u4e07\u4e2a\u6574\u578b\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u6211\u4eec\u5728 lesson 8.16 -- Timing your code \u4e2d\u5f00\u53d1\u7684\u8ba1\u65f6\u5668\u7c7b\u3002\u6211\u4eec\u5c06\u4f7f\u7528\u8fd9\u4e2a\u8ba1\u65f6\u5668\u7c7b\u6765\u5c55\u793a\u6211\u4eec\u7684\u4ee3\u7801\u8fd0\u884c\u6709\u591a\u5feb\uff0c\u5411\u4f60\u5c55\u793a\u62f7\u8d1d\u548c\u79fb\u52a8\u4e4b\u95f4\u7684\u6027\u80fd\u5dee\u8ddd\u3002 # include <iostream> # include <chrono> // for std::chrono functions // Uses the above DynamicArray class class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u4f5c\u8005\u4e4b\u4e00\u7684\u673a\u5668\u4e0a\uff0c\u5728\u53d1\u5e03\u6a21\u5f0f\u4e0b\uff0c\u8fd9\u6bb5\u7a0b\u5e8f\u5728 0.00825559 \u79d2\u5185\u6267\u884c\u5b8c\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u540c\u6837\u7684\u7a0b\u5e8f\uff0c\u4f7f\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u51fd\u6570\u6765\u66ff\u6362\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u8d4b\u503c\u51fd\u6570\u3002 template < class T > class DynamicArray { private : T * m_array ; int m_length ; public : DynamicArray ( int length ) : m_array ( new T [ length ]), m_length ( length ) { } ~ DynamicArray () { delete [] m_array ; } // Copy constructor DynamicArray ( const DynamicArray & arr ) = delete ; // Copy assignment DynamicArray & operator = ( const DynamicArray & arr ) = delete ; // Move constructor DynamicArray ( DynamicArray && arr ) : m_length ( arr . m_length ), m_array ( arr . m_array ) { arr . m_length = 0 ; arr . m_array = nullptr ; } // Move assignment DynamicArray & operator = ( DynamicArray && arr ) { if ( & arr == this ) return * this ; delete [] m_array ; m_length = arr . m_length ; m_array = arr . m_array ; arr . m_length = 0 ; arr . m_array = nullptr ; return * this ; } int getLength () const { return m_length ; } T & operator []( int index ) { return m_array [ index ]; } const T & operator []( int index ) const { return m_array [ index ]; } }; # include <iostream> # include <chrono> // for std::chrono functions class Timer { private : // Type aliases to make accessing nested type easier using clock_t = std :: chrono :: high_resolution_clock ; using second_t = std :: chrono :: duration < double , std :: ratio < 1 > > ; std :: chrono :: time_point < clock_t > m_beg ; public : Timer () : m_beg ( clock_t :: now ()) { } void reset () { m_beg = clock_t :: now (); } double elapsed () const { return std :: chrono :: duration_cast < second_t > ( clock_t :: now () - m_beg ). count (); } }; // Return a copy of arr with all of the values doubled DynamicArray < int > cloneArrayAndDouble ( const DynamicArray < int > & arr ) { DynamicArray < int > dbl ( arr . getLength ()); for ( int i = 0 ; i < arr . getLength (); ++ i ) dbl [ i ] = arr [ i ] * 2 ; return dbl ; } int main () { Timer t ; DynamicArray < int > arr ( 1000000 ); for ( int i = 0 ; i < arr . getLength (); i ++ ) arr [ i ] = i ; arr = cloneArrayAndDouble ( arr ); std :: cout << t . elapsed (); } \u5728\u540c\u6837\u7684\u673a\u5668\u4e0a\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5728 0.0056 \u79d2\u5185\u6267\u884c\u5b8c\u6bd5\u3002 \u6bd4\u8f83\u4e24\u4e2a\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u95f4\uff0c 0.0056 / 0.00825559 = 67.8% \u3002\u201c\u79fb\u52a8\u8bed\u4e49\u201d\u7684\u7248\u672c\u51e0\u4e4e\u5feb\u4e8633%","title":"\u53e6\u4e00\u4e2a\u4f8b\u5b50"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/","text":"15.4 std::move \u00b6 By Alex on March 4 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e00\u65e6\u4f60\u5f00\u59cb\u4f7f\u7528\u66f4\u52a0\u9891\u7e41\u7684\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0\u5f88\u591a\u60c5\u51b5\u4e0b\uff0c\u4f60\u60f3\u8981\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4f60\u521b\u5efa\u7684\u5bf9\u8c61\u4e0d\u5f97\u4e0d\u4f5c\u4e3a\u5de6\u503c\uff0c\u800c\u4e0d\u662f\u53f3\u503c\u3002\u601d\u8003\u4e0b\u5217\u4ea4\u6362\u51fd\u6570\u7684\u4ee3\u7801\uff1a #include <iostream> #include <string> template < class T > void myswap ( T & a , T & b ) { T tmp { a }; // invokes copy constructor a = b ; // invokes copy assignment b = tmp ; // invokes copy assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } \u4f20\u5165\u4e24\u4e2a T\uff08\u4f8b\u5b50\u4e2d\u4f7f\u7528\u4e86 std::string \uff09 \u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u51fd\u6570\u4ea4\u6362\u4ed6\u4eec\u7684\u503c\u901a\u8fc7\u4e09\u6b21\u62f7\u8d1d\u3002 x: abc y: de x: de y: abc \u5728\u6211\u4eec\u5b66\u4e60\u4e86\u4e0a\u8282\u8bfe\u540e\uff0c\u8fdb\u884c\u62f7\u8d1d\u53ef\u80fd\u662f\u4f4e\u6548\u7684\u3002\u5e76\u4e14\u8fd9\u4e2a\u7248\u672c\u7684\u4ea4\u6362\u51fd\u6570\u8fdb\u884c\u4e86\u4e09\u6b21\u62f7\u8d1d\u3002\u90a3\u4f1a\u5f15\u8d77\u8fc7\u91cf\u7684\u5b57\u7b26\u4e32\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u662f\u975e\u5e38\u7f13\u6162\u7684\u3002 \u7136\u800c\uff0c\u5728\u8fd9\u91cc\u8fdb\u884c\u62f7\u8d1d\u662f\u4e0d\u5fc5\u8981\u7684\u3002\u6211\u4eec\u771f\u6b63\u8981\u505a\u7684\u662f\u4ea4\u6362 a \u548c b \u7684\u503c\uff0c\u53ef\u4ee5\u88ab\u4f7f\u7528\u4e09\u6b21\u79fb\u52a8\u6765\u66ff\u4ee3\uff01\u56e0\u6b64\u5982\u679c\u6211\u4eec\u4ece\u62f7\u8d1d\u8bed\u4e49\u5207\u6362\u5230\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u6211\u4eec\u7684\u4ee3\u7801\u62e5\u6709\u66f4\u9ad8\u6027\u80fd\u3002 \u600e\u4e48\u505a\u5462\uff1f\u8fd9\u91cc\u7684\u95ee\u9898\u662f a \u548c b \u90fd\u662f\u5de6\u503c\u5f15\u7528\uff0c\u4e0d\u662f\u53f3\u503c\u5f15\u7528\uff0c\u56e0\u6b64\u6211\u4eec\u65e0\u6cd5\u8c03\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u66ff\u4ee3\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u4f1a\u5f97\u5230\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u7684\u884c\u4e3a\u3002\u6211\u4eec\u80fd\u600e\u4e48\u529e\u5462\uff1f std::move \u00b6 \u5728 C++11 \u4e2d std::move \u662f\u4e00\u4e2a\u6807\u51c6\u5e93\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u76ee\u7684\uff0c\u628a\u53c2\u6570\u8f6c\u5316\u4e3a\u53f3\u503c\u3002\u6211\u4eec\u53ef\u4ee5\u4f20\u4e00\u4e2a\u5de6\u503c\u7ed9 std::move \uff0c\u7136\u540e\u5b83\u5c31\u4f1a\u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u3002 std::move \u88ab\u5b9a\u4e49\u5728 utility \u5934\u4e2d\u3002 \u8fd9\u6709\u4e00\u4e2a\u548c\u4e0a\u9762\u76f8\u540c\uff0c\u4f46\u662f\u4f7f\u7528 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff0c\u6765\u5b9e\u73b0 myswap() \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff1a #include <iostream> #include <string> #include <utility> // for std::move template < class T > void myswap ( T & a , T & b ) { T tmp { std :: move ( a ) }; // invokes move constructor a = std :: move ( b ); // invokes move assignment b = std :: move ( tmp ); // invokes move assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } This prints the same result as above: x: abc y: de x: de y: abc \u4f46\u662f\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6027\u80fd\u9ad8\u4e86\u8bb8\u591a\u3002\u5f53 tmp \u88ab\u521d\u59cb\u5316\u65f6\uff0c\u4e0d\u518d\u5bf9 x \u8fdb\u884c\u62f7\u8d1d\uff0c\u6211\u4eec\u7528 std::move \u6765\u8f6c\u5316\u5de6\u503c\u53d8\u91cf x \u6210\u4e00\u4e2a r-value \u3002\u56e0\u4e3a\u53c2\u6570\u662f\u4e00\u4e2a \u53f3\u503c\uff0c\u56e0\u6b64\u79fb\u52a8\u8bed\u4e49\u88ab\u89e6\u53d1\uff0c\u56e0\u6b64 x \u88ab\u79fb\u52a8\u8fdb tmp \u3002 \u4f7f\u7528\u4e00\u5bf9\u4ea4\u6362\uff0cx \u7684\u503c\u88ab\u79fb\u52a8\u5230\u4e86 y \u4e0a\uff0c\u5e76\u4e14 y \u7684\u503c \u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e86 x\u3002 Another example \u00b6 \u5f53\u7528\u5de6\u503c\u586b\u5145\u4e00\u4e2a\u5bb9\u5668\u7684\u5143\u7d20\u65f6\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528 std::move \uff0c\u4f8b\u5982 std::vector \u3002 \u5728\u4e0b\u9762\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u5148\u901a\u8fc7\u62f7\u8d1d\u8bed\u4e49\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5143\u7d20\u5230 vector\uff0c\u7136\u540e\u6211\u4eec\u901a\u8fc7\u79fb\u52a8\u8bed\u4e49\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector\u3002 #include <iostream> #include <string> #include <utility> // for std::move #include <vector> int main () { std :: vector < std :: string > v ; std :: string str = \"Knock\" ; std :: cout << \"Copying str \\n \" ; v . push_back ( str ); // calls l-value version of push_back, which copies str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector: \" << v [ 0 ] << '\\n' ; std :: cout << \" \\n Moving str \\n \" ; v . push_back ( std :: move ( str )); // calls r-value version of push_back, which moves str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector:\" << v [ 0 ] << ' ' << v [ 1 ] << '\\n' ; return 0 ; } \u7a0b\u5e8f\u6253\u5370\uff1a Copying str str: Knock vector: Knock Moving str str: vector: Knock Knock \u5728\u7b2c\u4e00\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u9012\u4e86\u4e00\u4e2a\u5de6\u503c\u5230 push_back() \u4e2d\uff0c\u56e0\u6b64\u5b83\u4f7f\u7528\u4e86\u62f7\u8d1d\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vecotr\u3002\u56e0\u4e3a\u8fd9\u6837\uff0cstr \u4e2d\u7684\u503c\u88ab\u7559\u4e0b\u4e86\u3002 \u5728\u7b2c\u4e8c\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u4e86\u4e00\u4e2a\u53f3\u503c\u5230 push_back() \uff08\u5b9e\u9645\u4e0a\u662f\u901a\u8fc7 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff09\uff0c\u8fd9\u6837\u4e00\u6765\u5b83\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector \u8fd9\u66f4\u52a0\u7684\u9ad8\u6548\uff0c\u56e0\u4e3a vector \u5143\u7d20\u53ef\u4ee5\u5077\u8d70 string \u7684\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u5b83\u3002\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\uff0cstr \u4f1a\u88ab\u7559\u7a7a\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u503c\u5f97\u91cd\u7533\u4e00\u904d\u7684\u662f std::move() \u63d0\u4f9b\u4e86\u4e00\u4e2a\u63d0\u793a\u7ed9\u7f16\u8bd1\u5668\uff0c\u7a0b\u5e8f\u5458\u4e0d\u518d\u9700\u8981\u8fd9\u4e2a\u5bf9\u8c61\u4e86\uff08\u81f3\u5c11\uff0c\u4e0d\u9700\u8981\u5b83\u5f53\u524d\u7684\u72b6\u6001\uff09\u3002\u56e0\u6b64\uff0c\u4f60\u5e94\u8be5\u4e0d\u8981\u4f7f\u7528 std::move() \u5728\u4efb\u4f55\u6301\u7eed\u4f7f\u7528\uff0c\u4e0d\u60f3\u88ab\u4fee\u6539\u7684\u5bf9\u8c61\uff0c\u5e76\u4e14\u4f60\u5e94\u8be5\u4e0d\u8981\u671f\u671b\u4efb\u4f55\u7ecf\u8fc7 std::move() \u7684\u5bf9\u8c61\u5728\u7ecf\u8fc7\u79fb\u52a8\u540e\u76f8\u540c\uff01\uff08you should not expect the state of any objects that have had std::move() applied to be the same after they are moved!\uff09 \u79fb\u52a8\u51fd\u6570\u5e94\u8be5\u603b\u662f\u4fdd\u6301\u5bf9\u8c61 well-defined \u7684\u72b6\u6001 \u00b6 \u5982\u6211\u4eec\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u4e86\u89e3\u7684\u90a3\u6837\uff0c\u6700\u597d\u603b\u662f\u8ba9\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4fdd\u6301\u67d0\u79cd\u826f\u597d\u7684\uff08\u786e\u5b9a\u6027\uff09\u7684\u72b6\u6001\u3002\u5728\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u5e94\u8be5\u662f\u4e00\u4e2a null state \uff0c\u5c06\u5bf9\u8c61\u8bbe\u7f6e\u56de\u5b83\u6700\u521d\u59cb\u6216\u80050\u72b6\u6001\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u8c08\u8c08\u4e3a\u4ec0\u4e48\u8fd9\u6837\u505a\uff1a\u4f7f\u7528 std::move \uff0c\u6bd5\u7adf\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4e5f\u53ef\u80fd\u4e0d\u662f\u4e00\u4e2a\u4e34\u65f6\u72b6\u6001\u6bd5\u7adf\u3002\u7528\u6237\u53ef\u80fd\u60f3\u8981\u518d\u6b21\u91cd\u7528\u8fd9\u4e2a\uff08\u73b0\u5728\u4e3a\u7a7a\uff09\u7684\u5bf9\u8c61\uff0c\u6216\u8005\u6d4b\u8bd5\u5b83\u4ee5\u67d0\u79cd\u65b9\u5f0f\uff0c\u5e76\u4e14\u53ef\u80fd\u8fdb\u884c\u76f8\u5e94\u7684\u8ba1\u5212\uff08or test it in some way, and can plan accordingly\uff09\u3002 \u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c string \u7c7b\u578b\u7684 str \u88ab\u8bbe\u7f6e\u6210\u7a7a\u5b57\u7b26\u4e32\uff0c\u5728\u88ab\u79fb\u52a8\u4e4b\u540e\uff08std::sttring \u5728\u4e00\u6b21\u6210\u529f\u7684move\u540e\u603b\u662f\u8fd9\u4e48\u505a\uff09\u3002\u8fd9\u5141\u8bb8\u6211\u4eec\u91cd\u7528\u53d8\u91cf str \u5982\u679c\u6211\u4eec\u5e0c\u671b\uff08\u6216\u8005\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u5b83\uff0c\u5982\u679c\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4f7f\u7528\u5b83\uff09\u3002 std::move \u5728\u5176\u4ed6\u5730\u65b9\u7684\u5e94\u7528 \u00b6 \u5f53\u6392\u5e8f\u4e00\u4e2a\u6570\u7ec4\u65f6\uff0c std::move \u4e5f\u53ef\u4ee5\u5f88\u6709\u7528\u3002\u8bb8\u591a\u6392\u5e8f\u7b97\u6cd5\uff08\u4f8b\u5982\u9009\u62e9\u6392\u5e8f\u548c\u5192\u6ce1\u6392\u5e8f\uff09\u90fd\u4f1a\u6d89\u53ca\u4e00\u5bf9\u5143\u7d20\u7684\u4ea4\u6362\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u501f\u52a9\u62f7\u8d1d\u8bed\u4e49\u6765\u505a\u4ea4\u6362\uff0c\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u66f4\u9ad8\u6548\u7684\u79fb\u52a8\u8bed\u4e49\u3002 \u5982\u679c\u6211\u4eec\u60f3\u8981\u79fb\u52a8\u6307\u9488\u6240\u7ba1\u7406\u7684 contents \u7ed9\u53e6\u4e00\u4e2a\uff0c\u4e5f\u662f\u5f88\u6709\u7528\u7684\u3002 \u7ed3\u8bba \u00b6 std::move \u53ef\u80fd\u88ab\u7528\u5728\u6bcf\u5f53\u6211\u4eec\u9700\u8981\u5bf9\u5f85\u4e00\u4e2a\u5de6\u503c\u50cf\u5bf9\u5f85\u53f3\u503c\u90a3\u6837\uff0c\u4e3a\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u800c\u4e0d\u662f\u62f7\u8d1d\u8bed\u4e49\u3002","title":"15.4 std::move"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#154-stdmove","text":"By Alex on March 4 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e00\u65e6\u4f60\u5f00\u59cb\u4f7f\u7528\u66f4\u52a0\u9891\u7e41\u7684\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0\u5f88\u591a\u60c5\u51b5\u4e0b\uff0c\u4f60\u60f3\u8981\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff0c\u4f46\u662f\u4f60\u521b\u5efa\u7684\u5bf9\u8c61\u4e0d\u5f97\u4e0d\u4f5c\u4e3a\u5de6\u503c\uff0c\u800c\u4e0d\u662f\u53f3\u503c\u3002\u601d\u8003\u4e0b\u5217\u4ea4\u6362\u51fd\u6570\u7684\u4ee3\u7801\uff1a #include <iostream> #include <string> template < class T > void myswap ( T & a , T & b ) { T tmp { a }; // invokes copy constructor a = b ; // invokes copy assignment b = tmp ; // invokes copy assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } \u4f20\u5165\u4e24\u4e2a T\uff08\u4f8b\u5b50\u4e2d\u4f7f\u7528\u4e86 std::string \uff09 \u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u51fd\u6570\u4ea4\u6362\u4ed6\u4eec\u7684\u503c\u901a\u8fc7\u4e09\u6b21\u62f7\u8d1d\u3002 x: abc y: de x: de y: abc \u5728\u6211\u4eec\u5b66\u4e60\u4e86\u4e0a\u8282\u8bfe\u540e\uff0c\u8fdb\u884c\u62f7\u8d1d\u53ef\u80fd\u662f\u4f4e\u6548\u7684\u3002\u5e76\u4e14\u8fd9\u4e2a\u7248\u672c\u7684\u4ea4\u6362\u51fd\u6570\u8fdb\u884c\u4e86\u4e09\u6b21\u62f7\u8d1d\u3002\u90a3\u4f1a\u5f15\u8d77\u8fc7\u91cf\u7684\u5b57\u7b26\u4e32\u521b\u5efa\u548c\u9500\u6bc1\uff0c\u662f\u975e\u5e38\u7f13\u6162\u7684\u3002 \u7136\u800c\uff0c\u5728\u8fd9\u91cc\u8fdb\u884c\u62f7\u8d1d\u662f\u4e0d\u5fc5\u8981\u7684\u3002\u6211\u4eec\u771f\u6b63\u8981\u505a\u7684\u662f\u4ea4\u6362 a \u548c b \u7684\u503c\uff0c\u53ef\u4ee5\u88ab\u4f7f\u7528\u4e09\u6b21\u79fb\u52a8\u6765\u66ff\u4ee3\uff01\u56e0\u6b64\u5982\u679c\u6211\u4eec\u4ece\u62f7\u8d1d\u8bed\u4e49\u5207\u6362\u5230\u79fb\u52a8\u8bed\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u6211\u4eec\u7684\u4ee3\u7801\u62e5\u6709\u66f4\u9ad8\u6027\u80fd\u3002 \u600e\u4e48\u505a\u5462\uff1f\u8fd9\u91cc\u7684\u95ee\u9898\u662f a \u548c b \u90fd\u662f\u5de6\u503c\u5f15\u7528\uff0c\u4e0d\u662f\u53f3\u503c\u5f15\u7528\uff0c\u56e0\u6b64\u6211\u4eec\u65e0\u6cd5\u8c03\u7528\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u64cd\u4f5c\u7b26\u6765\u66ff\u4ee3\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u4f1a\u5f97\u5230\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u7684\u884c\u4e3a\u3002\u6211\u4eec\u80fd\u600e\u4e48\u529e\u5462\uff1f","title":"15.4 std::move"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#stdmove","text":"\u5728 C++11 \u4e2d std::move \u662f\u4e00\u4e2a\u6807\u51c6\u5e93\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u76ee\u7684\uff0c\u628a\u53c2\u6570\u8f6c\u5316\u4e3a\u53f3\u503c\u3002\u6211\u4eec\u53ef\u4ee5\u4f20\u4e00\u4e2a\u5de6\u503c\u7ed9 std::move \uff0c\u7136\u540e\u5b83\u5c31\u4f1a\u8fd4\u56de\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u3002 std::move \u88ab\u5b9a\u4e49\u5728 utility \u5934\u4e2d\u3002 \u8fd9\u6709\u4e00\u4e2a\u548c\u4e0a\u9762\u76f8\u540c\uff0c\u4f46\u662f\u4f7f\u7528 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff0c\u6765\u5b9e\u73b0 myswap() \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u79fb\u52a8\u8bed\u4e49\uff1a #include <iostream> #include <string> #include <utility> // for std::move template < class T > void myswap ( T & a , T & b ) { T tmp { std :: move ( a ) }; // invokes move constructor a = std :: move ( b ); // invokes move assignment b = std :: move ( tmp ); // invokes move assignment } int main () { std :: string x { \"abc\" }; std :: string y { \"de\" }; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; myswap ( x , y ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; return 0 ; } This prints the same result as above: x: abc y: de x: de y: abc \u4f46\u662f\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6027\u80fd\u9ad8\u4e86\u8bb8\u591a\u3002\u5f53 tmp \u88ab\u521d\u59cb\u5316\u65f6\uff0c\u4e0d\u518d\u5bf9 x \u8fdb\u884c\u62f7\u8d1d\uff0c\u6211\u4eec\u7528 std::move \u6765\u8f6c\u5316\u5de6\u503c\u53d8\u91cf x \u6210\u4e00\u4e2a r-value \u3002\u56e0\u4e3a\u53c2\u6570\u662f\u4e00\u4e2a \u53f3\u503c\uff0c\u56e0\u6b64\u79fb\u52a8\u8bed\u4e49\u88ab\u89e6\u53d1\uff0c\u56e0\u6b64 x \u88ab\u79fb\u52a8\u8fdb tmp \u3002 \u4f7f\u7528\u4e00\u5bf9\u4ea4\u6362\uff0cx \u7684\u503c\u88ab\u79fb\u52a8\u5230\u4e86 y \u4e0a\uff0c\u5e76\u4e14 y \u7684\u503c \u5df2\u7ecf\u88ab\u79fb\u52a8\u5230\u4e86 x\u3002","title":"std::move"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#another-example","text":"\u5f53\u7528\u5de6\u503c\u586b\u5145\u4e00\u4e2a\u5bb9\u5668\u7684\u5143\u7d20\u65f6\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528 std::move \uff0c\u4f8b\u5982 std::vector \u3002 \u5728\u4e0b\u9762\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u5148\u901a\u8fc7\u62f7\u8d1d\u8bed\u4e49\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5143\u7d20\u5230 vector\uff0c\u7136\u540e\u6211\u4eec\u901a\u8fc7\u79fb\u52a8\u8bed\u4e49\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector\u3002 #include <iostream> #include <string> #include <utility> // for std::move #include <vector> int main () { std :: vector < std :: string > v ; std :: string str = \"Knock\" ; std :: cout << \"Copying str \\n \" ; v . push_back ( str ); // calls l-value version of push_back, which copies str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector: \" << v [ 0 ] << '\\n' ; std :: cout << \" \\n Moving str \\n \" ; v . push_back ( std :: move ( str )); // calls r-value version of push_back, which moves str into the array element std :: cout << \"str: \" << str << '\\n' ; std :: cout << \"vector:\" << v [ 0 ] << ' ' << v [ 1 ] << '\\n' ; return 0 ; } \u7a0b\u5e8f\u6253\u5370\uff1a Copying str str: Knock vector: Knock Moving str str: vector: Knock Knock \u5728\u7b2c\u4e00\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u9012\u4e86\u4e00\u4e2a\u5de6\u503c\u5230 push_back() \u4e2d\uff0c\u56e0\u6b64\u5b83\u4f7f\u7528\u4e86\u62f7\u8d1d\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vecotr\u3002\u56e0\u4e3a\u8fd9\u6837\uff0cstr \u4e2d\u7684\u503c\u88ab\u7559\u4e0b\u4e86\u3002 \u5728\u7b2c\u4e8c\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f20\u4e86\u4e00\u4e2a\u53f3\u503c\u5230 push_back() \uff08\u5b9e\u9645\u4e0a\u662f\u901a\u8fc7 std::move \u5c06\u5de6\u503c\u8f6c\u5316\u4e3a\u53f3\u503c\uff09\uff0c\u8fd9\u6837\u4e00\u6765\u5b83\u4f7f\u7528\u79fb\u52a8\u8bed\u4e49\u6765\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\u5230 vector \u8fd9\u66f4\u52a0\u7684\u9ad8\u6548\uff0c\u56e0\u4e3a vector \u5143\u7d20\u53ef\u4ee5\u5077\u8d70 string \u7684\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u5b83\u3002\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\uff0cstr \u4f1a\u88ab\u7559\u7a7a\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u503c\u5f97\u91cd\u7533\u4e00\u904d\u7684\u662f std::move() \u63d0\u4f9b\u4e86\u4e00\u4e2a\u63d0\u793a\u7ed9\u7f16\u8bd1\u5668\uff0c\u7a0b\u5e8f\u5458\u4e0d\u518d\u9700\u8981\u8fd9\u4e2a\u5bf9\u8c61\u4e86\uff08\u81f3\u5c11\uff0c\u4e0d\u9700\u8981\u5b83\u5f53\u524d\u7684\u72b6\u6001\uff09\u3002\u56e0\u6b64\uff0c\u4f60\u5e94\u8be5\u4e0d\u8981\u4f7f\u7528 std::move() \u5728\u4efb\u4f55\u6301\u7eed\u4f7f\u7528\uff0c\u4e0d\u60f3\u88ab\u4fee\u6539\u7684\u5bf9\u8c61\uff0c\u5e76\u4e14\u4f60\u5e94\u8be5\u4e0d\u8981\u671f\u671b\u4efb\u4f55\u7ecf\u8fc7 std::move() \u7684\u5bf9\u8c61\u5728\u7ecf\u8fc7\u79fb\u52a8\u540e\u76f8\u540c\uff01\uff08you should not expect the state of any objects that have had std::move() applied to be the same after they are moved!\uff09","title":"Another example"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#well-defined","text":"\u5982\u6211\u4eec\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u4e86\u89e3\u7684\u90a3\u6837\uff0c\u6700\u597d\u603b\u662f\u8ba9\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4fdd\u6301\u67d0\u79cd\u826f\u597d\u7684\uff08\u786e\u5b9a\u6027\uff09\u7684\u72b6\u6001\u3002\u5728\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u5e94\u8be5\u662f\u4e00\u4e2a null state \uff0c\u5c06\u5bf9\u8c61\u8bbe\u7f6e\u56de\u5b83\u6700\u521d\u59cb\u6216\u80050\u72b6\u6001\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u8c08\u8c08\u4e3a\u4ec0\u4e48\u8fd9\u6837\u505a\uff1a\u4f7f\u7528 std::move \uff0c\u6bd5\u7adf\u88ab\u7a83\u53d6\u7684\u5bf9\u8c61\u4e5f\u53ef\u80fd\u4e0d\u662f\u4e00\u4e2a\u4e34\u65f6\u72b6\u6001\u6bd5\u7adf\u3002\u7528\u6237\u53ef\u80fd\u60f3\u8981\u518d\u6b21\u91cd\u7528\u8fd9\u4e2a\uff08\u73b0\u5728\u4e3a\u7a7a\uff09\u7684\u5bf9\u8c61\uff0c\u6216\u8005\u6d4b\u8bd5\u5b83\u4ee5\u67d0\u79cd\u65b9\u5f0f\uff0c\u5e76\u4e14\u53ef\u80fd\u8fdb\u884c\u76f8\u5e94\u7684\u8ba1\u5212\uff08or test it in some way, and can plan accordingly\uff09\u3002 \u5728\u4ee5\u4e0a\u7684\u4f8b\u5b50\u4e2d\uff0c string \u7c7b\u578b\u7684 str \u88ab\u8bbe\u7f6e\u6210\u7a7a\u5b57\u7b26\u4e32\uff0c\u5728\u88ab\u79fb\u52a8\u4e4b\u540e\uff08std::sttring \u5728\u4e00\u6b21\u6210\u529f\u7684move\u540e\u603b\u662f\u8fd9\u4e48\u505a\uff09\u3002\u8fd9\u5141\u8bb8\u6211\u4eec\u91cd\u7528\u53d8\u91cf str \u5982\u679c\u6211\u4eec\u5e0c\u671b\uff08\u6216\u8005\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u5b83\uff0c\u5982\u679c\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4f7f\u7528\u5b83\uff09\u3002","title":"\u79fb\u52a8\u51fd\u6570\u5e94\u8be5\u603b\u662f\u4fdd\u6301\u5bf9\u8c61 well-defined \u7684\u72b6\u6001"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#stdmove_1","text":"\u5f53\u6392\u5e8f\u4e00\u4e2a\u6570\u7ec4\u65f6\uff0c std::move \u4e5f\u53ef\u4ee5\u5f88\u6709\u7528\u3002\u8bb8\u591a\u6392\u5e8f\u7b97\u6cd5\uff08\u4f8b\u5982\u9009\u62e9\u6392\u5e8f\u548c\u5192\u6ce1\u6392\u5e8f\uff09\u90fd\u4f1a\u6d89\u53ca\u4e00\u5bf9\u5143\u7d20\u7684\u4ea4\u6362\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u501f\u52a9\u62f7\u8d1d\u8bed\u4e49\u6765\u505a\u4ea4\u6362\uff0c\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u66f4\u9ad8\u6548\u7684\u79fb\u52a8\u8bed\u4e49\u3002 \u5982\u679c\u6211\u4eec\u60f3\u8981\u79fb\u52a8\u6307\u9488\u6240\u7ba1\u7406\u7684 contents \u7ed9\u53e6\u4e00\u4e2a\uff0c\u4e5f\u662f\u5f88\u6709\u7528\u7684\u3002","title":"std::move \u5728\u5176\u4ed6\u5730\u65b9\u7684\u5e94\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/#_1","text":"std::move \u53ef\u80fd\u88ab\u7528\u5728\u6bcf\u5f53\u6211\u4eec\u9700\u8981\u5bf9\u5f85\u4e00\u4e2a\u5de6\u503c\u50cf\u5bf9\u5f85\u53f3\u503c\u90a3\u6837\uff0c\u4e3a\u4e86\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u800c\u4e0d\u662f\u62f7\u8d1d\u8bed\u4e49\u3002","title":"\u7ed3\u8bba"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/","text":"15.5 std::unique_ptr \u00b6 By Alex on March 15 th , 2017 | last modified by nascardriver on July 12 th , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u672c\u7ae0\u7684\u5f00\u59cb\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5728\u4e00\u4e9b\u6761\u4ef6\u4e0b\uff0c\u5982\u4f55\u4f7f\u7528\u6307\u9488\u4f1a\u5f15\u8d77bug\u548c\u5185\u5b58\u6cc4\u9732\u3002\u4f8b\u5982\uff0c\u8fd9\u5c31\u53ef\u80fd\u4f1a\u53d1\u751f\u5728\uff0c\u5f53\u4e00\u4e2a\u51fd\u6570\u63d0\u524d\u9000\u51fa\uff0c\u6216\u629b\u51fa\u5f02\u5e38\uff0c\u6216\u8005\u6307\u9488\u6ca1\u6709\u88ab\u5408\u7406\u7684\u5220\u9664\u65f6\u3002 #include <iostream> void someFunction () { auto * ptr { new Resource () }; int x {}; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 \u79fb\u52a8\u8bed\u4e49 \u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u56de\u5230 \u667a\u80fd\u6307\u9488 \u7684\u8bdd\u9898\u4e86\u3002\u63d0\u9192\u4e00\u4e0b\uff0c \u667a\u80fd\u6307\u9488 \u662f\u4e00\u4e2a\u7ba1\u7406\u7740 \u52a8\u6001\u5206\u914d\u8d44\u6e90 \u7684\u7c7b\uff0c\u5e76\u4e14\u4fdd\u8bc1\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\u5728\u5408\u9002\u7684\u65f6\u95f4\u88ab\u5408\u9002\u7684 \u91ca\u653e \uff0c\uff08\u901a\u5e38\u662f\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff09\u3002 \u56e0\u4e3a\u8fd9\u6837\uff0c\u667a\u80fd\u6307\u9488\u672c\u8eab\u5e94\u8be5\u4ece\u4e0d\u88ab\u52a8\u6001\u5206\u914d\uff08\u5426\u5219\uff0c\u5982\u679c\u4ed6\u4eec\u81ea\u5df1\u672c\u8eab\u5c31\u53ef\u80fd\u6709\u6ca1\u88ab\u5408\u9002\u5730\u91ca\u653e\u7684\u98ce\u9669\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u6301\u6709\u7684\u5bf9\u8c61\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u9732\uff09\u3002\u901a\u8fc7\u59cb\u7ec8\u53ea\u5728\u6808\u533a\u521b\u5efa\u667a\u80fd\u6307\u9488\u7684\u65b9\u5f0f\uff08\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\u6216\u8005\u662f\u5176\u4ed6\u7c7b\u7684\u7ec4\u6210\uff09\uff0c\u6211\u4eec\u4fdd\u8bc1\u90a3\u6837\u7684\u667a\u80fd\u6307\u9488\u5c06\u4f1a\u5408\u7406\u5730\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5f53\u51fd\u6570\u7ed3\u675f\u6216\u8005\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u65f6\uff0c\u80fd\u786e\u4fdd\u667a\u80fd\u6307\u9488 \u6301\u6709\u7684\u5bf9\u8c61 \u88ab\u5408\u9002\u7684\u91ca\u653e\u3002 C++11 \u6807\u51c6\u5e93\u9644\u5e26\u56db\u79cd\u6307\u9488\u7c7b\u578b\uff1a std::auto_ptr \uff08\u4e0d\u5e94\u8be5\u4f7f\u7528\u2014\u2014\u2014\u2014\u5728C++17\u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff09\uff0c std::unique_ptr \uff0c std::share_ptr \u548c std::weak_ptr \u3002 std::unique_ptr \u662f\u76ee\u524d\u6700\u591a\u4f7f\u7528\u7684\u667a\u80fd\u6307\u9488\u7c7b\uff0c\u56e0\u6b64\u6211\u4eec\u4e5f\u7b2c\u4e00\u4e2a\u6765\u8bb2\u5b83\u3002\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u8bb2 std::shared_ptr \u548c std::weak_ptr \u3002 std::unique_ptr \u00b6 std::unique_ptr \u662f C++11 \u4e2d std::auto_ptr \u7684\u66ff\u4ee3\u54c1\u3002\u5b83\u5e94\u8be5\u88ab\u7528\u4e8e\u7ba1\u7406\u4efb\u4f55\u52a8\u6001\u5206\u914d\uff0c\u5e76\u4e0d\u4f1a\u5728\u591a\u4e2a\u5bf9\u8c61\u4e2d\u5206\u4eab\u7684\u5bf9\u8c61\u3002 std::unique_ptr \uff0c\u5e94\u8be5\u5b8c\u5168\u7684\u6301\u6709\u5b83\u7ba1\u7406\u7684\u5bf9\u8c61\uff0c\u4e0d\u5e94\u8be5\u548c\u5176\u4ed6\u7c7b\u578b\u5206\u4eab\u5bf9\u8c61\u7684\u6240\u6709\u6743\u3002 std::unique_ptr \u5b9a\u4e49\u5728 <memory> \u5934\u4e2d\u3002 \u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2a\u7b80\u5355\u7684\u667a\u80fd\u6307\u9488\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::unique_ptr std :: unique_ptr < Resource > res { new Resource () }; return 0 ; } // res goes out of scope here, and the allocated Resource is destroyed \u56e0\u4e3a std::unique_ptr \u5728\u6808\u533a\u4e0a\u88ab\u5206\u914d\uff0c\u5b83\u6700\u7ec8\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u4f1a\u81ea\u52a8\u5220\u9664\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u3002 \u4e0d\u50cf std::auto_ptr \uff0c std::unique_ptr \u66f4\u9002\u5408\u7528\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u3002 # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { std :: unique_ptr < Resource > res1 { new Resource {} }; // Resource created here std :: unique_ptr < Resource > res2 {}; // Start as nullptr std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); // res2 = res1; // Won't compile: copy assignment is disabled res2 = std :: move ( res1 ); // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); return 0 ; } // Resource destroyed here when res2 goes out of scope \u8fd9\u4e2a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u56e0\u4e3a std__unique_ptr \u5728\u8bbe\u8ba1\u65f6\u8003\u8651\u4e86\u79fb\u52a8\u8bed\u4e49\uff0c \u62f7\u8d1d\u521d\u59cb\u5316 \u548c \u62f7\u8d1d\u8d4b\u503c \u90fd\u88ab\u7981\u7528\u4e86\u3002\u5982\u679c\u4f60\u6211\u76f8\u8981\u8f6c\u79fb\u4e00\u4e2a\u88ab std::unique_ptr \u7ba1\u7406\u7684\u5185\u5bb9\uff0c\u4f60\u5fc5\u987b\u4f7f\u7528 \u79fb\u52a8\u8bed\u4e49 \u3002\u5728\u4ee5\u4e0a\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 std::move \uff08\u5c06 res1 \u8f6c\u5316\u6210\u4e00\u4e2a\u53f3\u503c\uff0c\u53ef\u4ee5\u89e6\u53d1\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u8d4b\u503c\uff09 \u6765\u5b8c\u6210\u3002 \u8bbf\u95ee\u88ab\u7ba1\u7406\u7684\u5bf9\u8c61 \u00b6 std::unique_ptr \u91cd\u8f7d\u4e86 *\u64cd\u4f5c\u7b26 \u548c ->\u64cd\u4f5c\u7b26 \u53ef\u4ee5\u7528\u6765\u8fd4\u56de\u6240\u7ba1\u7406\u7684\u8d44\u6e90\uff0c operator* \u8fd4\u56de\u4e00\u4e2a\u8d44\u6e90\u7684\u5f15\u7528\uff0c operator-> \u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u3002 \u8bb0\u4f4f std::unique_ptr \u53ef\u80fd\u4e0d\u603b\u662f\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\uff0c\u5b83\u4e5f\u53ef\u80fd\u88ab\u521b\u9020\u4e3a\u7a7a(\u4f7f\u7528\u9ed8\u8ba4\u7684\u6784\u9020\u51fd\u6570\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u7a7a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570)\uff0c\u6216\u8005\u56e0\u4e3a\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u79fb\u52a8\u5230\u53e6\u4e00\u4e2a std::unique_ptr . \u56e0\u6b64\u5728\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9b\u6307\u9488\u4e4b\u524d\uff0c\u6211\u4eec\u5e94\u8be5\u68c0\u67e5 std::unique_ptr \u662f\u5426\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u8fd9\u5f88\u7b80\u5355\uff1a std::unique_ptr \u6709\u4e00\u4e2a\u53ef\u4ee5\u8f6c\u5316\u6210\u4e00\u4e2abool\u503c\u7684\u51fd\u6570\uff0c\u5982\u679c\u8be5 unique_ptr \u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\u5219\u8fd4\u56de true\u3002 \u8fd9\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; int main () { std :: unique_ptr < Resource > res { new Resource {} }; if ( res ) // use implicit cast to bool to ensure res contains a Resource std :: cout << * res << '\\n' ; // print the Resource that res is owning return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed \u5728\u4e0a\u65b9\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u91cd\u8f7d\u7684 operator* \u6765\u83b7\u5f97 unique_ptr \u6301\u6709\u7684\u8d44\u6e90\uff0c\u7136\u540e\u9001\u5230 std::cout \u6253\u5370\u3002 std::unique_ptr \u548c\u6570\u7ec4 \u00b6 \u4e0d\u50cf std::auto_ptr \u90a3\u6837\uff0c std::unique_ptr \u662f\u8db3\u591f\u667a\u80fd\u7684\u77e5\u9053\u662f\u5426\u4f7f\u7528\u6807\u91cf\u5220\u9664(scalar delete)\u6216\u6570\u7ec4\u5220\u9664(array delete[])\uff0c\u56e0\u6b64 std::unique_ptr \u53ef\u4ee5\u540c\u65f6\u642d\u914d scalar objects \u548c arrays \u3002 \u7136\u800c\uff0c std::array \u6216\u8005 std::vector (\u6216 std::string ) \u603b\u4f1a\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff0c\u76f8\u6bd4\u8d77\u7528\u56fa\u5b9a\u6570\u7ec4( fixed array )\uff0cC\u7c7b\u578b\u5b57\u7b26\u4e32( C-style string ) \u6216 \u52a8\u6001\u6570\u7ec4\uff08 dynamic array \uff09\u642d\u914d std::unique_ptr \u3002 \u89c4\u5219\uff1a\u66f4\u52a0\u504f\u597d\u4f7f\u7528 std::array , std::vector \u6216\u8005 std::string \u800c\u4e0d\u662f\u667a\u80fd\u6307\u9488\u7ba1\u7406\u7684\u5b9a\u957f\u6570\u7ec4\uff0c\u52a8\u6001\u6570\u7ec4\uff0c\u6216\u8005C\u98ce\u683c\u5b57\u7b26\u4e32\u3002 std::make_unique \u00b6 C++14 \u5e26\u6709\u4e00\u4e2a\u9644\u52a0\u7684\u51fd\u6570\u53eb\u505a std::make_unique() \u3002\u6b64\u6a21\u677f\u5316\u51fd\u6570\u6784\u9020\u6a21\u677f\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5e76\u4f7f\u7528\u4f20\u9012\u7ed9\u51fd\u6570\u7684\u53c2\u6570\u5bf9\u5176\u8fdb\u884c\u521d\u59cb\u5316\u3002 # include <memory> // for std::unique_ptr and std::make_unique # include <iostream> class Fraction { private : int m_numerator { 0 }; int m_denominator { 1 }; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { // Create a single dynamically allocated Fraction with numerator 3 and denominator 5 // We can also use automatic type deduction to good effect here auto f1 { std :: make_unique < Fraction > ( 3 , 5 ) }; std :: cout << * f1 << '\\n' ; // Create a dynamically allocated array of Fractions of length 4 auto f2 { std :: make_unique < Fraction [] > ( 4 ) }; std :: cout << f2 [ 0 ] << '\\n' ; return 0 ; } \u8f93\u51fa 3 /5 0 /1 std::make_unique \u7684\u4f7f\u7528\u662f\u4e00\u4e2a\u53ef\u9009\u9879\uff0c\u4f46\u662f\u662f\u975e\u5e38\u63a8\u8350\u7684\u3002\u8fd9\u662f\u56e0\u4e3a\u4f7f\u7528 std::make_unique \u5f88\u7b80\u5355\uff0c\u5e76\u4e14\u5b83\u4e5f\u9700\u8981\u5199\u66f4\u5c11\u7684\u4ee3\u7801\u3002\uff08\u5f53\u4f7f\u7528\u81ea\u52a8\u7c7b\u578b\u5224\u65ad\u65f6\uff09\uff0c\u66f4\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b83\u4e5f\u89e3\u51b3\u4e86\u4e00\u4e2a\u5f02\u5e38\u5b89\u5168\u95ee\u9898\uff0c\u8fd9\u4f1a\u5f15\u8d77C++... (Furthermore it resolves an exception safety issue that can result from C++ leaving the order of evaluation for function arguments unspecified.) \u89c4\u5b9a: \u4f7f\u7528 std::make_unique() \u800c\u4e0d\u662f\u81ea\u5df1\u624b\u52a8\u521b\u5efa\u3002 \u5f02\u5e38\u5b89\u5168\u95ee\u9898\u7ec6\u8282 \u00b6 \u7ed9\u90a3\u4e9b\u60f3\u77e5\u9053\u4e0a\u65b9\u63d0\u5230\u7684\u662f\u4ec0\u4e48 \u201c\u5f02\u5e38\u5b89\u5168\u95ee\u9898\u201d\u7684\u4eba\u4e00\u4e9b\u89e3\u91ca\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u4e8e\u6b64\u95ee\u9898\u7684\u63cf\u8ff0 \u601d\u8003\u4e00\u4e2a\u50cf\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\uff1a some_function ( std :: unique_ptr < T > ( new T ), function_that_can_throw_exception ()); \u7f16\u8bd1\u5668\u5728\u5982\u4f55\u5904\u7406\u8fd9\u4e2a\u8c03\u7528\u65b9\u9762\u6709\u5f88\u5927\u7684\u6d3b\u52a8\u7a7a\u95f4\u3002\u5b83\u53ef\u80fd\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 T\uff0c\u7136\u540e\u518d\u8c03\u7528 function_that_can_throw_exception() \uff0c\u7136\u540e\u521b\u5efa std::unique_ptr \u7ba1\u7406\u8fd9\u52a8\u6001\u5206\u914d\u7684T\u3002\u5982\u679c function_that_can_throw_exception() \u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u7136\u540e T \u88ab\u5206\u914d\u4f46\u662f\u6ca1\u6709\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u7528\u6765\u91ca\u653e\u8be5\u8d44\u6e90\u7684\u667a\u80fd\u6307\u9488\u8fd8\u6ca1\u6709\u88ab\u521b\u5efa\uff0c\u8fd9\u5f15\u8d77\u4e86 T \u7684\u6cc4\u9732\u3002 std::make_unique() \u4e0d\u4f1a\u9047\u5230\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a\u5bf9\u8c61 T \u7684\u521b\u5efa\u548c\u521b\u5efa std::unique_ptr \u90fd\u53d1\u751f\u5728 std::make_unique() \u51fd\u6570\uff0c\u4e0d\u5b58\u5728\u6267\u884c\u987a\u5e8f\u6a21\u7cca\u7684\u95ee\u9898\u3002 \u4ece\u51fd\u6570\u8fd4\u56de std::unique_ptr \u00b6 std::unique_ptr \u53ef\u4ee5\u88ab\u4ece\u4e00\u4e2a\u51fd\u6570\u5b89\u5168\u7684\u8fd4\u56de\uff1a std :: unique_ptr < Resource > createResource () { return std :: make_unique < Resource > (); } int main () { auto ptr { createResource () }; // do whatever return 0 ; } \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c createResource() \u901a\u8fc7\u503c\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u3002\u5982\u679c\u8fd9\u503c\u4e0d\u4f1a\u88ab\u8d4b\u503c\u7ed9\u4efb\u4f55\u5bf9\u8c61\uff0c\u8fd4\u56de\u7684\u4e34\u65f6\u503c\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u6e05\u7406\u3002\u5982\u679c\u5b83\u88ab\u8d4b\u503c\uff08\u50cfmain\u4e2d\u5c55\u793a\u7684\u90a3\u6837\uff09\uff0c\u5728C++14\u6216\u8005\u66f4\u65e9\uff0c\u79fb\u52a8\u8bed\u4e49\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u4ece\u8fd4\u56de\u503c\u8f6c\u79fb\u8d44\u6e90\u5230\u5373\u5c06\u8d4b\u503c\u7684\u5bf9\u8c61\uff08\u4e0a\u65b9\u4f8b\u5b50\u4e2d\u7684ptr\uff09\uff0c\u5728C++17\u6216\u8005\u66f4\u65b0\uff0c\u8fd4\u56de\u5c06\u4f1a\u88ab\u7701\u7565\uff0c\u8fd9\u4f7f\u5f97\u76f8\u6bd4\u8fd4\u56de\u539f\u6307\u9488\uff0c\u8fd4\u56de\u4e00\u4e2a unique_ptr \u7684\u8d44\u6e90\u66f4\u52a0\u5b89\u5168\u3002 \u603b\u4f53\u6765\u8bb2\uff0c\u4f60\u5e94\u8be5\u4ece\u4e0d\u901a\u8fc7\u6307\u9488\u6216\u5f15\u7528\u8fd4\u56de std::unique_ptr \uff08\u9664\u975e\u4f60\u6709\u7279\u6b8a\u7684\u539f\u56e0\u6765\u8fd9\u6837\u505a\uff09\u3002 \u5411\u51fd\u6570\u4f20\u5165 std::unique_ptr \u00b6 \u5982\u679c\u4f60\u60f3\u8981\u51fd\u6570\u6765\u83b7\u5f97\u6307\u9488\u5185\u5bb9\u7684\u6240\u6709\u6743\uff0c\u901a\u8fc7\u503c\u4f20\u4e00\u4e2a std::unique_ptr \u3002\u6ce8\u610f\uff0c\u56e0\u4e3a\u62f7\u8d1d\u8bed\u4e49\u5df2\u7ecf\u88ab\u7981\u7528\uff0c\u4f60\u5c06\u4f1a\u4f7f\u7528 std::move \u6765\u4f20\u503c\u8fdb\u5165\u51fd\u6570\u3002 # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; void takeOwnership ( std :: unique_ptr < Resource > res ) { if ( res ) std :: cout << * res << '\\n' ; } // the Resource is destroyed here int main () { auto ptr { std :: make_unique < Resource > () }; // takeOwnership(ptr); // This doesn't work, need to use move semantics takeOwnership ( std :: move ( ptr )); // ok: use move semantics std :: cout << \"Ending program \\n \" ; return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed Ending program \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u8d44\u6e90\u7684\u6240\u6709\u6743\u88ab\u4f20\u7ed9\u4e86 takeOwnership() \uff0c\u56e0\u6b64\u8d44\u6e90\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728 takeOwnership() \u51fd\u6570\u7ed3\u675f\u65f6\uff0c\u800c\u4e0d\u662f main() \u7136\u800c\uff0c\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u60f3\u8ba9\u51fd\u6570\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743\u3002\u867d\u7136\u4f60\u53ef\u4ee5\u4f20\u5165\u4e00\u4e2a std::unique_ptr \u7684\u5f15\u7528\uff08\u8fd9\u5141\u8bb8\u51fd\u6570\u4f7f\u7528\u5bf9\u8c61\uff0c\u800c\u4e0d\u5f97\u5230\u6240\u6709\u6743\uff09\uff0c\u4f60\u5e94\u8be5\u4ec5\u4ec5\u5728 \u8c03\u7528\u51fd\u6570\u4f1a\u4fee\u6539\u6216\u8005\u6539\u53d8\u6301\u5176\u7ba1\u7406\u7684\u5bf9\u8c61\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u3002 \u76f8\u53cd\uff0c\u66f4\u597d\u7684\u65b9\u5f0f\u662f\u4f20\u5165\u4e00\u4e2a\u8d44\u6e90\u672c\u8eab\uff08\u901a\u8fc7\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u6839\u636enull\u662f\u5426\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u53c2\u6570\uff09\uff0c\u8fd9\u5141\u8bb8\u51fd\u6570\u4fdd\u6301\u8c03\u7528\u8005\u7ba1\u7406\u8d44\u6e90\u3002\u4e3a\u4e86\u4ece\u4e00\u4e2a std::unique_ptr \u5f97\u5230\u539f\u6765\u7684\u8d44\u6e90\u6307\u9488\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 get() \u6210\u5458\u51fd\u6570\uff1a # include <memory> // for std::unique_ptr # include <iostream> class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; // The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr<Resource> void useResource ( Resource * res ) { if ( res ) std :: cout << * res << '\\n' ; } int main () { auto ptr { std :: make_unique < Resource > () }; useResource ( ptr . get ()); // note: get() used here to get a pointer to the Resource std :: cout << \"Ending program \\n \" ; return 0 ; } // The Resource is destroyed here \u8f93\u51fa Resource acquired I am a resource Ending program Resource destroyed std::unique_ptr \u548c\u7c7b\u578b \u00b6 \u5f53\u7136\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 std::unique_ptr \u4f5c\u4e3a\u4f60\u7684\u7c7b\u578b\u4e2d\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u4f60\u5c06\u4e0d\u7528\u62c5\u5fc3\u786e\u4fdd\u4f60\u7684\u7c7b\u578b\u7684\u6790\u6784\u51fd\u6570\u91ca\u653e\u52a8\u6001\u5185\u5b58\u4e86\uff0c\u56e0\u4e3a std::uniqut_ptr \u5c06\u4f1a\u81ea\u52a8\u7684\u9500\u6bc1\uff0c\u5f53\u7c7b\u578b\u5bf9\u8c61\u88ab\u9500\u6bc1\u65f6\u3002\u7136\u800c\uff0c\u8bb0\u4f4f\u5982\u679c\u4f60\u7684\u7c7b\u578b\u662f\u52a8\u6001\u5206\u914d\u7684\uff0c\u90a3\u4e48\u5bf9\u8c61\u672c\u8eab\u5c31\u6709\u98ce\u9669\u4e0d\u80fd\u88ab\u6b63\u786e\u7684\u91ca\u653e\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u667a\u80fd\u6307\u9488\u4e5f\u4e0d\u80fd\u5e2e\u4f60\u3002 std::unique_ptr \u7684\u8bef\u7528 \u00b6 \u8fd9\u6709\u4e24\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u8bef\u7528 std::unique_ptr \uff0c\u4ed6\u4eec\u90fd\u662f\u975e\u5e38\u5bb9\u6613\u907f\u514d\u7684\u3002 \u9996\u5148\uff0c\u4e0d\u8981\u8ba9\u591a\u4e2a\u6307\u9488\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\uff0c\u4f8b\u5982\uff1a Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; std :: unique_ptr < Resource > res2 { res }; \u8fd9\u5728\u8bed\u4e49\u4e0a\u662f\u5408\u6cd5\u7684\uff0c\u6700\u540e\u7684\u7ed3\u679c\u5c31\u662f res1 \u548c res2 \u5c1d\u8bd5\u5220\u9664\u8d44\u6e90\uff0c\u4f1a\u5f15\u53d1\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u7b2c\u4e8c\uff0c\u4e0d\u8981\u624b\u52a8\u5220\u9664 std::unique_ptr \u7ba1\u7406\u7684\u8d44\u6e90 Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; delete res ; \u5982\u679c\u4f60\u90a3\u6837\u505a\uff0c std::unique_ptr \u5c06\u4f1a\u5c1d\u8bd5\u5220\u9664\u4e00\u4e2a\u65e9\u5c31\u5220\u9664\u7684\u8d44\u6e90\uff0c\u4e5f\u4f1a\u5f15\u8d77\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u6211\u4eec\u6ce8\u610f\u5230\uff0c std::make_unique() \u521a\u597d\u65e0\u610f\u4e2d\u5c31\u907f\u514d\u4e86\u8fd9\u4e24\u79cd\u60c5\u51b5\u7684\u53d1\u751f\u3002","title":"15.5 std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#155-stdunique_ptr","text":"By Alex on March 15 th , 2017 | last modified by nascardriver on July 12 th , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u672c\u7ae0\u7684\u5f00\u59cb\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u5728\u4e00\u4e9b\u6761\u4ef6\u4e0b\uff0c\u5982\u4f55\u4f7f\u7528\u6307\u9488\u4f1a\u5f15\u8d77bug\u548c\u5185\u5b58\u6cc4\u9732\u3002\u4f8b\u5982\uff0c\u8fd9\u5c31\u53ef\u80fd\u4f1a\u53d1\u751f\u5728\uff0c\u5f53\u4e00\u4e2a\u51fd\u6570\u63d0\u524d\u9000\u51fa\uff0c\u6216\u629b\u51fa\u5f02\u5e38\uff0c\u6216\u8005\u6307\u9488\u6ca1\u6709\u88ab\u5408\u7406\u7684\u5220\u9664\u65f6\u3002 #include <iostream> void someFunction () { auto * ptr { new Resource () }; int x {}; std :: cout << \"Enter an integer: \" ; std :: cin >> x ; if ( x == 0 ) throw 0 ; // the function returns early, and ptr won\u2019t be deleted! // do stuff with ptr here delete ptr ; } \u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 \u79fb\u52a8\u8bed\u4e49 \u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u56de\u5230 \u667a\u80fd\u6307\u9488 \u7684\u8bdd\u9898\u4e86\u3002\u63d0\u9192\u4e00\u4e0b\uff0c \u667a\u80fd\u6307\u9488 \u662f\u4e00\u4e2a\u7ba1\u7406\u7740 \u52a8\u6001\u5206\u914d\u8d44\u6e90 \u7684\u7c7b\uff0c\u5e76\u4e14\u4fdd\u8bc1\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\u5728\u5408\u9002\u7684\u65f6\u95f4\u88ab\u5408\u9002\u7684 \u91ca\u653e \uff0c\uff08\u901a\u5e38\u662f\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff09\u3002 \u56e0\u4e3a\u8fd9\u6837\uff0c\u667a\u80fd\u6307\u9488\u672c\u8eab\u5e94\u8be5\u4ece\u4e0d\u88ab\u52a8\u6001\u5206\u914d\uff08\u5426\u5219\uff0c\u5982\u679c\u4ed6\u4eec\u81ea\u5df1\u672c\u8eab\u5c31\u53ef\u80fd\u6709\u6ca1\u88ab\u5408\u9002\u5730\u91ca\u653e\u7684\u98ce\u9669\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u6301\u6709\u7684\u5bf9\u8c61\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u9732\uff09\u3002\u901a\u8fc7\u59cb\u7ec8\u53ea\u5728\u6808\u533a\u521b\u5efa\u667a\u80fd\u6307\u9488\u7684\u65b9\u5f0f\uff08\u4f5c\u4e3a\u5c40\u90e8\u53d8\u91cf\u6216\u8005\u662f\u5176\u4ed6\u7c7b\u7684\u7ec4\u6210\uff09\uff0c\u6211\u4eec\u4fdd\u8bc1\u90a3\u6837\u7684\u667a\u80fd\u6307\u9488\u5c06\u4f1a\u5408\u7406\u5730\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5f53\u51fd\u6570\u7ed3\u675f\u6216\u8005\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u65f6\uff0c\u80fd\u786e\u4fdd\u667a\u80fd\u6307\u9488 \u6301\u6709\u7684\u5bf9\u8c61 \u88ab\u5408\u9002\u7684\u91ca\u653e\u3002 C++11 \u6807\u51c6\u5e93\u9644\u5e26\u56db\u79cd\u6307\u9488\u7c7b\u578b\uff1a std::auto_ptr \uff08\u4e0d\u5e94\u8be5\u4f7f\u7528\u2014\u2014\u2014\u2014\u5728C++17\u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\uff09\uff0c std::unique_ptr \uff0c std::share_ptr \u548c std::weak_ptr \u3002 std::unique_ptr \u662f\u76ee\u524d\u6700\u591a\u4f7f\u7528\u7684\u667a\u80fd\u6307\u9488\u7c7b\uff0c\u56e0\u6b64\u6211\u4eec\u4e5f\u7b2c\u4e00\u4e2a\u6765\u8bb2\u5b83\u3002\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u91cc\uff0c\u6211\u4eec\u4f1a\u8bb2 std::shared_ptr \u548c std::weak_ptr \u3002","title":"15.5 std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr","text":"std::unique_ptr \u662f C++11 \u4e2d std::auto_ptr \u7684\u66ff\u4ee3\u54c1\u3002\u5b83\u5e94\u8be5\u88ab\u7528\u4e8e\u7ba1\u7406\u4efb\u4f55\u52a8\u6001\u5206\u914d\uff0c\u5e76\u4e0d\u4f1a\u5728\u591a\u4e2a\u5bf9\u8c61\u4e2d\u5206\u4eab\u7684\u5bf9\u8c61\u3002 std::unique_ptr \uff0c\u5e94\u8be5\u5b8c\u5168\u7684\u6301\u6709\u5b83\u7ba1\u7406\u7684\u5bf9\u8c61\uff0c\u4e0d\u5e94\u8be5\u548c\u5176\u4ed6\u7c7b\u578b\u5206\u4eab\u5bf9\u8c61\u7684\u6240\u6709\u6743\u3002 std::unique_ptr \u5b9a\u4e49\u5728 <memory> \u5934\u4e2d\u3002 \u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2a\u7b80\u5355\u7684\u667a\u80fd\u6307\u9488\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::unique_ptr std :: unique_ptr < Resource > res { new Resource () }; return 0 ; } // res goes out of scope here, and the allocated Resource is destroyed \u56e0\u4e3a std::unique_ptr \u5728\u6808\u533a\u4e0a\u88ab\u5206\u914d\uff0c\u5b83\u6700\u7ec8\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u4f1a\u81ea\u52a8\u5220\u9664\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u3002 \u4e0d\u50cf std::auto_ptr \uff0c std::unique_ptr \u66f4\u9002\u5408\u7528\u6765\u5b9e\u73b0\u79fb\u52a8\u8bed\u4e49\u3002 # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { std :: unique_ptr < Resource > res1 { new Resource {} }; // Resource created here std :: unique_ptr < Resource > res2 {}; // Start as nullptr std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); // res2 = res1; // Won't compile: copy assignment is disabled res2 = std :: move ( res1 ); // res2 assumes ownership, res1 is set to null std :: cout << \"Ownership transferred \\n \" ; std :: cout << \"res1 is \" << ( static_cast < bool > ( res1 ) ? \"not null \\n \" : \"null \\n \" ); std :: cout << \"res2 is \" << ( static_cast < bool > ( res2 ) ? \"not null \\n \" : \"null \\n \" ); return 0 ; } // Resource destroyed here when res2 goes out of scope \u8fd9\u4e2a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a Resource acquired res1 is not null res2 is null Ownership transferred res1 is null res2 is not null Resource destroyed \u56e0\u4e3a std__unique_ptr \u5728\u8bbe\u8ba1\u65f6\u8003\u8651\u4e86\u79fb\u52a8\u8bed\u4e49\uff0c \u62f7\u8d1d\u521d\u59cb\u5316 \u548c \u62f7\u8d1d\u8d4b\u503c \u90fd\u88ab\u7981\u7528\u4e86\u3002\u5982\u679c\u4f60\u6211\u76f8\u8981\u8f6c\u79fb\u4e00\u4e2a\u88ab std::unique_ptr \u7ba1\u7406\u7684\u5185\u5bb9\uff0c\u4f60\u5fc5\u987b\u4f7f\u7528 \u79fb\u52a8\u8bed\u4e49 \u3002\u5728\u4ee5\u4e0a\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 std::move \uff08\u5c06 res1 \u8f6c\u5316\u6210\u4e00\u4e2a\u53f3\u503c\uff0c\u53ef\u4ee5\u89e6\u53d1\u4e00\u4e2a\u79fb\u52a8\u8d4b\u503c\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u8d4b\u503c\uff09 \u6765\u5b8c\u6210\u3002","title":"std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#_1","text":"std::unique_ptr \u91cd\u8f7d\u4e86 *\u64cd\u4f5c\u7b26 \u548c ->\u64cd\u4f5c\u7b26 \u53ef\u4ee5\u7528\u6765\u8fd4\u56de\u6240\u7ba1\u7406\u7684\u8d44\u6e90\uff0c operator* \u8fd4\u56de\u4e00\u4e2a\u8d44\u6e90\u7684\u5f15\u7528\uff0c operator-> \u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u3002 \u8bb0\u4f4f std::unique_ptr \u53ef\u80fd\u4e0d\u603b\u662f\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\uff0c\u5b83\u4e5f\u53ef\u80fd\u88ab\u521b\u9020\u4e3a\u7a7a(\u4f7f\u7528\u9ed8\u8ba4\u7684\u6784\u9020\u51fd\u6570\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u7a7a\u6307\u9488\u4f5c\u4e3a\u53c2\u6570)\uff0c\u6216\u8005\u56e0\u4e3a\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u79fb\u52a8\u5230\u53e6\u4e00\u4e2a std::unique_ptr . \u56e0\u6b64\u5728\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9b\u6307\u9488\u4e4b\u524d\uff0c\u6211\u4eec\u5e94\u8be5\u68c0\u67e5 std::unique_ptr \u662f\u5426\u7ba1\u7406\u4e00\u4e2a\u8d44\u6e90\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u8fd9\u5f88\u7b80\u5355\uff1a std::unique_ptr \u6709\u4e00\u4e2a\u53ef\u4ee5\u8f6c\u5316\u6210\u4e00\u4e2abool\u503c\u7684\u51fd\u6570\uff0c\u5982\u679c\u8be5 unique_ptr \u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\u5219\u8fd4\u56de true\u3002 \u8fd9\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a # include <iostream> # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; int main () { std :: unique_ptr < Resource > res { new Resource {} }; if ( res ) // use implicit cast to bool to ensure res contains a Resource std :: cout << * res << '\\n' ; // print the Resource that res is owning return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed \u5728\u4e0a\u65b9\u7684\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u91cd\u8f7d\u7684 operator* \u6765\u83b7\u5f97 unique_ptr \u6301\u6709\u7684\u8d44\u6e90\uff0c\u7136\u540e\u9001\u5230 std::cout \u6253\u5370\u3002","title":"\u8bbf\u95ee\u88ab\u7ba1\u7406\u7684\u5bf9\u8c61"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_1","text":"\u4e0d\u50cf std::auto_ptr \u90a3\u6837\uff0c std::unique_ptr \u662f\u8db3\u591f\u667a\u80fd\u7684\u77e5\u9053\u662f\u5426\u4f7f\u7528\u6807\u91cf\u5220\u9664(scalar delete)\u6216\u6570\u7ec4\u5220\u9664(array delete[])\uff0c\u56e0\u6b64 std::unique_ptr \u53ef\u4ee5\u540c\u65f6\u642d\u914d scalar objects \u548c arrays \u3002 \u7136\u800c\uff0c std::array \u6216\u8005 std::vector (\u6216 std::string ) \u603b\u4f1a\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff0c\u76f8\u6bd4\u8d77\u7528\u56fa\u5b9a\u6570\u7ec4( fixed array )\uff0cC\u7c7b\u578b\u5b57\u7b26\u4e32( C-style string ) \u6216 \u52a8\u6001\u6570\u7ec4\uff08 dynamic array \uff09\u642d\u914d std::unique_ptr \u3002 \u89c4\u5219\uff1a\u66f4\u52a0\u504f\u597d\u4f7f\u7528 std::array , std::vector \u6216\u8005 std::string \u800c\u4e0d\u662f\u667a\u80fd\u6307\u9488\u7ba1\u7406\u7684\u5b9a\u957f\u6570\u7ec4\uff0c\u52a8\u6001\u6570\u7ec4\uff0c\u6216\u8005C\u98ce\u683c\u5b57\u7b26\u4e32\u3002","title":"std::unique_ptr \u548c\u6570\u7ec4"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdmake_unique","text":"C++14 \u5e26\u6709\u4e00\u4e2a\u9644\u52a0\u7684\u51fd\u6570\u53eb\u505a std::make_unique() \u3002\u6b64\u6a21\u677f\u5316\u51fd\u6570\u6784\u9020\u6a21\u677f\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5e76\u4f7f\u7528\u4f20\u9012\u7ed9\u51fd\u6570\u7684\u53c2\u6570\u5bf9\u5176\u8fdb\u884c\u521d\u59cb\u5316\u3002 # include <memory> // for std::unique_ptr and std::make_unique # include <iostream> class Fraction { private : int m_numerator { 0 }; int m_denominator { 1 }; public : Fraction ( int numerator = 0 , int denominator = 1 ) : m_numerator { numerator }, m_denominator { denominator } { } friend std :: ostream & operator << ( std :: ostream & out , const Fraction & f1 ) { out << f1 . m_numerator << '/' << f1 . m_denominator ; return out ; } }; int main () { // Create a single dynamically allocated Fraction with numerator 3 and denominator 5 // We can also use automatic type deduction to good effect here auto f1 { std :: make_unique < Fraction > ( 3 , 5 ) }; std :: cout << * f1 << '\\n' ; // Create a dynamically allocated array of Fractions of length 4 auto f2 { std :: make_unique < Fraction [] > ( 4 ) }; std :: cout << f2 [ 0 ] << '\\n' ; return 0 ; } \u8f93\u51fa 3 /5 0 /1 std::make_unique \u7684\u4f7f\u7528\u662f\u4e00\u4e2a\u53ef\u9009\u9879\uff0c\u4f46\u662f\u662f\u975e\u5e38\u63a8\u8350\u7684\u3002\u8fd9\u662f\u56e0\u4e3a\u4f7f\u7528 std::make_unique \u5f88\u7b80\u5355\uff0c\u5e76\u4e14\u5b83\u4e5f\u9700\u8981\u5199\u66f4\u5c11\u7684\u4ee3\u7801\u3002\uff08\u5f53\u4f7f\u7528\u81ea\u52a8\u7c7b\u578b\u5224\u65ad\u65f6\uff09\uff0c\u66f4\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b83\u4e5f\u89e3\u51b3\u4e86\u4e00\u4e2a\u5f02\u5e38\u5b89\u5168\u95ee\u9898\uff0c\u8fd9\u4f1a\u5f15\u8d77C++... (Furthermore it resolves an exception safety issue that can result from C++ leaving the order of evaluation for function arguments unspecified.) \u89c4\u5b9a: \u4f7f\u7528 std::make_unique() \u800c\u4e0d\u662f\u81ea\u5df1\u624b\u52a8\u521b\u5efa\u3002","title":"std::make_unique"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#_2","text":"\u7ed9\u90a3\u4e9b\u60f3\u77e5\u9053\u4e0a\u65b9\u63d0\u5230\u7684\u662f\u4ec0\u4e48 \u201c\u5f02\u5e38\u5b89\u5168\u95ee\u9898\u201d\u7684\u4eba\u4e00\u4e9b\u89e3\u91ca\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u4e8e\u6b64\u95ee\u9898\u7684\u63cf\u8ff0 \u601d\u8003\u4e00\u4e2a\u50cf\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\uff1a some_function ( std :: unique_ptr < T > ( new T ), function_that_can_throw_exception ()); \u7f16\u8bd1\u5668\u5728\u5982\u4f55\u5904\u7406\u8fd9\u4e2a\u8c03\u7528\u65b9\u9762\u6709\u5f88\u5927\u7684\u6d3b\u52a8\u7a7a\u95f4\u3002\u5b83\u53ef\u80fd\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 T\uff0c\u7136\u540e\u518d\u8c03\u7528 function_that_can_throw_exception() \uff0c\u7136\u540e\u521b\u5efa std::unique_ptr \u7ba1\u7406\u8fd9\u52a8\u6001\u5206\u914d\u7684T\u3002\u5982\u679c function_that_can_throw_exception() \u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u7136\u540e T \u88ab\u5206\u914d\u4f46\u662f\u6ca1\u6709\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u7528\u6765\u91ca\u653e\u8be5\u8d44\u6e90\u7684\u667a\u80fd\u6307\u9488\u8fd8\u6ca1\u6709\u88ab\u521b\u5efa\uff0c\u8fd9\u5f15\u8d77\u4e86 T \u7684\u6cc4\u9732\u3002 std::make_unique() \u4e0d\u4f1a\u9047\u5230\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a\u5bf9\u8c61 T \u7684\u521b\u5efa\u548c\u521b\u5efa std::unique_ptr \u90fd\u53d1\u751f\u5728 std::make_unique() \u51fd\u6570\uff0c\u4e0d\u5b58\u5728\u6267\u884c\u987a\u5e8f\u6a21\u7cca\u7684\u95ee\u9898\u3002","title":"\u5f02\u5e38\u5b89\u5168\u95ee\u9898\u7ec6\u8282"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_2","text":"std::unique_ptr \u53ef\u4ee5\u88ab\u4ece\u4e00\u4e2a\u51fd\u6570\u5b89\u5168\u7684\u8fd4\u56de\uff1a std :: unique_ptr < Resource > createResource () { return std :: make_unique < Resource > (); } int main () { auto ptr { createResource () }; // do whatever return 0 ; } \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c createResource() \u901a\u8fc7\u503c\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u3002\u5982\u679c\u8fd9\u503c\u4e0d\u4f1a\u88ab\u8d4b\u503c\u7ed9\u4efb\u4f55\u5bf9\u8c61\uff0c\u8fd4\u56de\u7684\u4e34\u65f6\u503c\u5c06\u4f1a\u79bb\u5f00\u4f5c\u7528\u57df\u5e76\u4e14\u88ab\u6e05\u7406\u3002\u5982\u679c\u5b83\u88ab\u8d4b\u503c\uff08\u50cfmain\u4e2d\u5c55\u793a\u7684\u90a3\u6837\uff09\uff0c\u5728C++14\u6216\u8005\u66f4\u65e9\uff0c\u79fb\u52a8\u8bed\u4e49\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u4ece\u8fd4\u56de\u503c\u8f6c\u79fb\u8d44\u6e90\u5230\u5373\u5c06\u8d4b\u503c\u7684\u5bf9\u8c61\uff08\u4e0a\u65b9\u4f8b\u5b50\u4e2d\u7684ptr\uff09\uff0c\u5728C++17\u6216\u8005\u66f4\u65b0\uff0c\u8fd4\u56de\u5c06\u4f1a\u88ab\u7701\u7565\uff0c\u8fd9\u4f7f\u5f97\u76f8\u6bd4\u8fd4\u56de\u539f\u6307\u9488\uff0c\u8fd4\u56de\u4e00\u4e2a unique_ptr \u7684\u8d44\u6e90\u66f4\u52a0\u5b89\u5168\u3002 \u603b\u4f53\u6765\u8bb2\uff0c\u4f60\u5e94\u8be5\u4ece\u4e0d\u901a\u8fc7\u6307\u9488\u6216\u5f15\u7528\u8fd4\u56de std::unique_ptr \uff08\u9664\u975e\u4f60\u6709\u7279\u6b8a\u7684\u539f\u56e0\u6765\u8fd9\u6837\u505a\uff09\u3002","title":"\u4ece\u51fd\u6570\u8fd4\u56de std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_3","text":"\u5982\u679c\u4f60\u60f3\u8981\u51fd\u6570\u6765\u83b7\u5f97\u6307\u9488\u5185\u5bb9\u7684\u6240\u6709\u6743\uff0c\u901a\u8fc7\u503c\u4f20\u4e00\u4e2a std::unique_ptr \u3002\u6ce8\u610f\uff0c\u56e0\u4e3a\u62f7\u8d1d\u8bed\u4e49\u5df2\u7ecf\u88ab\u7981\u7528\uff0c\u4f60\u5c06\u4f1a\u4f7f\u7528 std::move \u6765\u4f20\u503c\u8fdb\u5165\u51fd\u6570\u3002 # include <memory> // for std::unique_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; void takeOwnership ( std :: unique_ptr < Resource > res ) { if ( res ) std :: cout << * res << '\\n' ; } // the Resource is destroyed here int main () { auto ptr { std :: make_unique < Resource > () }; // takeOwnership(ptr); // This doesn't work, need to use move semantics takeOwnership ( std :: move ( ptr )); // ok: use move semantics std :: cout << \"Ending program \\n \" ; return 0 ; } \u8f93\u51fa\uff1a Resource acquired I am a resource Resource destroyed Ending program \u6ce8\u610f\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u8d44\u6e90\u7684\u6240\u6709\u6743\u88ab\u4f20\u7ed9\u4e86 takeOwnership() \uff0c\u56e0\u6b64\u8d44\u6e90\u5c06\u4f1a\u88ab\u9500\u6bc1\u5728 takeOwnership() \u51fd\u6570\u7ed3\u675f\u65f6\uff0c\u800c\u4e0d\u662f main() \u7136\u800c\uff0c\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u60f3\u8ba9\u51fd\u6570\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743\u3002\u867d\u7136\u4f60\u53ef\u4ee5\u4f20\u5165\u4e00\u4e2a std::unique_ptr \u7684\u5f15\u7528\uff08\u8fd9\u5141\u8bb8\u51fd\u6570\u4f7f\u7528\u5bf9\u8c61\uff0c\u800c\u4e0d\u5f97\u5230\u6240\u6709\u6743\uff09\uff0c\u4f60\u5e94\u8be5\u4ec5\u4ec5\u5728 \u8c03\u7528\u51fd\u6570\u4f1a\u4fee\u6539\u6216\u8005\u6539\u53d8\u6301\u5176\u7ba1\u7406\u7684\u5bf9\u8c61\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u3002 \u76f8\u53cd\uff0c\u66f4\u597d\u7684\u65b9\u5f0f\u662f\u4f20\u5165\u4e00\u4e2a\u8d44\u6e90\u672c\u8eab\uff08\u901a\u8fc7\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u6839\u636enull\u662f\u5426\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u53c2\u6570\uff09\uff0c\u8fd9\u5141\u8bb8\u51fd\u6570\u4fdd\u6301\u8c03\u7528\u8005\u7ba1\u7406\u8d44\u6e90\u3002\u4e3a\u4e86\u4ece\u4e00\u4e2a std::unique_ptr \u5f97\u5230\u539f\u6765\u7684\u8d44\u6e90\u6307\u9488\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 get() \u6210\u5458\u51fd\u6570\uff1a # include <memory> // for std::unique_ptr # include <iostream> class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } friend std :: ostream & operator << ( std :: ostream & out , const Resource & res ) { out << \"I am a resource \\n \" ; return out ; } }; // The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr<Resource> void useResource ( Resource * res ) { if ( res ) std :: cout << * res << '\\n' ; } int main () { auto ptr { std :: make_unique < Resource > () }; useResource ( ptr . get ()); // note: get() used here to get a pointer to the Resource std :: cout << \"Ending program \\n \" ; return 0 ; } // The Resource is destroyed here \u8f93\u51fa Resource acquired I am a resource Ending program Resource destroyed","title":"\u5411\u51fd\u6570\u4f20\u5165 std::unique_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_4","text":"\u5f53\u7136\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 std::unique_ptr \u4f5c\u4e3a\u4f60\u7684\u7c7b\u578b\u4e2d\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u4ee5\u8fd9\u4e2a\u65b9\u5f0f\uff0c\u4f60\u5c06\u4e0d\u7528\u62c5\u5fc3\u786e\u4fdd\u4f60\u7684\u7c7b\u578b\u7684\u6790\u6784\u51fd\u6570\u91ca\u653e\u52a8\u6001\u5185\u5b58\u4e86\uff0c\u56e0\u4e3a std::uniqut_ptr \u5c06\u4f1a\u81ea\u52a8\u7684\u9500\u6bc1\uff0c\u5f53\u7c7b\u578b\u5bf9\u8c61\u88ab\u9500\u6bc1\u65f6\u3002\u7136\u800c\uff0c\u8bb0\u4f4f\u5982\u679c\u4f60\u7684\u7c7b\u578b\u662f\u52a8\u6001\u5206\u914d\u7684\uff0c\u90a3\u4e48\u5bf9\u8c61\u672c\u8eab\u5c31\u6709\u98ce\u9669\u4e0d\u80fd\u88ab\u6b63\u786e\u7684\u91ca\u653e\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u667a\u80fd\u6307\u9488\u4e5f\u4e0d\u80fd\u5e2e\u4f60\u3002","title":"std::unique_ptr \u548c\u7c7b\u578b"},{"location":"15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/#stdunique_ptr_5","text":"\u8fd9\u6709\u4e24\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u8bef\u7528 std::unique_ptr \uff0c\u4ed6\u4eec\u90fd\u662f\u975e\u5e38\u5bb9\u6613\u907f\u514d\u7684\u3002 \u9996\u5148\uff0c\u4e0d\u8981\u8ba9\u591a\u4e2a\u6307\u9488\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\uff0c\u4f8b\u5982\uff1a Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; std :: unique_ptr < Resource > res2 { res }; \u8fd9\u5728\u8bed\u4e49\u4e0a\u662f\u5408\u6cd5\u7684\uff0c\u6700\u540e\u7684\u7ed3\u679c\u5c31\u662f res1 \u548c res2 \u5c1d\u8bd5\u5220\u9664\u8d44\u6e90\uff0c\u4f1a\u5f15\u53d1\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u7b2c\u4e8c\uff0c\u4e0d\u8981\u624b\u52a8\u5220\u9664 std::unique_ptr \u7ba1\u7406\u7684\u8d44\u6e90 Resource * res { new Resource () }; std :: unique_ptr < Resource > res1 { res }; delete res ; \u5982\u679c\u4f60\u90a3\u6837\u505a\uff0c std::unique_ptr \u5c06\u4f1a\u5c1d\u8bd5\u5220\u9664\u4e00\u4e2a\u65e9\u5c31\u5220\u9664\u7684\u8d44\u6e90\uff0c\u4e5f\u4f1a\u5f15\u8d77\u672a\u5b9a\u4e49\u884c\u4e3a\u3002 \u6211\u4eec\u6ce8\u610f\u5230\uff0c std::make_unique() \u521a\u597d\u65e0\u610f\u4e2d\u5c31\u907f\u514d\u4e86\u8fd9\u4e24\u79cd\u60c5\u51b5\u7684\u53d1\u751f\u3002","title":"std::unique_ptr \u7684\u8bef\u7528"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/","text":"15.6 std::shared_ptr \u00b6 By Alex on March 16 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e0d\u50cf std::unique_ptr \u90a3\u6837\uff0c\u4ec5\u4ec5\u88ab\u8bbe\u8ba1\u5355\u72ec\u62e5\u6709\u548c\u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\uff0c std::shared_ptr \u662f\u4e3a\u4e86\u89e3\u51b3\u4f60\u9700\u8981\u521b\u5efa\u5f88\u591a\u667a\u80fd\u6307\u9488\u5171\u7528\u4e00\u4e2a\u8d44\u6e90\u7684\u60c5\u51b5\u3002 \u8fd9\u610f\u5473\u7740\uff0c\u540c\u65f6\u8bb8\u591a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u662fOK\u7684\u3002\u5728\u5185\u90e8\uff0c std::shared_ptr \u4fdd\u6301\u8ddf\u8e2a\u6b63\u5728\u5206\u4eab\u540c\u4e00\u4efd\u8d44\u6e90\u7684 std::shared_ptr \u6570\u91cf\u3002\u5f53\u53ea\u8981\u6709\u4e00\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\uff0c\u8fd9\u4e2a\u8d44\u6e90\u5c31\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u5373\u4f7f\u4e00\u4e9b std::shared_ptr \u88ab\u9500\u6bc1\u3002\u5f53\u6700\u540e\u4e00\u4e2a\u7ba1\u7406\u7740\u8d44\u6e90\u7684 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff08\u6216\u8005\u88ab\u91cd\u65b0\u8d4b\u503c\u6307\u5411\u5176\u4ed6\u8d44\u6e90\uff09\u539f\u6765\u7ba1\u7406\u7684\u8d44\u6e90\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002 \u548c std::unique_ptr \u4e00\u6837\uff0c std_shared_ptr \u5728 \u5934\u90e8\u4e2d\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( ptr1 ); // use copy initialization to make another std::shared_ptr pointing to the same thing std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u8f93\u51fa Resource acquired Killing one shared pointer Killing another shared pointer Resource destroyed \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u52a8\u6001\u8d44\u6e90\u5bf9\u8c61\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u540d\u5b57\u4e3a ptr1 \u7684 std::shared_ptr \u6765\u7ba1\u7406\u5b83\u3002\u5728\u8fd9\u4e2a\u5d4c\u5957\u7684\u8bed\u53e5\u5757\u4e2d\uff0c\u6211\u4eec\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff08 \u5728 std::shared_ptr \u4e2d\u5141\u8bb8\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u8d44\u6e90\u53ef\u4ee5\u88ab\u5171\u4eab \uff09\u6765\u521b\u5efa\u7b2c\u4e8c\u4e2a std::shared_ptr (ptr2)\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u3002\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c ptr1 \u6ce8\u610f\u5230\u8fd9\u91cc\u5df2\u7ecf\u6ca1\u6709 std::shared_ptr \u7ba1\u7406\u8fd9\u4efd\u8d44\u6e90\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u91ca\u653e\u8be5\u8d44\u6e90\u3002 \u6ce8\u610f\u6211\u4eec\u521b\u5efa\u4e86\u7b2c\u4e8c\u4e2a\u667a\u80fd\u6307\u9488\u4ece\u7b2c\u4e00\u4e2a\u667a\u80fd\u6307\u9488 \uff08\u4f7f\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff09 \u3002\u8fd9\u5f88\u91cd\u8981\uff0c\u601d\u8003\u5982\u4e0b\u4ee3\u7801\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( res ); // create ptr2 directly from res (instead of ptr1) std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, and the allocated Resource is destroyed std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed again \u8f93\u51fa Resource acquired Killing one shared pointer Resource destroyed Killing another shared pointer Resource destroyed \u7136\u540e\u7d27\u63a5\u7740\u5d29\u6e83\uff08\u81f3\u5c11\u5728\u4f5c\u8005\u7684\u673a\u5668\u4e0a\uff09\u3002 \u8fd9\u91cc\u4e0d\u540c\u7684\u662f\u6211\u4eec\u521b\u5efa\u4e86\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_Ptr \u3002\u7ed3\u679c\uff0c\u5373\u4f7f\u4ed6\u4eec\u90fd\u6307\u5411 \u540c\u4e00\u4efd\u8d44\u6e90 \uff0c\u4f46\u662f\u4ed6\u4eec\u90fd\u6ca1\u610f\u8bc6\u5230\u5bf9\u65b9\u7684\u5b58\u5728\u3002\u5f53 ptr2 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u4ed6 \u8ba4\u4e3a \u4ed6\u662f\u8d44\u6e90\u552f\u4e00\u7684\u62e5\u6709\u8005\uff0c\u6240\u4ee5\u91ca\u653e\u4e86\u5b83\u3002\u5f53 ptr1 \u4e4b\u540e\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u601d\u8003\u7684\u7740\u540c\u6837\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u5c1d\u8bd5\u518d\u6b21\u5220\u9664\u5b83\u3002\u7cdf\u7cd5\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u5f53\u4f60\u9700\u8981\u591a\u4e2a\u5171\u4eab\u6307\u9488\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u65f6\uff0c\u8fd9\u662f\u975e\u5e38\u5bb9\u6613\u4f7f\u7528 \u62f7\u8d1d\u8d4b\u503c \u6216\u8005 \u62f7\u8d1d\u521d\u59cb\u5316 \u6765\u907f\u514d\u7684\u3002 \u89c4\u5b9a\uff1a\u5f53\u4f60\u9700\u8981\u4e0d\u6b62\u4e00\u4e2a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\uff0c\u8bf7\u603b\u662f\u4ece\u5df2\u5b58\u5728\u7684 std::shared_ptr \u521b\u5efa\u62f7\u8d1d\u3002 std::make_shared \u00b6 \u5c31\u50cf\u5728C++14\u4e2d std::make_unique() \u53ef\u4ee5\u88ab\u7528\u6765\u521b\u5efa std::unique_ptr \u4e00\u6837\uff0c std::make_shared() \u53ef\u4ee5\uff08\u5e76\u4e14\u5e94\u8be5\uff09\u88ab\u7528\u6765\u521b\u5efa\u4e00\u4e2a std::shared_ptr \u3002 std::make_shared() \u5728C++11\u4e2d\u5c31\u53ef\u7528\u3002 \u6709\u4e9b\u4f8b\u5b50\uff0c\u4f7f\u7528\u4e86 std::make_shared() : #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr auto ptr1 = std :: make_shared < Resource > (); { auto ptr2 = ptr1 ; // create ptr2 using copy initialization of ptr1 std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u4f7f\u7528 std::make_shared() \u7684\u539f\u56e0\u548c std::make_unique() \u4e00\u6837 \u2014\u2014\u2014\u2014 std::make_shared() \u66f4\u7b80\u5355\u66f4\u5b89\u5168\uff08\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u4e0d\u53ef\u80fd\u76f4\u63a5\u521b\u5efa\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_ptr \u6307\u5411\u540c\u4e00\u5757\u8d44\u6e90\uff09\uff0c\u800c\u4e14\uff0c\u6bd4\u8d77\u4e0d\u4f7f\u7528\u5b83\uff0c std::make_shared() \u6709\u66f4\u52a0\u9ad8\u6027\u80fd\u3002\u5176\u539f\u56e0\u5728\u4e8e std::shared ptr \u8ddf\u8e2a\u6307\u5411\u7ed9\u5b9a\u8d44\u6e90\u7684\u6307\u9488\u6570\u91cf\u3002 \u6df1\u6316 std::shared_ptr \u00b6 \u4e0d\u50cf\u5185\u90e8\u4ec5\u4ec5\u4f7f\u7528\u4e00\u4e2a\u6307\u9488\u7684 std::unique_ptr \u90a3\u6837\uff0c std::shared_ptr \u5185\u90e8\u6709\u4e24\u4e2a\u6307\u9488\uff1a\u4e00\u4e2a\u6307\u9488\u6307\u5411\u88ab\u7ba1\u7406\u7684\u8d44\u6e90\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u5728\u201c\u63a7\u5236\u5757\uff08control block\uff09\u201d\uff0c\u662f\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\uff0c\u4f1a\u8ddf\u8e2a\u5f88\u591a\u4e1c\u897f\uff0c\u5305\u62ec\u6709\u591a\u5c11\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\u3002 \u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u6784\u9020\u51fd\u6570\u5355\u72ec\u521b\u5efa\u7684\u65f6\u5019\uff0c\u7ba1\u7406\u5bf9\u8c61\uff08\u4f20\u5165\u7684\u8d44\u6e90\uff09\u548c\u63a7\u5236\u5757\uff08\u6784\u9020\u5668\u521b\u5efa\uff09\u7684\u5185\u5b58\u5c31\u88ab\u5355\u72ec\u5206\u914d\u4e86\u3002\u7136\u800c\uff0c\u5f53\u4f7f\u7528 std::make_shared() \u65f6\uff0c\u8fd9\u53ef\u4ee5\u88ab\u4f18\u5316\u6210\u4e00\u4e2a\u5355\u72ec\u5185\u5b58\u5206\u914d\uff0c\u6709\u66f4\u597d\u7684\u6027\u80fd\u3002 \u8fd9\u4e5f\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u5355\u72ec\u521b\u5efa\u4e24\u4e2a std::shared_ptr \u4f1a\u9047\u5230\u95ee\u9898\u3002\u6bcf\u4e2a std::shared_ptr \u5c06\u4f1a\u6709\u4e00\u4e2a\u6307\u9488\u6307\u5411\u8d44\u6e90\uff0c\u7136\u800c\u6bcf\u4e2a std::shared_ptr \u72ec\u7acb\u5206\u914d\u5b83\u81ea\u5df1\u7684\u63a7\u5236\u5757\uff0c\u8fd9\u610f\u5473\u7740\u8fd9\u662f\u6301\u6709\u8d44\u6e90\u7684\u552f\u4e00\u7684\u6307\u9488\u3002\u56e0\u6b64\uff0c\u5f53 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u4f1a\u91ca\u653e\u8d44\u6e90\uff0c\u5e76\u6ca1\u6709\u610f\u8bc6\u5230\u8fd8\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u4ecd\u7136\u5728\u7ba1\u7406\u8d44\u6e90\u3002 \u7136\u800c\uff0c\u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u62f7\u8d1d\u6784\u9020\u590d\u5236\u7684\u65f6\u5019\uff0c\u63a7\u5236\u5757\u4e2d\u7684\u6570\u636e\u540c\u6837\u88ab\u66f4\u65b0\u6210\u5408\u9002\u7684\u503c\uff0c\u8868\u660e\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u5171\u540c\u7ba1\u7406\u8fd9\u4e2a\u8d44\u6e90\u3002 Shared pointers \u53ef\u4ee5\u4ece Unique pointers \u521b\u5efa \u00b6 \u4e00\u4e2a std::unique_ptr \u53ef\u4ee5\u88ab\u8f6c\u5316\u6210\u4e00\u4e2a std::shared_ptr \u901a\u8fc7\u4e00\u4e2a\u7279\u6b8a\u7684\u6784\u9020\u51fd\u6570\u63a5\u6536\u53f3\u503c\u3002 std::unique_ptr \u6301\u6709\u7684\u5185\u5bb9\u5c06\u4f1a\u79fb\u52a8\u7ed9 std::shared_ptr \u3002 \u7136\u800c\uff0c std::shared_ptr \u5374\u4e0d\u80fd\u5b89\u5168\u7684\u8f6c\u5316\u6210 std::unique_ptr \u3002\u8fd9\u610f\u5473\u7740\u5982\u679c\u4f60\u6b63\u5728\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u667a\u80fd\u6307\u9488\uff0c\u4f60\u6700\u597d\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u5e76\u4e14\u8d4b\u503c\u5b83\u7ed9\u4e00\u4e2a std::shared_ptr \u5982\u679c\u5408\u9002\u7684\u8bdd\u3002 \u4f7f\u7528 std::shared_ptr \u7684\u5371\u9669\u4e4b\u5904 \u00b6 std::shared_ptr \u6709\u4e00\u4e9b\u548c std::unique_ptr \u540c\u6837\u7684\u6311\u6218\uff0c\u5982\u679c std::shared_ptr \u6ca1\u6709\u88ab\u5408\u9002\u7684\u5904\u7406\uff08\u53ef\u80fd\u662f\u56e0\u4e3a\u5b83\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4e14\u4ece\u672a\u5220\u9664\uff0c\u6216\u8005\u5b83\u4f5c\u4e3a\u5bf9\u8c61\u7684\u4e00\u90e8\u5206\uff0c\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4ece\u672a\u5220\u9664\uff09\uff0c\u7d27\u63a5\u7740\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u4e5f\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u4f7f\u7528 std::unique_ptr \uff0c\u4f60\u4ec5\u9700\u8981\u53bb\u5173\u6ce8\u667a\u80fd\u6307\u9488\u662f\u5426\u88ab\u5408\u9002\u7684\u5904\u7406\u3002\u5982\u679c\u4f7f\u7528 std::shared_ptr \uff0c\u4f60\u4e0d\u5f97\u4e0d\u62c5\u5fc3\u4ed6\u4eec\u5168\u90e8\u3002\u5982\u679c\u4efb\u4f55\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u8d44\u6e90\u6ca1\u6709\u88ab\u5408\u9002\u7684\u6e05\u7406\uff0c\u8d44\u6e90\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002 std::shared_ptr \u548c\u6570\u7ec4 \u00b6 \u5728 C++14 \u6216\u66f4\u65e9\uff0c std::shared_ptr \u6ca1\u529e\u6cd5\u652f\u6301\u7ba1\u7406\u6570\u7ec4\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u4f7f\u7528C\u7c7b\u578b\u6570\u7ec4\u3002\u5728C++17\u4e2d\uff0c std::shared_ptr \u5df2\u7ecf\u652f\u6301\u6570\u7ec4\u4e86\u3002\u7136\u800c\uff0c\u5728C++17\u4e2d\uff0c std::make_shared \u4ecd\u7136\u7f3a\u4e4f\u5408\u9002\u7684\u9488\u5bf9\u6570\u7ec4\u7684\u652f\u6301\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u7528\u6765\u521b\u5efa\u6570\u7ec4\uff0c\u8fd9\u4f1a\u5728C++20\u4e2d\u88ab\u89e3\u51b3\u3002 \u7ed3\u8bba \u00b6 std::shared_ptr \u88ab\u8bbe\u8ba1\u7528\u4e8e\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u5171\u540c\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\u3002\u8d44\u6e90\u8b66\u5fbd\u88ab\u91ca\u653e\uff0c\u5f53\u6700\u540e\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u9500\u6bc1\u65f6\u3002","title":"15.6 std::shared_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#156-stdshared_ptr","text":"By Alex on March 16 th , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u4e0d\u50cf std::unique_ptr \u90a3\u6837\uff0c\u4ec5\u4ec5\u88ab\u8bbe\u8ba1\u5355\u72ec\u62e5\u6709\u548c\u7ba1\u7406\u4e00\u4efd\u8d44\u6e90\uff0c std::shared_ptr \u662f\u4e3a\u4e86\u89e3\u51b3\u4f60\u9700\u8981\u521b\u5efa\u5f88\u591a\u667a\u80fd\u6307\u9488\u5171\u7528\u4e00\u4e2a\u8d44\u6e90\u7684\u60c5\u51b5\u3002 \u8fd9\u610f\u5473\u7740\uff0c\u540c\u65f6\u8bb8\u591a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u662fOK\u7684\u3002\u5728\u5185\u90e8\uff0c std::shared_ptr \u4fdd\u6301\u8ddf\u8e2a\u6b63\u5728\u5206\u4eab\u540c\u4e00\u4efd\u8d44\u6e90\u7684 std::shared_ptr \u6570\u91cf\u3002\u5f53\u53ea\u8981\u6709\u4e00\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\uff0c\u8fd9\u4e2a\u8d44\u6e90\u5c31\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u5373\u4f7f\u4e00\u4e9b std::shared_ptr \u88ab\u9500\u6bc1\u3002\u5f53\u6700\u540e\u4e00\u4e2a\u7ba1\u7406\u7740\u8d44\u6e90\u7684 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff08\u6216\u8005\u88ab\u91cd\u65b0\u8d4b\u503c\u6307\u5411\u5176\u4ed6\u8d44\u6e90\uff09\u539f\u6765\u7ba1\u7406\u7684\u8d44\u6e90\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002 \u548c std::unique_ptr \u4e00\u6837\uff0c std_shared_ptr \u5728 \u5934\u90e8\u4e2d\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( ptr1 ); // use copy initialization to make another std::shared_ptr pointing to the same thing std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u8f93\u51fa Resource acquired Killing one shared pointer Killing another shared pointer Resource destroyed \u5728\u4e0a\u65b9\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u52a8\u6001\u8d44\u6e90\u5bf9\u8c61\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u540d\u5b57\u4e3a ptr1 \u7684 std::shared_ptr \u6765\u7ba1\u7406\u5b83\u3002\u5728\u8fd9\u4e2a\u5d4c\u5957\u7684\u8bed\u53e5\u5757\u4e2d\uff0c\u6211\u4eec\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff08 \u5728 std::shared_ptr \u4e2d\u5141\u8bb8\u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u8d44\u6e90\u53ef\u4ee5\u88ab\u5171\u4eab \uff09\u6765\u521b\u5efa\u7b2c\u4e8c\u4e2a std::shared_ptr (ptr2)\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u3002\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c ptr1 \u6ce8\u610f\u5230\u8fd9\u91cc\u5df2\u7ecf\u6ca1\u6709 std::shared_ptr \u7ba1\u7406\u8fd9\u4efd\u8d44\u6e90\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u91ca\u653e\u8be5\u8d44\u6e90\u3002 \u6ce8\u610f\u6211\u4eec\u521b\u5efa\u4e86\u7b2c\u4e8c\u4e2a\u667a\u80fd\u6307\u9488\u4ece\u7b2c\u4e00\u4e2a\u667a\u80fd\u6307\u9488 \uff08\u4f7f\u7528\u62f7\u8d1d\u521d\u59cb\u5316\uff09 \u3002\u8fd9\u5f88\u91cd\u8981\uff0c\u601d\u8003\u5982\u4e0b\u4ee3\u7801\u3002 #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { Resource * res = new Resource ; std :: shared_ptr < Resource > ptr1 ( res ); { std :: shared_ptr < Resource > ptr2 ( res ); // create ptr2 directly from res (instead of ptr1) std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, and the allocated Resource is destroyed std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed again \u8f93\u51fa Resource acquired Killing one shared pointer Resource destroyed Killing another shared pointer Resource destroyed \u7136\u540e\u7d27\u63a5\u7740\u5d29\u6e83\uff08\u81f3\u5c11\u5728\u4f5c\u8005\u7684\u673a\u5668\u4e0a\uff09\u3002 \u8fd9\u91cc\u4e0d\u540c\u7684\u662f\u6211\u4eec\u521b\u5efa\u4e86\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_Ptr \u3002\u7ed3\u679c\uff0c\u5373\u4f7f\u4ed6\u4eec\u90fd\u6307\u5411 \u540c\u4e00\u4efd\u8d44\u6e90 \uff0c\u4f46\u662f\u4ed6\u4eec\u90fd\u6ca1\u610f\u8bc6\u5230\u5bf9\u65b9\u7684\u5b58\u5728\u3002\u5f53 ptr2 \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u4ed6 \u8ba4\u4e3a \u4ed6\u662f\u8d44\u6e90\u552f\u4e00\u7684\u62e5\u6709\u8005\uff0c\u6240\u4ee5\u91ca\u653e\u4e86\u5b83\u3002\u5f53 ptr1 \u4e4b\u540e\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u601d\u8003\u7684\u7740\u540c\u6837\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u5c1d\u8bd5\u518d\u6b21\u5220\u9664\u5b83\u3002\u7cdf\u7cd5\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u5f53\u4f60\u9700\u8981\u591a\u4e2a\u5171\u4eab\u6307\u9488\u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\u65f6\uff0c\u8fd9\u662f\u975e\u5e38\u5bb9\u6613\u4f7f\u7528 \u62f7\u8d1d\u8d4b\u503c \u6216\u8005 \u62f7\u8d1d\u521d\u59cb\u5316 \u6765\u907f\u514d\u7684\u3002 \u89c4\u5b9a\uff1a\u5f53\u4f60\u9700\u8981\u4e0d\u6b62\u4e00\u4e2a std::shared_ptr \u6307\u5411\u540c\u4e00\u4efd\u8d44\u6e90\uff0c\u8bf7\u603b\u662f\u4ece\u5df2\u5b58\u5728\u7684 std::shared_ptr \u521b\u5efa\u62f7\u8d1d\u3002","title":"15.6 std::shared_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdmake_shared","text":"\u5c31\u50cf\u5728C++14\u4e2d std::make_unique() \u53ef\u4ee5\u88ab\u7528\u6765\u521b\u5efa std::unique_ptr \u4e00\u6837\uff0c std::make_shared() \u53ef\u4ee5\uff08\u5e76\u4e14\u5e94\u8be5\uff09\u88ab\u7528\u6765\u521b\u5efa\u4e00\u4e2a std::shared_ptr \u3002 std::make_shared() \u5728C++11\u4e2d\u5c31\u53ef\u7528\u3002 \u6709\u4e9b\u4f8b\u5b50\uff0c\u4f7f\u7528\u4e86 std::make_shared() : #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { // allocate a Resource object and have it owned by std::shared_ptr auto ptr1 = std :: make_shared < Resource > (); { auto ptr2 = ptr1 ; // create ptr2 using copy initialization of ptr1 std :: cout << \"Killing one shared pointer \\n \" ; } // ptr2 goes out of scope here, but nothing happens std :: cout << \"Killing another shared pointer \\n \" ; return 0 ; } // ptr1 goes out of scope here, and the allocated Resource is destroyed \u4f7f\u7528 std::make_shared() \u7684\u539f\u56e0\u548c std::make_unique() \u4e00\u6837 \u2014\u2014\u2014\u2014 std::make_shared() \u66f4\u7b80\u5355\u66f4\u5b89\u5168\uff08\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u4e0d\u53ef\u80fd\u76f4\u63a5\u521b\u5efa\u4e24\u4e2a\u76f8\u4e92\u72ec\u7acb\u7684 std::shared_ptr \u6307\u5411\u540c\u4e00\u5757\u8d44\u6e90\uff09\uff0c\u800c\u4e14\uff0c\u6bd4\u8d77\u4e0d\u4f7f\u7528\u5b83\uff0c std::make_shared() \u6709\u66f4\u52a0\u9ad8\u6027\u80fd\u3002\u5176\u539f\u56e0\u5728\u4e8e std::shared ptr \u8ddf\u8e2a\u6307\u5411\u7ed9\u5b9a\u8d44\u6e90\u7684\u6307\u9488\u6570\u91cf\u3002","title":"std::make_shared"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdshared_ptr","text":"\u4e0d\u50cf\u5185\u90e8\u4ec5\u4ec5\u4f7f\u7528\u4e00\u4e2a\u6307\u9488\u7684 std::unique_ptr \u90a3\u6837\uff0c std::shared_ptr \u5185\u90e8\u6709\u4e24\u4e2a\u6307\u9488\uff1a\u4e00\u4e2a\u6307\u9488\u6307\u5411\u88ab\u7ba1\u7406\u7684\u8d44\u6e90\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u5728\u201c\u63a7\u5236\u5757\uff08control block\uff09\u201d\uff0c\u662f\u4e00\u4e2a\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\uff0c\u4f1a\u8ddf\u8e2a\u5f88\u591a\u4e1c\u897f\uff0c\u5305\u62ec\u6709\u591a\u5c11\u4e2a std::shared_ptr \u6307\u5411\u8d44\u6e90\u3002 \u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u6784\u9020\u51fd\u6570\u5355\u72ec\u521b\u5efa\u7684\u65f6\u5019\uff0c\u7ba1\u7406\u5bf9\u8c61\uff08\u4f20\u5165\u7684\u8d44\u6e90\uff09\u548c\u63a7\u5236\u5757\uff08\u6784\u9020\u5668\u521b\u5efa\uff09\u7684\u5185\u5b58\u5c31\u88ab\u5355\u72ec\u5206\u914d\u4e86\u3002\u7136\u800c\uff0c\u5f53\u4f7f\u7528 std::make_shared() \u65f6\uff0c\u8fd9\u53ef\u4ee5\u88ab\u4f18\u5316\u6210\u4e00\u4e2a\u5355\u72ec\u5185\u5b58\u5206\u914d\uff0c\u6709\u66f4\u597d\u7684\u6027\u80fd\u3002 \u8fd9\u4e5f\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u5355\u72ec\u521b\u5efa\u4e24\u4e2a std::shared_ptr \u4f1a\u9047\u5230\u95ee\u9898\u3002\u6bcf\u4e2a std::shared_ptr \u5c06\u4f1a\u6709\u4e00\u4e2a\u6307\u9488\u6307\u5411\u8d44\u6e90\uff0c\u7136\u800c\u6bcf\u4e2a std::shared_ptr \u72ec\u7acb\u5206\u914d\u5b83\u81ea\u5df1\u7684\u63a7\u5236\u5757\uff0c\u8fd9\u610f\u5473\u7740\u8fd9\u662f\u6301\u6709\u8d44\u6e90\u7684\u552f\u4e00\u7684\u6307\u9488\u3002\u56e0\u6b64\uff0c\u5f53 std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u4f1a\u91ca\u653e\u8d44\u6e90\uff0c\u5e76\u6ca1\u6709\u610f\u8bc6\u5230\u8fd8\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u4ecd\u7136\u5728\u7ba1\u7406\u8d44\u6e90\u3002 \u7136\u800c\uff0c\u5f53\u4e00\u4e2a std::shared_ptr \u88ab\u4f7f\u7528\u62f7\u8d1d\u6784\u9020\u590d\u5236\u7684\u65f6\u5019\uff0c\u63a7\u5236\u5757\u4e2d\u7684\u6570\u636e\u540c\u6837\u88ab\u66f4\u65b0\u6210\u5408\u9002\u7684\u503c\uff0c\u8868\u660e\u6709\u53e6\u4e00\u4e2a std::shared_ptr \u5171\u540c\u7ba1\u7406\u8fd9\u4e2a\u8d44\u6e90\u3002","title":"\u6df1\u6316 std::shared_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#shared-pointers-unique-pointers","text":"\u4e00\u4e2a std::unique_ptr \u53ef\u4ee5\u88ab\u8f6c\u5316\u6210\u4e00\u4e2a std::shared_ptr \u901a\u8fc7\u4e00\u4e2a\u7279\u6b8a\u7684\u6784\u9020\u51fd\u6570\u63a5\u6536\u53f3\u503c\u3002 std::unique_ptr \u6301\u6709\u7684\u5185\u5bb9\u5c06\u4f1a\u79fb\u52a8\u7ed9 std::shared_ptr \u3002 \u7136\u800c\uff0c std::shared_ptr \u5374\u4e0d\u80fd\u5b89\u5168\u7684\u8f6c\u5316\u6210 std::unique_ptr \u3002\u8fd9\u610f\u5473\u7740\u5982\u679c\u4f60\u6b63\u5728\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u667a\u80fd\u6307\u9488\uff0c\u4f60\u6700\u597d\u8fd4\u56de\u4e00\u4e2a std::unique_ptr \u5e76\u4e14\u8d4b\u503c\u5b83\u7ed9\u4e00\u4e2a std::shared_ptr \u5982\u679c\u5408\u9002\u7684\u8bdd\u3002","title":"Shared pointers \u53ef\u4ee5\u4ece Unique pointers \u521b\u5efa"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdshared_ptr_1","text":"std::shared_ptr \u6709\u4e00\u4e9b\u548c std::unique_ptr \u540c\u6837\u7684\u6311\u6218\uff0c\u5982\u679c std::shared_ptr \u6ca1\u6709\u88ab\u5408\u9002\u7684\u5904\u7406\uff08\u53ef\u80fd\u662f\u56e0\u4e3a\u5b83\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4e14\u4ece\u672a\u5220\u9664\uff0c\u6216\u8005\u5b83\u4f5c\u4e3a\u5bf9\u8c61\u7684\u4e00\u90e8\u5206\uff0c\u88ab\u52a8\u6001\u5206\u914d\u5e76\u4ece\u672a\u5220\u9664\uff09\uff0c\u7d27\u63a5\u7740\u5b83\u7ba1\u7406\u7684\u8d44\u6e90\u4e5f\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u4f7f\u7528 std::unique_ptr \uff0c\u4f60\u4ec5\u9700\u8981\u53bb\u5173\u6ce8\u667a\u80fd\u6307\u9488\u662f\u5426\u88ab\u5408\u9002\u7684\u5904\u7406\u3002\u5982\u679c\u4f7f\u7528 std::shared_ptr \uff0c\u4f60\u4e0d\u5f97\u4e0d\u62c5\u5fc3\u4ed6\u4eec\u5168\u90e8\u3002\u5982\u679c\u4efb\u4f55\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u8d44\u6e90\u6ca1\u6709\u88ab\u5408\u9002\u7684\u6e05\u7406\uff0c\u8d44\u6e90\u5c06\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002","title":"\u4f7f\u7528 std::shared_ptr \u7684\u5371\u9669\u4e4b\u5904"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#stdshared_ptr_2","text":"\u5728 C++14 \u6216\u66f4\u65e9\uff0c std::shared_ptr \u6ca1\u529e\u6cd5\u652f\u6301\u7ba1\u7406\u6570\u7ec4\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u4f7f\u7528C\u7c7b\u578b\u6570\u7ec4\u3002\u5728C++17\u4e2d\uff0c std::shared_ptr \u5df2\u7ecf\u652f\u6301\u6570\u7ec4\u4e86\u3002\u7136\u800c\uff0c\u5728C++17\u4e2d\uff0c std::make_shared \u4ecd\u7136\u7f3a\u4e4f\u5408\u9002\u7684\u9488\u5bf9\u6570\u7ec4\u7684\u652f\u6301\uff0c\u5e76\u4e14\u4e0d\u5e94\u8be5\u88ab\u7528\u6765\u521b\u5efa\u6570\u7ec4\uff0c\u8fd9\u4f1a\u5728C++20\u4e2d\u88ab\u89e3\u51b3\u3002","title":"std::shared_ptr \u548c\u6570\u7ec4"},{"location":"15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/#_1","text":"std::shared_ptr \u88ab\u8bbe\u8ba1\u7528\u4e8e\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u5171\u540c\u7ba1\u7406\u540c\u6837\u7684\u8d44\u6e90\u3002\u8d44\u6e90\u8b66\u5fbd\u88ab\u91ca\u653e\uff0c\u5f53\u6700\u540e\u4e00\u4e2a std::shared_ptr \u7ba1\u7406\u7684\u8d44\u6e90\u88ab\u9500\u6bc1\u65f6\u3002","title":"\u7ed3\u8bba"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/","text":"15.7 std::shared_ptr \u7684\u5faa\u73af\u4f9d\u8d56\u95ee\u9898\uff0c\u4ecb\u7ecd std::weak_ptr \u00b6 By Alex on March 21 st , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86 std::shared_ptr \u5982\u4f55\u5141\u8bb8\u6211\u4eec\u6709\u591a\u4e2a\u804c\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709\u540c\u6837\u7684\u8d44\u6e90\uff0c\u7136\u800c\uff0c\u5728\u5177\u4f53\u7684\u60c5\u51b5\u4e0b\uff0c\u8fd9\u53ef\u80fd\u5e26\u6765\u5f88\u591a\u95ee\u9898\uff0c\u601d\u8003\u5982\u4e0b\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u4e24\u4e2a\u5bf9\u8c61\u4e2d\u7684\u667a\u80fd\u6307\u9488\u5206\u522b\u6307\u5411\u4e86\u5176\u4ed6\u5bf9\u8c61\u3002 #include <iostream> #include <memory> // for std::shared_ptr #include <string> class Person { std :: string m_name ; std :: shared_ptr < Person > m_partner ; // initially created empty public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); // create a Person named \"Lucy\" auto ricky = std :: make_shared < Person > ( \"Ricky\" ); // create a Person named \"Ricky\" partnerUp ( lucy , ricky ); // Make \"Lucy\" point to \"Ricky\" and vice-versa return 0 ; } \u5728\u4e0a\u4e2a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 make_shared() \u52a8\u6001\u5206\u914d\u4e86\u4e24\u4e2a Persons ,\u201cLucy\u201d \u548c \u201cRicky\u201d\uff08\u6765\u4fdd\u8bc1\u4ed6\u4eec\u5728 main()\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \uff09\u3002\u7d27\u63a5\u7740\uff0c\u6211\u4eec\u8ba9\u4ed6\u4eec\u6210\u4e3a\u642d\u6863\u3002\u8fd9\u4e2a\u64cd\u4f5c\u8bbe\u7f6e \"Lucy\" \u7684 std::shared_ptr \u6307\u5411 \u201cRicky\u201d\uff0c\u5e76\u4e14\u4f7f\u5f97 \u201cRicky\u201d \u5185\u7684 std::shared_ptr \u6307\u5411 \u201cLucy\u201d\u3002\u5171\u4eab\u6307\u9488\u88ab\u8bbe\u8ba1\u7528\u6765\u5171\u4eab\u7684\uff0c\u56e0\u6b64\u8fd9\u6837\u5f88\u68d2\uff0c\u5206\u522b\u8bbe\u7f6e\u4e24\u4e2a Persion \u4e3a\u5bf9\u65b9\u7684\u642d\u6863\u3002 \u7136\u800c\u6267\u884c\u8d77\u6765\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u6ca1\u6709\u6309\u7167\u671f\u671b\u6267\u884c\uff1a Lucy created Ricky created Lucy is now partnered with Ricky \u55ef\uff0c\u4f7f\u5f97\u3002\u6ca1\u6709\u9500\u6bc1\u53d1\u751f\uff0c\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5728 partnerUp() \u88ab\u8c03\u7528\u540e\uff0c\u6709\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u4e24\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cLucy\u201d\u3002 \u5728\u51fd\u6570\u7684\u7ed3\u5c3e\uff0c\u201cricky\u201d \u7684\u5171\u4eab\u6307\u9488\u5148\u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u5f53\u90a3\u53d1\u751f\u65f6\uff0c\u201cricky\u201d \u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u5176\u4ed6\u7684\u5171\u4eab\u6307\u9488\u5171\u7528\u62e5\u6709 \u201cRicky\u201d\u3002\u786e\u5b9e\u6709\uff08\u201clucy\u2018s m_partner\u201d\uff09\u3002\u56e0\u4e3a\u8fd9\uff0c\u5b83\u6ca1\u6709\u91ca\u653e\u201cRicky\u201d\uff08\u5982\u679c\u5b83\u91ca\u653e\u4e86\uff0c\u90a3\u4e48 \u201cLucy\u201d \u7684 m_partner \u5c31\u4f1a\u53d8\u6210\u60ac\u7a7a\u6307\u9488\uff09\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u73b0\u5728\u6709\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u548c\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u53d8\u91cf lucy \u548c \u201cRicky\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740 lucy \u7684\u5171\u4eab\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u540c\u6837\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\uff0c\u667a\u80fd\u6307\u9488 lucy \u68c0\u67e5\u662f\u5426\u6709\u5176\u4ed6\u667a\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709 \u201cLucy\u201d\uff0c\u786e\u5b9e\u5b58\u5728\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u56e0\u6b64 \u201cLucy\u201d \u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6709\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u548c\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740\uff0c\u7a0b\u5e8f\u7ed3\u675f \u2014\u2014\u2014\u2014 \u201cLucy\u201d \u6216 \u201cRicky\u201d \u90fd\u6ca1\u6709\u88ab\u91ca\u653e\uff01\u672c\u8d28\u4e0a \u201cLucy\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cRicky\u201d \u4e0d\u88ab\u9500\u6bc1\uff0c\u800c\u4e14 \u201cRicky\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cLucy\u201d \u4e0d\u88ab\u9500\u6bc1\u3002 It turns out that this can happen any time shared pointers form a circular reference. \u8fd9\u4f1a\u53d1\u751f\u5728\u4efb\u4f55\u65f6\u5019\uff0c\u53ea\u8981\u667a\u80fd\u6307\u9488\u51fa\u73b0\u5faa\u73af\u5f15\u7528\u3002 \u5faa\u73af\u4f9d\u8d56 \u00b6 \u5faa\u73af\u4f9d\u8d56\uff08\u4e5f\u53eb cyclical reference)\u662f\u4e00\u7cfb\u5217\u5f15\u7528\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u4e0b\u4e00\u4e2a\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u7b2c\u4e00\u4e2a\uff0c\u9020\u6210\u5faa\u73af\u3002\u8fd9\u4e2a\u5f15\u7528\u4e0d\u9700\u8981\u662f\u786e\u5207\u7684 C++ \u5f15\u7528 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u662f\u6307\u9488\uff0c\u552f\u4e00\u7684ID\uff0c\u6216\u8005\u4efb\u4f55\u7279\u6b8a\u5bf9\u8c61\u3002 \u5728\u667a\u80fd\u6307\u9488\uff08shared pointers\uff09\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5faa\u73af\u5f15\u7528\u5c31\u4f1a\u6307\u9488\u5f15\u8d77\u7684\u3002 \u8fd9\u6b63\u597d\u53d1\u751f\u5728\u4ee5\u4e0a\u7684\u60c5\u51b5\u4e0b\uff1a\u201cLucy\u201d \u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u7136\u540e \u201cRicky\u201d \u6307\u5411\u4e86 \u201cLucy\u201d\u3002\u5982\u679c\u6709\u4e09\u4e2a\u6307\u9488\uff0c\u4f60\u4f1a\u5f97\u5230\u76f8\u4f3c\u7684\u7ed3\u679c\u5c31\u662f A\u6307\u5411B\uff0cB\u6307\u5411C\uff0cC\u6307\u5411A\u3002\u5728\u73af\u4e2d\uff0c\u667a\u80fd\u6307\u9488\u7684\u6548\u679c\u4f9d\u7136\u662f\u4fdd\u8bc1\u4e0b\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b \u2014\u2014\u2014\u2014 \u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u4fdd\u8bc1\u4e86\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b\uff0c\u56e0\u6b64\uff0c\u6ca1\u6709\u5bf9\u8c61\u4f1a\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u4efb\u4e3a\u5176\u4ed6\u5bf9\u8c61\u4ecd\u7136\u9700\u8981\u5b83\uff01 \u4e00\u4e2a reductive \u7684\u60c5\u51b5 \u00b6 \u4e8b\u5b9e\u8bc1\u660e\uff0c\u5faa\u73af\u5f15\u7528\u7684\u95ee\u9898\u751a\u81f3\u5728\u53ea\u6709\u4e00\u4e2a std::shared_ptr \u7684\u60c5\u51b5\u4e0b\u6210\u7acb\u3002 \u2014\u2014\u2014\u2014 \u4e00\u4e2a std::shared_ptr \u5f15\u7528\u7684\u5bf9\u8c61\u5305\u542b\u4e86\u4e00\u4e2a\u5faa\u73af\u3002\u5c3d\u7ba1\u8fd9\u5728\u5b9e\u9645\u60c5\u51b5\u4e0b\u5f88\u4e0d\u5e38\u89c1\uff0c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u7ed9\u4f60\uff0c\u4e3a\u4e86\u8fdb\u4e00\u6b65\u7406\u89e3\uff1a #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : std :: shared_ptr < Resource > m_ptr ; // initially created empty Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { auto ptr1 = std :: make_shared < Resource > (); ptr1 -> m_ptr = ptr1 ; // m_ptr is now sharing the Resource that contains it return 0 ; } \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\uff0c\u4ed6\u4e0d\u4f1a\u91ca\u653e Resource \u56e0\u4e3a Rresource \u7684 m_ptr \u6b63\u5728\u5171\u4eab Resource\u3002\u7d27\u63a5\u7740\u6ca1\u6709\u8c01\u4f1a\u88ab\u5220\u9664 \uff08 m_ptr \u4ece\u672a\u79bb\u5f00\u4f5c\u7528\u4e8e\uff0c\u6240\u4ee5\u5b83\u6ca1\u6709\u673a\u4f1a\u88ab\u5220\u9664\uff09\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\uff1a Resource acquired \u5c31\u662f\u8fd9\u6837 std::weak_ptr \u7528\u6765\u505a\u4ec0\u4e48 \u00b6 std::weak_ptr \u5c31\u662f\u7528\u6765\u89e3\u51b3\u4e0a\u65b9\u63cf\u8ff0\u7684\u5faa\u73af\u4f9d\u8d56\u7684\u95ee\u9898\u3002\u4e00\u4e2a \u201cstd::waek_ptr\u201d \u662f\u4e00\u4e2a\u89c2\u5bdf\u8005 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u8bbf\u95ee\u548c\u540c\u6837\u7684\u5bf9\u8c61\u5c31\u50cf std::shared_ptr \u90a3\u6837\uff0c\u4f46\u5b83\u4e0d\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u62e5\u6709\u8005\u3002\u8bb0\u4f4f\uff0c\u5f53\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5b83\u4ec5\u4ec5\u601d\u8003\u662f\u5426\u6709\u5176\u4ed6\u7684 std::shared_ptr \u5171\u540c\u6301\u6709\u8fd9\u4e2a\u5bf9\u8c61\uff0c std::weak_ptr \u4e0d\u7b97\u6570\uff01 \u8ba9\u6211\u4eec\u4f7f\u7528 weak_ptr \u6765\u89e3\u51b3\u4e4b\u524d\u7684 Persion \u95ee\u9898\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); return 0 ; } \u8fd9\u6bb5\u4ee3\u7801\u8868\u73b0\u6b63\u5e38\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky destroyed Lucy destroyed \u4ece\u529f\u80fd\u4e0a\u6765\u8bb2\uff0c\u5b83\u540c\u6709\u95ee\u9898\u7684\u4f8b\u5b50\u5de5\u4f5c\u8d77\u6765\u51e0\u4e4e\u4e00\u6837\u3002\u7136\u800c\uff0c\u73b0\u5728\u5f53 ricky \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u68c0\u67e5\u53d1\u73b0\u6ca1\u6709\u5176\u4ed6 std::shared_ptr \u6307\u5411\u4e86 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 std::weak_ptr \u4e0d\u7b97\uff09\u3002\u56e0\u6b64\uff0c\u5b83\u4f1a\u91ca\u653e \u201cRicky\u201d\u3002\u540c\u6837\u7684\u60c5\u51b5\u53d1\u751f\u5728 lucy \u4e0a\u3002 \u4f7f\u7528 std::weak_ptr \u00b6 std::weak_ptr \u7684\u7f3a\u70b9\u662f std::weak_ptr \u4e0d\u80fd\u76f4\u63a5\u88ab\u4f7f\u7528\uff08\u5b83\u6ca1\u6709 -> \u64cd\u4f5c\u7b26\uff09\u3002\u8981\u4f7f\u7528 std::weak_ptr \u4f60\u5fc5\u987b\u5148\u8f6c\u5316\u5b83\u6210\u4e3a\u4e00\u4e2a std::shared_ptr \u3002\u8981\u5b8c\u6210\u8f6c\u5316\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 lock() \u6210\u5458\u51fd\u6570\uff0c\u8fd9\u662f\u4e4b\u524d\u7684\u4f8b\u5b50\u7ecf\u8fc7\u66f4\u65b0\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } const std :: shared_ptr < Person > getPartner () const { return m_partner . lock (); } // use lock() to convert weak_ptr to shared_ptr const std :: string & getName () const { return m_name ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); auto partner = ricky -> getPartner (); // get shared_ptr to Ricky's partner std :: cout << ricky -> getName () << \"'s partner is: \" << partner -> getName () << '\\n' ; return 0 ; } \u8f93\u51fa\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky's partner is: Lucy Ricky destroyed Lucy destroyed \u5728\u4f7f\u7528 partner \u53d8\u91cf\u7684\u65f6\u5019\uff0c\u6211\u4eec\u65e0\u9700\u5173\u5fc3\u5faa\u73af\u5f15\uff0c\u56e0\u4e3a\u4ed6\u5c31\u662f\u4e00\u4e2a\u51fd\u6570\u5185\u7684\u5c40\u90e8\u53d8\u91cf\u3002\u4ed6\u4f1a\u6700\u7ec8\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u7136\u540e\u5f15\u7528\u6570\u91cf\u4f1a\u51cf\u5c111. \u7ed3\u8bba \u00b6 \u5f53\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u7ba1\u7406\u540c\u4e00\u4e2a\u8d44\u6e90\u65f6\uff0c\u53ef\u4ee5\u7528 std::shared_ptr \u3002\u8d44\u6e90\u5c06\u4f1a\u5728\u6700\u540e\u4e00\u4e2a std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u9500\u6bc1\u3002 \u5f53\u4f60\u9700\u8981\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6765\u8bbf\u95ee\u53e6\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u65f6\uff0c\u53ef\u4ee5\u7528 std::weak_ptr \uff0c\u4f46\u662f\u4e0d\u4f1a\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743","title":"15.7 std::shared_ptr \u7684\u5faa\u73af\u4f9d\u8d56\u95ee\u9898\uff0c\u4ecb\u7ecd std::weak_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#157-stdshared_ptr-stdweak_ptr","text":"By Alex on March 21 st , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86 std::shared_ptr \u5982\u4f55\u5141\u8bb8\u6211\u4eec\u6709\u591a\u4e2a\u804c\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709\u540c\u6837\u7684\u8d44\u6e90\uff0c\u7136\u800c\uff0c\u5728\u5177\u4f53\u7684\u60c5\u51b5\u4e0b\uff0c\u8fd9\u53ef\u80fd\u5e26\u6765\u5f88\u591a\u95ee\u9898\uff0c\u601d\u8003\u5982\u4e0b\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u4e24\u4e2a\u5bf9\u8c61\u4e2d\u7684\u667a\u80fd\u6307\u9488\u5206\u522b\u6307\u5411\u4e86\u5176\u4ed6\u5bf9\u8c61\u3002 #include <iostream> #include <memory> // for std::shared_ptr #include <string> class Person { std :: string m_name ; std :: shared_ptr < Person > m_partner ; // initially created empty public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); // create a Person named \"Lucy\" auto ricky = std :: make_shared < Person > ( \"Ricky\" ); // create a Person named \"Ricky\" partnerUp ( lucy , ricky ); // Make \"Lucy\" point to \"Ricky\" and vice-versa return 0 ; } \u5728\u4e0a\u4e2a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 make_shared() \u52a8\u6001\u5206\u914d\u4e86\u4e24\u4e2a Persons ,\u201cLucy\u201d \u548c \u201cRicky\u201d\uff08\u6765\u4fdd\u8bc1\u4ed6\u4eec\u5728 main()\u7ed3\u675f\u524d\u88ab\u9500\u6bc1 \uff09\u3002\u7d27\u63a5\u7740\uff0c\u6211\u4eec\u8ba9\u4ed6\u4eec\u6210\u4e3a\u642d\u6863\u3002\u8fd9\u4e2a\u64cd\u4f5c\u8bbe\u7f6e \"Lucy\" \u7684 std::shared_ptr \u6307\u5411 \u201cRicky\u201d\uff0c\u5e76\u4e14\u4f7f\u5f97 \u201cRicky\u201d \u5185\u7684 std::shared_ptr \u6307\u5411 \u201cLucy\u201d\u3002\u5171\u4eab\u6307\u9488\u88ab\u8bbe\u8ba1\u7528\u6765\u5171\u4eab\u7684\uff0c\u56e0\u6b64\u8fd9\u6837\u5f88\u68d2\uff0c\u5206\u522b\u8bbe\u7f6e\u4e24\u4e2a Persion \u4e3a\u5bf9\u65b9\u7684\u642d\u6863\u3002 \u7136\u800c\u6267\u884c\u8d77\u6765\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u6ca1\u6709\u6309\u7167\u671f\u671b\u6267\u884c\uff1a Lucy created Ricky created Lucy is now partnered with Ricky \u55ef\uff0c\u4f7f\u5f97\u3002\u6ca1\u6709\u9500\u6bc1\u53d1\u751f\uff0c\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5728 partnerUp() \u88ab\u8c03\u7528\u540e\uff0c\u6709\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u4e24\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u4e86 \u201cLucy\u201d\u3002 \u5728\u51fd\u6570\u7684\u7ed3\u5c3e\uff0c\u201cricky\u201d \u7684\u5171\u4eab\u6307\u9488\u5148\u79bb\u5f00\u4f5c\u7528\u4e8e\u3002\u5f53\u90a3\u53d1\u751f\u65f6\uff0c\u201cricky\u201d \u68c0\u67e5\u662f\u5426\u6709\u4efb\u4f55\u5176\u4ed6\u7684\u5171\u4eab\u6307\u9488\u5171\u7528\u62e5\u6709 \u201cRicky\u201d\u3002\u786e\u5b9e\u6709\uff08\u201clucy\u2018s m_partner\u201d\uff09\u3002\u56e0\u4e3a\u8fd9\uff0c\u5b83\u6ca1\u6709\u91ca\u653e\u201cRicky\u201d\uff08\u5982\u679c\u5b83\u91ca\u653e\u4e86\uff0c\u90a3\u4e48 \u201cLucy\u201d \u7684 m_partner \u5c31\u4f1a\u53d8\u6210\u60ac\u7a7a\u6307\u9488\uff09\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u73b0\u5728\u6709\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u548c\u4e24\u4e2a\u53ea\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u53d8\u91cf lucy \u548c \u201cRicky\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740 lucy \u7684\u5171\u4eab\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5e76\u4e14\u540c\u6837\u7684\u4e8b\u60c5\u53d1\u751f\u4e86\uff0c\u667a\u80fd\u6307\u9488 lucy \u68c0\u67e5\u662f\u5426\u6709\u5176\u4ed6\u667a\u80fd\u6307\u6b63\u5171\u540c\u62e5\u6709 \u201cLucy\u201d\uff0c\u786e\u5b9e\u5b58\u5728\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u56e0\u6b64 \u201cLucy\u201d \u4e0d\u4f1a\u88ab\u91ca\u653e\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6709\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cLucy\u201d\uff08\u201cRicky\u201d \u7684 m_partner\uff09\uff0c\u548c\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 m_partner\uff09\u3002 \u7d27\u63a5\u7740\uff0c\u7a0b\u5e8f\u7ed3\u675f \u2014\u2014\u2014\u2014 \u201cLucy\u201d \u6216 \u201cRicky\u201d \u90fd\u6ca1\u6709\u88ab\u91ca\u653e\uff01\u672c\u8d28\u4e0a \u201cLucy\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cRicky\u201d \u4e0d\u88ab\u9500\u6bc1\uff0c\u800c\u4e14 \u201cRicky\u201d \u6700\u540e\u4fdd\u8bc1\u4e86 \u201cLucy\u201d \u4e0d\u88ab\u9500\u6bc1\u3002 It turns out that this can happen any time shared pointers form a circular reference. \u8fd9\u4f1a\u53d1\u751f\u5728\u4efb\u4f55\u65f6\u5019\uff0c\u53ea\u8981\u667a\u80fd\u6307\u9488\u51fa\u73b0\u5faa\u73af\u5f15\u7528\u3002","title":"15.7 std::shared_ptr \u7684\u5faa\u73af\u4f9d\u8d56\u95ee\u9898\uff0c\u4ecb\u7ecd std::weak_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#_1","text":"\u5faa\u73af\u4f9d\u8d56\uff08\u4e5f\u53eb cyclical reference)\u662f\u4e00\u7cfb\u5217\u5f15\u7528\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u4e0b\u4e00\u4e2a\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e86\u7b2c\u4e00\u4e2a\uff0c\u9020\u6210\u5faa\u73af\u3002\u8fd9\u4e2a\u5f15\u7528\u4e0d\u9700\u8981\u662f\u786e\u5207\u7684 C++ \u5f15\u7528 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u662f\u6307\u9488\uff0c\u552f\u4e00\u7684ID\uff0c\u6216\u8005\u4efb\u4f55\u7279\u6b8a\u5bf9\u8c61\u3002 \u5728\u667a\u80fd\u6307\u9488\uff08shared pointers\uff09\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5faa\u73af\u5f15\u7528\u5c31\u4f1a\u6307\u9488\u5f15\u8d77\u7684\u3002 \u8fd9\u6b63\u597d\u53d1\u751f\u5728\u4ee5\u4e0a\u7684\u60c5\u51b5\u4e0b\uff1a\u201cLucy\u201d \u6307\u5411\u4e86 \u201cRicky\u201d\uff0c\u7136\u540e \u201cRicky\u201d \u6307\u5411\u4e86 \u201cLucy\u201d\u3002\u5982\u679c\u6709\u4e09\u4e2a\u6307\u9488\uff0c\u4f60\u4f1a\u5f97\u5230\u76f8\u4f3c\u7684\u7ed3\u679c\u5c31\u662f A\u6307\u5411B\uff0cB\u6307\u5411C\uff0cC\u6307\u5411A\u3002\u5728\u73af\u4e2d\uff0c\u667a\u80fd\u6307\u9488\u7684\u6548\u679c\u4f9d\u7136\u662f\u4fdd\u8bc1\u4e0b\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b \u2014\u2014\u2014\u2014 \u6700\u540e\u4e00\u4e2a\u5bf9\u8c61\u4fdd\u8bc1\u4e86\u7b2c\u4e00\u4e2a\u5bf9\u8c61\u7684\u5b58\u6d3b\uff0c\u56e0\u6b64\uff0c\u6ca1\u6709\u5bf9\u8c61\u4f1a\u88ab\u91ca\u653e\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u4efb\u4e3a\u5176\u4ed6\u5bf9\u8c61\u4ecd\u7136\u9700\u8981\u5b83\uff01","title":"\u5faa\u73af\u4f9d\u8d56"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#reductive","text":"\u4e8b\u5b9e\u8bc1\u660e\uff0c\u5faa\u73af\u5f15\u7528\u7684\u95ee\u9898\u751a\u81f3\u5728\u53ea\u6709\u4e00\u4e2a std::shared_ptr \u7684\u60c5\u51b5\u4e0b\u6210\u7acb\u3002 \u2014\u2014\u2014\u2014 \u4e00\u4e2a std::shared_ptr \u5f15\u7528\u7684\u5bf9\u8c61\u5305\u542b\u4e86\u4e00\u4e2a\u5faa\u73af\u3002\u5c3d\u7ba1\u8fd9\u5728\u5b9e\u9645\u60c5\u51b5\u4e0b\u5f88\u4e0d\u5e38\u89c1\uff0c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u7ed9\u4f60\uff0c\u4e3a\u4e86\u8fdb\u4e00\u6b65\u7406\u89e3\uff1a #include <iostream> #include <memory> // for std::shared_ptr class Resource { public : std :: shared_ptr < Resource > m_ptr ; // initially created empty Resource () { std :: cout << \"Resource acquired \\n \" ; } ~ Resource () { std :: cout << \"Resource destroyed \\n \" ; } }; int main () { auto ptr1 = std :: make_shared < Resource > (); ptr1 -> m_ptr = ptr1 ; // m_ptr is now sharing the Resource that contains it return 0 ; } \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u5f53 ptr1 \u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\uff0c\u4ed6\u4e0d\u4f1a\u91ca\u653e Resource \u56e0\u4e3a Rresource \u7684 m_ptr \u6b63\u5728\u5171\u4eab Resource\u3002\u7d27\u63a5\u7740\u6ca1\u6709\u8c01\u4f1a\u88ab\u5220\u9664 \uff08 m_ptr \u4ece\u672a\u79bb\u5f00\u4f5c\u7528\u4e8e\uff0c\u6240\u4ee5\u5b83\u6ca1\u6709\u673a\u4f1a\u88ab\u5220\u9664\uff09\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u8f93\u51fa\uff1a Resource acquired \u5c31\u662f\u8fd9\u6837","title":"\u4e00\u4e2a reductive \u7684\u60c5\u51b5"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#stdweak_ptr","text":"std::weak_ptr \u5c31\u662f\u7528\u6765\u89e3\u51b3\u4e0a\u65b9\u63cf\u8ff0\u7684\u5faa\u73af\u4f9d\u8d56\u7684\u95ee\u9898\u3002\u4e00\u4e2a \u201cstd::waek_ptr\u201d \u662f\u4e00\u4e2a\u89c2\u5bdf\u8005 \u2014\u2014\u2014\u2014 \u5b83\u53ef\u4ee5\u8bbf\u95ee\u548c\u540c\u6837\u7684\u5bf9\u8c61\u5c31\u50cf std::shared_ptr \u90a3\u6837\uff0c\u4f46\u5b83\u4e0d\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u62e5\u6709\u8005\u3002\u8bb0\u4f4f\uff0c\u5f53\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u5b83\u4ec5\u4ec5\u601d\u8003\u662f\u5426\u6709\u5176\u4ed6\u7684 std::shared_ptr \u5171\u540c\u6301\u6709\u8fd9\u4e2a\u5bf9\u8c61\uff0c std::weak_ptr \u4e0d\u7b97\u6570\uff01 \u8ba9\u6211\u4eec\u4f7f\u7528 weak_ptr \u6765\u89e3\u51b3\u4e4b\u524d\u7684 Persion \u95ee\u9898\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); return 0 ; } \u8fd9\u6bb5\u4ee3\u7801\u8868\u73b0\u6b63\u5e38\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky destroyed Lucy destroyed \u4ece\u529f\u80fd\u4e0a\u6765\u8bb2\uff0c\u5b83\u540c\u6709\u95ee\u9898\u7684\u4f8b\u5b50\u5de5\u4f5c\u8d77\u6765\u51e0\u4e4e\u4e00\u6837\u3002\u7136\u800c\uff0c\u73b0\u5728\u5f53 ricky \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u68c0\u67e5\u53d1\u73b0\u6ca1\u6709\u5176\u4ed6 std::shared_ptr \u6307\u5411\u4e86 \u201cRicky\u201d\uff08\u201cLucy\u201d \u7684 std::weak_ptr \u4e0d\u7b97\uff09\u3002\u56e0\u6b64\uff0c\u5b83\u4f1a\u91ca\u653e \u201cRicky\u201d\u3002\u540c\u6837\u7684\u60c5\u51b5\u53d1\u751f\u5728 lucy \u4e0a\u3002","title":"std::weak_ptr \u7528\u6765\u505a\u4ec0\u4e48"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#stdweak_ptr_1","text":"std::weak_ptr \u7684\u7f3a\u70b9\u662f std::weak_ptr \u4e0d\u80fd\u76f4\u63a5\u88ab\u4f7f\u7528\uff08\u5b83\u6ca1\u6709 -> \u64cd\u4f5c\u7b26\uff09\u3002\u8981\u4f7f\u7528 std::weak_ptr \u4f60\u5fc5\u987b\u5148\u8f6c\u5316\u5b83\u6210\u4e3a\u4e00\u4e2a std::shared_ptr \u3002\u8981\u5b8c\u6210\u8f6c\u5316\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 lock() \u6210\u5458\u51fd\u6570\uff0c\u8fd9\u662f\u4e4b\u524d\u7684\u4f8b\u5b50\u7ecf\u8fc7\u66f4\u65b0\uff1a #include <iostream> #include <memory> // for std::shared_ptr and std::weak_ptr #include <string> class Person { std :: string m_name ; std :: weak_ptr < Person > m_partner ; // note: This is now a std::weak_ptr public : Person ( const std :: string & name ) : m_name ( name ) { std :: cout << m_name << \" created \\n \" ; } ~ Person () { std :: cout << m_name << \" destroyed \\n \" ; } friend bool partnerUp ( std :: shared_ptr < Person > & p1 , std :: shared_ptr < Person > & p2 ) { if ( ! p1 || ! p2 ) return false ; p1 -> m_partner = p2 ; p2 -> m_partner = p1 ; std :: cout << p1 -> m_name << \" is now partnered with \" << p2 -> m_name << \" \\n \" ; return true ; } const std :: shared_ptr < Person > getPartner () const { return m_partner . lock (); } // use lock() to convert weak_ptr to shared_ptr const std :: string & getName () const { return m_name ; } }; int main () { auto lucy = std :: make_shared < Person > ( \"Lucy\" ); auto ricky = std :: make_shared < Person > ( \"Ricky\" ); partnerUp ( lucy , ricky ); auto partner = ricky -> getPartner (); // get shared_ptr to Ricky's partner std :: cout << ricky -> getName () << \"'s partner is: \" << partner -> getName () << '\\n' ; return 0 ; } \u8f93\u51fa\uff1a Lucy created Ricky created Lucy is now partnered with Ricky Ricky's partner is: Lucy Ricky destroyed Lucy destroyed \u5728\u4f7f\u7528 partner \u53d8\u91cf\u7684\u65f6\u5019\uff0c\u6211\u4eec\u65e0\u9700\u5173\u5fc3\u5faa\u73af\u5f15\uff0c\u56e0\u4e3a\u4ed6\u5c31\u662f\u4e00\u4e2a\u51fd\u6570\u5185\u7684\u5c40\u90e8\u53d8\u91cf\u3002\u4ed6\u4f1a\u6700\u7ec8\u79bb\u5f00\u4f5c\u7528\u57df\uff0c\u7136\u540e\u5f15\u7528\u6570\u91cf\u4f1a\u51cf\u5c111.","title":"\u4f7f\u7528 std::weak_ptr"},{"location":"15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/#_2","text":"\u5f53\u4f60\u9700\u8981\u591a\u4e2a\u667a\u80fd\u6307\u9488\u7ba1\u7406\u540c\u4e00\u4e2a\u8d44\u6e90\u65f6\uff0c\u53ef\u4ee5\u7528 std::shared_ptr \u3002\u8d44\u6e90\u5c06\u4f1a\u5728\u6700\u540e\u4e00\u4e2a std::shared_ptr \u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u9500\u6bc1\u3002 \u5f53\u4f60\u9700\u8981\u4e00\u4e2a\u53ea\u80fd\u6307\u9488\u6765\u8bbf\u95ee\u53e6\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u65f6\uff0c\u53ef\u4ee5\u7528 std::weak_ptr \uff0c\u4f46\u662f\u4e0d\u4f1a\u5f97\u5230\u8d44\u6e90\u7684\u6240\u6709\u6743","title":"\u7ed3\u8bba"},{"location":"15-move-semantics-and-smart-pointers/15.x-chapter15-comprehensive-review/","text":"15.x \u5341\u4e94\u7ae0\u7406\u89e3\u548c\u590d\u4e60 \u00b6 By Alex on May 3 rd , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u667a\u80fd\u6307\u9488\u7c7b\u662f\u4e00\u4e2a\u88ab\u8bbe\u8ba1\u6765\u7ba1\u7406\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u7ec4\u5408\u7c7b\uff0c\u5e76\u4e14\u80fd\u786e\u4fdd\u5f53\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u5185\u5b58\u88ab\u91ca\u653e\u3002 \u62f7\u8d1d\u8bed\u4e49\u5141\u8bb8\u6211\u4eec\u7684\u7c7b\u88ab\u62f7\u8d1d\uff0c\u80fd\u4f7f\u7528\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b8c\u6210\u3002 \u79fb\u52a8\u8bed\u4e49\u610f\u5473\u7740\u4e00\u4e2a\u7c7b\u5c06\u4f1a\u8f6c\u79fb\u5bf9\u8c61\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u3002\u8fd9\u901a\u5e38\u901a\u8fc7\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b8c\u6210\u3002 std::auto_ptr \u5df2\u7ecf\u88ab\u5e9f\u5f03\uff0c\u5e76\u4e14\u5e94\u8be5\u88ab\u907f\u514d\u3002 \u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u662f\u88ab\u8bbe\u8ba1\u4f7f\u7528\u53f3\u503c\u521d\u59cb\u5316\u7684\u5f15\u7528\u3002\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u88ab\u4f7f\u7528 \u53cc & \u7b26\u53f7\u521b\u5efa\u3002\u5199\u51fd\u6570\u7684\u65f6\u5019\u4f20\u5165\u53f3\u503c\u5f15\u7528\u5f88\u68d2\uff0c\u4f46\u662f\u4f60\u5e94\u8be5\u4ece\u6765\u4e0d\u8981\u53cd\u6094\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u3002 \u5982\u679c\u6211\u4eec\u6784\u9020\u4e86\u4e00\u4e2a\u7c7b\u6216\u8005\u4f7f\u7528\u4e00\u4e2a\u5de6\u503c\u8fdb\u884c\u8fdb\u884c\u4e86\u4e00\u6b21\u8d4b\u503c\uff0c\u6211\u4eec\u80fd\u505a\u7684\u53ea\u6709\u62f7\u8d1d\u5de6\u503c\u3002\u6211\u4eec\u4e0d\u80fd\u5047\u8bbe\u5b89\u5168\u7684\u4fee\u6539\u5de6\u503c\uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u4f1a\u5728\u7a0b\u5e8f\u4e2d\u88ab\u518d\u6b21\u4f7f\u7528\u3002\u5982\u679c\u6211\u4eec\u6709\u4e00\u4e2a\u8868\u8fbe\u5f0f a = b \uff0c\u6211\u4eec\u5f53\u7136\u4e0d\u4f1a\u671f\u5f85 b \u88ab\u4ee5\u4efb\u4f55\u65b9\u5f0f\u4fee\u6539\u3002 \u7136\u800c\uff0c\u5982\u679c\u6211\u4eec\u6784\u9020\u4e86\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u4f7f\u7528\u4e00\u4e2a\u53f3\u503c\u8fdb\u884c\u4e00\u6b21\u8d4b\u503c\uff0c\u7136\u540e\u6211\u4eec\u5c31\u4f1a\u77e5\u9053\u53f3\u503c\u5c31\u662f\u4e00\u4e2a\u4e34\u65f6\u503c\u3002\u62f7\u8d1d\u5b83\uff08\u4f1a\u6709\u5f88\u591a\u5f00\u9500\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u8f6c\u79fb\uff08\u5f00\u9500\u975e\u5e38\u5c0f\uff09\u8d44\u6e90\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\u6211\u4eec\u5373\u5c06\u521b\u5efa\u6216\u8005\u8d4b\u503c\u7684\u3002\u8fd9\u975e\u5e38\u5b89\u5168\uff0c\u56e0\u4e3a\u4e34\u65f6\u503c\u5728\u8868\u8fbe\u5f0f\u672b\u5c3e\u5c31\u4f1a\u88ab\u5220\u9664\uff0c\u56e0\u6b64\u6211\u4eec\u77e5\u9053\u5b83\u7edd\u4e0d\u4f1a\u518d\u6b21\u88ab\u4f7f\u7528\u3002 \u4f60\u53ef\u4ee5\u7528\u5220\u9664\u5173\u952e\u8bcd\u6765\u4e3a\u4f60\u5b9a\u4e49\u7684\u7c7b\u7981\u7528\u62f7\u8d1d\u8bed\u4e49\uff0c\u8fd9\u6837\u4f60\u5c31\u5220\u9664\u4e86\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002 std::move \u5141\u8bb8\u4f60\u50cf\u5bf9\u5f85\u4e00\u4e2a\u53f3\u503c\u90a3\u6837\u5bf9\u5f85\u4e00\u4e2a\u5de6\u503c\u3002\u8fd9\u662f\u975e\u5e38\u6709\u7528\u7684\uff0c\u5f53\u4f60\u60f3\u8981\u5728\u4e00\u4e2a\u5de6\u503c\u4e0a\u89e6\u53d1\u79fb\u52a8\u8bed\u4e49\u800c\u4e0d\u662f\u62f7\u8d1d\u8bed\u4e49\u3002 std\"\"unique_ptr \u662f\u4f60\u5e94\u8be5\u4f7f\u7528\u7684\u667a\u80fd\u6307\u9488\u7c7b\u3002\u4ed6\u5355\u72ec\u7ba1\u7406\u7740\u4e00\u4efd\u4e0d\u80fd\u5206\u4eab\u7684\u8d44\u6e90\u3002 std::make_unique() \uff08\u5728 C++14\u4e2d\uff09\u5e94\u8be5\u4f5c\u4e3a\u521b\u5efa\u65b0 std::unique_ptr \u7684\u9996\u9009\u3002 std::unique_ptr \u7981\u7528\u4e86\u62f7\u8d1d\u8bed\u4e49\u3002 \u5f53\u4f60\u9700\u8981\u591a\u4e2a\u5bf9\u8c61\u8bbf\u95ee\u540c\u4e00\u4efd\u8d44\u6e90\u65f6\uff0c\u53ef\u4ee5\u7528 std::shared_ptr \u667a\u80fd\u6307\u9488\u7c7b\u3002\u8d44\u6e90\u5c06\u4f1a\u88ab\u9500\u6bc1\uff0c\u76f4\u5230\u6700\u540e\u4e00\u4e2a\u7ba1\u7406\u8be5\u8d44\u6e90\u7684 std::shared_ptr \u88ab\u9500\u6bc1\u3002 std::make_shared() \u5e94\u8be5\u4f5c\u4e3a\u521b\u5efa\u65b0 std::shared_ptr \u7684\u9996\u9009\u3002\u4f7f\u7528 std::shared_ptr \uff0c\u62f7\u8d1d\u8bed\u4e49\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u521b\u5efa\u4e00\u4e2a std::shared_ptr \u6765\u6307\u5411\u76f8\u540c\u7684\u5bf9\u8c61\u3002 \u5f53\u4f60\u9700\u8981\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u72ec\u4eab\u5177\u6709\u8bbf\u95ee\u4e00\u4e2a\u8d44\u6e90\u7684\u80fd\u529b\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528 std::weak_ptr \u667a\u80fd\u6307\u9488\uff0c\u4e0d\u50cf std::shared_ptr \u90a3\u6837\uff0c std::weak_ptr \u4e0d\u4f1a\u51b3\u5b9a\u8d44\u6e90\u662f\u5426\u5e94\u8be5\u88ab\u9500\u6bc1\u3002","title":"15.x \u5341\u4e94\u7ae0\u7406\u89e3\u548c\u590d\u4e60"},{"location":"15-move-semantics-and-smart-pointers/15.x-chapter15-comprehensive-review/#15x","text":"By Alex on May 3 rd , 2017 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 2020.07.18 \u667a\u80fd\u6307\u9488\u7c7b\u662f\u4e00\u4e2a\u88ab\u8bbe\u8ba1\u6765\u7ba1\u7406\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u7ec4\u5408\u7c7b\uff0c\u5e76\u4e14\u80fd\u786e\u4fdd\u5f53\u667a\u80fd\u6307\u9488\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u5185\u5b58\u88ab\u91ca\u653e\u3002 \u62f7\u8d1d\u8bed\u4e49\u5141\u8bb8\u6211\u4eec\u7684\u7c7b\u88ab\u62f7\u8d1d\uff0c\u80fd\u4f7f\u7528\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b8c\u6210\u3002 \u79fb\u52a8\u8bed\u4e49\u610f\u5473\u7740\u4e00\u4e2a\u7c7b\u5c06\u4f1a\u8f6c\u79fb\u5bf9\u8c61\uff0c\u800c\u4e0d\u662f\u62f7\u8d1d\u3002\u8fd9\u901a\u5e38\u901a\u8fc7\u79fb\u52a8\u6784\u9020\u548c\u79fb\u52a8\u8d4b\u503c\u8fd0\u7b97\u7b26\u6765\u5b8c\u6210\u3002 std::auto_ptr \u5df2\u7ecf\u88ab\u5e9f\u5f03\uff0c\u5e76\u4e14\u5e94\u8be5\u88ab\u907f\u514d\u3002 \u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u662f\u88ab\u8bbe\u8ba1\u4f7f\u7528\u53f3\u503c\u521d\u59cb\u5316\u7684\u5f15\u7528\u3002\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u88ab\u4f7f\u7528 \u53cc & \u7b26\u53f7\u521b\u5efa\u3002\u5199\u51fd\u6570\u7684\u65f6\u5019\u4f20\u5165\u53f3\u503c\u5f15\u7528\u5f88\u68d2\uff0c\u4f46\u662f\u4f60\u5e94\u8be5\u4ece\u6765\u4e0d\u8981\u53cd\u6094\u4e00\u4e2a\u53f3\u503c\u5f15\u7528\u3002 \u5982\u679c\u6211\u4eec\u6784\u9020\u4e86\u4e00\u4e2a\u7c7b\u6216\u8005\u4f7f\u7528\u4e00\u4e2a\u5de6\u503c\u8fdb\u884c\u8fdb\u884c\u4e86\u4e00\u6b21\u8d4b\u503c\uff0c\u6211\u4eec\u80fd\u505a\u7684\u53ea\u6709\u62f7\u8d1d\u5de6\u503c\u3002\u6211\u4eec\u4e0d\u80fd\u5047\u8bbe\u5b89\u5168\u7684\u4fee\u6539\u5de6\u503c\uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u4f1a\u5728\u7a0b\u5e8f\u4e2d\u88ab\u518d\u6b21\u4f7f\u7528\u3002\u5982\u679c\u6211\u4eec\u6709\u4e00\u4e2a\u8868\u8fbe\u5f0f a = b \uff0c\u6211\u4eec\u5f53\u7136\u4e0d\u4f1a\u671f\u5f85 b \u88ab\u4ee5\u4efb\u4f55\u65b9\u5f0f\u4fee\u6539\u3002 \u7136\u800c\uff0c\u5982\u679c\u6211\u4eec\u6784\u9020\u4e86\u4e00\u4e2a\u5bf9\u8c61\u6216\u8005\u4f7f\u7528\u4e00\u4e2a\u53f3\u503c\u8fdb\u884c\u4e00\u6b21\u8d4b\u503c\uff0c\u7136\u540e\u6211\u4eec\u5c31\u4f1a\u77e5\u9053\u53f3\u503c\u5c31\u662f\u4e00\u4e2a\u4e34\u65f6\u503c\u3002\u62f7\u8d1d\u5b83\uff08\u4f1a\u6709\u5f88\u591a\u5f00\u9500\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7684\u8f6c\u79fb\uff08\u5f00\u9500\u975e\u5e38\u5c0f\uff09\u8d44\u6e90\u5230\u53e6\u4e00\u4e2a\u5bf9\u8c61\u6211\u4eec\u5373\u5c06\u521b\u5efa\u6216\u8005\u8d4b\u503c\u7684\u3002\u8fd9\u975e\u5e38\u5b89\u5168\uff0c\u56e0\u4e3a\u4e34\u65f6\u503c\u5728\u8868\u8fbe\u5f0f\u672b\u5c3e\u5c31\u4f1a\u88ab\u5220\u9664\uff0c\u56e0\u6b64\u6211\u4eec\u77e5\u9053\u5b83\u7edd\u4e0d\u4f1a\u518d\u6b21\u88ab\u4f7f\u7528\u3002 \u4f60\u53ef\u4ee5\u7528\u5220\u9664\u5173\u952e\u8bcd\u6765\u4e3a\u4f60\u5b9a\u4e49\u7684\u7c7b\u7981\u7528\u62f7\u8d1d\u8bed\u4e49\uff0c\u8fd9\u6837\u4f60\u5c31\u5220\u9664\u4e86\u62f7\u8d1d\u6784\u9020\u548c\u62f7\u8d1d\u8d4b\u503c\u64cd\u4f5c\u7b26\u3002 std::move \u5141\u8bb8\u4f60\u50cf\u5bf9\u5f85\u4e00\u4e2a\u53f3\u503c\u90a3\u6837\u5bf9\u5f85\u4e00\u4e2a\u5de6\u503c\u3002\u8fd9\u662f\u975e\u5e38\u6709\u7528\u7684\uff0c\u5f53\u4f60\u60f3\u8981\u5728\u4e00\u4e2a\u5de6\u503c\u4e0a\u89e6\u53d1\u79fb\u52a8\u8bed\u4e49\u800c\u4e0d\u662f\u62f7\u8d1d\u8bed\u4e49\u3002 std\"\"unique_ptr \u662f\u4f60\u5e94\u8be5\u4f7f\u7528\u7684\u667a\u80fd\u6307\u9488\u7c7b\u3002\u4ed6\u5355\u72ec\u7ba1\u7406\u7740\u4e00\u4efd\u4e0d\u80fd\u5206\u4eab\u7684\u8d44\u6e90\u3002 std::make_unique() \uff08\u5728 C++14\u4e2d\uff09\u5e94\u8be5\u4f5c\u4e3a\u521b\u5efa\u65b0 std::unique_ptr \u7684\u9996\u9009\u3002 std::unique_ptr \u7981\u7528\u4e86\u62f7\u8d1d\u8bed\u4e49\u3002 \u5f53\u4f60\u9700\u8981\u591a\u4e2a\u5bf9\u8c61\u8bbf\u95ee\u540c\u4e00\u4efd\u8d44\u6e90\u65f6\uff0c\u53ef\u4ee5\u7528 std::shared_ptr \u667a\u80fd\u6307\u9488\u7c7b\u3002\u8d44\u6e90\u5c06\u4f1a\u88ab\u9500\u6bc1\uff0c\u76f4\u5230\u6700\u540e\u4e00\u4e2a\u7ba1\u7406\u8be5\u8d44\u6e90\u7684 std::shared_ptr \u88ab\u9500\u6bc1\u3002 std::make_shared() \u5e94\u8be5\u4f5c\u4e3a\u521b\u5efa\u65b0 std::shared_ptr \u7684\u9996\u9009\u3002\u4f7f\u7528 std::shared_ptr \uff0c\u62f7\u8d1d\u8bed\u4e49\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u521b\u5efa\u4e00\u4e2a std::shared_ptr \u6765\u6307\u5411\u76f8\u540c\u7684\u5bf9\u8c61\u3002 \u5f53\u4f60\u9700\u8981\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u72ec\u4eab\u5177\u6709\u8bbf\u95ee\u4e00\u4e2a\u8d44\u6e90\u7684\u80fd\u529b\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528 std::weak_ptr \u667a\u80fd\u6307\u9488\uff0c\u4e0d\u50cf std::shared_ptr \u90a3\u6837\uff0c std::weak_ptr \u4e0d\u4f1a\u51b3\u5b9a\u8d44\u6e90\u662f\u5426\u5e94\u8be5\u88ab\u9500\u6bc1\u3002","title":"15.x \u5341\u4e94\u7ae0\u7406\u89e3\u548c\u590d\u4e60"},{"location":"18-virtual-functions/","text":"\u7b2c\u5341\u516b\u7ae0 \u865a\u51fd\u6570 \u00b6 18.1-\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528 18.2-\u865a\u51fd\u6570\u548c\u591a\u6001 18.3-\u91cd\u5199 final \u6807\u8bc6\u7b26\uff0c\u5e76\u4e14\u534f\u53d8\u8fd4\u56de\u7c7b\u578b 18.4-\u865a\u6784\u9020\u51fd\u6570\uff0c\u865a\u91cd\u8f7d\u8fd0\u7b97\u7b26\u51fd\u6570\uff0c\u91cd\u5199\u865a\u51fd\u6570 18.5-\u9884\u7ed1\u5b9a\u548c\u540e\u671f\u7ed1\u5b9a 18.6-\u865a\u8868 18.7-\u865a\u57fa\u7c7b 18.8-\u5bf9\u8c61\u5207\u5272 18.9-\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 18.x-\u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60","title":"\u7b2c\u5341\u516b\u7ae0 \u865a\u51fd\u6570"},{"location":"18-virtual-functions/#_1","text":"18.1-\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528 18.2-\u865a\u51fd\u6570\u548c\u591a\u6001 18.3-\u91cd\u5199 final \u6807\u8bc6\u7b26\uff0c\u5e76\u4e14\u534f\u53d8\u8fd4\u56de\u7c7b\u578b 18.4-\u865a\u6784\u9020\u51fd\u6570\uff0c\u865a\u91cd\u8f7d\u8fd0\u7b97\u7b26\u51fd\u6570\uff0c\u91cd\u5199\u865a\u51fd\u6570 18.5-\u9884\u7ed1\u5b9a\u548c\u540e\u671f\u7ed1\u5b9a 18.6-\u865a\u8868 18.7-\u865a\u57fa\u7c7b 18.8-\u5bf9\u8c61\u5207\u5272 18.9-\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 18.x-\u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60","title":"\u7b2c\u5341\u516b\u7ae0 \u865a\u51fd\u6570"},{"location":"18-virtual-functions/18.1-pointers-and-references-to-the-base-class-of-derived-objects/","text":"18.1 \u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528\u6307\u5411\u6d3e\u751f\u7c7b \u00b6 By Alex on January 29 th , 2008 | last modified by nascardriver on December 5 th , 2020 \u7ffb\u8bd1 by dashjay 2020-12-17 \u5728\u524d\u4e9b\u7ae0\u8282\uff0c\u6211\u4eec\u5b66\u4e60\u4e86\u6240\u6709\u5173\u4e8e\u5982\u4f55\u4f7f\u7528\u7ee7\u627f\u4ece\u5df2\u7ecf\u5b58\u5728\u7684\u7c7b\u6765\u6d3e\u751f\u51fa\u65b0\u7c7b\u3002\u5728\u8fd9\u4e2a\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u4e13\u6ce8\u5b66\u4e60\u7ee7\u627f\u4e2d\u6700\u91cd\u8981\u548c\u6700\u5f3a\u5927\u7684\u65b9\u9762 -- \u865a\u51fd\u6570\u3002 \u4f46\u662f\u4e4b\u524d\u6211\u4eec\u8ba8\u8bba\u8fc7\u865a\u51fd\u6570\u662f\u4ec0\u4e48\uff0c\u8ba9\u6211\u4eec\u5148\u6765\u8bf4\u8bf4\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u5b83\u3002 \u5728\u8fd9\u4e2a\u6d3e\u751f\u7c7b\u7684\u6784\u9020\u8fd9\u4e2a\u7ae0\u8282\u4e2d\uff0c\u4f60\u4e86\u89e3\u4e86\u5f53\u4f60\u521b\u5efa\u4e00\u4e2a\u6d3e\u751f\u7c7b\u7684\u65f6\u5019\uff0c\u5b83\u662f\u7531\u591a\u4e2a\u90e8\u5206\u7ec4\u6210\u7684\uff1a\u6bcf\u4e00\u4e2a\u90fd\u662f\u4e00\u4e2a\u7ee7\u627f\u7c7b\uff0c\u548c\u5b83\u672c\u8eab\u7684\u4e00\u4e2a\u90e8\u5206\u3002 \u4f8b\u5982\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a #include <string_view> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } std :: string_view getName () const { return \"Base\" ; } int getValue () const { return m_value ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } std :: string_view getName () const { return \"Derived\" ; } int getValueDoubled () const { return m_value * 2 ; } }; \u5f53\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6d3e\u751f\u7684\u5bf9\u8c61\uff0c\u5b83\u5305\u542b\u4e86\u4e00\u4e2a\u57fa\u7c7b\u90e8\u5206\uff08\u5148\u88ab\u6784\u9020\u51fa\u6765\uff09\uff0c\u7136\u540e\u5305\u542b\u4e86\u4e00\u4e2a\u6d3e\u751f\uff08\u7b2c\u4e8c\u4e2a\u88ab\u6784\u9020\u51fa\u6765\u7684\uff09\u3002\u8bb0\u4f4f\u7ee7\u627f\u610f\u5473\u7740\u5728\u4e24\u4e2a\u7c7b\u95f4\u4ea7\u751f\u4e86\u201d\u662f\u4e00\u4e2a (is a)\u201c\u7684\u5173\u7cfb\u3002\u56e0\u4e3a\u4e00\u4e2a\u7ee7\u627f\u7c7b\u662f\u4e00\u4e2a\u57fa\u7c7b\uff0c\u4e5f\u53ef\u4ee5\u8ba4\u4e3a\u7ee7\u627f\u7c7b\u5305\u542b\u4e86\u4e00\u4e2a\u57fa\u7c7b\u90e8\u5206\u3002 \u6307\u9488\uff0c\u5f15\u7528\u548c\u7ee7\u627f\u7c7b \u00b6 \u975e\u5e38\u76f4\u89c2\u7684\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6d3e\u751f\u6307\u9488\u548c\u5f15\u7528\u6307\u5411\u6d3e\u751f\u5bf9\u8c61\uff1a #include <iostream> int main () { Derived derived { 5 }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; Derived & rDerived { derived }; std :: cout << \"rDerived is a \" << rDerived . getName () << \" and has value \" << rDerived . getValue () << '\\n' ; Derived * pDerived { & derived }; std :: cout << \"pDerived is a \" << pDerived -> getName () << \" and has value \" << pDerived -> getValue () << '\\n' ; return 0 ; } \u4e0b\u9762\u5c31\u662f\u8f93\u51fa\uff1a derived is a Derived and has value 5 rDerived is a Derived and has value 5 pDerived is a Derived and has value 5 \u7136\u800c\uff0c\u81ea\u4ece\u6d3e\u751f\u7c7b\u6709\u4e00\u4e2a\u57fa\u7c7b\u90e8\u5206\uff0c\u4e00\u4e2a\u66f4\u6709\u8da3\u7684\u95ee\u9898\u5c31\u662f C++ \u5c06\u4f1a\u6211\u4eec\u8ba9\u6211\u4eec\u5c06\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6216\u8005\u5f15\u7528\u6307\u5411\u4e00\u4e2a\u6d3e\u751f\u7c7b\u5bf9\u8c61\u3002\u6211\u4eec\u786e\u5b9e\u53ef\u4ee5\u8fd9\u6837\u505a\uff01 # include <iostream> int main () { Derived derived { 5 }; // These are both legal! Base & rBase { derived }; Base * pBase { & derived }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; std :: cout << \"rBase is a \" << rBase . getName () << \" and has value \" << rBase . getValue () << '\\n' ; std :: cout << \"pBase is a \" << pBase -> getName () << \" and has value \" << pBase -> getValue () << '\\n' ; return 0 ; } \u8fd9\u4e2a\u4ea7\u751f\u4e86\u7ed3\u679c\uff1a derived is a Derived and has value 5 rBase is a Base and has value 5 pBase is a Base and has value 5 \u8fd9\u4e2a\u7ed3\u679c\u53ef\u80fd\u4e00\u5f00\u59cb\u4e0d\u90a3\u4e48\u7b26\u5408\u4f60\u7684\u671f\u671b! \u4e8b\u5b9e\u8bc1\u660e rBase \u548c pBase \u662f\u4e00\u4e2a\u57fa\u7c7b\u5f15\u7528\u548c\u6307\u9488\uff0c\u4ed6\u4eec\u53ef\u4ee5\u4ec5\u4ec5\u770b\u5230\u57fa\u7c7b\u6210\u5458\uff08\u6216\u8005\u4efb\u4f55\u4ece\u57fa\u7c7b\u7ee7\u627f\u7684\u7c7b\uff09\u3002\u56e0\u6b64\u5c3d\u7ba1 Derived::getName() \u9690\u85cf\u4e86\u6d3e\u751f\u5bf9\u8c61\u7684 Base::getName() \uff0c\u57fa\u7c7b\u6307\u9488/\u5f15\u7528\u4e0d\u53ef\u4ee5\u770b\u5230 Derived::getName() \u3002\u56e0\u6b64\uff0c\u4ed6\u4eec\u8c03\u7528 Base::getName() \uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48 rBase \u548c pBase \u663e\u793a\u5b83\u4eec\u662f\u4e00\u4e2a\u57fa\u7c7b\u800c\u4e0d\u662f\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002 \uff08\u4e0a\u9762\u8fd9\u53e5\u8bdd\u592a\u96be\u7ffb\u8bd1\uff09It turns out that because rBase and pBase are a Base reference and pointer, they can only see members of Base (or any classes that Base inherited). So even though Derived::getName() shadows (hides) Base::getName() for Derived objects, the Base pointer/reference can not see Derived::getName(). Consequently, they call Base::getName(), which is why rBase and pBase report that they are a Base rather than a Derived. \u6ce8\u610f\u8fd9\u4e5f\u610f\u5473\u7740\u4e0d\u53ef\u80fd\u4ece rBase \u548c pBase \u6765\u8c03\u7528 Derived::getValueDoubled() \u3002\u5b83\u4eec\u662f\u4e0d\u53ef\u80fd\u5728\u6d3e\u751f\u7c7b\u4e2d\u770b\u89c1\u7684\u3002 \u8fd9\u6709\u4e00\u4e2a\u66f4\u52a0\u590d\u6742\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u8be6\u7ec6\u8bf4\u660e\uff1a # include <iostream> # include <string_view> # include <string> class Animal { protected : std :: string m_name ; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( std :: string_view name ) : m_name { name } { } // To prevent slicing (covered later) Animal ( const Animal & ) = delete ; Animal & operator = ( const Animal & ) = delete ; public : const std :: string & getName () const { return m_name ; } std :: string_view speak () const { return \"???\" ; } }; class Cat : public Animal { public : Cat ( std :: string_view name ) : Animal { name } { } std :: string_view speak () const { return \"Meow\" ; } }; class Dog : public Animal { public : Dog ( std :: string_view name ) : Animal { name } { } std :: string_view speak () const { return \"Woof\" ; } }; int main () { const Cat cat { \"Fred\" }; std :: cout << \"cat is named \" << cat . getName () << \", and it says \" << cat . speak () << '\\n' ; const Dog dog { \"Garbo\" }; std :: cout << \"dog is named \" << dog . getName () << \", and it says \" << dog . speak () << '\\n' ; const Animal * pAnimal { & cat }; std :: cout << \"pAnimal is named \" << pAnimal -> getName () << \", and it says \" << pAnimal -> speak () << '\\n' ; pAnimal = & dog ; std :: cout << \"pAnimal is named \" << pAnimal -> getName () << \", and it says \" << pAnimal -> speak () << '\\n' ; return 0 ; } \u8fd9\u751f\u6210\u7ed3\u679c\uff1a cat is named Fred , and it says Meow dog is named Garbo , and it says Woof pAnimal is named Fred , and it says ??? pAnimal is named Garbo , and it says ??? \u6211\u4eec\u5728\u8fd9\u91cc\u770b\u5230\u540c\u6837\u7684\u95ee\u9898\u3002\u56e0\u4e3a pAnimal \u662f\u4e00\u4e2a Animal \u6307\u9488\uff0c\u5b83\u53ea\u80fd\u770b\u89c1\u7c7b\u4e2d Animal \u90e8\u5206\u7684\u3002\u56e0\u6b64\uff0c pAnimal->speak() \u8c03\u7528\u4e86 Animal::speak() \u800c\u4e0d\u662f Dog::Speak \u6216\u8005 Cat::speak() \u51fd\u6570\u3002 \u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u548c\u5f15\u7528\u7684\u4f7f\u7528\u65b9\u6cd5 \u00b6 \u73b0\u5728\u4f60\u53ef\u80fd\u4f1a\u8bf4\uff0c\u201c\u4e0a\u9762\u7684\u4f8b\u5b50\u770b\u8d77\u6765\u6709\u70b9\u8822\uff0c\u4e3a\u4ec0\u4e48\u6211\u4eec\u4e0d\u8bbe\u7f6e\u4e00\u4e2a\u6307\u9488\u6216\u8005\u5f15\u7528\u5230\u4e00\u4e2a\u6d3e\u751f\u7c7b\u4e2d\u7684\u57fa\u7c7b\u90e8\u5206\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u80fd\u4f7f\u7528\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61\uff1f\u201d\u4e8b\u5b9e\u8bc1\u660e\uff0c\u6709\u5145\u5206\u7684\u7406\u7531\u3002 \u9996\u5148\uff0c\u6211\u4eec\u77e5\u9053\u4f60\u60f3\u8981\u5199\u51fa\u4e00\u4e2a\u51fd\u6570\u53ef\u4ee5\u6253\u5370\u4e00\u4e2a\u52a8\u7269\u7684\u540d\u5b57\u548c\u58f0\u97f3\u3002\u4e0d\u9002\u7528\u57fa\u7c7b\u6307\u9488\uff0c\u4f60\u5fc5\u987b\u50cf\u8fd9\u6837\u5199\u91cd\u8f7d\u51fd\u6570\uff1a void report ( const Cat & cat ) { std :: cout << cat . getName () << \" says \" << cat . speak () << '\\n' ; } void report ( const Dog & dog ) { std :: cout << dog . getName () << \" says \" << dog . speak () << '\\n' ; } \u4e0d\u662f\u5f88\u590d\u6742\uff0c\u4f46\u662f\u60f3\u8c61\u5982\u679c\u4f60\u670930\u79cd\u4e0d\u540c\u7684\u52a8\u7269\uff0c\u800c\u4e0d\u662f\u4e24\u79cd\u3002\u4f60\u5c31\u9700\u8981\u5199\u4e09\u5341\u79cd\u4e0d\u540c\u7684\u51fd\u6570\uff01\u800c\u4e14\uff0c\u5982\u679c\u4f60\u6bcf\u6dfb\u52a0\u4e00\u79cd\u65b0\u7684\u52a8\u7269\uff0c\u4f60\u5c31\u8981\u4e3a\u8fd9\u4e2a\u52a8\u7269\u5199\u4e00\u4e2a\u65b0\u7684\u51fd\u6570\u3002\u8fd9\u662f\u4e00\u4e2a\u5de8\u5927\u7684\u65f6\u95f4\u6d6a\u8d39\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u53ea\u6709\u7c7b\u578b\u7684\u53c2\u6570\u4e0d\u540c\u3002 \u7136\u800c\uff0c\u56e0\u4e3a Cat \u548c Dog \u662f\u6d3e\u751f\u4e8e Animal \uff0c Cat \u548c Dog \u90fd\u6709 Animal \u7684\u57fa\u7c7b\u90e8\u5206\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u50cf\u8fd9\u6837\u505a\u5566\uff1a void report ( const Animal & rAnimal ) { std :: cout << rAnimal . getName () << \" says \" << rAnimal . speak () << '\\n' ; } \u6211\u4eec\u5c31\u53ef\u4ee5\u4f20\u5165\u4efb\u4f55\u7684 Animal \u6d3e\u751f\u7c7b\uff0c\u751a\u81f3\u662f\u6211\u4eec\u5728\u5199\u8fd9\u4e2a\u51fd\u6570\u4ee5\u540e\u521b\u5efa\u65b0\u7684\u6d3e\u751f\u7c7b\uff01\u800c\u65e0\u9700\u7ed9\u6bcf\u4e2a\u6d3e\u751f\u7c7b\u90fd\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u4e00\u4e2a\u53ef\u4ee5\u4e3a\u6240\u6709 Animal \u6d3e\u751f\u7c7b\u670d\u52a1\u7684\u51fd\u6570\u3002 \u95ee\u9898\u662f\uff0c\u5f53\u7136\uff0c\u56e0\u4e3a rAnimal \u662f\u4e00\u4e2a Animal \u5f15\u7528\uff0c rAnimal.speak() \u5c06\u4f1a\u8c03\u7528 Animal::speak() \u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684 speak() \u3002 \u5176\u6b21\uff0c\u6211\u4eec\u73b0\u5728\u6709\u4e09\u4e2a cats \u548c \u4e09\u4e2a dogs \u4f60\u60f3\u8981\u628a\u4ed6\u4eec\u653e\u5728\u6570\u7ec4\u91cc\uff0c\u65b9\u4fbf\u4f60\u53bb\u8bbf\u95ee\u3002\u56e0\u4e3a\u6570\u7ec4\u53ea\u80fd\u6301\u6709\u4e00\u4e2a\u5bf9\u8c61\u7684\u7c7b\u578b\uff0c\u5982\u679c\u4e0d\u4f7f\u7528\u57fa\u7c7b\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u4f60\u5c31\u4e0d\u5f97\u4e0d\u521b\u5efa\u4e24\u4e2a\u4e0d\u540c\u7684\u6570\u7ec4\u5206\u522b\u7ed9\u4e24\u4e2a\u4e0d\u540c\u7684\u7c7b\u578b\uff0c\u50cf\u8fd9\u6837\uff1a # include <array> # include <iostream> // Cat and Dog from the example above int main () { const auto cats { std :: to_array < Cat > ({{ \"Fred\" }, { \"Misty\" }, { \"Zeke\" }}) }; const auto dogs { std :: to_array < Dog > ({{ \"Garbo\" }, { \"Pooky\" }, { \"Truffle\" }}) }; // Before C++20 // const std::array<Cat, 3> cats{{ { \"Fred\" }, { \"Misty\" }, { \"Zeke\" } }}; // const std::array<Dog, 3> dogs{{ { \"Garbo\" }, { \"Pooky\" }, { \"Truffle\" } }}; for ( const auto & cat : cats ) { std :: cout << cat . getName () << \" says \" << cat . speak () << '\\n' ; } for ( const auto & dog : dogs ) { std :: cout << dog . getName () << \" says \" << dog . speak () << '\\n' ; } return 0 ; } \u73b0\u5728\uff0c\u60f3\u8c61\u5982\u679c\u6709\u4e09\u5341\u79cd\u4e0d\u540c\u7684\u52a8\u7269\uff0c\u4f60\u9700\u898130\u4e2a\u4e0d\u540c\u7684\u6570\u7ec4\uff0c\u6bcf\u79cd\u52a8\u7269\u90fd\u9700\u8981\u4e00\u4e2a\uff01 \u7136\u800c\uff0c\u56e0\u4e3a Cat \u548c Dog \u662f\u4ece Animal \u6d3e\u751f\u7684\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u53bb\u505a\u4e00\u4e9b\u4e8b\uff0c\u50cf\u8fd9\u6837\uff1a # include <iostream> int main () { const Cat fred { \"Fred\" }; const Cat misty { \"Misty\" }; const Cat zeke { \"Zeke\" }; const Dog garbo { \"Garbo\" }; const Dog pooky { \"Pooky\" }; const Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects const auto animals { std :: to_array < const Animal *> ({ & fred , & garbo , & misty , & pooky , & truffle , & zeke }) }; // Before C++20, with the array size being explicitly specified // const std::array<const Animal*, 6> animals{ &fred, &garbo, &misty, &pooky, &truffle, &zeke }; for ( const auto animal : animals ) { std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; } return 0 ; } \u5f53\u8fd9\u4e2a\u7f16\u8bd1\u6267\u884c\u65f6\uff0c\u4e0d\u5e78\u7684\u662f\u6bcf\u4e2a animals \u662f\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e00\u4e2a Animal \u8fd9\u610f\u5473\u7740 animal->speak() \u5c06\u4f1a\u8c03\u7528 Animal::speak() \u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u6211\u4eec\u60f3\u8981\u7684\u6d3e\u751f\u7c7b\u7248\u672c\u7684 speak() \uff0c\u8fd9\u4f1a\u5f97\u5230\u8f93\u51fa\uff1a Fred says ??? Garbo says ??? Misty says ??? Pooky says ??? Truffle says ??? Zeke says ??? \u5c3d\u7ba1\u8fd9\u4e9b\u6280\u5de7\u53ef\u4ee5\u8282\u7701\u6211\u4eec\u5927\u91cf\u7684\u65f6\u95f4\u548c\u80fd\u91cf\uff0c\u4ed6\u4eec\u4e5f\u6709\u540c\u6837\u7684\u95ee\u9898\u3002\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\u8c03\u7528\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e9b\u65b9\u5f0f\u4f7f\u5f97\u90a3\u4e9b\u57fa\u7c7b\u6307\u9488\u8c03\u7528\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u51fd\u6570\u800c\u4e0d\u662f\u57fa\u7c7b\u7248\u672c\u7684\u2026\u2026 \u8bf7\u731c\u731c\u865a\u51fd\u6570\u662f\u5e72\u5565\u7528\u7684\uff1f:) Quiz time 1\uff09\u6211\u4eec\u7684 Animal/Cat/Dog \u89e3\u91ca\u4e86\u4e0a\u65b9\u7684\u4ee3\u7801\u4e0d\u80fd\u50cf\u6211\u4eec\u60f3\u8c61\u7684\u90a3\u6837\u53bb\u5de5\u4f5c\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5f15\u7528\u6216\u8005\u6307\u9488\u6307\u5411 Animal \u4e0d\u80fd\u8bbf\u95ee\u6d3e\u751f\u7c7b\u7684\u7248\u672c\u7684 speak() \u9700\u8981\u8fd4\u56de\u4e00\u4e2a Cat \u6216\u8005 Dog \u7684\u6b63\u786e\u503c\u3002\u552f\u4e00\u7684\u65b9\u5f0f\u5c31\u662f\u4f7f\u5f97 speak() \u8fd4\u56de\u7684\u6570\u636e\u6210\u4e3a Animal \u57fa\u7c7b\u7684\u4e00\u90e8\u5206\uff08\u5c31\u50cf\u662f Animal \u7684 name \u662f\u901a\u8fc7 m_name \u8fd9\u4e2a\u6210\u5458\u6765\u8bbf\u95ee\u7684\uff09 \uff08\u9898\u76ee\u7ffb\u8bd1\u4e5f\u8bb8\u6709\u95ee\u9898\uff091) Our Animal/Cat/Dog example above doesn\u2019t work like we want because a reference or pointer to an Animal can\u2019t access the derived version of speak() needed to return the right value for the Cat or Dog. One way to work around this issue would be to make the data returned by the speak() function accessible as part of the Animal base class (much like the Animal\u2019s name is accessible via member m_name). Update the Animal, Cat, and Dog classes in the lesson above by adding a new member to Animal named m_speak. Initialize it appropriately. The following program should work properly: \u66f4\u65b0\u4e4b\u524d\u8bfe\u7a0b\u4e2d\u7f16\u5199\u7684 Animal, Cat, Dog \u4e09\u4e2a\u7c7b\uff0c\u901a\u8fc7\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u6210\u5458 m_speak \u5230 Animal \u57fa\u7c7b\u3002\u4ee5\u5408\u9002\u7684\u65b9\u5f0f\u521d\u59cb\u5316\u4ed6\u4eec\uff0c\u4e0b\u9762\u7684\u7a0b\u5e8f\u80fd\u591f\u5f88\u597d\u7684\u5de5\u4f5c\u3002 # include <array> # include <iostream> int main () { const Cat fred { \"Fred\" }; const Cat misty { \"Misty\" }; const Cat zeke { \"Zeke\" }; const Dog garbo { \"Garbo\" }; const Dog pooky { \"Pooky\" }; const Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects const auto animals { std :: to_array < const Animal *> ({ & fred , & garbo , & misty , & pooky , & truffle , & zeke }) }; // Before C++20, with the array size being explicitly specified // const std::array<const Animal*, 6> animals{ &fred, &garbo, &misty, &pooky, &truffle, &zeke }; for ( const auto animal : animals ) { std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; } return 0 ; } \u7b54\u6848\uff1a # include <array> # include <string> # include <string_view> # include <iostream> class Animal { protected : std :: string m_name {}; std :: string m_speak {}; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( std :: string_view name , std :: string_view speak ) : m_name { name }, m_speak { speak } { } // To prevent slicing (covered later) Animal ( const Animal & ) = delete ; Animal & operator = ( const Animal & ) = delete ; public : const std :: string & getName () const { return m_name ; } const std :: string & speak () const { return m_speak ; } }; class Cat : public Animal { public : Cat ( std :: string_view name ) : Animal { name , \"Meow\" } { } }; class Dog : public Animal { public : Dog ( std :: string_view name ) : Animal { name , \"Woof\" } { } }; int main () { const Cat fred { \"Fred\" }; const Cat misty { \"Misty\" }; const Cat zeke { \"Zeke\" }; const Dog garbo { \"Garbo\" }; const Dog pooky { \"Pooky\" }; const Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects const auto animals { std :: to_array < const Animal *> ({ & fred , & garbo , & misty , & pooky , & truffle , & zeke }) }; // Before C++20, with the array size being explicitly specified // const std::array<const Animal*, 6> animals{ &fred, &garbo, &misty, &pooky, &truffle, &zeke }; // animal is not a reference, because we're looping over pointers for ( const auto animal : animals ) { std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; } return 0 ; } 2\uff09\u4e3a\u4ec0\u4e48\u4e0a\u9762\u7684\u89e3\u51b3\u65b9\u6848\u4e0d\u662f\u6700\u4f18\u7684\uff1f \u63d0\u793a\uff1a\u60f3\u60f3\u732b\u548c\u72d7\u7684\u672a\u6765\u72b6\u6001\uff0c\u6211\u4eec\u60f3\u7528\u66f4\u591a\u7684\u65b9\u5f0f\u6765\u533a\u5206\u732b\u548c\u72d7 \u63d0\u793a\uff1a\u8003\u8651\u4e00\u4e0b\u5728\u521d\u59cb\u5316\u65f6\u9700\u8981\u8bbe\u7f6e\u7684\u6210\u5458\u5bf9\u60a8\u7684\u9650\u5236\u3002 \u5f53\u524d\u7684\u89e3\u51b3\u65b9\u6848\u5e76\u4e0d\u662f\u6700\u4f18\u7684\uff0c\u539f\u56e0\u662f\u6211\u4eec\u5fc5\u987b\u7ed9\u6bcf\u4e2a\u4e0d\u540c\u7684\u7c7b\u6dfb\u52a0\u4e00\u4e2a\u6210\u5458\u6765\u5206\u8fa8 Cat \u548c Dog \uff0c\u4e00\u6bb5\u65f6\u95f4\u4e4b\u540e\uff0c\u6211\u4eec\u7684 Animal \u7c7b\u53ef\u80fd\u53d8\u5f97\u975e\u5e38\u6d88\u8017\u5185\u5b58\u5e76\u4e14\u975e\u5e38\u590d\u6742\uff01 \u800c\u4e14\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u53ea\u80fd\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u51b3\u5b9a\u624d\u80fd\u6b63\u5e38\u5de5\u4f5c\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c speak() \u8fd4\u56de\u4e86\u4e00\u4e2a\u968f\u673a\u7684\u7ed3\u679c\uff0c\u4e3a\u6bcf\u4e2a Animal \u7c7b\uff08\u4f8b\u5982\u8c03\u7528 Dog::speak() \u53ef\u80fd\u8fd4\u56de woof \uff0c arf \uff0c\u6216\u8005 yip \uff09\uff0c\u8fd9\u7c7b\u7684\u89e3\u51b3\u65b9\u6848\u5f00\u59cb\u53d8\u5f97\u5c34\u5c2c\u3001\u5d29\u6e83\u3002","title":"18.1 \u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528\u6307\u5411\u6d3e\u751f\u7c7b"},{"location":"18-virtual-functions/18.1-pointers-and-references-to-the-base-class-of-derived-objects/#181","text":"By Alex on January 29 th , 2008 | last modified by nascardriver on December 5 th , 2020 \u7ffb\u8bd1 by dashjay 2020-12-17 \u5728\u524d\u4e9b\u7ae0\u8282\uff0c\u6211\u4eec\u5b66\u4e60\u4e86\u6240\u6709\u5173\u4e8e\u5982\u4f55\u4f7f\u7528\u7ee7\u627f\u4ece\u5df2\u7ecf\u5b58\u5728\u7684\u7c7b\u6765\u6d3e\u751f\u51fa\u65b0\u7c7b\u3002\u5728\u8fd9\u4e2a\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u4e13\u6ce8\u5b66\u4e60\u7ee7\u627f\u4e2d\u6700\u91cd\u8981\u548c\u6700\u5f3a\u5927\u7684\u65b9\u9762 -- \u865a\u51fd\u6570\u3002 \u4f46\u662f\u4e4b\u524d\u6211\u4eec\u8ba8\u8bba\u8fc7\u865a\u51fd\u6570\u662f\u4ec0\u4e48\uff0c\u8ba9\u6211\u4eec\u5148\u6765\u8bf4\u8bf4\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u5b83\u3002 \u5728\u8fd9\u4e2a\u6d3e\u751f\u7c7b\u7684\u6784\u9020\u8fd9\u4e2a\u7ae0\u8282\u4e2d\uff0c\u4f60\u4e86\u89e3\u4e86\u5f53\u4f60\u521b\u5efa\u4e00\u4e2a\u6d3e\u751f\u7c7b\u7684\u65f6\u5019\uff0c\u5b83\u662f\u7531\u591a\u4e2a\u90e8\u5206\u7ec4\u6210\u7684\uff1a\u6bcf\u4e00\u4e2a\u90fd\u662f\u4e00\u4e2a\u7ee7\u627f\u7c7b\uff0c\u548c\u5b83\u672c\u8eab\u7684\u4e00\u4e2a\u90e8\u5206\u3002 \u4f8b\u5982\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a #include <string_view> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } std :: string_view getName () const { return \"Base\" ; } int getValue () const { return m_value ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } std :: string_view getName () const { return \"Derived\" ; } int getValueDoubled () const { return m_value * 2 ; } }; \u5f53\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6d3e\u751f\u7684\u5bf9\u8c61\uff0c\u5b83\u5305\u542b\u4e86\u4e00\u4e2a\u57fa\u7c7b\u90e8\u5206\uff08\u5148\u88ab\u6784\u9020\u51fa\u6765\uff09\uff0c\u7136\u540e\u5305\u542b\u4e86\u4e00\u4e2a\u6d3e\u751f\uff08\u7b2c\u4e8c\u4e2a\u88ab\u6784\u9020\u51fa\u6765\u7684\uff09\u3002\u8bb0\u4f4f\u7ee7\u627f\u610f\u5473\u7740\u5728\u4e24\u4e2a\u7c7b\u95f4\u4ea7\u751f\u4e86\u201d\u662f\u4e00\u4e2a (is a)\u201c\u7684\u5173\u7cfb\u3002\u56e0\u4e3a\u4e00\u4e2a\u7ee7\u627f\u7c7b\u662f\u4e00\u4e2a\u57fa\u7c7b\uff0c\u4e5f\u53ef\u4ee5\u8ba4\u4e3a\u7ee7\u627f\u7c7b\u5305\u542b\u4e86\u4e00\u4e2a\u57fa\u7c7b\u90e8\u5206\u3002","title":"18.1 \u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528\u6307\u5411\u6d3e\u751f\u7c7b"},{"location":"18-virtual-functions/18.1-pointers-and-references-to-the-base-class-of-derived-objects/#_1","text":"\u975e\u5e38\u76f4\u89c2\u7684\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6d3e\u751f\u6307\u9488\u548c\u5f15\u7528\u6307\u5411\u6d3e\u751f\u5bf9\u8c61\uff1a #include <iostream> int main () { Derived derived { 5 }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; Derived & rDerived { derived }; std :: cout << \"rDerived is a \" << rDerived . getName () << \" and has value \" << rDerived . getValue () << '\\n' ; Derived * pDerived { & derived }; std :: cout << \"pDerived is a \" << pDerived -> getName () << \" and has value \" << pDerived -> getValue () << '\\n' ; return 0 ; } \u4e0b\u9762\u5c31\u662f\u8f93\u51fa\uff1a derived is a Derived and has value 5 rDerived is a Derived and has value 5 pDerived is a Derived and has value 5 \u7136\u800c\uff0c\u81ea\u4ece\u6d3e\u751f\u7c7b\u6709\u4e00\u4e2a\u57fa\u7c7b\u90e8\u5206\uff0c\u4e00\u4e2a\u66f4\u6709\u8da3\u7684\u95ee\u9898\u5c31\u662f C++ \u5c06\u4f1a\u6211\u4eec\u8ba9\u6211\u4eec\u5c06\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6216\u8005\u5f15\u7528\u6307\u5411\u4e00\u4e2a\u6d3e\u751f\u7c7b\u5bf9\u8c61\u3002\u6211\u4eec\u786e\u5b9e\u53ef\u4ee5\u8fd9\u6837\u505a\uff01 # include <iostream> int main () { Derived derived { 5 }; // These are both legal! Base & rBase { derived }; Base * pBase { & derived }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; std :: cout << \"rBase is a \" << rBase . getName () << \" and has value \" << rBase . getValue () << '\\n' ; std :: cout << \"pBase is a \" << pBase -> getName () << \" and has value \" << pBase -> getValue () << '\\n' ; return 0 ; } \u8fd9\u4e2a\u4ea7\u751f\u4e86\u7ed3\u679c\uff1a derived is a Derived and has value 5 rBase is a Base and has value 5 pBase is a Base and has value 5 \u8fd9\u4e2a\u7ed3\u679c\u53ef\u80fd\u4e00\u5f00\u59cb\u4e0d\u90a3\u4e48\u7b26\u5408\u4f60\u7684\u671f\u671b! \u4e8b\u5b9e\u8bc1\u660e rBase \u548c pBase \u662f\u4e00\u4e2a\u57fa\u7c7b\u5f15\u7528\u548c\u6307\u9488\uff0c\u4ed6\u4eec\u53ef\u4ee5\u4ec5\u4ec5\u770b\u5230\u57fa\u7c7b\u6210\u5458\uff08\u6216\u8005\u4efb\u4f55\u4ece\u57fa\u7c7b\u7ee7\u627f\u7684\u7c7b\uff09\u3002\u56e0\u6b64\u5c3d\u7ba1 Derived::getName() \u9690\u85cf\u4e86\u6d3e\u751f\u5bf9\u8c61\u7684 Base::getName() \uff0c\u57fa\u7c7b\u6307\u9488/\u5f15\u7528\u4e0d\u53ef\u4ee5\u770b\u5230 Derived::getName() \u3002\u56e0\u6b64\uff0c\u4ed6\u4eec\u8c03\u7528 Base::getName() \uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48 rBase \u548c pBase \u663e\u793a\u5b83\u4eec\u662f\u4e00\u4e2a\u57fa\u7c7b\u800c\u4e0d\u662f\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002 \uff08\u4e0a\u9762\u8fd9\u53e5\u8bdd\u592a\u96be\u7ffb\u8bd1\uff09It turns out that because rBase and pBase are a Base reference and pointer, they can only see members of Base (or any classes that Base inherited). So even though Derived::getName() shadows (hides) Base::getName() for Derived objects, the Base pointer/reference can not see Derived::getName(). Consequently, they call Base::getName(), which is why rBase and pBase report that they are a Base rather than a Derived. \u6ce8\u610f\u8fd9\u4e5f\u610f\u5473\u7740\u4e0d\u53ef\u80fd\u4ece rBase \u548c pBase \u6765\u8c03\u7528 Derived::getValueDoubled() \u3002\u5b83\u4eec\u662f\u4e0d\u53ef\u80fd\u5728\u6d3e\u751f\u7c7b\u4e2d\u770b\u89c1\u7684\u3002 \u8fd9\u6709\u4e00\u4e2a\u66f4\u52a0\u590d\u6742\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u8be6\u7ec6\u8bf4\u660e\uff1a # include <iostream> # include <string_view> # include <string> class Animal { protected : std :: string m_name ; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( std :: string_view name ) : m_name { name } { } // To prevent slicing (covered later) Animal ( const Animal & ) = delete ; Animal & operator = ( const Animal & ) = delete ; public : const std :: string & getName () const { return m_name ; } std :: string_view speak () const { return \"???\" ; } }; class Cat : public Animal { public : Cat ( std :: string_view name ) : Animal { name } { } std :: string_view speak () const { return \"Meow\" ; } }; class Dog : public Animal { public : Dog ( std :: string_view name ) : Animal { name } { } std :: string_view speak () const { return \"Woof\" ; } }; int main () { const Cat cat { \"Fred\" }; std :: cout << \"cat is named \" << cat . getName () << \", and it says \" << cat . speak () << '\\n' ; const Dog dog { \"Garbo\" }; std :: cout << \"dog is named \" << dog . getName () << \", and it says \" << dog . speak () << '\\n' ; const Animal * pAnimal { & cat }; std :: cout << \"pAnimal is named \" << pAnimal -> getName () << \", and it says \" << pAnimal -> speak () << '\\n' ; pAnimal = & dog ; std :: cout << \"pAnimal is named \" << pAnimal -> getName () << \", and it says \" << pAnimal -> speak () << '\\n' ; return 0 ; } \u8fd9\u751f\u6210\u7ed3\u679c\uff1a cat is named Fred , and it says Meow dog is named Garbo , and it says Woof pAnimal is named Fred , and it says ??? pAnimal is named Garbo , and it says ??? \u6211\u4eec\u5728\u8fd9\u91cc\u770b\u5230\u540c\u6837\u7684\u95ee\u9898\u3002\u56e0\u4e3a pAnimal \u662f\u4e00\u4e2a Animal \u6307\u9488\uff0c\u5b83\u53ea\u80fd\u770b\u89c1\u7c7b\u4e2d Animal \u90e8\u5206\u7684\u3002\u56e0\u6b64\uff0c pAnimal->speak() \u8c03\u7528\u4e86 Animal::speak() \u800c\u4e0d\u662f Dog::Speak \u6216\u8005 Cat::speak() \u51fd\u6570\u3002","title":"\u6307\u9488\uff0c\u5f15\u7528\u548c\u7ee7\u627f\u7c7b"},{"location":"18-virtual-functions/18.1-pointers-and-references-to-the-base-class-of-derived-objects/#_2","text":"\u73b0\u5728\u4f60\u53ef\u80fd\u4f1a\u8bf4\uff0c\u201c\u4e0a\u9762\u7684\u4f8b\u5b50\u770b\u8d77\u6765\u6709\u70b9\u8822\uff0c\u4e3a\u4ec0\u4e48\u6211\u4eec\u4e0d\u8bbe\u7f6e\u4e00\u4e2a\u6307\u9488\u6216\u8005\u5f15\u7528\u5230\u4e00\u4e2a\u6d3e\u751f\u7c7b\u4e2d\u7684\u57fa\u7c7b\u90e8\u5206\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u80fd\u4f7f\u7528\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61\uff1f\u201d\u4e8b\u5b9e\u8bc1\u660e\uff0c\u6709\u5145\u5206\u7684\u7406\u7531\u3002 \u9996\u5148\uff0c\u6211\u4eec\u77e5\u9053\u4f60\u60f3\u8981\u5199\u51fa\u4e00\u4e2a\u51fd\u6570\u53ef\u4ee5\u6253\u5370\u4e00\u4e2a\u52a8\u7269\u7684\u540d\u5b57\u548c\u58f0\u97f3\u3002\u4e0d\u9002\u7528\u57fa\u7c7b\u6307\u9488\uff0c\u4f60\u5fc5\u987b\u50cf\u8fd9\u6837\u5199\u91cd\u8f7d\u51fd\u6570\uff1a void report ( const Cat & cat ) { std :: cout << cat . getName () << \" says \" << cat . speak () << '\\n' ; } void report ( const Dog & dog ) { std :: cout << dog . getName () << \" says \" << dog . speak () << '\\n' ; } \u4e0d\u662f\u5f88\u590d\u6742\uff0c\u4f46\u662f\u60f3\u8c61\u5982\u679c\u4f60\u670930\u79cd\u4e0d\u540c\u7684\u52a8\u7269\uff0c\u800c\u4e0d\u662f\u4e24\u79cd\u3002\u4f60\u5c31\u9700\u8981\u5199\u4e09\u5341\u79cd\u4e0d\u540c\u7684\u51fd\u6570\uff01\u800c\u4e14\uff0c\u5982\u679c\u4f60\u6bcf\u6dfb\u52a0\u4e00\u79cd\u65b0\u7684\u52a8\u7269\uff0c\u4f60\u5c31\u8981\u4e3a\u8fd9\u4e2a\u52a8\u7269\u5199\u4e00\u4e2a\u65b0\u7684\u51fd\u6570\u3002\u8fd9\u662f\u4e00\u4e2a\u5de8\u5927\u7684\u65f6\u95f4\u6d6a\u8d39\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u53ea\u6709\u7c7b\u578b\u7684\u53c2\u6570\u4e0d\u540c\u3002 \u7136\u800c\uff0c\u56e0\u4e3a Cat \u548c Dog \u662f\u6d3e\u751f\u4e8e Animal \uff0c Cat \u548c Dog \u90fd\u6709 Animal \u7684\u57fa\u7c7b\u90e8\u5206\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u50cf\u8fd9\u6837\u505a\u5566\uff1a void report ( const Animal & rAnimal ) { std :: cout << rAnimal . getName () << \" says \" << rAnimal . speak () << '\\n' ; } \u6211\u4eec\u5c31\u53ef\u4ee5\u4f20\u5165\u4efb\u4f55\u7684 Animal \u6d3e\u751f\u7c7b\uff0c\u751a\u81f3\u662f\u6211\u4eec\u5728\u5199\u8fd9\u4e2a\u51fd\u6570\u4ee5\u540e\u521b\u5efa\u65b0\u7684\u6d3e\u751f\u7c7b\uff01\u800c\u65e0\u9700\u7ed9\u6bcf\u4e2a\u6d3e\u751f\u7c7b\u90fd\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u4e00\u4e2a\u53ef\u4ee5\u4e3a\u6240\u6709 Animal \u6d3e\u751f\u7c7b\u670d\u52a1\u7684\u51fd\u6570\u3002 \u95ee\u9898\u662f\uff0c\u5f53\u7136\uff0c\u56e0\u4e3a rAnimal \u662f\u4e00\u4e2a Animal \u5f15\u7528\uff0c rAnimal.speak() \u5c06\u4f1a\u8c03\u7528 Animal::speak() \u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684 speak() \u3002 \u5176\u6b21\uff0c\u6211\u4eec\u73b0\u5728\u6709\u4e09\u4e2a cats \u548c \u4e09\u4e2a dogs \u4f60\u60f3\u8981\u628a\u4ed6\u4eec\u653e\u5728\u6570\u7ec4\u91cc\uff0c\u65b9\u4fbf\u4f60\u53bb\u8bbf\u95ee\u3002\u56e0\u4e3a\u6570\u7ec4\u53ea\u80fd\u6301\u6709\u4e00\u4e2a\u5bf9\u8c61\u7684\u7c7b\u578b\uff0c\u5982\u679c\u4e0d\u4f7f\u7528\u57fa\u7c7b\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u4f60\u5c31\u4e0d\u5f97\u4e0d\u521b\u5efa\u4e24\u4e2a\u4e0d\u540c\u7684\u6570\u7ec4\u5206\u522b\u7ed9\u4e24\u4e2a\u4e0d\u540c\u7684\u7c7b\u578b\uff0c\u50cf\u8fd9\u6837\uff1a # include <array> # include <iostream> // Cat and Dog from the example above int main () { const auto cats { std :: to_array < Cat > ({{ \"Fred\" }, { \"Misty\" }, { \"Zeke\" }}) }; const auto dogs { std :: to_array < Dog > ({{ \"Garbo\" }, { \"Pooky\" }, { \"Truffle\" }}) }; // Before C++20 // const std::array<Cat, 3> cats{{ { \"Fred\" }, { \"Misty\" }, { \"Zeke\" } }}; // const std::array<Dog, 3> dogs{{ { \"Garbo\" }, { \"Pooky\" }, { \"Truffle\" } }}; for ( const auto & cat : cats ) { std :: cout << cat . getName () << \" says \" << cat . speak () << '\\n' ; } for ( const auto & dog : dogs ) { std :: cout << dog . getName () << \" says \" << dog . speak () << '\\n' ; } return 0 ; } \u73b0\u5728\uff0c\u60f3\u8c61\u5982\u679c\u6709\u4e09\u5341\u79cd\u4e0d\u540c\u7684\u52a8\u7269\uff0c\u4f60\u9700\u898130\u4e2a\u4e0d\u540c\u7684\u6570\u7ec4\uff0c\u6bcf\u79cd\u52a8\u7269\u90fd\u9700\u8981\u4e00\u4e2a\uff01 \u7136\u800c\uff0c\u56e0\u4e3a Cat \u548c Dog \u662f\u4ece Animal \u6d3e\u751f\u7684\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u53bb\u505a\u4e00\u4e9b\u4e8b\uff0c\u50cf\u8fd9\u6837\uff1a # include <iostream> int main () { const Cat fred { \"Fred\" }; const Cat misty { \"Misty\" }; const Cat zeke { \"Zeke\" }; const Dog garbo { \"Garbo\" }; const Dog pooky { \"Pooky\" }; const Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects const auto animals { std :: to_array < const Animal *> ({ & fred , & garbo , & misty , & pooky , & truffle , & zeke }) }; // Before C++20, with the array size being explicitly specified // const std::array<const Animal*, 6> animals{ &fred, &garbo, &misty, &pooky, &truffle, &zeke }; for ( const auto animal : animals ) { std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; } return 0 ; } \u5f53\u8fd9\u4e2a\u7f16\u8bd1\u6267\u884c\u65f6\uff0c\u4e0d\u5e78\u7684\u662f\u6bcf\u4e2a animals \u662f\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e00\u4e2a Animal \u8fd9\u610f\u5473\u7740 animal->speak() \u5c06\u4f1a\u8c03\u7528 Animal::speak() \u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u6211\u4eec\u60f3\u8981\u7684\u6d3e\u751f\u7c7b\u7248\u672c\u7684 speak() \uff0c\u8fd9\u4f1a\u5f97\u5230\u8f93\u51fa\uff1a Fred says ??? Garbo says ??? Misty says ??? Pooky says ??? Truffle says ??? Zeke says ??? \u5c3d\u7ba1\u8fd9\u4e9b\u6280\u5de7\u53ef\u4ee5\u8282\u7701\u6211\u4eec\u5927\u91cf\u7684\u65f6\u95f4\u548c\u80fd\u91cf\uff0c\u4ed6\u4eec\u4e5f\u6709\u540c\u6837\u7684\u95ee\u9898\u3002\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\u8c03\u7528\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e9b\u65b9\u5f0f\u4f7f\u5f97\u90a3\u4e9b\u57fa\u7c7b\u6307\u9488\u8c03\u7528\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u51fd\u6570\u800c\u4e0d\u662f\u57fa\u7c7b\u7248\u672c\u7684\u2026\u2026 \u8bf7\u731c\u731c\u865a\u51fd\u6570\u662f\u5e72\u5565\u7528\u7684\uff1f:) Quiz time 1\uff09\u6211\u4eec\u7684 Animal/Cat/Dog \u89e3\u91ca\u4e86\u4e0a\u65b9\u7684\u4ee3\u7801\u4e0d\u80fd\u50cf\u6211\u4eec\u60f3\u8c61\u7684\u90a3\u6837\u53bb\u5de5\u4f5c\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5f15\u7528\u6216\u8005\u6307\u9488\u6307\u5411 Animal \u4e0d\u80fd\u8bbf\u95ee\u6d3e\u751f\u7c7b\u7684\u7248\u672c\u7684 speak() \u9700\u8981\u8fd4\u56de\u4e00\u4e2a Cat \u6216\u8005 Dog \u7684\u6b63\u786e\u503c\u3002\u552f\u4e00\u7684\u65b9\u5f0f\u5c31\u662f\u4f7f\u5f97 speak() \u8fd4\u56de\u7684\u6570\u636e\u6210\u4e3a Animal \u57fa\u7c7b\u7684\u4e00\u90e8\u5206\uff08\u5c31\u50cf\u662f Animal \u7684 name \u662f\u901a\u8fc7 m_name \u8fd9\u4e2a\u6210\u5458\u6765\u8bbf\u95ee\u7684\uff09 \uff08\u9898\u76ee\u7ffb\u8bd1\u4e5f\u8bb8\u6709\u95ee\u9898\uff091) Our Animal/Cat/Dog example above doesn\u2019t work like we want because a reference or pointer to an Animal can\u2019t access the derived version of speak() needed to return the right value for the Cat or Dog. One way to work around this issue would be to make the data returned by the speak() function accessible as part of the Animal base class (much like the Animal\u2019s name is accessible via member m_name). Update the Animal, Cat, and Dog classes in the lesson above by adding a new member to Animal named m_speak. Initialize it appropriately. The following program should work properly: \u66f4\u65b0\u4e4b\u524d\u8bfe\u7a0b\u4e2d\u7f16\u5199\u7684 Animal, Cat, Dog \u4e09\u4e2a\u7c7b\uff0c\u901a\u8fc7\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u6210\u5458 m_speak \u5230 Animal \u57fa\u7c7b\u3002\u4ee5\u5408\u9002\u7684\u65b9\u5f0f\u521d\u59cb\u5316\u4ed6\u4eec\uff0c\u4e0b\u9762\u7684\u7a0b\u5e8f\u80fd\u591f\u5f88\u597d\u7684\u5de5\u4f5c\u3002 # include <array> # include <iostream> int main () { const Cat fred { \"Fred\" }; const Cat misty { \"Misty\" }; const Cat zeke { \"Zeke\" }; const Dog garbo { \"Garbo\" }; const Dog pooky { \"Pooky\" }; const Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects const auto animals { std :: to_array < const Animal *> ({ & fred , & garbo , & misty , & pooky , & truffle , & zeke }) }; // Before C++20, with the array size being explicitly specified // const std::array<const Animal*, 6> animals{ &fred, &garbo, &misty, &pooky, &truffle, &zeke }; for ( const auto animal : animals ) { std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; } return 0 ; } \u7b54\u6848\uff1a # include <array> # include <string> # include <string_view> # include <iostream> class Animal { protected : std :: string m_name {}; std :: string m_speak {}; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( std :: string_view name , std :: string_view speak ) : m_name { name }, m_speak { speak } { } // To prevent slicing (covered later) Animal ( const Animal & ) = delete ; Animal & operator = ( const Animal & ) = delete ; public : const std :: string & getName () const { return m_name ; } const std :: string & speak () const { return m_speak ; } }; class Cat : public Animal { public : Cat ( std :: string_view name ) : Animal { name , \"Meow\" } { } }; class Dog : public Animal { public : Dog ( std :: string_view name ) : Animal { name , \"Woof\" } { } }; int main () { const Cat fred { \"Fred\" }; const Cat misty { \"Misty\" }; const Cat zeke { \"Zeke\" }; const Dog garbo { \"Garbo\" }; const Dog pooky { \"Pooky\" }; const Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects const auto animals { std :: to_array < const Animal *> ({ & fred , & garbo , & misty , & pooky , & truffle , & zeke }) }; // Before C++20, with the array size being explicitly specified // const std::array<const Animal*, 6> animals{ &fred, &garbo, &misty, &pooky, &truffle, &zeke }; // animal is not a reference, because we're looping over pointers for ( const auto animal : animals ) { std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; } return 0 ; } 2\uff09\u4e3a\u4ec0\u4e48\u4e0a\u9762\u7684\u89e3\u51b3\u65b9\u6848\u4e0d\u662f\u6700\u4f18\u7684\uff1f \u63d0\u793a\uff1a\u60f3\u60f3\u732b\u548c\u72d7\u7684\u672a\u6765\u72b6\u6001\uff0c\u6211\u4eec\u60f3\u7528\u66f4\u591a\u7684\u65b9\u5f0f\u6765\u533a\u5206\u732b\u548c\u72d7 \u63d0\u793a\uff1a\u8003\u8651\u4e00\u4e0b\u5728\u521d\u59cb\u5316\u65f6\u9700\u8981\u8bbe\u7f6e\u7684\u6210\u5458\u5bf9\u60a8\u7684\u9650\u5236\u3002 \u5f53\u524d\u7684\u89e3\u51b3\u65b9\u6848\u5e76\u4e0d\u662f\u6700\u4f18\u7684\uff0c\u539f\u56e0\u662f\u6211\u4eec\u5fc5\u987b\u7ed9\u6bcf\u4e2a\u4e0d\u540c\u7684\u7c7b\u6dfb\u52a0\u4e00\u4e2a\u6210\u5458\u6765\u5206\u8fa8 Cat \u548c Dog \uff0c\u4e00\u6bb5\u65f6\u95f4\u4e4b\u540e\uff0c\u6211\u4eec\u7684 Animal \u7c7b\u53ef\u80fd\u53d8\u5f97\u975e\u5e38\u6d88\u8017\u5185\u5b58\u5e76\u4e14\u975e\u5e38\u590d\u6742\uff01 \u800c\u4e14\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u53ea\u80fd\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u51b3\u5b9a\u624d\u80fd\u6b63\u5e38\u5de5\u4f5c\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c speak() \u8fd4\u56de\u4e86\u4e00\u4e2a\u968f\u673a\u7684\u7ed3\u679c\uff0c\u4e3a\u6bcf\u4e2a Animal \u7c7b\uff08\u4f8b\u5982\u8c03\u7528 Dog::speak() \u53ef\u80fd\u8fd4\u56de woof \uff0c arf \uff0c\u6216\u8005 yip \uff09\uff0c\u8fd9\u7c7b\u7684\u89e3\u51b3\u65b9\u6848\u5f00\u59cb\u53d8\u5f97\u5c34\u5c2c\u3001\u5d29\u6e83\u3002","title":"\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u548c\u5f15\u7528\u7684\u4f7f\u7528\u65b9\u6cd5"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/","text":"18.2 \u2014 \u865a\u51fd\u6570\u548c\u591a\u6001 \u00b6 By Alex on January 30 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1 by dashjay Dec 20 th 2020 \u5728\u4e4b\u524d\u7684\u5173\u4e8e\u6307\u5411\u6d3e\u751f\u7c7b\u4e2d\u57fa\u7c7b\u90e8\u5206\u7684\u6307\u9488\u548c\u5f15\u7528\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u770b\u4e86\u5f88\u591a\u4f8b\u5b50\u4f7f\u7528\u6307\u9488\u6216\u8005\u5f15\u7528\u6307\u5411\u57fa\u7c7b\uff0c\u6709\u53ef\u80fd\u4f18\u5316\u4ee3\u7801\u3002\u7136\u800c\uff0c\u5728\u6bcf\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u9047\u5230\u7684\u95ee\u9898\u90fd\u662f\u57fa\u7c7b\u6307\u9488\u6216\u8005\u5f15\u7528\u53ea\u80fd\u8c03\u7528\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u3002 \u8fd9\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a #include <iostream> #include <string_view> class Base { public : std :: string_view getName () const { return \"Base\" ; } }; class Derived : public Base { public : std :: string_view getName () const { return \"Derived\" ; } }; int main () { Derived derived ; Base & rBase { derived }; std :: cout << \"rBase is a \" << rBase . getName () << '\\n' ; return 0 ; } \u4f8b\u5b50\u8f93\u51fa\uff1a rBase is a Base \u56e0\u4e3a rBase \u662f\u4e00\u4e2a Base \u7684\u5f15\u7528\uff0c\u5b83\u8c03\u7528\u4e86 Base::getName() \uff0c\u5373\u4fbf\u5b83\u5b9e\u9645\u4e0a\u5f15\u7528\u7684\u662f\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u57fa\u7c7b\u90e8\u5206\u3002 \u5728\u8fd9\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u5982\u4f55\u4f7f\u7528\u865a\u51fd\u6570\u53bb\u89e3\u51b3\u8fd9\u79cd\u95ee\u9898\u3002 \u865a\u51fd\u6570\u548c\u591a\u6001 \u00b6 \u4e00\u4e2a\u865a\u6c57\u662f\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u51fd\u6570\uff0c\u5f53\u88ab\u8c03\u7528\u65f6\uff0c\u89e3\u6790\u5230\u5b58\u5728\u4e8e\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e2d\u7684\u6700\u540e\u7684\u6d3e\u751f\u7248\u672c\u7684\u51fd\u6570\u3002\u8fd9\u4e2a\u80fd\u529b\u88ab\u53eb\u505a\u591a\u6001\u3002\u6211\u4eec\u8ba4\u4e3a\u4e00\u4e2a\u6d3e\u751f\u51fd\u6570\u5339\u914d\u540c\u6837\u7684\u7b7e\u540d\uff08\u540d\u5b57\uff0c\u53c2\u6570\u7c7b\u578b\uff0c\u662f\u5426\u4e3a const \u51fd\u6570\uff0c\u548c\u4ed6\u7684\u8fd4\u56de\u503c\u7c7b\u578b\u90fd\u8981\u548c\u57fa\u7c7b\u7248\u672c\u4e00\u6837\uff09\uff0c\u8fd9\u6837\u7684\u51fd\u6570\u88ab\u53eb\u505a\u91cd\u5199\u3002 \u4e3a\u4e86\u7f16\u5199\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u7b80\u5355\u7684\u5728\u51fd\u6570\u7533\u660e\u524d\u653e\u7f6e\u4e00\u4e2a virtual \u7684\u5173\u952e\u8bcd\u5373\u53ef\u3002 \u8fd9\u662f\u4e00\u4e2a\u865a\u51fd\u6570\u7684\u4f8b\u5b50\uff1a #include <iostream> #include <string_view> class Base { public : virtual std :: string_view getName () const { return \"Base\" ; } // note addition of virtual keyword }; class Derived : public Base { public : virtual std :: string_view getName () const { return \"Derived\" ; } }; int main () { Derived derived ; Base & rBase { derived }; std :: cout << \"rBase is a \" << rBase . getName () << '\\n' ; return 0 ; } \u8fd9\u4e2a\u4f8b\u5b50\u8f93\u51fa\uff1a rBase is a Derived \u56e0\u4e3a rBase \u662f\u4e00\u4e2a\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u57fa\u7c7b\u90e8\u5206\u7684\u5f15\u7528\uff0c\u5f53 rBase.getName() \u88ab\u8c03\u7528\u65f6\uff0c\u4ed6\u5c06\u4f1a\u89e3\u6790\u5230 Base::getName() \u3002\u7136\u800c\uff0c Base::getName() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u5c06\u4f1a\u544a\u8bc9\u7a0b\u5e8f\u53bb\u68c0\u67e5\u662f\u5426\u6709\u66f4\u5916\u5c42\u7684\u6d3e\u751f\u7248\u672c\u7684\u51fd\u6570\uff08\u5728\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e4b\u95f4\uff09\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u4f1a\u89e3\u6790\u5230 Derived::getName() \uff01 \u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u7a0d\u7a0d\u590d\u6742\u7684\u4f8b\u5b50\uff1a #include <iostream> #include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << \"rBase is a \" << rBase . getName () << '\\n' ; return 0 ; } \u4f60\u8ba4\u4e3a\u4ed6\u4f1a\u8f93\u51fa\u4ec0\u4e48\uff1f \u8ba9\u6211\u4eec\u6765\u770b\u770b\u5b83\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002\u9996\u5148\u6211\u4eec\u5b9e\u4f8b\u5316\u4e86\u4e00\u4e2aC\u7c7b\u5bf9\u8c61\uff0crBase\u662f\u4e00\u4e2a A \u7c7b\u7684\u5f15\u7528\uff0c\u6211\u4eec\u5c06\u5f15\u7528\u6307\u5411 C \u5bf9\u8c61\u7684\u4e2d\u7684 A \u57fa\u7c7b\u90e8\u5206\u3002\u6700\u540e\uff0c\u6211\u4eec\u8c03\u7528 rBase.getName() \u3002 rBase.getName() \u53d6\u503c\u5230 A::getName() \u3002\u7136\u800c A::getName() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u56e0\u6b64\u7f16\u8bd1\u5668\u5c06\u8c03\u7528\u6700\u5916\u5c42\u7684\u6d3e\u751f\u7248\u672c\uff08\u4ecb\u4e8e A \u548c C \u4e4b\u95f4\uff09\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5c31\u662f\u4f1a\u8c03\u7528 C::getName() \u3002\u6ce8\u610f\uff0c\u5b83\u4e0d\u4f1a\u53bb\u8c03\u7528 D::getName() \u56e0\u4e3a\u6211\u4eec\u539f\u59cb\u5bf9\u8c61\u662f\u4e00\u4e2a C \u7c7b\u5bf9\u8c61\uff0c\u800c\u4e0d\u662f D\uff0c\u56e0\u6b64\u53ea\u6709 A \u548c C \u4e4b\u95f4\u7684\u51fd\u6570\u4f1a\u88ab\u8003\u8651\u3002 \u7ed3\u679c\u5c31\u662f\uff0c\u6211\u4eec\u7684\u7a0b\u5e8f\u8f93\u51fa\uff1a rBase is a C \u4e00\u4e2a\u66f4\u52a0\u590d\u6742\u7684\u4f8b\u5b50 \u00b6 \u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u4e4b\u524d\u8bfe\u4e0a\u63d0\u5230\u7684 Animal \u7684\u4f8b\u5b50\u3002\u8fd9\u91cc\u662f\u4e4b\u524d\u7684\u4ee3\u7801\uff1a # include <iostream> # include <string> # include <string_view> class Animal { protected : std :: string m_name ; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( const std :: string & name ) : m_name { name } { } public : const std :: string & getName () const { return m_name ; } std :: string_view speak () const { return \"???\" ; } }; class Cat : public Animal { public : Cat ( const std :: string & name ) : Animal { name } { } std :: string_view speak () const { return \"Meow\" ; } }; class Dog : public Animal { public : Dog ( const std :: string & name ) : Animal { name } { } std :: string_view speak () const { return \"Woof\" ; } }; void report ( const Animal & animal ) { std :: cout << animal . getName () << \" says \" << animal . speak () << '\\n' ; } int main () { Cat cat { \"Fred\" }; Dog dog { \"Garbo\" }; report ( cat ); report ( dog ); return 0 ; } \u7a0b\u5e8f\u8f93\u51fa\uff1a Fred says ??? Garbo says ??? \u4e0b\u9762\u662f\u7b49\u6548\u7684\u4ee3\u7801\uff0c\u5176\u4e2d\u4e0d\u540c\u7684\u5c06 speak() \u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff1a # include <iostream> # include <string> # include <string_view> class Animal { protected : std :: string m_name ; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( const std :: string & name ) : m_name { name } { } public : const std :: string & getName () const { return m_name ; } virtual std :: string_view speak () const { return \"???\" ; } }; class Cat : public Animal { public : Cat ( const std :: string & name ) : Animal { name } { } virtual std :: string_view speak () const { return \"Meow\" ; } }; class Dog : public Animal { public : Dog ( const std :: string & name ) : Animal { name } { } virtual std :: string_view speak () const { return \"Woof\" ; } }; void report ( const Animal & animal ) { std :: cout << animal . getName () << \" says \" << animal . speak () << '\\n' ; } int main () { Cat cat { \"Fred\" }; Dog dog { \"Garbo\" }; report ( cat ); report ( dog ); return 0 ; } \u7a0b\u5e8f\u6253\u5370\u7ed3\u679c\uff1a Fred says Meow Garbo says Woof \u6210\u529f\u4e86\uff01 \u5f53 animal.speak() \u88ab\u53d6\u503c(evaluated)\u7684\u65f6\u5019\uff0c\u7a0b\u5e8f Animal:speak() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c animal \u5f15\u7528\u4e86 Cat \u7c7b\u5bf9\u8c61\u7684 Animal \u90e8\u5206\uff0c\u7a0b\u5e8f\u5c31\u4f1a\u5bfb\u627e\u6240\u6709\u5728 Animal \u548c Cat \u4e4b\u95f4\u7684\u7c7b\uff0c\u6765\u68c0\u67e5\u6709\u6ca1\u6709\u9760\u540e(more-derived)\u7684\u6d3e\u751f\u51fd\u6570\u7248\u672c\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5b83\u627e\u5230\u4e86 Cat::speak() \u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c animal \u53c8\u5f15\u7528\u4e86 Dog \u7c7b\u5bf9\u8c61\u4e2d\u7684 Animal \u90e8\u5206\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u89e3\u6790\u5230\u4e86 Dog::speak() \u5e76\u8c03\u7528\u3002 \u6ce8\u610f\u5230\u6211\u4eec\u6ca1\u6709\u8ba9 Animal::getName() \u6210\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u8fd9\u662f\u56e0\u4e3a getName() \u4e0d\u4f1a\u5728\u4efb\u4f55\u6d3e\u751f\u7c7b\u4e2d\u88ab\u91cd\u5199\uff0c\u6ca1\u6709\u90a3\u6837\u505a\u7684\u5fc5\u8981 \u76f8\u4f3c\u7684\u662f\uff0c\u4e0b\u9762\u7684\u6570\u7ec4\u4f8b\u5b50\u4e5f\u6309\u7167\u671f\u671b\u5de5\u4f5c\u4e86\uff1a Cat fred { \"Fred\" }; Cat misty { \"Misty\" }; Cat zeke { \"Zeke\" }; Dog garbo { \"Garbo\" }; Dog pooky { \"Pooky\" }; Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects Animal * animals []{ & fred , & garbo , & misty , & pooky , & truffle , & zeke }; for ( const auto * animal : animals ) std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; \u4ea7\u751f\u7ed3\u679c\uff1a Fred says Meow Garbo says Woof Misty says Meow Pooky says Woof Truffle says Woof Zeke says Meow \u5373\u4fbf\u8fd9\u4e24\u4e2a\u4f8b\u5b50\u4ec5\u4ec5\u4f7f\u7528\u4e86 Cat \u548c Dog \uff0c\u4f46\u662f\u5176\u4ed6\u7684\u6d3e\u751f\u81ea Animal \u7684\u7c7b\u4e5f\u4f1a\u5728 report() \u51fd\u6570\u8d77\u4f5c\u7528\uff0c\u751a\u81f3\u662f animal \u6570\u7ec4\u4e5f\u53ef\u4ee5\uff01\u8fd9\u4e5f\u8bb8\u5c31\u662f\u865a\u51fd\u6570\u6700\u5927\u7684\u597d\u5904\u4e86\u5427 \u2014\u2014 \u6709\u80fd\u529b\u4f7f\u65b0\u6d3e\u751f\u7684\u7c7b\u80fd\u591f\u5728\u4e0d\u8fdb\u884c\u4fee\u6539\u7684\u60c5\u51b5\u4e0b\u81ea\u52a8\u4f7f\u7528\u65e7\u4ee3\u7801\u6765\u6784\u9020\u4ee3\u7801\uff01 \u63d0\u9192\u4e00\u53e5\uff1a\u4e3a\u4e86\u4f7f\u6d3e\u751f\u7c7b\u7684\u51fd\u6570\u88ab\u8c03\u7528\uff0c\u6d3e\u751f\u7c7b\u7684\u7b7e\u540d\u5fc5\u987b\u6b63\u597d\u548c\u57fa\u7c7b\u7684\u4e00\u6837\u3002\u5982\u679c\u6d3e\u751f\u7c7b\u7684\u51fd\u6570\u6709\u4e0d\u540c\u7684\u53c2\u6570\u7c7b\u578b\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u4e5f\u4f1a\u88ab\u8c03\u7528\uff0c\u4f46\u662f\u865a\u51fd\u6570\u5b9e\u9645\u4e0a\u4e0d\u4f1a\u6309\u7167\u671f\u671b\u88ab\u8c03\u7528\u3002 virtual \u5173\u952e\u8bcd\u7684\u4f7f\u7528 \u00b6 \u5982\u679c\u4e00\u4e2a\u51fd\u6570\u88ab\u6807\u8bb0\u4e3a\u865a\u51fd\u6570\uff0c\u90a3\u4e48\u6240\u6709\u91cd\u5199\u7684\u51fd\u6570\u4e5f\u4f1a\u88ab\u8ba4\u4e3a\u662f\u865a\u51fd\u6570\uff0c\u5373\u4fbf\u6ca1\u6709\u50cf\u90a3\u6837\u663e\u5f0f\u7684\u7533\u660e\u3002\u7136\u800c\uff0c\u6d3e\u751f\u7c7b\u6709\u4e00\u4e2a virtual \u7684\u5173\u952e\u8bcd\u4e5f\u65e0\u4f24\u5927\u96c5\uff0c\u5e76\u4e14\u4e5f\u4f5c\u4e3a\u4e00\u4e2a\u51fd\u6570\u662f\u865a\u51fd\u6570\u800c\u4e0d\u662f\u666e\u901a\u51fd\u6570\u7684\u63d0\u793a\u3002\u56e0\u6b64\uff0c\u5bf9\u6d3e\u751f\u7c7b\u4e2d\u7684\u865a\u51fd\u6570\u4f7f\u7528 virtual \u5173\u952e\u8bcd\u4e5f\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u4e60\u60ef\uff0c\u5c3d\u7ba1\u8fd9\u4e0d\u662f\u4e25\u683c\u5fc5\u987b\u7684\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\u7684\u8fd4\u56de\u7c7b\u578b \u00b6 \u5728\u5e38\u89c4\u7684\u60c5\u51b5\u4e0b\uff0c\u91cd\u5199\u865a\u51fd\u6570\u7684\u8fd4\u56de\u503c\u5fc5\u987b\u548c\u865a\u51fd\u6570\u4fdd\u6301\u4e00\u81f4\uff0c\u770b\u5982\u4e0b\u4f8b\u5b50\uff1a class Base { public : virtual int getValue () const { return 5 ; } }; class Derived : public Base { public : virtual double getValue () const { return 6.78 ; } }; \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c Derived::getValue() \u4e0d\u4f1a\u88ab\u5f53\u505a Base::getValue() \u7684\u91cd\u5199\uff08\u5b83\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u4e0d\u540c\u7684\u51fd\u6570\uff09\u3002 \u4e0d\u8981\u5728\u6784\u9020\u51fd\u6570\u548c\u89e3\u6784\u51fd\u6570\u4e2d\u8c03\u7528\u865a\u51fd\u6570 \u00b6 \u8fd9\u6709\u4e00\u4e2a\u5176\u4ed6\u7684\u95ee\u9898\u7ecf\u5e38\u4e3a\u65b0\u624b\u7a0b\u5e8f\u5458\u4ee3\u7801\u4e0d\u53ef\u9884\u6599\u7684\u95ee\u9898\u3002\u4f60\u4e0d\u5e94\u8be5\u4ece\u6784\u9020\u51fd\u6570\u548c\u89e3\u6784\u51fd\u6570\u4e2d\u8c03\u7528\u865a\u51fd\u6570\u3002\u4e3a\u4ec0\u4e48\uff1f \u8bb0\u4f4f\u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u88ab\u6784\u9020\u65f6\uff0c\u57fa\u7c7b\u90e8\u5206\u5148\u88ab\u6784\u9020\uff0c\u5982\u679c\u4f60\u5728\u57fa\u7c7b\u7684\u6784\u9020\u51fd\u6570\u8c03\u7528\u865a\u51fd\u6570\uff0c\u5e76\u4e14\u6d3e\u751f\u7c7b\u90e8\u5206\u81f3\u4eca\u5e76\u6ca1\u6709\u88ab\u521b\u9020\u51fa\u6765\uff0c\u5c31\u4e0d\u80fd\u8c03\u7528\u5230\u6d3e\u751f\u7248\u672c\u7684\u51fd\u6570\uff0c\u56e0\u4e3a\u6ca1\u6709\u6d3e\u751f\u5bf9\u8c61\u80fd\u591f\u652f\u6301\u6d3e\u751f\u7c7b\u51fd\u6570\u7684\u8c03\u7528\uff0c\u5728 C++ \u4e2d\uff0c\u5b83\u4f1a\u5148\u8c03\u7528\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u3002 \u5728\u89e3\u6784\u51fd\u6570\u4e2d\u6709\u4e00\u4e2a\u7c7b\u4f3c\u7684\u95ee\u9898\u3002\u5982\u679c\u4f60\u8c03\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u5728\u57fa\u7c7b\u7684\u7ed3\u6784\u51fd\u6570\u4e2d\uff0c\u4ed6\u5c06\u603b\u662f\u89e3\u6790\u5230\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u4e2d\uff0c\u56e0\u4e3a\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u51fd\u6570\u65e9\u5c31\u88ab\u9500\u6bc1\u4e86\u3002 \u89c4\u5b9a\uff1a\u7edd\u5bf9\u4e0d\u4ece\u6784\u9020\u51fd\u6570\u548c\u89e3\u6784\u51fd\u6570\u4e2d\u8c03\u7528\u865a\u51fd\u6570\u3002 \u865a\u51fd\u6570\u7684\u7f3a\u70b9 \u00b6 \u5927\u591a\u6570\u7684\u65f6\u5019\uff0c\u4f60\u5e0c\u671b\u4f60\u7684\u51fd\u6570\u6210\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8ba9\u6240\u6709\u51fd\u6570\u90fd\u662f\u865a\u51fd\u6570\u5462\uff1f\u7b54\u6848\u5c31\u662f\u56e0\u4e3a\u5b83\u4e0d\u9ad8\u6548\u2014\u2014\u89e3\u6790\u4e00\u4e2a\u865a\u51fd\u6570\u7684\u8c03\u7528\u4f1a\u6d88\u8017\u66f4\u957f\u7684\u65f6\u95f4\uff0c\u76f8\u6bd4\u89e3\u6790\u666e\u901a\u7684\u51fd\u6570\u3002\u800c\u4e14\uff0c\u7f16\u8bd1\u5668\u9700\u8981\u4e3a\u6709\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u865a\u51fd\u6570\u7684\u7c7b\u7684\u5bf9\u8c61\u5206\u914d\u989d\u5916\u7684\u6307\u9488\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\u8ba8\u8bba\u8fd9\u4e2a\u95ee\u9898\u3002 Quiz time 1) What do the following programs print? This exercise is meant to be done by inspection, not by compiling the examples with your compiler. 1a) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : // Note: no getName() function here }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << rBase . getName () << '\\n' ; return 0 ; } B. rBase is an A reference pointing to a C object. Normally rBase.getName() would call A::getName(), but A::getName() is virtual so it instead calls the most derived matching function between A and C. That is B::getName(), which prints B. 1b) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; B & rBase { c }; // note: rBase is a B this time std :: cout << rBase . getName () << '\\n' ; return 0 ; } C. This is pretty straightforward, as C::getName() is the most derived matching call between classes B and C. 1c) # include <iostream> # include <string_view> class A { public : // note: no virtual keyword std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << rBase . getName () << '\\n' ; return 0 ; } A. Since A is not virtual, when rBase.getName() is called, A::getName() is called. 1d) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : // note: no virtual keyword in B, C, and D std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; B & rBase { c }; // note: rBase is a B this time std :: cout << rBase . getName () << '\\n' ; return 0 ; } C. Even though B and C aren\u2019t marked as virtual functions, A::getName() is virtual and B::getName() and C::getName() are overrides. Therefore, B::getName() and C::getName() are considered implicitly virtual, and thus the call to rBase.getName() resolves to C::getName(), not B::getName(). 1e) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : // Note: Functions in B, C, and D are non-const. virtual std :: string_view getName () { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << rBase . getName () << '\\n' ; return 0 ; } A. This one is a little trickier. rBase is an A reference to a C object, so rBase.getName() would normally call A::getName(). But A::getName() is virtual, so it calls the most derived version of the function between A and C. And that is A::getName(). Because B::getName() and c::getName() are not const, they are not considered overrides! Consequently, this program prints A. 1f) # include <iostream> # include <string_view> class A { public : A () { std :: cout << getName (); } // note addition of constructor virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; return 0 ; } A. Another tricky one. When we create a C object, the A part is constructed first. When the A constructor is called to do this, it calls virtual function getName(). Because the B and C parts of the class aren\u2019t set up yet, this resolves to A::getName().","title":"18.2 \u2014 \u865a\u51fd\u6570\u548c\u591a\u6001"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/#182","text":"By Alex on January 30 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1 by dashjay Dec 20 th 2020 \u5728\u4e4b\u524d\u7684\u5173\u4e8e\u6307\u5411\u6d3e\u751f\u7c7b\u4e2d\u57fa\u7c7b\u90e8\u5206\u7684\u6307\u9488\u548c\u5f15\u7528\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u770b\u4e86\u5f88\u591a\u4f8b\u5b50\u4f7f\u7528\u6307\u9488\u6216\u8005\u5f15\u7528\u6307\u5411\u57fa\u7c7b\uff0c\u6709\u53ef\u80fd\u4f18\u5316\u4ee3\u7801\u3002\u7136\u800c\uff0c\u5728\u6bcf\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u9047\u5230\u7684\u95ee\u9898\u90fd\u662f\u57fa\u7c7b\u6307\u9488\u6216\u8005\u5f15\u7528\u53ea\u80fd\u8c03\u7528\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u3002 \u8fd9\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a #include <iostream> #include <string_view> class Base { public : std :: string_view getName () const { return \"Base\" ; } }; class Derived : public Base { public : std :: string_view getName () const { return \"Derived\" ; } }; int main () { Derived derived ; Base & rBase { derived }; std :: cout << \"rBase is a \" << rBase . getName () << '\\n' ; return 0 ; } \u4f8b\u5b50\u8f93\u51fa\uff1a rBase is a Base \u56e0\u4e3a rBase \u662f\u4e00\u4e2a Base \u7684\u5f15\u7528\uff0c\u5b83\u8c03\u7528\u4e86 Base::getName() \uff0c\u5373\u4fbf\u5b83\u5b9e\u9645\u4e0a\u5f15\u7528\u7684\u662f\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u57fa\u7c7b\u90e8\u5206\u3002 \u5728\u8fd9\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u5982\u4f55\u4f7f\u7528\u865a\u51fd\u6570\u53bb\u89e3\u51b3\u8fd9\u79cd\u95ee\u9898\u3002","title":"18.2 \u2014 \u865a\u51fd\u6570\u548c\u591a\u6001"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/#_1","text":"\u4e00\u4e2a\u865a\u6c57\u662f\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u51fd\u6570\uff0c\u5f53\u88ab\u8c03\u7528\u65f6\uff0c\u89e3\u6790\u5230\u5b58\u5728\u4e8e\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e2d\u7684\u6700\u540e\u7684\u6d3e\u751f\u7248\u672c\u7684\u51fd\u6570\u3002\u8fd9\u4e2a\u80fd\u529b\u88ab\u53eb\u505a\u591a\u6001\u3002\u6211\u4eec\u8ba4\u4e3a\u4e00\u4e2a\u6d3e\u751f\u51fd\u6570\u5339\u914d\u540c\u6837\u7684\u7b7e\u540d\uff08\u540d\u5b57\uff0c\u53c2\u6570\u7c7b\u578b\uff0c\u662f\u5426\u4e3a const \u51fd\u6570\uff0c\u548c\u4ed6\u7684\u8fd4\u56de\u503c\u7c7b\u578b\u90fd\u8981\u548c\u57fa\u7c7b\u7248\u672c\u4e00\u6837\uff09\uff0c\u8fd9\u6837\u7684\u51fd\u6570\u88ab\u53eb\u505a\u91cd\u5199\u3002 \u4e3a\u4e86\u7f16\u5199\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u7b80\u5355\u7684\u5728\u51fd\u6570\u7533\u660e\u524d\u653e\u7f6e\u4e00\u4e2a virtual \u7684\u5173\u952e\u8bcd\u5373\u53ef\u3002 \u8fd9\u662f\u4e00\u4e2a\u865a\u51fd\u6570\u7684\u4f8b\u5b50\uff1a #include <iostream> #include <string_view> class Base { public : virtual std :: string_view getName () const { return \"Base\" ; } // note addition of virtual keyword }; class Derived : public Base { public : virtual std :: string_view getName () const { return \"Derived\" ; } }; int main () { Derived derived ; Base & rBase { derived }; std :: cout << \"rBase is a \" << rBase . getName () << '\\n' ; return 0 ; } \u8fd9\u4e2a\u4f8b\u5b50\u8f93\u51fa\uff1a rBase is a Derived \u56e0\u4e3a rBase \u662f\u4e00\u4e2a\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u57fa\u7c7b\u90e8\u5206\u7684\u5f15\u7528\uff0c\u5f53 rBase.getName() \u88ab\u8c03\u7528\u65f6\uff0c\u4ed6\u5c06\u4f1a\u89e3\u6790\u5230 Base::getName() \u3002\u7136\u800c\uff0c Base::getName() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u5c06\u4f1a\u544a\u8bc9\u7a0b\u5e8f\u53bb\u68c0\u67e5\u662f\u5426\u6709\u66f4\u5916\u5c42\u7684\u6d3e\u751f\u7248\u672c\u7684\u51fd\u6570\uff08\u5728\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e4b\u95f4\uff09\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u4f1a\u89e3\u6790\u5230 Derived::getName() \uff01 \u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u7a0d\u7a0d\u590d\u6742\u7684\u4f8b\u5b50\uff1a #include <iostream> #include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << \"rBase is a \" << rBase . getName () << '\\n' ; return 0 ; } \u4f60\u8ba4\u4e3a\u4ed6\u4f1a\u8f93\u51fa\u4ec0\u4e48\uff1f \u8ba9\u6211\u4eec\u6765\u770b\u770b\u5b83\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002\u9996\u5148\u6211\u4eec\u5b9e\u4f8b\u5316\u4e86\u4e00\u4e2aC\u7c7b\u5bf9\u8c61\uff0crBase\u662f\u4e00\u4e2a A \u7c7b\u7684\u5f15\u7528\uff0c\u6211\u4eec\u5c06\u5f15\u7528\u6307\u5411 C \u5bf9\u8c61\u7684\u4e2d\u7684 A \u57fa\u7c7b\u90e8\u5206\u3002\u6700\u540e\uff0c\u6211\u4eec\u8c03\u7528 rBase.getName() \u3002 rBase.getName() \u53d6\u503c\u5230 A::getName() \u3002\u7136\u800c A::getName() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u56e0\u6b64\u7f16\u8bd1\u5668\u5c06\u8c03\u7528\u6700\u5916\u5c42\u7684\u6d3e\u751f\u7248\u672c\uff08\u4ecb\u4e8e A \u548c C \u4e4b\u95f4\uff09\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5c31\u662f\u4f1a\u8c03\u7528 C::getName() \u3002\u6ce8\u610f\uff0c\u5b83\u4e0d\u4f1a\u53bb\u8c03\u7528 D::getName() \u56e0\u4e3a\u6211\u4eec\u539f\u59cb\u5bf9\u8c61\u662f\u4e00\u4e2a C \u7c7b\u5bf9\u8c61\uff0c\u800c\u4e0d\u662f D\uff0c\u56e0\u6b64\u53ea\u6709 A \u548c C \u4e4b\u95f4\u7684\u51fd\u6570\u4f1a\u88ab\u8003\u8651\u3002 \u7ed3\u679c\u5c31\u662f\uff0c\u6211\u4eec\u7684\u7a0b\u5e8f\u8f93\u51fa\uff1a rBase is a C","title":"\u865a\u51fd\u6570\u548c\u591a\u6001"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/#_2","text":"\u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u4e4b\u524d\u8bfe\u4e0a\u63d0\u5230\u7684 Animal \u7684\u4f8b\u5b50\u3002\u8fd9\u91cc\u662f\u4e4b\u524d\u7684\u4ee3\u7801\uff1a # include <iostream> # include <string> # include <string_view> class Animal { protected : std :: string m_name ; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( const std :: string & name ) : m_name { name } { } public : const std :: string & getName () const { return m_name ; } std :: string_view speak () const { return \"???\" ; } }; class Cat : public Animal { public : Cat ( const std :: string & name ) : Animal { name } { } std :: string_view speak () const { return \"Meow\" ; } }; class Dog : public Animal { public : Dog ( const std :: string & name ) : Animal { name } { } std :: string_view speak () const { return \"Woof\" ; } }; void report ( const Animal & animal ) { std :: cout << animal . getName () << \" says \" << animal . speak () << '\\n' ; } int main () { Cat cat { \"Fred\" }; Dog dog { \"Garbo\" }; report ( cat ); report ( dog ); return 0 ; } \u7a0b\u5e8f\u8f93\u51fa\uff1a Fred says ??? Garbo says ??? \u4e0b\u9762\u662f\u7b49\u6548\u7684\u4ee3\u7801\uff0c\u5176\u4e2d\u4e0d\u540c\u7684\u5c06 speak() \u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff1a # include <iostream> # include <string> # include <string_view> class Animal { protected : std :: string m_name ; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal ( const std :: string & name ) : m_name { name } { } public : const std :: string & getName () const { return m_name ; } virtual std :: string_view speak () const { return \"???\" ; } }; class Cat : public Animal { public : Cat ( const std :: string & name ) : Animal { name } { } virtual std :: string_view speak () const { return \"Meow\" ; } }; class Dog : public Animal { public : Dog ( const std :: string & name ) : Animal { name } { } virtual std :: string_view speak () const { return \"Woof\" ; } }; void report ( const Animal & animal ) { std :: cout << animal . getName () << \" says \" << animal . speak () << '\\n' ; } int main () { Cat cat { \"Fred\" }; Dog dog { \"Garbo\" }; report ( cat ); report ( dog ); return 0 ; } \u7a0b\u5e8f\u6253\u5370\u7ed3\u679c\uff1a Fred says Meow Garbo says Woof \u6210\u529f\u4e86\uff01 \u5f53 animal.speak() \u88ab\u53d6\u503c(evaluated)\u7684\u65f6\u5019\uff0c\u7a0b\u5e8f Animal:speak() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c animal \u5f15\u7528\u4e86 Cat \u7c7b\u5bf9\u8c61\u7684 Animal \u90e8\u5206\uff0c\u7a0b\u5e8f\u5c31\u4f1a\u5bfb\u627e\u6240\u6709\u5728 Animal \u548c Cat \u4e4b\u95f4\u7684\u7c7b\uff0c\u6765\u68c0\u67e5\u6709\u6ca1\u6709\u9760\u540e(more-derived)\u7684\u6d3e\u751f\u51fd\u6570\u7248\u672c\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5b83\u627e\u5230\u4e86 Cat::speak() \u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c animal \u53c8\u5f15\u7528\u4e86 Dog \u7c7b\u5bf9\u8c61\u4e2d\u7684 Animal \u90e8\u5206\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u89e3\u6790\u5230\u4e86 Dog::speak() \u5e76\u8c03\u7528\u3002 \u6ce8\u610f\u5230\u6211\u4eec\u6ca1\u6709\u8ba9 Animal::getName() \u6210\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u8fd9\u662f\u56e0\u4e3a getName() \u4e0d\u4f1a\u5728\u4efb\u4f55\u6d3e\u751f\u7c7b\u4e2d\u88ab\u91cd\u5199\uff0c\u6ca1\u6709\u90a3\u6837\u505a\u7684\u5fc5\u8981 \u76f8\u4f3c\u7684\u662f\uff0c\u4e0b\u9762\u7684\u6570\u7ec4\u4f8b\u5b50\u4e5f\u6309\u7167\u671f\u671b\u5de5\u4f5c\u4e86\uff1a Cat fred { \"Fred\" }; Cat misty { \"Misty\" }; Cat zeke { \"Zeke\" }; Dog garbo { \"Garbo\" }; Dog pooky { \"Pooky\" }; Dog truffle { \"Truffle\" }; // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects Animal * animals []{ & fred , & garbo , & misty , & pooky , & truffle , & zeke }; for ( const auto * animal : animals ) std :: cout << animal -> getName () << \" says \" << animal -> speak () << '\\n' ; \u4ea7\u751f\u7ed3\u679c\uff1a Fred says Meow Garbo says Woof Misty says Meow Pooky says Woof Truffle says Woof Zeke says Meow \u5373\u4fbf\u8fd9\u4e24\u4e2a\u4f8b\u5b50\u4ec5\u4ec5\u4f7f\u7528\u4e86 Cat \u548c Dog \uff0c\u4f46\u662f\u5176\u4ed6\u7684\u6d3e\u751f\u81ea Animal \u7684\u7c7b\u4e5f\u4f1a\u5728 report() \u51fd\u6570\u8d77\u4f5c\u7528\uff0c\u751a\u81f3\u662f animal \u6570\u7ec4\u4e5f\u53ef\u4ee5\uff01\u8fd9\u4e5f\u8bb8\u5c31\u662f\u865a\u51fd\u6570\u6700\u5927\u7684\u597d\u5904\u4e86\u5427 \u2014\u2014 \u6709\u80fd\u529b\u4f7f\u65b0\u6d3e\u751f\u7684\u7c7b\u80fd\u591f\u5728\u4e0d\u8fdb\u884c\u4fee\u6539\u7684\u60c5\u51b5\u4e0b\u81ea\u52a8\u4f7f\u7528\u65e7\u4ee3\u7801\u6765\u6784\u9020\u4ee3\u7801\uff01 \u63d0\u9192\u4e00\u53e5\uff1a\u4e3a\u4e86\u4f7f\u6d3e\u751f\u7c7b\u7684\u51fd\u6570\u88ab\u8c03\u7528\uff0c\u6d3e\u751f\u7c7b\u7684\u7b7e\u540d\u5fc5\u987b\u6b63\u597d\u548c\u57fa\u7c7b\u7684\u4e00\u6837\u3002\u5982\u679c\u6d3e\u751f\u7c7b\u7684\u51fd\u6570\u6709\u4e0d\u540c\u7684\u53c2\u6570\u7c7b\u578b\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u4e5f\u4f1a\u88ab\u8c03\u7528\uff0c\u4f46\u662f\u865a\u51fd\u6570\u5b9e\u9645\u4e0a\u4e0d\u4f1a\u6309\u7167\u671f\u671b\u88ab\u8c03\u7528\u3002","title":"\u4e00\u4e2a\u66f4\u52a0\u590d\u6742\u7684\u4f8b\u5b50"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/#virtual","text":"\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u88ab\u6807\u8bb0\u4e3a\u865a\u51fd\u6570\uff0c\u90a3\u4e48\u6240\u6709\u91cd\u5199\u7684\u51fd\u6570\u4e5f\u4f1a\u88ab\u8ba4\u4e3a\u662f\u865a\u51fd\u6570\uff0c\u5373\u4fbf\u6ca1\u6709\u50cf\u90a3\u6837\u663e\u5f0f\u7684\u7533\u660e\u3002\u7136\u800c\uff0c\u6d3e\u751f\u7c7b\u6709\u4e00\u4e2a virtual \u7684\u5173\u952e\u8bcd\u4e5f\u65e0\u4f24\u5927\u96c5\uff0c\u5e76\u4e14\u4e5f\u4f5c\u4e3a\u4e00\u4e2a\u51fd\u6570\u662f\u865a\u51fd\u6570\u800c\u4e0d\u662f\u666e\u901a\u51fd\u6570\u7684\u63d0\u793a\u3002\u56e0\u6b64\uff0c\u5bf9\u6d3e\u751f\u7c7b\u4e2d\u7684\u865a\u51fd\u6570\u4f7f\u7528 virtual \u5173\u952e\u8bcd\u4e5f\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u4e60\u60ef\uff0c\u5c3d\u7ba1\u8fd9\u4e0d\u662f\u4e25\u683c\u5fc5\u987b\u7684\u3002","title":"virtual \u5173\u952e\u8bcd\u7684\u4f7f\u7528"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/#_3","text":"\u5728\u5e38\u89c4\u7684\u60c5\u51b5\u4e0b\uff0c\u91cd\u5199\u865a\u51fd\u6570\u7684\u8fd4\u56de\u503c\u5fc5\u987b\u548c\u865a\u51fd\u6570\u4fdd\u6301\u4e00\u81f4\uff0c\u770b\u5982\u4e0b\u4f8b\u5b50\uff1a class Base { public : virtual int getValue () const { return 5 ; } }; class Derived : public Base { public : virtual double getValue () const { return 6.78 ; } }; \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c Derived::getValue() \u4e0d\u4f1a\u88ab\u5f53\u505a Base::getValue() \u7684\u91cd\u5199\uff08\u5b83\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u4e0d\u540c\u7684\u51fd\u6570\uff09\u3002","title":"\u4e00\u4e2a\u865a\u51fd\u6570\u7684\u8fd4\u56de\u7c7b\u578b"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/#_4","text":"\u8fd9\u6709\u4e00\u4e2a\u5176\u4ed6\u7684\u95ee\u9898\u7ecf\u5e38\u4e3a\u65b0\u624b\u7a0b\u5e8f\u5458\u4ee3\u7801\u4e0d\u53ef\u9884\u6599\u7684\u95ee\u9898\u3002\u4f60\u4e0d\u5e94\u8be5\u4ece\u6784\u9020\u51fd\u6570\u548c\u89e3\u6784\u51fd\u6570\u4e2d\u8c03\u7528\u865a\u51fd\u6570\u3002\u4e3a\u4ec0\u4e48\uff1f \u8bb0\u4f4f\u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u88ab\u6784\u9020\u65f6\uff0c\u57fa\u7c7b\u90e8\u5206\u5148\u88ab\u6784\u9020\uff0c\u5982\u679c\u4f60\u5728\u57fa\u7c7b\u7684\u6784\u9020\u51fd\u6570\u8c03\u7528\u865a\u51fd\u6570\uff0c\u5e76\u4e14\u6d3e\u751f\u7c7b\u90e8\u5206\u81f3\u4eca\u5e76\u6ca1\u6709\u88ab\u521b\u9020\u51fa\u6765\uff0c\u5c31\u4e0d\u80fd\u8c03\u7528\u5230\u6d3e\u751f\u7248\u672c\u7684\u51fd\u6570\uff0c\u56e0\u4e3a\u6ca1\u6709\u6d3e\u751f\u5bf9\u8c61\u80fd\u591f\u652f\u6301\u6d3e\u751f\u7c7b\u51fd\u6570\u7684\u8c03\u7528\uff0c\u5728 C++ \u4e2d\uff0c\u5b83\u4f1a\u5148\u8c03\u7528\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u3002 \u5728\u89e3\u6784\u51fd\u6570\u4e2d\u6709\u4e00\u4e2a\u7c7b\u4f3c\u7684\u95ee\u9898\u3002\u5982\u679c\u4f60\u8c03\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u5728\u57fa\u7c7b\u7684\u7ed3\u6784\u51fd\u6570\u4e2d\uff0c\u4ed6\u5c06\u603b\u662f\u89e3\u6790\u5230\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u4e2d\uff0c\u56e0\u4e3a\u6d3e\u751f\u7c7b\u7248\u672c\u7684\u51fd\u6570\u65e9\u5c31\u88ab\u9500\u6bc1\u4e86\u3002 \u89c4\u5b9a\uff1a\u7edd\u5bf9\u4e0d\u4ece\u6784\u9020\u51fd\u6570\u548c\u89e3\u6784\u51fd\u6570\u4e2d\u8c03\u7528\u865a\u51fd\u6570\u3002","title":"\u4e0d\u8981\u5728\u6784\u9020\u51fd\u6570\u548c\u89e3\u6784\u51fd\u6570\u4e2d\u8c03\u7528\u865a\u51fd\u6570"},{"location":"18-virtual-functions/18.2-virtual-functions-and-polymorphism/#_5","text":"\u5927\u591a\u6570\u7684\u65f6\u5019\uff0c\u4f60\u5e0c\u671b\u4f60\u7684\u51fd\u6570\u6210\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u8ba9\u6240\u6709\u51fd\u6570\u90fd\u662f\u865a\u51fd\u6570\u5462\uff1f\u7b54\u6848\u5c31\u662f\u56e0\u4e3a\u5b83\u4e0d\u9ad8\u6548\u2014\u2014\u89e3\u6790\u4e00\u4e2a\u865a\u51fd\u6570\u7684\u8c03\u7528\u4f1a\u6d88\u8017\u66f4\u957f\u7684\u65f6\u95f4\uff0c\u76f8\u6bd4\u89e3\u6790\u666e\u901a\u7684\u51fd\u6570\u3002\u800c\u4e14\uff0c\u7f16\u8bd1\u5668\u9700\u8981\u4e3a\u6709\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u865a\u51fd\u6570\u7684\u7c7b\u7684\u5bf9\u8c61\u5206\u914d\u989d\u5916\u7684\u6307\u9488\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\u8ba8\u8bba\u8fd9\u4e2a\u95ee\u9898\u3002 Quiz time 1) What do the following programs print? This exercise is meant to be done by inspection, not by compiling the examples with your compiler. 1a) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : // Note: no getName() function here }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << rBase . getName () << '\\n' ; return 0 ; } B. rBase is an A reference pointing to a C object. Normally rBase.getName() would call A::getName(), but A::getName() is virtual so it instead calls the most derived matching function between A and C. That is B::getName(), which prints B. 1b) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; B & rBase { c }; // note: rBase is a B this time std :: cout << rBase . getName () << '\\n' ; return 0 ; } C. This is pretty straightforward, as C::getName() is the most derived matching call between classes B and C. 1c) # include <iostream> # include <string_view> class A { public : // note: no virtual keyword std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << rBase . getName () << '\\n' ; return 0 ; } A. Since A is not virtual, when rBase.getName() is called, A::getName() is called. 1d) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : // note: no virtual keyword in B, C, and D std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; B & rBase { c }; // note: rBase is a B this time std :: cout << rBase . getName () << '\\n' ; return 0 ; } C. Even though B and C aren\u2019t marked as virtual functions, A::getName() is virtual and B::getName() and C::getName() are overrides. Therefore, B::getName() and C::getName() are considered implicitly virtual, and thus the call to rBase.getName() resolves to C::getName(), not B::getName(). 1e) # include <iostream> # include <string_view> class A { public : virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : // Note: Functions in B, C, and D are non-const. virtual std :: string_view getName () { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () { return \"D\" ; } }; int main () { C c ; A & rBase { c }; std :: cout << rBase . getName () << '\\n' ; return 0 ; } A. This one is a little trickier. rBase is an A reference to a C object, so rBase.getName() would normally call A::getName(). But A::getName() is virtual, so it calls the most derived version of the function between A and C. And that is A::getName(). Because B::getName() and c::getName() are not const, they are not considered overrides! Consequently, this program prints A. 1f) # include <iostream> # include <string_view> class A { public : A () { std :: cout << getName (); } // note addition of constructor virtual std :: string_view getName () const { return \"A\" ; } }; class B : public A { public : virtual std :: string_view getName () const { return \"B\" ; } }; class C : public B { public : virtual std :: string_view getName () const { return \"C\" ; } }; class D : public C { public : virtual std :: string_view getName () const { return \"D\" ; } }; int main () { C c ; return 0 ; } A. Another tricky one. When we create a C object, the A part is constructed first. When the A constructor is called to do this, it calls virtual function getName(). Because the B and C parts of the class aren\u2019t set up yet, this resolves to A::getName().","title":"\u865a\u51fd\u6570\u7684\u7f3a\u70b9"},{"location":"18-virtual-functions/18.3-The-override-and-final-specifiers-and-covariant-return-types/","text":"18.3 \u91cd\u5199 final \u6807\u8bc6\u7b26\uff0c\u5e76\u4e14\u534f\u53d8\u8fd4\u56de\u7c7b\u578b \u00b6 By Alex on November 6 th , 2016 | last modified by nascardriver on December 12 th , 2020 \u7ffb\u8bd1 by \u8d75\u6587\u6770 2020-12-20 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-20 \u4e3a\u4e86\u89e3\u51b3\u4e00\u4e9b\u4f7f\u7528\u7ee7\u627f\u8fc7\u7a0b\u5e38\u89c1\u7684\u95ee\u9898\uff0cC++ \u6dfb\u52a0\u4e86\u4e24\u79cd\u7279\u6b8a\u7684\u6807\u8bc6\u7b26\uff1a ovveride \u548c final \u3002\u6ce8\u610f\u8fd9\u4e9b\u6807\u8bc6\u7b26\u4e0d\u662f\u5173\u952e\u8bcd \u2014\u2014 \u4ed6\u4eec\u662f\u6709\u7279\u6b8a\u610f\u4e49\u7684\u666e\u901a\u7684\u6807\u8bc6\u7b26\u3002 \u5c3d\u7ba1 final \u4e0d\u662f\u5f88\u5e38\u7528\uff0c\u91cd\u5199\u662f\u4e00\u4e2a\u4f60\u5e94\u8be5\u89c4\u5f8b\u4f7f\u7528\u7684\u795e\u5947\u7684\u529f\u80fd\u3002\u5728\u8fd9\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u4e5f\u4f1a\u770b\u4e00\u773c\u8fd9\u4e24\u4e2a\u95ee\u9898\uff0c\u4ee5\u53ca\u865a\u62df\u51fd\u6570\u91cd\u5199\u8fd4\u56de\u7c7b\u578b\u5fc5\u987b\u5339\u914d\u7684\u89c4\u5219\u7684\u4e00\u4e2a\u4f8b\u5916\u3002 ovveride \u8bf4\u660e\u7b26 \u00b6 \u6211\u4eec\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u63d0\u5230\u8fc7\uff0c\u4e00\u4e2a\u6d3e\u751f\u7c7b\u865a\u51fd\u6570\u5982\u679c\u6070\u597d\u5339\u914d\u8fd4\u56de\u503c\u7c7b\u578b\u5c31\u662f\u91cd\u5199\u3002\u8fd9\u4f1a\u65e0\u610f\u4e2d\u5f15\u8d77\u95ee\u9898\uff0c\u4e00\u4e2a\u6253\u7b97\u91cd\u5199\u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u91cd\u5199\u3002 \u601d\u8003\u4e0b\u5217\u4f8b\u5b50\uff1a class A { public : virtual const char * getName1 ( int x ) { return \"A\" ; } virtual const char * getName2 ( int x ) { return \"A\" ; } }; class B : public A { public : virtual const char * getName1 ( short int x ) { return \"B\" ; } // note: parameter is a short int virtual const char * getName2 ( int x ) const { return \"B\" ; } // note: function is const }; int main () { B b {}; A & rBase { b }; std :: cout << rBase . getName1 ( 1 ) << '\\n' ; std :: cout << rBase . getName2 ( 2 ) << '\\n' ; return 0 ; } \u56e0\u4e3a rBase \u662f\u4e00\u4e2a\u6307\u5411 B \u5bf9\u8c61\u7684 A \u7c7b\u5f15\u7528\uff0c\u76ee\u7684\u662f\u4f7f\u7528\u865a\u51fd\u6570\u6765\u8bbf\u95ee B::getName1() \u548c B::getName2() \u3002\u7136\u800c\uff0c\u56e0\u4e3a B::getName() \u643a\u5e26\u4e86\u4e00\u4e2a\u4e0d\u540c\u7684\u53c2\u6570\uff08short int \u800c\u4e0d\u662f int\uff09\uff0c\u5b83\u4e0d\u88ab\u5f53\u505a\u662f\u4e00\u4e2a A::getName1() \u7684\u91cd\u5199\u3002\u5728\u4e0d\u77e5\u4e0d\u89c9\u4e2d\uff0c B::getName2 \u662f\u4e00\u4e2a const \u51fd\u6570\uff0c\u800c A::getName2() \u4e0d\u662f\uff0c B::getName2() \u4e5f\u4e0d\u4f1a\u6210\u4e3a A::getName2() \u7684\u91cd\u5199\u3002 \u56e0\u6b64\uff0c\u7a0b\u5e8f\u4f1a\u6253\u5370\uff1a A A \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a A \u548c B \u53ea\u6253\u5370\u4e86\u4ed6\u4eec\u7684\u540d\u5b57\uff0c\u5f88\u5bb9\u6613\u80fd\u770b\u51fa\u6211\u4eec\u641e\u4e71\u4e86\u8fd9\u4e9b\u91cd\u5199\u51fd\u6570\uff0c\u7136\u540e\u9519\u8bef\u7684\u865a\u51fd\u6570\u5c31\u88ab\u8c03\u7528\u4e86\u3002\u7136\u800c\uff0c\u5728\u66f4\u52a0\u590d\u6742\u7684\u7a0b\u5e8f\u5f53\u4e2d\uff0c\u51fd\u6570\u6709\u4ec0\u4e48\u884c\u4e3a\u6216\u8005\u8fd4\u56de\u503c\u6ca1\u6709\u88ab\u6253\u5370\uff0c\u8fd9\u6837\u7684\u95ee\u9898\u53ef\u80fd\u5f88\u96be\u8c03\u8bd5\u3001 \u4e3a\u4e86\u5e2e\u52a9\u89e3\u51b3\u672c\u6765\u8981\u91cd\u5199\u4f46\u662f\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u7684\u95ee\u9898\uff0cC++11 \u5f15\u5165\u4e86\u91cd\u5199\u8bf4\u660e\u7b26\u3002 override \u8bf4\u660e\u7b26\u53ef\u4ee5\u88ab\u5e94\u7528\u5230\u4efb\u4f55\u91cd\u5199\u51fd\u6570\uff0c\u53ea\u8981\u6446\u5728 const \u6240\u5728\u7684\u4f4d\u7f6e\u5c31\u53ef\u4ee5\u3002\u5982\u679c\u8fd9\u4e2a\u51fd\u6570\u5b9e\u9645\u4e0a\u6ca1\u6709\u91cd\u5199\u4e00\u4e2a\u57fa\u7c7b\u7684\u51fd\u6570\uff08\u6216\u8005\u88ab\u4f7f\u7528\u5230\u4e86\u975e\u865a\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c31\u4f1a\u6807\u6ce8\u8fd9\u4e2a\u51fd\u6570\u4e3a\u4e00\u4e2a\u9519\u8bef\uff09\u3002 class A { public : virtual const char * getName1 ( int x ) { return \"A\" ; } virtual const char * getName2 ( int x ) { return \"A\" ; } virtual const char * getName3 ( int x ) { return \"A\" ; } }; class B : public A { public : virtual const char * getName1 ( short int x ) override { return \"B\" ; } // compile error, function is not an override virtual const char * getName2 ( int x ) const override { return \"B\" ; } // compile error, function is not an override virtual const char * getName3 ( int x ) override { return \"B\" ; } // okay, function is an override of A::getName3(int) }; int main () { return 0 ; } \u4e0a\u65b9\u7684\u7a0b\u5e8f\u4ea7\u751f\u4e24\u4e2a\u7f16\u8bd1\u9519\u8bef\uff1a\u4e00\u4e2a\u662f B::getName1() \u7136\u540e\u4e00\u4e2a\u662f B::getName() \uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u6ca1\u6709\u91cd\u5199\u4e86\u4e4b\u524d\u7684\u51fd\u6570\u3002 B::getName3() \u786e\u5b9e\u91cd\u5199\u4e86 A::getName() \uff0c\u56e0\u6b64\u6ca1\u6709\u9519\u8bef\u4ea7\u751f\u3002 \u4f7f\u7528\u91cd\u5199\u8bf4\u660e\u7b26\u6ca1\u6709\u4efb\u4f55\u6027\u80fd\u635f\u5931\uff0c\u5e2e\u52a9\u6211\u4eec\u907f\u514d\u65e0\u610f\u4e2d\u72af\u9519\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u975e\u5e38\u5efa\u8bae\u5728\u6bcf\u4e2a\u865a\u51fd\u6570\u7684\u91cd\u5199\u4e2d\u4f7f\u7528 override \u6765\u786e\u4fdd\u4f60\u91cd\u5199\u4e86\u4f60\u80fd\u50cf\u4f60\u5982\u671f\u91cd\u5199\u51fd\u6570\u3002 \u89c4\u5219: \u7ed9\u4f60\u5199\u7684\u6bcf\u4e00\u4e2a\u60f3\u8981\u91cd\u8f7d\u7684\u51fd\u6570\u6dfb\u52a0 override \u8bf4\u660e\u7b26 final \u8bf4\u660e\u7b26 \u00b6 \u6709\u65f6\u5019\u4f60\u53ef\u80fd\u4e0d\u5e0c\u671b\u4f60\u7684\u51fd\u6570\u91cd\u5199\u4e86\u865a\u51fd\u6570\uff0c\u6216\u8005\u4ece\u4e00\u4e2a\u7c7b\u7ee7\u627f\u3002 final \u8bf4\u660e\u7b26\u53ef\u4ee5\u88ab\u7528\u6765\u544a\u8bc9\u7f16\u8bd1\u5668\u5f3a\u8c03\u8fd9\u4e2a\u3002\u5982\u679c\u7528\u6237\u5c1d\u8bd5\u91cd\u5199\u4e00\u4e2a\u57fa\u7c7b\u4e2d\u7684\u51fd\u6570\uff0c\u5e76\u4e14\u8fd9\u4e2a\u865a\u51fd\u6570\u94fe\u5df2\u7ecf\u88ab\u6807\u8bb0\u4e3a final \uff0c\u7f16\u8bd1\u5668\u4f1a\u62a5\u9519\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u4f60\u60f3\u8981\u9650\u5236\u7528\u6237\u91cd\u8f7d\u51fd\u6570\uff0c final \u8bf4\u660e\u7b26\u53ef\u4ee5\u66ff\u6362 ovrride \u8bf4\u660e\u7b26\uff0c\u50cf\u8fd9\u6837\uff1a class A { public : virtual const char * getName () { return \"A\" ; } }; class B : public A { public : // note use of final specifier on following line -- that makes this function no longer overridable virtual const char * getName () override final { return \"B\" ; } // okay, overrides A::getName() }; class C : public B { public : virtual const char * getName () override { return \"C\" ; } // compile error: overrides B::getName(), which is final }; \u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c B::getName() \u91cd\u5199\u4e86 A::getName() \uff0c\u6ca1\u4ec0\u4e48\u9519\u8bef\u3002\u4f46\u662f B:;getName() \u6709\u4e00\u4e2a final \u8bf4\u660e\u7b26\uff0c\u610f\u601d\u662f\u4efb\u4f55\u5c1d\u8bd5\u91cd\u5199\u8fd9\u4e2a\u51fd\u6570\u90fd\u4f1a\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u9519\u8bef\u3002\u4e8b\u5b9e\u4e0a\uff0c C::getName() \u5c1d\u8bd5\u91cd\u5199 B::getName() \uff08 override \u5173\u952e\u8bcd\u5e76\u4e0d\u662f\u5fc5\u8981\u7684\uff0c\u53ea\u662f\u4e3a\u4e86\u826f\u597d\u7684\u4e60\u60ef\uff09\uff0c\u56e0\u6b64\u7f16\u8bd1\u5668\u62a5\u4e00\u4e2a\u7f16\u8bd1\u9519\u8bef\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u6211\u4eec\u60f3\u8981\u963b\u6b62\u4efb\u4f55\u7c7b\u7684\u7ee7\u627f\uff0c\u7c7b\u540d\u540e\u53ef\u4ee5\u6dfb\u52a0\u4e00\u4e2a final \u8bf4\u660e\u7b26\u6765\u5b9e\u73b0\uff1a class A { public : virtual const char * getName () { return \"A\" ; } }; class B final : public A // note use of final specifier here { public : virtual const char * getName () override { return \"B\" ; } }; class C : public B // compile error: cannot inherit from final class { public : virtual const char * getName () override { return \"C\" ; } }; \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0cB \u7c7b\u4ee5 final \u5173\u952e\u8bcd\u7533\u660e\uff0c\u5f53 C \u5c1d\u8bd5\u4ece B \u7ee7\u627f\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u5c31\u4f1a\u62a5\u51fa\u4e00\u4e2a\u7f16\u8bd1\u9519\u8bef\u3002 Covariant \u8fd4\u56de\u7c7b\u578b \u00b6 \u6709\u4e00\u79cd\u7279\u6b8a\u7684\u60c5\u51b5\uff0c\u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u865a\u51fd\u6570\u91cd\u5199\u53ef\u4ee5\u548c\u57fa\u7c7b\u6709\u4e0d\u540c\u7684\u8fd4\u56de\u7c7b\u578b\uff0c\u5e76\u4e14\u4ecd\u7136\u80fd\u5339\u914d\u91cd\u8f7d\u3002\u5982\u679c\u4e00\u4e2a\u865a\u51fd\u6570\u7684\u8fd4\u56de\u503c\u7c7b\u578b\u662f\u4e00\u4e2a\u7c7b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u91cd\u5199\u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u6216\u8005\u5f15\u7528\u5230\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u8fd9\u53eb\u505a covariant return types\u3002\u4f8b\u5982\uff1a # include <iostream> class Base { public : // This version of getThis() returns a pointer to a Base class virtual Base * getThis () { std :: cout << \"called Base::getThis() \\n \" ; return this ; } void printType () { std :: cout << \"returned a Base \\n \" ; } }; class Derived : public Base { public : // Normally override functions have to return objects of the same type as the base function // However, because Derived is derived from Base, it's okay to return Derived*instead of Base* Derived * getThis () override { std :: cout << \"called Derived::getThis() \\n \" ; return this ; } void printType () { std :: cout << \"returned a Derived \\n \" ; } }; int main () { Derived d {}; Base * b { & d }; d . getThis () -> printType (); // calls Derived::getThis(), returns a Derived*, calls Derived::printType b -> getThis () -> printType (); // calls Derived::getThis(), returns a Base*, calls Base::printType return 0 ; } \u6253\u5370\uff1a called Derived :: getThis () returned a Derived called Derived :: getThis () returned a Base \u6ce8\u610f\uff0c\u4e00\u4e9b\u8001\u65e7\u7684\u7f16\u8bd1\u5668\uff08\u5982 Visual Studio 6 \uff09\u4e0d\u652f\u6301\u8fd9\u79cd\u53ef\u53d8\u8fd4\u56de\u7c7b\u578b\u3002 \u4e00\u4e2a\u6709\u610f\u601d\u7684\u5173\u4e8e covariant return types \u7684\u4e8b\u60c5\u5c31\u662f\uff1a C++ \u4e0d\u80fd\u52a8\u6001\u7684\u9009\u62e9\u800c\u7c7b\u578b\uff0c\u56e0\u6b64\u60a8\u5c06\u59cb\u7ec8\u83b7\u5f97\u4e0e\u88ab\u8c03\u7528\u51fd\u6570\u7684\u57fa\u7c7b\u7248\u672c\u76f8\u5339\u914d\u7684\u7c7b\u578b\u3002\uff08so you\u2019ll always get the type that matches the base version of the function being called.\uff09 \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5148\u8c03\u7528\u4e86 d.getThis() \u3002\u56e0\u4e3a d \u662f\u4e00\u4e2a\u6d3e\u751f\u7c7b\uff0c\u8fd9\u8c03\u7528\u4e86 Derived::getThis() \uff0c\u8fd4\u56de\u4e86\u4e00\u4e2a Derived* \u3002\u8fd9 Derived* \u7d27\u63a5\u7740\u8c03\u7528\u4e86\u4e00\u4e2a\u975e\u865a\u51fd\u6570 Derived::printType() \u3002 \u73b0\u5728\u6765\u770b\u4e00\u4e2a\u6709\u8da3\u7684\u4f8b\u5b50\u3002\u6211\u4eec\u63a5\u7740\u8c03\u7528 d->getThis() \u3002\u53d8\u91cf b \u662f\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6307\u5411 Derived \u7c7b\u7684\u5bf9\u8c61\u3002 Base::getThis() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u56e0\u6b64\u8fd9\u8c03\u7528\u4e86 Derived::getThis() \u3002\u5c3d\u7ba1 Derived::getThis() \u8fd4\u56de\u4e86\u4e00\u4e2a Derived* \uff0c\u56e0\u4e3a\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a Base* \uff0c\u8fd4\u56de\u7684 Derived* \u4f1a\u5411\u4e0a\u8f6c\u5316\u4e3a\u4e00\u4e2a Base* \u3002\u6240\u4ee5\uff0c Base::printType() \u88ab\u8c03\u7528\u4e86\u3002 \uff08\u672a\u7ffb\u8bd1\uff09In other words, in the above example, you only get a Derived* if you call getThis() with an object that is typed as a Derived object in the first place.","title":"18.3 \u91cd\u5199 final \u6807\u8bc6\u7b26\uff0c\u5e76\u4e14\u534f\u53d8\u8fd4\u56de\u7c7b\u578b"},{"location":"18-virtual-functions/18.3-The-override-and-final-specifiers-and-covariant-return-types/#183-final","text":"By Alex on November 6 th , 2016 | last modified by nascardriver on December 12 th , 2020 \u7ffb\u8bd1 by \u8d75\u6587\u6770 2020-12-20 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-20 \u4e3a\u4e86\u89e3\u51b3\u4e00\u4e9b\u4f7f\u7528\u7ee7\u627f\u8fc7\u7a0b\u5e38\u89c1\u7684\u95ee\u9898\uff0cC++ \u6dfb\u52a0\u4e86\u4e24\u79cd\u7279\u6b8a\u7684\u6807\u8bc6\u7b26\uff1a ovveride \u548c final \u3002\u6ce8\u610f\u8fd9\u4e9b\u6807\u8bc6\u7b26\u4e0d\u662f\u5173\u952e\u8bcd \u2014\u2014 \u4ed6\u4eec\u662f\u6709\u7279\u6b8a\u610f\u4e49\u7684\u666e\u901a\u7684\u6807\u8bc6\u7b26\u3002 \u5c3d\u7ba1 final \u4e0d\u662f\u5f88\u5e38\u7528\uff0c\u91cd\u5199\u662f\u4e00\u4e2a\u4f60\u5e94\u8be5\u89c4\u5f8b\u4f7f\u7528\u7684\u795e\u5947\u7684\u529f\u80fd\u3002\u5728\u8fd9\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u4e5f\u4f1a\u770b\u4e00\u773c\u8fd9\u4e24\u4e2a\u95ee\u9898\uff0c\u4ee5\u53ca\u865a\u62df\u51fd\u6570\u91cd\u5199\u8fd4\u56de\u7c7b\u578b\u5fc5\u987b\u5339\u914d\u7684\u89c4\u5219\u7684\u4e00\u4e2a\u4f8b\u5916\u3002","title":"18.3 \u91cd\u5199 final \u6807\u8bc6\u7b26\uff0c\u5e76\u4e14\u534f\u53d8\u8fd4\u56de\u7c7b\u578b"},{"location":"18-virtual-functions/18.3-The-override-and-final-specifiers-and-covariant-return-types/#ovveride","text":"\u6211\u4eec\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u63d0\u5230\u8fc7\uff0c\u4e00\u4e2a\u6d3e\u751f\u7c7b\u865a\u51fd\u6570\u5982\u679c\u6070\u597d\u5339\u914d\u8fd4\u56de\u503c\u7c7b\u578b\u5c31\u662f\u91cd\u5199\u3002\u8fd9\u4f1a\u65e0\u610f\u4e2d\u5f15\u8d77\u95ee\u9898\uff0c\u4e00\u4e2a\u6253\u7b97\u91cd\u5199\u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u91cd\u5199\u3002 \u601d\u8003\u4e0b\u5217\u4f8b\u5b50\uff1a class A { public : virtual const char * getName1 ( int x ) { return \"A\" ; } virtual const char * getName2 ( int x ) { return \"A\" ; } }; class B : public A { public : virtual const char * getName1 ( short int x ) { return \"B\" ; } // note: parameter is a short int virtual const char * getName2 ( int x ) const { return \"B\" ; } // note: function is const }; int main () { B b {}; A & rBase { b }; std :: cout << rBase . getName1 ( 1 ) << '\\n' ; std :: cout << rBase . getName2 ( 2 ) << '\\n' ; return 0 ; } \u56e0\u4e3a rBase \u662f\u4e00\u4e2a\u6307\u5411 B \u5bf9\u8c61\u7684 A \u7c7b\u5f15\u7528\uff0c\u76ee\u7684\u662f\u4f7f\u7528\u865a\u51fd\u6570\u6765\u8bbf\u95ee B::getName1() \u548c B::getName2() \u3002\u7136\u800c\uff0c\u56e0\u4e3a B::getName() \u643a\u5e26\u4e86\u4e00\u4e2a\u4e0d\u540c\u7684\u53c2\u6570\uff08short int \u800c\u4e0d\u662f int\uff09\uff0c\u5b83\u4e0d\u88ab\u5f53\u505a\u662f\u4e00\u4e2a A::getName1() \u7684\u91cd\u5199\u3002\u5728\u4e0d\u77e5\u4e0d\u89c9\u4e2d\uff0c B::getName2 \u662f\u4e00\u4e2a const \u51fd\u6570\uff0c\u800c A::getName2() \u4e0d\u662f\uff0c B::getName2() \u4e5f\u4e0d\u4f1a\u6210\u4e3a A::getName2() \u7684\u91cd\u5199\u3002 \u56e0\u6b64\uff0c\u7a0b\u5e8f\u4f1a\u6253\u5370\uff1a A A \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a A \u548c B \u53ea\u6253\u5370\u4e86\u4ed6\u4eec\u7684\u540d\u5b57\uff0c\u5f88\u5bb9\u6613\u80fd\u770b\u51fa\u6211\u4eec\u641e\u4e71\u4e86\u8fd9\u4e9b\u91cd\u5199\u51fd\u6570\uff0c\u7136\u540e\u9519\u8bef\u7684\u865a\u51fd\u6570\u5c31\u88ab\u8c03\u7528\u4e86\u3002\u7136\u800c\uff0c\u5728\u66f4\u52a0\u590d\u6742\u7684\u7a0b\u5e8f\u5f53\u4e2d\uff0c\u51fd\u6570\u6709\u4ec0\u4e48\u884c\u4e3a\u6216\u8005\u8fd4\u56de\u503c\u6ca1\u6709\u88ab\u6253\u5370\uff0c\u8fd9\u6837\u7684\u95ee\u9898\u53ef\u80fd\u5f88\u96be\u8c03\u8bd5\u3001 \u4e3a\u4e86\u5e2e\u52a9\u89e3\u51b3\u672c\u6765\u8981\u91cd\u5199\u4f46\u662f\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u7684\u95ee\u9898\uff0cC++11 \u5f15\u5165\u4e86\u91cd\u5199\u8bf4\u660e\u7b26\u3002 override \u8bf4\u660e\u7b26\u53ef\u4ee5\u88ab\u5e94\u7528\u5230\u4efb\u4f55\u91cd\u5199\u51fd\u6570\uff0c\u53ea\u8981\u6446\u5728 const \u6240\u5728\u7684\u4f4d\u7f6e\u5c31\u53ef\u4ee5\u3002\u5982\u679c\u8fd9\u4e2a\u51fd\u6570\u5b9e\u9645\u4e0a\u6ca1\u6709\u91cd\u5199\u4e00\u4e2a\u57fa\u7c7b\u7684\u51fd\u6570\uff08\u6216\u8005\u88ab\u4f7f\u7528\u5230\u4e86\u975e\u865a\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c31\u4f1a\u6807\u6ce8\u8fd9\u4e2a\u51fd\u6570\u4e3a\u4e00\u4e2a\u9519\u8bef\uff09\u3002 class A { public : virtual const char * getName1 ( int x ) { return \"A\" ; } virtual const char * getName2 ( int x ) { return \"A\" ; } virtual const char * getName3 ( int x ) { return \"A\" ; } }; class B : public A { public : virtual const char * getName1 ( short int x ) override { return \"B\" ; } // compile error, function is not an override virtual const char * getName2 ( int x ) const override { return \"B\" ; } // compile error, function is not an override virtual const char * getName3 ( int x ) override { return \"B\" ; } // okay, function is an override of A::getName3(int) }; int main () { return 0 ; } \u4e0a\u65b9\u7684\u7a0b\u5e8f\u4ea7\u751f\u4e24\u4e2a\u7f16\u8bd1\u9519\u8bef\uff1a\u4e00\u4e2a\u662f B::getName1() \u7136\u540e\u4e00\u4e2a\u662f B::getName() \uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u6ca1\u6709\u91cd\u5199\u4e86\u4e4b\u524d\u7684\u51fd\u6570\u3002 B::getName3() \u786e\u5b9e\u91cd\u5199\u4e86 A::getName() \uff0c\u56e0\u6b64\u6ca1\u6709\u9519\u8bef\u4ea7\u751f\u3002 \u4f7f\u7528\u91cd\u5199\u8bf4\u660e\u7b26\u6ca1\u6709\u4efb\u4f55\u6027\u80fd\u635f\u5931\uff0c\u5e2e\u52a9\u6211\u4eec\u907f\u514d\u65e0\u610f\u4e2d\u72af\u9519\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u975e\u5e38\u5efa\u8bae\u5728\u6bcf\u4e2a\u865a\u51fd\u6570\u7684\u91cd\u5199\u4e2d\u4f7f\u7528 override \u6765\u786e\u4fdd\u4f60\u91cd\u5199\u4e86\u4f60\u80fd\u50cf\u4f60\u5982\u671f\u91cd\u5199\u51fd\u6570\u3002 \u89c4\u5219: \u7ed9\u4f60\u5199\u7684\u6bcf\u4e00\u4e2a\u60f3\u8981\u91cd\u8f7d\u7684\u51fd\u6570\u6dfb\u52a0 override \u8bf4\u660e\u7b26","title":"ovveride \u8bf4\u660e\u7b26"},{"location":"18-virtual-functions/18.3-The-override-and-final-specifiers-and-covariant-return-types/#final","text":"\u6709\u65f6\u5019\u4f60\u53ef\u80fd\u4e0d\u5e0c\u671b\u4f60\u7684\u51fd\u6570\u91cd\u5199\u4e86\u865a\u51fd\u6570\uff0c\u6216\u8005\u4ece\u4e00\u4e2a\u7c7b\u7ee7\u627f\u3002 final \u8bf4\u660e\u7b26\u53ef\u4ee5\u88ab\u7528\u6765\u544a\u8bc9\u7f16\u8bd1\u5668\u5f3a\u8c03\u8fd9\u4e2a\u3002\u5982\u679c\u7528\u6237\u5c1d\u8bd5\u91cd\u5199\u4e00\u4e2a\u57fa\u7c7b\u4e2d\u7684\u51fd\u6570\uff0c\u5e76\u4e14\u8fd9\u4e2a\u865a\u51fd\u6570\u94fe\u5df2\u7ecf\u88ab\u6807\u8bb0\u4e3a final \uff0c\u7f16\u8bd1\u5668\u4f1a\u62a5\u9519\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u4f60\u60f3\u8981\u9650\u5236\u7528\u6237\u91cd\u8f7d\u51fd\u6570\uff0c final \u8bf4\u660e\u7b26\u53ef\u4ee5\u66ff\u6362 ovrride \u8bf4\u660e\u7b26\uff0c\u50cf\u8fd9\u6837\uff1a class A { public : virtual const char * getName () { return \"A\" ; } }; class B : public A { public : // note use of final specifier on following line -- that makes this function no longer overridable virtual const char * getName () override final { return \"B\" ; } // okay, overrides A::getName() }; class C : public B { public : virtual const char * getName () override { return \"C\" ; } // compile error: overrides B::getName(), which is final }; \u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c B::getName() \u91cd\u5199\u4e86 A::getName() \uff0c\u6ca1\u4ec0\u4e48\u9519\u8bef\u3002\u4f46\u662f B:;getName() \u6709\u4e00\u4e2a final \u8bf4\u660e\u7b26\uff0c\u610f\u601d\u662f\u4efb\u4f55\u5c1d\u8bd5\u91cd\u5199\u8fd9\u4e2a\u51fd\u6570\u90fd\u4f1a\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u9519\u8bef\u3002\u4e8b\u5b9e\u4e0a\uff0c C::getName() \u5c1d\u8bd5\u91cd\u5199 B::getName() \uff08 override \u5173\u952e\u8bcd\u5e76\u4e0d\u662f\u5fc5\u8981\u7684\uff0c\u53ea\u662f\u4e3a\u4e86\u826f\u597d\u7684\u4e60\u60ef\uff09\uff0c\u56e0\u6b64\u7f16\u8bd1\u5668\u62a5\u4e00\u4e2a\u7f16\u8bd1\u9519\u8bef\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u6211\u4eec\u60f3\u8981\u963b\u6b62\u4efb\u4f55\u7c7b\u7684\u7ee7\u627f\uff0c\u7c7b\u540d\u540e\u53ef\u4ee5\u6dfb\u52a0\u4e00\u4e2a final \u8bf4\u660e\u7b26\u6765\u5b9e\u73b0\uff1a class A { public : virtual const char * getName () { return \"A\" ; } }; class B final : public A // note use of final specifier here { public : virtual const char * getName () override { return \"B\" ; } }; class C : public B // compile error: cannot inherit from final class { public : virtual const char * getName () override { return \"C\" ; } }; \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0cB \u7c7b\u4ee5 final \u5173\u952e\u8bcd\u7533\u660e\uff0c\u5f53 C \u5c1d\u8bd5\u4ece B \u7ee7\u627f\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u5c31\u4f1a\u62a5\u51fa\u4e00\u4e2a\u7f16\u8bd1\u9519\u8bef\u3002","title":"final \u8bf4\u660e\u7b26"},{"location":"18-virtual-functions/18.3-The-override-and-final-specifiers-and-covariant-return-types/#covariant","text":"\u6709\u4e00\u79cd\u7279\u6b8a\u7684\u60c5\u51b5\uff0c\u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u865a\u51fd\u6570\u91cd\u5199\u53ef\u4ee5\u548c\u57fa\u7c7b\u6709\u4e0d\u540c\u7684\u8fd4\u56de\u7c7b\u578b\uff0c\u5e76\u4e14\u4ecd\u7136\u80fd\u5339\u914d\u91cd\u8f7d\u3002\u5982\u679c\u4e00\u4e2a\u865a\u51fd\u6570\u7684\u8fd4\u56de\u503c\u7c7b\u578b\u662f\u4e00\u4e2a\u7c7b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u91cd\u5199\u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u6216\u8005\u5f15\u7528\u5230\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u8fd9\u53eb\u505a covariant return types\u3002\u4f8b\u5982\uff1a # include <iostream> class Base { public : // This version of getThis() returns a pointer to a Base class virtual Base * getThis () { std :: cout << \"called Base::getThis() \\n \" ; return this ; } void printType () { std :: cout << \"returned a Base \\n \" ; } }; class Derived : public Base { public : // Normally override functions have to return objects of the same type as the base function // However, because Derived is derived from Base, it's okay to return Derived*instead of Base* Derived * getThis () override { std :: cout << \"called Derived::getThis() \\n \" ; return this ; } void printType () { std :: cout << \"returned a Derived \\n \" ; } }; int main () { Derived d {}; Base * b { & d }; d . getThis () -> printType (); // calls Derived::getThis(), returns a Derived*, calls Derived::printType b -> getThis () -> printType (); // calls Derived::getThis(), returns a Base*, calls Base::printType return 0 ; } \u6253\u5370\uff1a called Derived :: getThis () returned a Derived called Derived :: getThis () returned a Base \u6ce8\u610f\uff0c\u4e00\u4e9b\u8001\u65e7\u7684\u7f16\u8bd1\u5668\uff08\u5982 Visual Studio 6 \uff09\u4e0d\u652f\u6301\u8fd9\u79cd\u53ef\u53d8\u8fd4\u56de\u7c7b\u578b\u3002 \u4e00\u4e2a\u6709\u610f\u601d\u7684\u5173\u4e8e covariant return types \u7684\u4e8b\u60c5\u5c31\u662f\uff1a C++ \u4e0d\u80fd\u52a8\u6001\u7684\u9009\u62e9\u800c\u7c7b\u578b\uff0c\u56e0\u6b64\u60a8\u5c06\u59cb\u7ec8\u83b7\u5f97\u4e0e\u88ab\u8c03\u7528\u51fd\u6570\u7684\u57fa\u7c7b\u7248\u672c\u76f8\u5339\u914d\u7684\u7c7b\u578b\u3002\uff08so you\u2019ll always get the type that matches the base version of the function being called.\uff09 \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5148\u8c03\u7528\u4e86 d.getThis() \u3002\u56e0\u4e3a d \u662f\u4e00\u4e2a\u6d3e\u751f\u7c7b\uff0c\u8fd9\u8c03\u7528\u4e86 Derived::getThis() \uff0c\u8fd4\u56de\u4e86\u4e00\u4e2a Derived* \u3002\u8fd9 Derived* \u7d27\u63a5\u7740\u8c03\u7528\u4e86\u4e00\u4e2a\u975e\u865a\u51fd\u6570 Derived::printType() \u3002 \u73b0\u5728\u6765\u770b\u4e00\u4e2a\u6709\u8da3\u7684\u4f8b\u5b50\u3002\u6211\u4eec\u63a5\u7740\u8c03\u7528 d->getThis() \u3002\u53d8\u91cf b \u662f\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6307\u5411 Derived \u7c7b\u7684\u5bf9\u8c61\u3002 Base::getThis() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u56e0\u6b64\u8fd9\u8c03\u7528\u4e86 Derived::getThis() \u3002\u5c3d\u7ba1 Derived::getThis() \u8fd4\u56de\u4e86\u4e00\u4e2a Derived* \uff0c\u56e0\u4e3a\u57fa\u7c7b\u7248\u672c\u7684\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a Base* \uff0c\u8fd4\u56de\u7684 Derived* \u4f1a\u5411\u4e0a\u8f6c\u5316\u4e3a\u4e00\u4e2a Base* \u3002\u6240\u4ee5\uff0c Base::printType() \u88ab\u8c03\u7528\u4e86\u3002 \uff08\u672a\u7ffb\u8bd1\uff09In other words, in the above example, you only get a Derived* if you call getThis() with an object that is typed as a Derived object in the first place.","title":"Covariant \u8fd4\u56de\u7c7b\u578b"},{"location":"18-virtual-functions/18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/","text":"18.4 \u865a\u6784\u9020\u51fd\u6570\uff0c\u865a\u8d4b\u503c\uff0c\u91cd\u5199\u865a\u51fd\u6570 \u00b6 By Alex on February 1 st , 2008 | last modified by nascardriver on June 26 th , 2020 \u7ffb\u8bd1 by dashjay 2020-12-21 | last modified at 2020-12-21 \u865a\u6784\u9020\u51fd\u6570 \u00b6 \u5c3d\u7ba1C++\u4f1a\u5728\u4f60\u4e0d\u63d0\u4f9b\u7ed3\u6784\u51fd\u6570\u65f6\u9ed8\u8ba4\u63d0\u4f9b\u4e00\u4e2a\uff0c\u4f46\u662f\u4f60\u6709\u65f6\u8981\u4f53\u7528\u81ea\u5df1\u7684\u7ed3\u6784\u51fd\u6570\uff08\u5c24\u5176\u662f\u9700\u8981\u5206\u914d\u5185\u5b58\u7684\u7c7b\uff09\u3002\u4f60\u5e94\u8be5\u603b\u662f\u5c06\u6790\u6784\u51fd\u6570\uff0c\u8bbe\u7f6e\u4e3a\u865a\u51fd\u6570\uff0c\u5728\u5904\u7406\u96c6\u6210\u5173\u7cfb\u7684\u65f6\u5019\u3002\u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a #include <iostream> class Base { public : ~ Base () // note: not virtual { std :: cout << \"Calling ~Base() \\n \" ; } }; class Derived : public Base { private : int * m_array ; public : Derived ( int length ) : m_array { new int [ length ] } { } ~ Derived () // note: not virtual (your compiler may warn you about this) { std :: cout << \"Calling ~Derived() \\n \" ; delete [] m_array ; } }; int main () { Derived * derived { new Derived ( 5 ) }; Base * base { derived }; delete base ; return 0 ; } \u6ce8\u610f\uff1a\u5982\u679c\u4f60\u7f16\u8bd1\u4e86\u4e0a\u9762\u7684\u4f8b\u5b50\uff0c\u4f60\u7684\u7f16\u8bd1\u5668\u53ef\u80fd\u63d0\u793a\u4f60\u6709\u5173\u975e\u865a\u89e3\u6784\u51fd\u6570\uff08\u6545\u610f\u5728\u4f8b\u5b50\u4e2d\u5448\u73b0\u7684\uff09\u3002\u4f60\u4e5f\u53ef\u4ee5\u7981\u7528\u7f16\u8bd1\u5668\u7684 flag\uff0c\u8fd9\u6837\u53ef\u4ee5\u5c06 warnings \u89c6\u4e3a\u62a5\u9519\u6765\u6267\u884c\u3002 \u56e0\u4e3a base \u662f\u4e00\u4e2a Base \u6307\u9488\uff0c\u5f53 base \u88ab\u5220\u9664\u7684\u65f6\u5019\uff0c\u7a0b\u5e8f\u68c0\u67e5 Base \u89e3\u6784\u51fd\u6570\u662f\u865a\u51fd\u6570\u3002\u800c\u5b83\u5e76\u4e0d\u662f\uff0c\u6240\u4ee5\u5b83\u5047\u8bbe\u5b83\u53ea\u9700\u8981\u8c03\u7528 Base \u7c7b\u7684\u6790\u6784\u51fd\u6570\uff0c\u6211\u4eec\u542c\u8fc7\u4e0b\u9762\u7684\u8f93\u51fa\u6765\u4e86\u89e3\u8fd9\u4e2a\uff1a Calling ~ Base () However, we really want the delete function to call Derived\u2019s destructor (which will call Base\u2019s destructor in turn), otherwise m_array will not be deleted. We do this by making Base\u2019s destructor virtual: #include <iostream> class Base { public : virtual ~ Base () // note: virtual { std :: cout << \"Calling ~Base() \\n \" ; } }; class Derived : public Base { private : int * m_array ; public : Derived ( int length ) : m_array { new int [ length ] } { } virtual ~ Derived () // note: virtual { std :: cout << \"Calling ~Derived() \\n \" ; delete [] m_array ; } }; int main () { Derived * derived { new Derived ( 5 ) }; Base * base { derived }; delete base ; return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u4ea7\u751f\u4e0b\u5217\u6548\u679c\uff1a Calling ~ Derived () Calling ~ Base () \u89c4\u5219\uff1a\u65e0\u8bba\u4f60\u4f55\u65f6\u5904\u7406\u7ee7\u627f\uff0c\u4f60\u5e94\u8be5\u663e\u5f0f\u7684\u8bbe\u7f6e\u6790\u6784\u51fd\u6570\u4e3a\u865a\u51fd\u6570 \u4e0e\u666e\u901a\u865a\u51fd\u6570\u6210\u5458\u4e00\u6837\uff0c\u5982\u679c\u4e00\u4e2a\u57fa\u7c7b\u51fd\u6570\u662f\u865a\u51fd\u6570\uff0c\u6240\u6709\u7684\u7ee7\u627f\u91cd\u5199\u7c7b\u5c06\u4f1a\u88ab\u5f53\u505a\u865a\u51fd\u6570\uff0c\u65e0\u8bba\u4f60\u662f\u5426\u6307\u5b9a\u3002\u5982\u679c\u6d3e\u751f\u7c7b\u7684\u89e3\u6784\u51fd\u6570\u4e0d\u4e3a\u7a7a\uff0c\u5c31\u8bf7\u6807\u6ce8\u4e3a\u865a\u51fd\u6570\u3002 \u865a\u8d4b\u503c\u65b9\u6cd5 \u00b6 \u53ef\u4ee5\u5c06\u8d4b\u503c\u64cd\u4f5c\u7b26\u8bbe\u4e3a\u865a\u51fd\u503c\uff0c\u4e0d\u50cf\u6790\u6784\u51fd\u6570\u90a3\u6837\uff0c\u8bbe\u7f6e\u4e3a\u865a\u6784\u51fd\u6570\u603b\u662f\u4e00\u4e2a\u597d\u4e3b\u610f\uff0c\u5c06\u8d4b\u503c\u64cd\u4f5c\u7b26\u8bbe\u7f6e\u4e3a\u865a\u62df\u5316\u5c31\u5bb9\u6613\u5f15\u8d77\u5f88\u591abug\uff0c\u5e76\u4e14\u8fdb\u5165\u5728\u8fd9\u4e2a\u6559\u7a0b\u4e4b\u5916\u7684\u8bdd\u9898\u3002\u56e0\u6b64\uff0c\u4e3a\u4e86\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u5efa\u8bae\u4f60\u76ee\u524d\u5148\u8ba9\u865a\u51fd\u6570\u4e3a\u975e\u865a\u51fd\u6570\u3002 \u5ffd\u7565\u865a\u51fd\u6570 \u00b6 \u6709\u65f6\u5019\u4f60\u60f3\u8981\u5ffd\u7565\u4e00\u4e2a\u51fd\u6570\u7684\u865a\u5316\uff0c\u4f8b\u5982\uff0c\u770b\u770b\u4e0b\u9762\u7684\u4ee3\u7801\uff1a class Base { public : virtual const char * getName () const { return \"Base\" ; } }; class Derived : public Base { public : virtual const char * getName () const { return \"Derived\" ; } }; \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u4f60\u4e5f\u8bb8\u60f3\u8981\u4f7f\u7528\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u57fa\u7c7b\u6307\u9488\u8c03\u7528 Base::getName() \u800c\u4e0d\u662f Derived::getName() \u3002\u4e3a\u4e86\u8fd9\u6837\uff0c\u53ea\u9700\u8981\u7b80\u5355\u7684\u4f7f\u7528\u8303\u56f4\u89e3\u6790\u64cd\u4f5c\u7b26\uff1a #include <iostream> int main () { Derived derived ; const Base & base { derived }; // Calls Base::GetName() instead of the virtualized Derived::GetName() std :: cout << base . Base :: getName () << '\\n' ; return 0 ; } \u4f60\u4e5f\u8bb8\u4e0d\u4f1a\u7ecf\u5e38\u8fd9\u6837\u4f7f\u7528\uff0c\u4f46\u77e5\u9053\u4e5f\u8fd8\u662f\u4e0d\u9519\u7684\u3002 \u6211\u4eec\u662f\u5426\u5e94\u8be5\u4f7f\u6240\u6709\u7ed3\u6784\u51fd\u6570\u4e3a\u865a\u51fd\u6570 \u00b6 \u8fd9\u662f\u4e00\u4e2a\u65b0\u624b\u5e38\u95ee\u7684\u95ee\u9898\u3002\u6b63\u5982\u4e0a\u65b9\u4f8b\u5b50\u6240\u8bf4\uff0c\u5982\u679c\u57fa\u7c7b\u7ed3\u6784\u51fd\u6570\u6ca1\u6709\u6807\u6ce8\u4e3a\u865a\u51fd\u6570\uff0c\u7a0b\u5e8f\u5458\u7a0d\u540e\u5220\u9664\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u57fa\u7c7b\u6307\u9488\u65f6\u7a0b\u5e8f\u6709\u5185\u5b58\u6cc4\u9732\u7684\u98ce\u9669\u3002\u4e00\u4e2a\u907f\u514d\u7684\u65b9\u5f0f\u5c31\u662f\u5c06\u6240\u6709\u6790\u6784\u51fd\u6570\u6807\u6ce8\u4e3a\u865a\u51fd\u6570\uff0c\u4f46\u662f\u4f60\u5e94\u8be5\u90a3\u6837\u505a\u4e48\uff1f \u8bf4\u201d\u662f\u201c\u5f88\u5bb9\u6613\uff0c\u7136\u540e\u4f60\u7a0d\u540e\u4f7f\u7528\u4efb\u4f55\u7c7b\u4f5c\u4e3a\u4e00\u4e2a\u57fa\u7c7b \u2014\u2014 \u4f46\u8fd9\u6837\u505a\u5b58\u5728\u6027\u80fd\u4ee3\u4ef7\uff08\u4e00\u4e2a\u865a\u6307\u9488\u4f1a\u6dfb\u52a0\u5230\u6bcf\u4e2a\u7c7b\u7684\u5b9e\u4f8b\u4e2d\uff09\u3002\u56e0\u6b64\u4f60\u4e0d\u5f97\u4e0d\u5e73\u8861\u5f00\u9500\uff0c\u548c\u4f60\u7684\u610f\u56fe\u3002 \u4f20\u7edf\u7684\u667a\u6167\uff08\u6700\u521d\u7531 Herb Sutter \u63d0\u51fa\uff0c\u4e00\u4e2a\u5f88\u91cd\u8981\u7684 C++ \u8001\u5e08\uff09\u5efa\u8bae\u907f\u514d\u5982\u4e0b\u7684\u96c6\u4e2d\u975e\u865a\u51fd\u6570\u7ed3\u6784\u51fd\u6570\u5185\u5b58\u6cc4\u9732\u60c5\u51b5\uff0c\u201d\u4e00\u4e2a\u57fa\u7c7b\u7ed3\u6784\u51fd\u6570\u5e94\u8be5\u65e2\u662fpublic\u7684\u53c8\u662f\u865a\u51fd\u6570\uff0c\u6216\u8005 \u662fprotected \u4e14\u975e\u865a\u51fd\u6570\u3002\u201c\uff0c\u4e00\u4e2a\u5e26\u6709 protected \u89e3\u6784\u51fd\u6570\u7684\u7c7b\u5b9e\u4f8b\u4e0d\u80fd\u88ab\u901a\u8fc7\u6307\u9488\u6765\u5220\u9664\uff0c\u56e0\u6b64\u963b\u6b62\u4e86\u5f53\u4e00\u57fa\u7c7b\u6709\u975e\u865a\u6790\u6784\u51fd\u6570\u7684\u65f6\u5019\uff0c\u610f\u5916\u7684\u901a\u8fc7\u57fa\u7c7b\u6307\u9488\u5220\u9664\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u4e5f\u610f\u5473\u7740\u57fa\u7c7b\u4e0d\u80fd\u88ab\u901a\u8fc7\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u5220\u9664\uff0c\u57fa\u672c\u4e0a\u610f\u5473\u7740\u7c7b\u4e0d\u80fd\u88ab\u52a8\u6001\u5206\u914d\uff0c\u6216\u8005\u5982\u671f\u88ab\u6d3e\u751f\u7c7b\u5220\u9664\u3002\u8fd9\u4e5f\u6392\u9664\u4e86\u5728\u8fd9\u4e2a\u7c7b\u4e0a\u4f7f\u7528\u667a\u80fd\u6307\u9488\uff08\u4f8b\u5982 std::unique_ptr \u548c std::shared_ptr \uff09\uff0c\u9650\u5236\u4e86\u90a3\u4e2a\u89c4\u5219\uff08\u6211\u4eec\u5c06\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u4e2d\u4ecb\u7ecd\u667a\u80fd\u6307\u9488\uff09\u7684\u53ef\u7528\u6027\u3002\u5b83\u4e5f\u610f\u5473\u7740\u57fa\u7c7b\u4e0d\u80fd\u88ab\u5728\u6808\u4e0a\u5206\u914d\u3002\u90a3\u662f\u4e00\u4e2a\u76f8\u5f53\u91cd\u7684\u4ee3\u4ef7\u3002 \uff08\u539f\u6587\u592a\u957f\uff09Conventional wisdom (as initially put forth by Herb Sutter, a highly regarded C++ guru) has suggested avoiding the non-virtual destructor memory leak situation as follows, \u201cA base class destructor should be either public and virtual, or protected and nonvirtual.\u201d A class with a protected destructor can\u2019t be deleted via a pointer, thus preventing the accidental deleting of a derived class through a base pointer when the base class has a non-virtual destructor. Unfortunately, this also means the base class can\u2019t be deleted through a base class pointer, which essentially means the class can\u2019t be dynamically allocated or deleted except by a derived class. This also precludes using smart pointers (such as std::unique_ptr and std::shared_ptr) for such classes, which limits the usefulness of that rule (we cover smart pointers in a later chapter). It also means the base class can\u2019t be allocated on the stack. That\u2019s a pretty heavy set of penalties. \u65e2\u7136 final \u63cf\u8ff0\u7b26\u5df2\u7ecf\u88ab\u5f15\u5165\u5230\u8fd9\u4e2a\u8bed\u8a00\uff0c\u6211\u4eec\u7684\u5efa\u8bae\u5982\u4e0b\uff1a \u5982\u679c\u4f60\u7684\u7c7b\u6253\u7b97\u88ab\u7ee7\u627f\uff0c\u8bf7\u786e\u4fdd\u6790\u6784\u51fd\u6570\u662f\u865a\u51fd\u6570\u3002 \u5982\u679c\u4f60\u7684\u7c7b\u4e0d\u6253\u7b97\u88ab\u7ee7\u627f\uff0c\u5c06\u4f60\u7684\u7c7b\u6807\u6ce8\u4e3a final\uff0c\u8fd9\u5c06\u4f1a\u963b\u6b62\u5176\u4ed6\u7c7b\u4e00\u5f00\u59cb\u5c31\u4ece\u8be5\u7c7b\u6d3e\u751f\uff0c\u4f46\u662f\u4e0d\u4f1a\u5bf9\u8be5\u7c7b\u672c\u8eab\u5e26\u6765\u4efb\u4f55\u9650\u5236","title":"18.4 \u865a\u6784\u9020\u51fd\u6570\uff0c\u865a\u8d4b\u503c\uff0c\u91cd\u5199\u865a\u51fd\u6570"},{"location":"18-virtual-functions/18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/#184","text":"By Alex on February 1 st , 2008 | last modified by nascardriver on June 26 th , 2020 \u7ffb\u8bd1 by dashjay 2020-12-21 | last modified at 2020-12-21","title":"18.4 \u865a\u6784\u9020\u51fd\u6570\uff0c\u865a\u8d4b\u503c\uff0c\u91cd\u5199\u865a\u51fd\u6570"},{"location":"18-virtual-functions/18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/#_1","text":"\u5c3d\u7ba1C++\u4f1a\u5728\u4f60\u4e0d\u63d0\u4f9b\u7ed3\u6784\u51fd\u6570\u65f6\u9ed8\u8ba4\u63d0\u4f9b\u4e00\u4e2a\uff0c\u4f46\u662f\u4f60\u6709\u65f6\u8981\u4f53\u7528\u81ea\u5df1\u7684\u7ed3\u6784\u51fd\u6570\uff08\u5c24\u5176\u662f\u9700\u8981\u5206\u914d\u5185\u5b58\u7684\u7c7b\uff09\u3002\u4f60\u5e94\u8be5\u603b\u662f\u5c06\u6790\u6784\u51fd\u6570\uff0c\u8bbe\u7f6e\u4e3a\u865a\u51fd\u6570\uff0c\u5728\u5904\u7406\u96c6\u6210\u5173\u7cfb\u7684\u65f6\u5019\u3002\u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a #include <iostream> class Base { public : ~ Base () // note: not virtual { std :: cout << \"Calling ~Base() \\n \" ; } }; class Derived : public Base { private : int * m_array ; public : Derived ( int length ) : m_array { new int [ length ] } { } ~ Derived () // note: not virtual (your compiler may warn you about this) { std :: cout << \"Calling ~Derived() \\n \" ; delete [] m_array ; } }; int main () { Derived * derived { new Derived ( 5 ) }; Base * base { derived }; delete base ; return 0 ; } \u6ce8\u610f\uff1a\u5982\u679c\u4f60\u7f16\u8bd1\u4e86\u4e0a\u9762\u7684\u4f8b\u5b50\uff0c\u4f60\u7684\u7f16\u8bd1\u5668\u53ef\u80fd\u63d0\u793a\u4f60\u6709\u5173\u975e\u865a\u89e3\u6784\u51fd\u6570\uff08\u6545\u610f\u5728\u4f8b\u5b50\u4e2d\u5448\u73b0\u7684\uff09\u3002\u4f60\u4e5f\u53ef\u4ee5\u7981\u7528\u7f16\u8bd1\u5668\u7684 flag\uff0c\u8fd9\u6837\u53ef\u4ee5\u5c06 warnings \u89c6\u4e3a\u62a5\u9519\u6765\u6267\u884c\u3002 \u56e0\u4e3a base \u662f\u4e00\u4e2a Base \u6307\u9488\uff0c\u5f53 base \u88ab\u5220\u9664\u7684\u65f6\u5019\uff0c\u7a0b\u5e8f\u68c0\u67e5 Base \u89e3\u6784\u51fd\u6570\u662f\u865a\u51fd\u6570\u3002\u800c\u5b83\u5e76\u4e0d\u662f\uff0c\u6240\u4ee5\u5b83\u5047\u8bbe\u5b83\u53ea\u9700\u8981\u8c03\u7528 Base \u7c7b\u7684\u6790\u6784\u51fd\u6570\uff0c\u6211\u4eec\u542c\u8fc7\u4e0b\u9762\u7684\u8f93\u51fa\u6765\u4e86\u89e3\u8fd9\u4e2a\uff1a Calling ~ Base () However, we really want the delete function to call Derived\u2019s destructor (which will call Base\u2019s destructor in turn), otherwise m_array will not be deleted. We do this by making Base\u2019s destructor virtual: #include <iostream> class Base { public : virtual ~ Base () // note: virtual { std :: cout << \"Calling ~Base() \\n \" ; } }; class Derived : public Base { private : int * m_array ; public : Derived ( int length ) : m_array { new int [ length ] } { } virtual ~ Derived () // note: virtual { std :: cout << \"Calling ~Derived() \\n \" ; delete [] m_array ; } }; int main () { Derived * derived { new Derived ( 5 ) }; Base * base { derived }; delete base ; return 0 ; } \u8fd9\u4e2a\u7a0b\u5e8f\u4ea7\u751f\u4e0b\u5217\u6548\u679c\uff1a Calling ~ Derived () Calling ~ Base () \u89c4\u5219\uff1a\u65e0\u8bba\u4f60\u4f55\u65f6\u5904\u7406\u7ee7\u627f\uff0c\u4f60\u5e94\u8be5\u663e\u5f0f\u7684\u8bbe\u7f6e\u6790\u6784\u51fd\u6570\u4e3a\u865a\u51fd\u6570 \u4e0e\u666e\u901a\u865a\u51fd\u6570\u6210\u5458\u4e00\u6837\uff0c\u5982\u679c\u4e00\u4e2a\u57fa\u7c7b\u51fd\u6570\u662f\u865a\u51fd\u6570\uff0c\u6240\u6709\u7684\u7ee7\u627f\u91cd\u5199\u7c7b\u5c06\u4f1a\u88ab\u5f53\u505a\u865a\u51fd\u6570\uff0c\u65e0\u8bba\u4f60\u662f\u5426\u6307\u5b9a\u3002\u5982\u679c\u6d3e\u751f\u7c7b\u7684\u89e3\u6784\u51fd\u6570\u4e0d\u4e3a\u7a7a\uff0c\u5c31\u8bf7\u6807\u6ce8\u4e3a\u865a\u51fd\u6570\u3002","title":"\u865a\u6784\u9020\u51fd\u6570"},{"location":"18-virtual-functions/18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/#_2","text":"\u53ef\u4ee5\u5c06\u8d4b\u503c\u64cd\u4f5c\u7b26\u8bbe\u4e3a\u865a\u51fd\u503c\uff0c\u4e0d\u50cf\u6790\u6784\u51fd\u6570\u90a3\u6837\uff0c\u8bbe\u7f6e\u4e3a\u865a\u6784\u51fd\u6570\u603b\u662f\u4e00\u4e2a\u597d\u4e3b\u610f\uff0c\u5c06\u8d4b\u503c\u64cd\u4f5c\u7b26\u8bbe\u7f6e\u4e3a\u865a\u62df\u5316\u5c31\u5bb9\u6613\u5f15\u8d77\u5f88\u591abug\uff0c\u5e76\u4e14\u8fdb\u5165\u5728\u8fd9\u4e2a\u6559\u7a0b\u4e4b\u5916\u7684\u8bdd\u9898\u3002\u56e0\u6b64\uff0c\u4e3a\u4e86\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u5efa\u8bae\u4f60\u76ee\u524d\u5148\u8ba9\u865a\u51fd\u6570\u4e3a\u975e\u865a\u51fd\u6570\u3002","title":"\u865a\u8d4b\u503c\u65b9\u6cd5"},{"location":"18-virtual-functions/18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/#_3","text":"\u6709\u65f6\u5019\u4f60\u60f3\u8981\u5ffd\u7565\u4e00\u4e2a\u51fd\u6570\u7684\u865a\u5316\uff0c\u4f8b\u5982\uff0c\u770b\u770b\u4e0b\u9762\u7684\u4ee3\u7801\uff1a class Base { public : virtual const char * getName () const { return \"Base\" ; } }; class Derived : public Base { public : virtual const char * getName () const { return \"Derived\" ; } }; \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u4f60\u4e5f\u8bb8\u60f3\u8981\u4f7f\u7528\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u57fa\u7c7b\u6307\u9488\u8c03\u7528 Base::getName() \u800c\u4e0d\u662f Derived::getName() \u3002\u4e3a\u4e86\u8fd9\u6837\uff0c\u53ea\u9700\u8981\u7b80\u5355\u7684\u4f7f\u7528\u8303\u56f4\u89e3\u6790\u64cd\u4f5c\u7b26\uff1a #include <iostream> int main () { Derived derived ; const Base & base { derived }; // Calls Base::GetName() instead of the virtualized Derived::GetName() std :: cout << base . Base :: getName () << '\\n' ; return 0 ; } \u4f60\u4e5f\u8bb8\u4e0d\u4f1a\u7ecf\u5e38\u8fd9\u6837\u4f7f\u7528\uff0c\u4f46\u77e5\u9053\u4e5f\u8fd8\u662f\u4e0d\u9519\u7684\u3002","title":"\u5ffd\u7565\u865a\u51fd\u6570"},{"location":"18-virtual-functions/18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/#_4","text":"\u8fd9\u662f\u4e00\u4e2a\u65b0\u624b\u5e38\u95ee\u7684\u95ee\u9898\u3002\u6b63\u5982\u4e0a\u65b9\u4f8b\u5b50\u6240\u8bf4\uff0c\u5982\u679c\u57fa\u7c7b\u7ed3\u6784\u51fd\u6570\u6ca1\u6709\u6807\u6ce8\u4e3a\u865a\u51fd\u6570\uff0c\u7a0b\u5e8f\u5458\u7a0d\u540e\u5220\u9664\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u57fa\u7c7b\u6307\u9488\u65f6\u7a0b\u5e8f\u6709\u5185\u5b58\u6cc4\u9732\u7684\u98ce\u9669\u3002\u4e00\u4e2a\u907f\u514d\u7684\u65b9\u5f0f\u5c31\u662f\u5c06\u6240\u6709\u6790\u6784\u51fd\u6570\u6807\u6ce8\u4e3a\u865a\u51fd\u6570\uff0c\u4f46\u662f\u4f60\u5e94\u8be5\u90a3\u6837\u505a\u4e48\uff1f \u8bf4\u201d\u662f\u201c\u5f88\u5bb9\u6613\uff0c\u7136\u540e\u4f60\u7a0d\u540e\u4f7f\u7528\u4efb\u4f55\u7c7b\u4f5c\u4e3a\u4e00\u4e2a\u57fa\u7c7b \u2014\u2014 \u4f46\u8fd9\u6837\u505a\u5b58\u5728\u6027\u80fd\u4ee3\u4ef7\uff08\u4e00\u4e2a\u865a\u6307\u9488\u4f1a\u6dfb\u52a0\u5230\u6bcf\u4e2a\u7c7b\u7684\u5b9e\u4f8b\u4e2d\uff09\u3002\u56e0\u6b64\u4f60\u4e0d\u5f97\u4e0d\u5e73\u8861\u5f00\u9500\uff0c\u548c\u4f60\u7684\u610f\u56fe\u3002 \u4f20\u7edf\u7684\u667a\u6167\uff08\u6700\u521d\u7531 Herb Sutter \u63d0\u51fa\uff0c\u4e00\u4e2a\u5f88\u91cd\u8981\u7684 C++ \u8001\u5e08\uff09\u5efa\u8bae\u907f\u514d\u5982\u4e0b\u7684\u96c6\u4e2d\u975e\u865a\u51fd\u6570\u7ed3\u6784\u51fd\u6570\u5185\u5b58\u6cc4\u9732\u60c5\u51b5\uff0c\u201d\u4e00\u4e2a\u57fa\u7c7b\u7ed3\u6784\u51fd\u6570\u5e94\u8be5\u65e2\u662fpublic\u7684\u53c8\u662f\u865a\u51fd\u6570\uff0c\u6216\u8005 \u662fprotected \u4e14\u975e\u865a\u51fd\u6570\u3002\u201c\uff0c\u4e00\u4e2a\u5e26\u6709 protected \u89e3\u6784\u51fd\u6570\u7684\u7c7b\u5b9e\u4f8b\u4e0d\u80fd\u88ab\u901a\u8fc7\u6307\u9488\u6765\u5220\u9664\uff0c\u56e0\u6b64\u963b\u6b62\u4e86\u5f53\u4e00\u57fa\u7c7b\u6709\u975e\u865a\u6790\u6784\u51fd\u6570\u7684\u65f6\u5019\uff0c\u610f\u5916\u7684\u901a\u8fc7\u57fa\u7c7b\u6307\u9488\u5220\u9664\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u4e5f\u610f\u5473\u7740\u57fa\u7c7b\u4e0d\u80fd\u88ab\u901a\u8fc7\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u5220\u9664\uff0c\u57fa\u672c\u4e0a\u610f\u5473\u7740\u7c7b\u4e0d\u80fd\u88ab\u52a8\u6001\u5206\u914d\uff0c\u6216\u8005\u5982\u671f\u88ab\u6d3e\u751f\u7c7b\u5220\u9664\u3002\u8fd9\u4e5f\u6392\u9664\u4e86\u5728\u8fd9\u4e2a\u7c7b\u4e0a\u4f7f\u7528\u667a\u80fd\u6307\u9488\uff08\u4f8b\u5982 std::unique_ptr \u548c std::shared_ptr \uff09\uff0c\u9650\u5236\u4e86\u90a3\u4e2a\u89c4\u5219\uff08\u6211\u4eec\u5c06\u5728\u4e4b\u540e\u7684\u8bfe\u7a0b\u4e2d\u4ecb\u7ecd\u667a\u80fd\u6307\u9488\uff09\u7684\u53ef\u7528\u6027\u3002\u5b83\u4e5f\u610f\u5473\u7740\u57fa\u7c7b\u4e0d\u80fd\u88ab\u5728\u6808\u4e0a\u5206\u914d\u3002\u90a3\u662f\u4e00\u4e2a\u76f8\u5f53\u91cd\u7684\u4ee3\u4ef7\u3002 \uff08\u539f\u6587\u592a\u957f\uff09Conventional wisdom (as initially put forth by Herb Sutter, a highly regarded C++ guru) has suggested avoiding the non-virtual destructor memory leak situation as follows, \u201cA base class destructor should be either public and virtual, or protected and nonvirtual.\u201d A class with a protected destructor can\u2019t be deleted via a pointer, thus preventing the accidental deleting of a derived class through a base pointer when the base class has a non-virtual destructor. Unfortunately, this also means the base class can\u2019t be deleted through a base class pointer, which essentially means the class can\u2019t be dynamically allocated or deleted except by a derived class. This also precludes using smart pointers (such as std::unique_ptr and std::shared_ptr) for such classes, which limits the usefulness of that rule (we cover smart pointers in a later chapter). It also means the base class can\u2019t be allocated on the stack. That\u2019s a pretty heavy set of penalties. \u65e2\u7136 final \u63cf\u8ff0\u7b26\u5df2\u7ecf\u88ab\u5f15\u5165\u5230\u8fd9\u4e2a\u8bed\u8a00\uff0c\u6211\u4eec\u7684\u5efa\u8bae\u5982\u4e0b\uff1a \u5982\u679c\u4f60\u7684\u7c7b\u6253\u7b97\u88ab\u7ee7\u627f\uff0c\u8bf7\u786e\u4fdd\u6790\u6784\u51fd\u6570\u662f\u865a\u51fd\u6570\u3002 \u5982\u679c\u4f60\u7684\u7c7b\u4e0d\u6253\u7b97\u88ab\u7ee7\u627f\uff0c\u5c06\u4f60\u7684\u7c7b\u6807\u6ce8\u4e3a final\uff0c\u8fd9\u5c06\u4f1a\u963b\u6b62\u5176\u4ed6\u7c7b\u4e00\u5f00\u59cb\u5c31\u4ece\u8be5\u7c7b\u6d3e\u751f\uff0c\u4f46\u662f\u4e0d\u4f1a\u5bf9\u8be5\u7c7b\u672c\u8eab\u5e26\u6765\u4efb\u4f55\u9650\u5236","title":"\u6211\u4eec\u662f\u5426\u5e94\u8be5\u4f7f\u6240\u6709\u7ed3\u6784\u51fd\u6570\u4e3a\u865a\u51fd\u6570"},{"location":"18-virtual-functions/18.5-early-binding-and-late-binding/","text":"18.5 \u9884\u7ed1\u5b9a\u548c\u540e\u671f\u7ed1\u5b9a \u00b6 By Alex on February 7 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1\u4e8e dashjay 2020-12-24 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-24 \u5728\u8fd9\u4e00\u8282\u548c\u4e0b\u4e00\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8fdb\u4e00\u6b65\u770b\u770b\u865a\u51fd\u6570\u600e\u4e48\u88ab\u5b9e\u73b0\u7684\uff0c\u5f53\u7136\u8fd9\u4e9b\u77e5\u8bc6\u5e76\u4e0d\u662f\u4e25\u683c\u5fc5\u987b\u7684\uff0c\u4ec5\u4ec5\u53ea\u662f\u4f5c\u4e3a\u5174\u8da3\u5f00\u62d3\u3002\u65e2\u7136\u5982\u6b64\uff0c\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u8fd9\u4e24\u8282\u662f\u9009\u8bfb\u3002 \u5f53\u4e00\u4e2a C++ \u7a0b\u5e8f\u88ab\u6267\u884c\uff0c\u5b83\u6309\u987a\u5e8f\u6267\u884c\uff0c\u5f00\u59cb\u4e8e main() \u3002\u5f53\u9047\u5230\u51fd\u6570\u8c03\u7528\u7684\u65f6\u5019\uff0c\u6267\u884c\u70b9\u8df3\u5230\u4e86\u88ab\u8c03\u7528\u51fd\u6570\u5f00\u59cb\u7684\u5730\u65b9\u3002CPU\u662f\u5982\u4f55\u77e5\u9053\u8fd9\u4e2a\u7684\u5462\uff1f \u5f53\u4e00\u4e2a\u7a0b\u5e8f\u88ab\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u8f6c\u5316\u6bcf\u4e00\u4e2a C++ \u7a0b\u5e8f\u4e2d\u7684\u8bed\u53e5\u6210\u4e3a\u4e00\u884c\u6216\u8005\u591a\u884c\u673a\u5668\u8bed\u8a00\u3002\u6bcf\u4e00\u884c\u673a\u5668\u8bed\u8a00\u7ed9\u4e86\u6709\u4e00\u4e2a\u4ed6\u81ea\u5df1\u7684\u5730\u5740\u3002\u6bcf\u4e2a\u51fd\u6570\u6ca1\u4ec0\u4e48\u4e0d\u540c \u2014\u2014 \u5f53\u9047\u5230\u4e00\u4e2a\u51fd\u6570\u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u8f6c\u5316\u6210\u673a\u5668\u8bed\u8a00\u5e76\u4e14\u63d0\u4f9b\u4e0b\u4e00\u4e2a\u53ef\u7528\u7684\u5730\u5740\uff0c\u56e0\u6b64\uff0c\u6bcf\u4e2a\u51fd\u6570\u7ed3\u675f\u4e8e\u4e00\u4e2a\u72ec\u7279\u7684\u5730\u5740\u3002 \u7ed1\u5b9a\u662f\u6307\u8fdb\u7a0b\u7528\u4e8e\u8f6c\u6362\u6807\u8bc6\u7b26\uff08\u4f8b\u5982\u53d8\u91cf\u548c\u51fd\u6570\u540d\u79f0\uff09\u5230\u5730\u5740\u7684\u8fc7\u7a0b\u3002\u5c3d\u7ba1\u7ed1\u5b9a\u540c\u65f6\u4f5c\u7528\u4e8e\u53d8\u91cf\u548c\u51fd\u6570\uff0c\u5728\u8fd9\u8282\u8bfe\u4e2d\u6211\u6211\u4eec\u4e3b\u8981\u5173\u6ce8\u51fd\u6570\u7684\u7ed1\u5b9a\u3002 \u65e9\u671f\u7ed1\u5b9a\uff08Early binding\uff09 \u00b6 \u7f16\u8bd1\u5668\u9047\u5230\u7684\u5927\u591a\u6570\u51fd\u6570\u8c03\u7528\u5c06\u4f1a\u76f4\u63a5\u6307\u5411\u51fd\u6570\u8c03\u7528\u3002\u4e00\u4e2a\u76f4\u63a5\u8c03\u7528\u662f\u4e00\u4e2a\u8bed\u53e5\u76f4\u63a5\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\uff0c\u4f8b\u5982\uff1a #include <iostream> void printValue ( int value ) { std :: cout << value ; } int main () { printValue ( 5 ); // This is a direct function call return 0 ; } \u76f4\u63a5\u8c03\u7528\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u79f0\u4e3a\u65e9\u671f\u7ed1\u5b9a\u7684\u8fc7\u7a0b\u6765\u89e3\u51b3\u3002\u65e9\u671f\u7ed1\u5b9a\uff08\u4e5f\u6210\u4e3a static binding\u3010\u9759\u6001\u7ed1\u5b9a\u3011\uff09\u610f\u5473\u7740\u7f16\u8bd1\u5668\uff08\u6216\u8005\u94fe\u63a5\u5668\uff09\u80fd\u591f\u76f4\u63a5\u5173\u8054\u6807\u8bc6\u7b26\u540d\u79f0\uff08\u4f8b\u5982\u51fd\u6570\u6216\u8005\u53d8\u91cf\uff09\u548c\u4e00\u4e2a\u673a\u5668\u5730\u5740\u3002\u6ce8\u610f\u6240\u6709\u7684\u51fd\u6570\u8c03\u7528\u6709\u72ec\u4e00\u65e0\u4e8c\u7684\u5730\u5740\u3002\u56e0\u6b64\u5f53\u4e00\u4e2a\u7f16\u8bd1\u5668\uff08\u6216\u8005\u94fe\u63a5\u5668\uff09\u9047\u5230\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\uff0c\u4ed6\u5c31\u7528\u4e00\u4e2a\u673a\u5668\u6307\u4ee4\u66ff\u6362\u51fd\u6570\u8c03\u7528\uff0c\u544a\u8bc9 CPU \u8df3\u5230\u51fd\u6570\u8c03\u7528\u7684\u5730\u65b9\u3002 \u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u4f7f\u7528\u65e9\u671f\u7ed1\u5b9a\u7684\u7b80\u5355\u8ba1\u7b97\u5668\u7a0b\u5e8f\uff1a #include <iostream> int add ( int x , int y ) { return x + y ; } int subtract ( int x , int y ) { return x - y ; } int multiply ( int x , int y ) { return x * y ; } int main () { int x ; std :: cout << \"Enter a number: \" ; std :: cin >> x ; int y ; std :: cout << \"Enter another number: \" ; std :: cin >> y ; int op ; do { std :: cout << \"Enter an operation (0=add, 1=subtract, 2=multiply): \" ; std :: cin >> op ; } while ( op < 0 || op > 2 ); int result = 0 ; switch ( op ) { // call the target function directly using early binding case 0 : result = add ( x , y ); break ; case 1 : result = subtract ( x , y ); break ; case 2 : result = multiply ( x , y ); break ; } std :: cout << \"The answer is: \" << result << std :: endl ; return 0 ; } \u56e0\u4e3a add(), substract() and multiply() \u90fd\u662f\u76f4\u63a5\u8c03\u7528\uff0c\u7f16\u8bd1\u5668\u5c06\u4f1a\u65e9\u671f\u7ed1\u5b9a\u6765\u89e3\u6790 add(), abstract(), multiply() \u51fd\u6570\u8c03\u7528\u3002\u7f16\u8bd1\u5668\u5c06\u4f1a\u7528\u4e00\u4e2a\u6307\u4ee4\u6765\u66ff\u6362 add() \u51fd\u6570\u8c03\u7528\uff0c\u90a3\u4f1a\u544a\u8bc9 CPU \u8df3\u5230 add() \u51fd\u6570\u7684\u6267\u884c\u3002\u540c\u6837\u7684\u9053\u7406\u4e5f\u9002\u7528\u4e8e substract() \u548c multiply() \u3002 \u5ef6\u8fdf\u7ed1\u5b9a\uff08Late Binding\uff09 \u00b6 \u5728\u540c\u6837\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4e0d\u5230\u8fd0\u884c\u65f6\uff08\u5f53\u7a0b\u5e8f\u8fd0\u884c\u7684\u65f6\u5019\uff09\u4e0d\u77e5\u9053\u8c03\u7528\u4e86\u54ea\u4e2a\u51fd\u6570\u3002\u8fd9\u88ab\u79f0\u4e3a\u540e\u671f\u7ed1\u5b9a\uff08\u6216\u8005\u52a8\u6001\u7ed1\u5b9a\uff09\u3002\u5728 C++ \u4e2d\uff0c\u540e\u671f\u7ed1\u5b9a\u7684\u552f\u4e00\u65b9\u5f0f\u662f\u4f7f\u7528\u51fd\u6570\u6307\u9488\u3002\u6765\u7b80\u5355\u7684\u56de\u5fc6\u4e00\u4e0b\u51fd\u6570\u6307\u9488\uff0c\u51fd\u6570\u6307\u9488\u662f\u4e00\u79cd\u6307\u9488\u6307\u5411\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u53d8\u91cf\u3002\u51fd\u6570\u6307\u9488\u6307\u5411\u7684\u51fd\u6570\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u51fd\u6570\u8c03\u7528\u64cd\u4f5c\u7b26\u6765\u8c03\u7528\uff0c\u901a\u8fc7\u90a3\u4e2a\u6307\u9488\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u51fd\u6570\u8c03\u7528 add() \u51fd\u6570\uff1a #include <iostream> int add ( int x , int y ) { return x + y ; } int main () { // Create a function pointer and make it point to the add function int ( * pFcn )( int , int ) = add ; std :: cout << pFcn ( 5 , 3 ) << std :: endl ; // add 5 + 3 return 0 ; } \u901a\u8fc7\u51fd\u6570\u6307\u9488\u8c03\u7528\u4e5f\u88ab\u770b\u505a\u4e00\u79cd\u95f4\u63a5\u8c03\u7528\u3002\u4e0b\u9762\u7684\u8ba1\u7b97\u673a\u7a0b\u5e8f\u5c31\u662f\u548c\u4e4b\u524d\u529f\u80fd\u76f8\u540c\u7684\u3002\u5c31\u662f\u4f7f\u7528\u4e86\u51fd\u6570\u6307\u9488\u800c\u4e0d\u662f\u76f4\u63a5\u8c03\u7528\uff1a #include <iostream> int add ( int x , int y ) { return x + y ; } int subtract ( int x , int y ) { return x - y ; } int multiply ( int x , int y ) { return x * y ; } int main () { int x ; std :: cout << \"Enter a number: \" ; std :: cin >> x ; int y ; std :: cout << \"Enter another number: \" ; std :: cin >> y ; int op ; do { std :: cout << \"Enter an operation (0=add, 1=subtract, 2=multiply): \" ; std :: cin >> op ; } while ( op < 0 || op > 2 ); // Create a function pointer named pFcn (yes, the syntax is ugly) int ( * pFcn )( int , int ) = nullptr ; // Set pFcn to point to the function the user chose switch ( op ) { case 0 : pFcn = add ; break ; case 1 : pFcn = subtract ; break ; case 2 : pFcn = multiply ; break ; } // Call the function that pFcn is pointing to with x and y as parameters // This uses late binding std :: cout << \"The answer is: \" << pFcn ( x , y ) << std :: endl ; return 0 ; } \u5728\u8fd9\u4e2a\u4f8b\u5b50\u5f53\u4e2d\uff0c\u6211\u4eec\u76f4\u63a5\u5c06 pFcn \u6307\u9488\u7684\u6307\u5411\u4e86\u6211\u4eec\u5e0c\u671b\u8c03\u7528\u7684\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u8c03\u7528 add(), substract(), multiply() \u7b49\u51fd\u6570\u3002\u7d27\u63a5\u7740\u6211\u4eec\u8c03\u7528\u51fd\u6570\u901a\u8fc7\u6307\u9488\uff0c\u7f16\u8bd1\u5668\u4e0d\u80fd\u901a\u8fc7\u65e9\u671f\u7ed1\u5b9a\u6765\u51b3\u5b9a\u51fd\u6570\u7684\u89e3\u6790 pFcn(x, y) \u56e0\u4e3a\u4e0d\u80fd\u5728\u7f16\u8bd1\u671f\u95f4\u544a\u8bc9\u51fd\u6570\u6307\u9488 pFcn \u6307\u5411\u54ea\u4e2a\u51fd\u6570\uff01 \u540e\u671f\u7ed1\u5b9a\u8f7b\u5fae\u7684\u4f4e\u6548\uff0c\u56e0\u4e3a\u5b83\u5f15\u5165\u4e86\u4e00\u5c42\u800c\u5916\u7684\u91cd\u5b9a\u5411\u3002\u4f7f\u7528\u65e9\u7ed1\u5b9a\uff0cCPU\u53ef\u4ee5\u76f4\u63a5\u8df3\u5230\u51fd\u6570\u7684\u5730\u5740\u3002\u4f7f\u7528\u665a\u671f\u7ed1\u5b9a\uff0c\u7a0b\u5e8f\u5fc5\u987b\u8bfb\u53d6\u6307\u9488\u6307\u5411\u7684\u5730\u5740\u624d\u80fd\u8df3\u8fc7\u53bb\u3002\u8fd9\u5f15\u5165\u4e86\u800c\u5916\u7684\u4e00\u90e8\uff0c\u4f7f\u5f97\u7a0b\u5e8f\u66f4\u6162\u4e86\u3002\u7136\u800c\u665a\u671f\u7ed1\u5b9a\u7684\u4f18\u70b9\u5c31\u662f\u80fd\u9694\u5e74\u7075\u6d3b\uff0c\u76f8\u6bd4\u4e8e\u65e9\u671f\u7ed1\u5b9a\uff0c\u56e0\u4e3a\u51b3\u5b9a\u8981\u8c03\u7528\u54ea\u4e2a\u51fd\u6570\u6307\u5bfc\u8fd0\u884c\u65f6\u624d\u9700\u8981\u786e\u5b9a\u3002 \u5728\u4e0b\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u4f1a\u770b\u4e00\u773c\u540e\u671f\u7ed1\u5b9a\u5982\u4f55\u5b9e\u73b0\u865a\u51fd\u6570\u3002","title":"18.5 \u9884\u7ed1\u5b9a\u548c\u540e\u671f\u7ed1\u5b9a"},{"location":"18-virtual-functions/18.5-early-binding-and-late-binding/#185","text":"By Alex on February 7 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1\u4e8e dashjay 2020-12-24 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-24 \u5728\u8fd9\u4e00\u8282\u548c\u4e0b\u4e00\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8fdb\u4e00\u6b65\u770b\u770b\u865a\u51fd\u6570\u600e\u4e48\u88ab\u5b9e\u73b0\u7684\uff0c\u5f53\u7136\u8fd9\u4e9b\u77e5\u8bc6\u5e76\u4e0d\u662f\u4e25\u683c\u5fc5\u987b\u7684\uff0c\u4ec5\u4ec5\u53ea\u662f\u4f5c\u4e3a\u5174\u8da3\u5f00\u62d3\u3002\u65e2\u7136\u5982\u6b64\uff0c\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u8fd9\u4e24\u8282\u662f\u9009\u8bfb\u3002 \u5f53\u4e00\u4e2a C++ \u7a0b\u5e8f\u88ab\u6267\u884c\uff0c\u5b83\u6309\u987a\u5e8f\u6267\u884c\uff0c\u5f00\u59cb\u4e8e main() \u3002\u5f53\u9047\u5230\u51fd\u6570\u8c03\u7528\u7684\u65f6\u5019\uff0c\u6267\u884c\u70b9\u8df3\u5230\u4e86\u88ab\u8c03\u7528\u51fd\u6570\u5f00\u59cb\u7684\u5730\u65b9\u3002CPU\u662f\u5982\u4f55\u77e5\u9053\u8fd9\u4e2a\u7684\u5462\uff1f \u5f53\u4e00\u4e2a\u7a0b\u5e8f\u88ab\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u8f6c\u5316\u6bcf\u4e00\u4e2a C++ \u7a0b\u5e8f\u4e2d\u7684\u8bed\u53e5\u6210\u4e3a\u4e00\u884c\u6216\u8005\u591a\u884c\u673a\u5668\u8bed\u8a00\u3002\u6bcf\u4e00\u884c\u673a\u5668\u8bed\u8a00\u7ed9\u4e86\u6709\u4e00\u4e2a\u4ed6\u81ea\u5df1\u7684\u5730\u5740\u3002\u6bcf\u4e2a\u51fd\u6570\u6ca1\u4ec0\u4e48\u4e0d\u540c \u2014\u2014 \u5f53\u9047\u5230\u4e00\u4e2a\u51fd\u6570\u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u8f6c\u5316\u6210\u673a\u5668\u8bed\u8a00\u5e76\u4e14\u63d0\u4f9b\u4e0b\u4e00\u4e2a\u53ef\u7528\u7684\u5730\u5740\uff0c\u56e0\u6b64\uff0c\u6bcf\u4e2a\u51fd\u6570\u7ed3\u675f\u4e8e\u4e00\u4e2a\u72ec\u7279\u7684\u5730\u5740\u3002 \u7ed1\u5b9a\u662f\u6307\u8fdb\u7a0b\u7528\u4e8e\u8f6c\u6362\u6807\u8bc6\u7b26\uff08\u4f8b\u5982\u53d8\u91cf\u548c\u51fd\u6570\u540d\u79f0\uff09\u5230\u5730\u5740\u7684\u8fc7\u7a0b\u3002\u5c3d\u7ba1\u7ed1\u5b9a\u540c\u65f6\u4f5c\u7528\u4e8e\u53d8\u91cf\u548c\u51fd\u6570\uff0c\u5728\u8fd9\u8282\u8bfe\u4e2d\u6211\u6211\u4eec\u4e3b\u8981\u5173\u6ce8\u51fd\u6570\u7684\u7ed1\u5b9a\u3002","title":"18.5 \u9884\u7ed1\u5b9a\u548c\u540e\u671f\u7ed1\u5b9a"},{"location":"18-virtual-functions/18.5-early-binding-and-late-binding/#early-binding","text":"\u7f16\u8bd1\u5668\u9047\u5230\u7684\u5927\u591a\u6570\u51fd\u6570\u8c03\u7528\u5c06\u4f1a\u76f4\u63a5\u6307\u5411\u51fd\u6570\u8c03\u7528\u3002\u4e00\u4e2a\u76f4\u63a5\u8c03\u7528\u662f\u4e00\u4e2a\u8bed\u53e5\u76f4\u63a5\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\uff0c\u4f8b\u5982\uff1a #include <iostream> void printValue ( int value ) { std :: cout << value ; } int main () { printValue ( 5 ); // This is a direct function call return 0 ; } \u76f4\u63a5\u8c03\u7528\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u79f0\u4e3a\u65e9\u671f\u7ed1\u5b9a\u7684\u8fc7\u7a0b\u6765\u89e3\u51b3\u3002\u65e9\u671f\u7ed1\u5b9a\uff08\u4e5f\u6210\u4e3a static binding\u3010\u9759\u6001\u7ed1\u5b9a\u3011\uff09\u610f\u5473\u7740\u7f16\u8bd1\u5668\uff08\u6216\u8005\u94fe\u63a5\u5668\uff09\u80fd\u591f\u76f4\u63a5\u5173\u8054\u6807\u8bc6\u7b26\u540d\u79f0\uff08\u4f8b\u5982\u51fd\u6570\u6216\u8005\u53d8\u91cf\uff09\u548c\u4e00\u4e2a\u673a\u5668\u5730\u5740\u3002\u6ce8\u610f\u6240\u6709\u7684\u51fd\u6570\u8c03\u7528\u6709\u72ec\u4e00\u65e0\u4e8c\u7684\u5730\u5740\u3002\u56e0\u6b64\u5f53\u4e00\u4e2a\u7f16\u8bd1\u5668\uff08\u6216\u8005\u94fe\u63a5\u5668\uff09\u9047\u5230\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\uff0c\u4ed6\u5c31\u7528\u4e00\u4e2a\u673a\u5668\u6307\u4ee4\u66ff\u6362\u51fd\u6570\u8c03\u7528\uff0c\u544a\u8bc9 CPU \u8df3\u5230\u51fd\u6570\u8c03\u7528\u7684\u5730\u65b9\u3002 \u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u4f7f\u7528\u65e9\u671f\u7ed1\u5b9a\u7684\u7b80\u5355\u8ba1\u7b97\u5668\u7a0b\u5e8f\uff1a #include <iostream> int add ( int x , int y ) { return x + y ; } int subtract ( int x , int y ) { return x - y ; } int multiply ( int x , int y ) { return x * y ; } int main () { int x ; std :: cout << \"Enter a number: \" ; std :: cin >> x ; int y ; std :: cout << \"Enter another number: \" ; std :: cin >> y ; int op ; do { std :: cout << \"Enter an operation (0=add, 1=subtract, 2=multiply): \" ; std :: cin >> op ; } while ( op < 0 || op > 2 ); int result = 0 ; switch ( op ) { // call the target function directly using early binding case 0 : result = add ( x , y ); break ; case 1 : result = subtract ( x , y ); break ; case 2 : result = multiply ( x , y ); break ; } std :: cout << \"The answer is: \" << result << std :: endl ; return 0 ; } \u56e0\u4e3a add(), substract() and multiply() \u90fd\u662f\u76f4\u63a5\u8c03\u7528\uff0c\u7f16\u8bd1\u5668\u5c06\u4f1a\u65e9\u671f\u7ed1\u5b9a\u6765\u89e3\u6790 add(), abstract(), multiply() \u51fd\u6570\u8c03\u7528\u3002\u7f16\u8bd1\u5668\u5c06\u4f1a\u7528\u4e00\u4e2a\u6307\u4ee4\u6765\u66ff\u6362 add() \u51fd\u6570\u8c03\u7528\uff0c\u90a3\u4f1a\u544a\u8bc9 CPU \u8df3\u5230 add() \u51fd\u6570\u7684\u6267\u884c\u3002\u540c\u6837\u7684\u9053\u7406\u4e5f\u9002\u7528\u4e8e substract() \u548c multiply() \u3002","title":"\u65e9\u671f\u7ed1\u5b9a\uff08Early binding\uff09"},{"location":"18-virtual-functions/18.5-early-binding-and-late-binding/#late-binding","text":"\u5728\u540c\u6837\u7684\u7a0b\u5e8f\u4e2d\uff0c\u4e0d\u5230\u8fd0\u884c\u65f6\uff08\u5f53\u7a0b\u5e8f\u8fd0\u884c\u7684\u65f6\u5019\uff09\u4e0d\u77e5\u9053\u8c03\u7528\u4e86\u54ea\u4e2a\u51fd\u6570\u3002\u8fd9\u88ab\u79f0\u4e3a\u540e\u671f\u7ed1\u5b9a\uff08\u6216\u8005\u52a8\u6001\u7ed1\u5b9a\uff09\u3002\u5728 C++ \u4e2d\uff0c\u540e\u671f\u7ed1\u5b9a\u7684\u552f\u4e00\u65b9\u5f0f\u662f\u4f7f\u7528\u51fd\u6570\u6307\u9488\u3002\u6765\u7b80\u5355\u7684\u56de\u5fc6\u4e00\u4e0b\u51fd\u6570\u6307\u9488\uff0c\u51fd\u6570\u6307\u9488\u662f\u4e00\u79cd\u6307\u9488\u6307\u5411\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u53d8\u91cf\u3002\u51fd\u6570\u6307\u9488\u6307\u5411\u7684\u51fd\u6570\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u51fd\u6570\u8c03\u7528\u64cd\u4f5c\u7b26\u6765\u8c03\u7528\uff0c\u901a\u8fc7\u90a3\u4e2a\u6307\u9488\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u51fd\u6570\u8c03\u7528 add() \u51fd\u6570\uff1a #include <iostream> int add ( int x , int y ) { return x + y ; } int main () { // Create a function pointer and make it point to the add function int ( * pFcn )( int , int ) = add ; std :: cout << pFcn ( 5 , 3 ) << std :: endl ; // add 5 + 3 return 0 ; } \u901a\u8fc7\u51fd\u6570\u6307\u9488\u8c03\u7528\u4e5f\u88ab\u770b\u505a\u4e00\u79cd\u95f4\u63a5\u8c03\u7528\u3002\u4e0b\u9762\u7684\u8ba1\u7b97\u673a\u7a0b\u5e8f\u5c31\u662f\u548c\u4e4b\u524d\u529f\u80fd\u76f8\u540c\u7684\u3002\u5c31\u662f\u4f7f\u7528\u4e86\u51fd\u6570\u6307\u9488\u800c\u4e0d\u662f\u76f4\u63a5\u8c03\u7528\uff1a #include <iostream> int add ( int x , int y ) { return x + y ; } int subtract ( int x , int y ) { return x - y ; } int multiply ( int x , int y ) { return x * y ; } int main () { int x ; std :: cout << \"Enter a number: \" ; std :: cin >> x ; int y ; std :: cout << \"Enter another number: \" ; std :: cin >> y ; int op ; do { std :: cout << \"Enter an operation (0=add, 1=subtract, 2=multiply): \" ; std :: cin >> op ; } while ( op < 0 || op > 2 ); // Create a function pointer named pFcn (yes, the syntax is ugly) int ( * pFcn )( int , int ) = nullptr ; // Set pFcn to point to the function the user chose switch ( op ) { case 0 : pFcn = add ; break ; case 1 : pFcn = subtract ; break ; case 2 : pFcn = multiply ; break ; } // Call the function that pFcn is pointing to with x and y as parameters // This uses late binding std :: cout << \"The answer is: \" << pFcn ( x , y ) << std :: endl ; return 0 ; } \u5728\u8fd9\u4e2a\u4f8b\u5b50\u5f53\u4e2d\uff0c\u6211\u4eec\u76f4\u63a5\u5c06 pFcn \u6307\u9488\u7684\u6307\u5411\u4e86\u6211\u4eec\u5e0c\u671b\u8c03\u7528\u7684\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u8c03\u7528 add(), substract(), multiply() \u7b49\u51fd\u6570\u3002\u7d27\u63a5\u7740\u6211\u4eec\u8c03\u7528\u51fd\u6570\u901a\u8fc7\u6307\u9488\uff0c\u7f16\u8bd1\u5668\u4e0d\u80fd\u901a\u8fc7\u65e9\u671f\u7ed1\u5b9a\u6765\u51b3\u5b9a\u51fd\u6570\u7684\u89e3\u6790 pFcn(x, y) \u56e0\u4e3a\u4e0d\u80fd\u5728\u7f16\u8bd1\u671f\u95f4\u544a\u8bc9\u51fd\u6570\u6307\u9488 pFcn \u6307\u5411\u54ea\u4e2a\u51fd\u6570\uff01 \u540e\u671f\u7ed1\u5b9a\u8f7b\u5fae\u7684\u4f4e\u6548\uff0c\u56e0\u4e3a\u5b83\u5f15\u5165\u4e86\u4e00\u5c42\u800c\u5916\u7684\u91cd\u5b9a\u5411\u3002\u4f7f\u7528\u65e9\u7ed1\u5b9a\uff0cCPU\u53ef\u4ee5\u76f4\u63a5\u8df3\u5230\u51fd\u6570\u7684\u5730\u5740\u3002\u4f7f\u7528\u665a\u671f\u7ed1\u5b9a\uff0c\u7a0b\u5e8f\u5fc5\u987b\u8bfb\u53d6\u6307\u9488\u6307\u5411\u7684\u5730\u5740\u624d\u80fd\u8df3\u8fc7\u53bb\u3002\u8fd9\u5f15\u5165\u4e86\u800c\u5916\u7684\u4e00\u90e8\uff0c\u4f7f\u5f97\u7a0b\u5e8f\u66f4\u6162\u4e86\u3002\u7136\u800c\u665a\u671f\u7ed1\u5b9a\u7684\u4f18\u70b9\u5c31\u662f\u80fd\u9694\u5e74\u7075\u6d3b\uff0c\u76f8\u6bd4\u4e8e\u65e9\u671f\u7ed1\u5b9a\uff0c\u56e0\u4e3a\u51b3\u5b9a\u8981\u8c03\u7528\u54ea\u4e2a\u51fd\u6570\u6307\u5bfc\u8fd0\u884c\u65f6\u624d\u9700\u8981\u786e\u5b9a\u3002 \u5728\u4e0b\u8282\u8bfe\u4e2d\uff0c\u6211\u4eec\u4f1a\u770b\u4e00\u773c\u540e\u671f\u7ed1\u5b9a\u5982\u4f55\u5b9e\u73b0\u865a\u51fd\u6570\u3002","title":"\u5ef6\u8fdf\u7ed1\u5b9a\uff08Late Binding\uff09"},{"location":"18-virtual-functions/18.6-the-virtual-table/","text":"18.6 \u865a\u8868 \u00b6 By Alex on February 8 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 by dashjay 2020-12-24 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-24 \u4e3a\u4e86\u5b9e\u73b0\u865a\u51fd\u6570\uff0cC++ \u4f7f\u7528\u4e86\u4e00\u79cd\u7279\u6b8a\u7684\u5f62\u5f0f\u7684\u540e\u671f\u7ed1\u5b9a\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u6240\u4e86\u89e3\u7684\u865a\u8868\u3002\u865a\u8868\u662f\u4e00\u4e2a\u51fd\u6570\u5feb\u901f\u67e5\u8be2\u8868\uff0c\u7528\u6765\u5728\u540e\u671f\u7ed1\u5b9a\u7684\u65b9\u5f0f\u89e3\u6790\u51fd\u6570\u8c03\u7528\u3002\u865a\u8868\u6709\u65f6\u5019\u4e5f\u53eb\u5176\u4ed6\u540d\u5b57\uff0c\u4f8b\u5982 \"vtable\", \"virtual function table\", \"virtual method table\" \u6216\u8005 \"dispatch table\"\u3002 \u56e0\u4e3a\u77e5\u9053\u865a\u51fd\u6570\u5982\u4f55\u5de5\u4f5c\u6ca1\u6709\u5fc5\u8981\u4f7f\u7528\u865a\u51fd\u6570\uff0c\u8fd9\u90e8\u5206\u53ef\u4ee5\u5f53\u505a\u9009\u8bfb\u3002 \u865a\u8868\u5b9e\u9645\u4e0a\u975e\u5e38\u7b80\u5355\uff0c\u867d\u7136\u7528\u8bed\u8a00\u63cf\u8ff0\u8d77\u6765\u6709\u70b9\u590d\u6742\u3002\u9996\u5148\uff0c\u6bcf\u4e2a\u4f7f\u7528\u865a\u51fd\u6570\u7684\u7c7b\uff08\u6216\u8005\u7ee7\u627f\u4e86\u53c8\u865a\u51fd\u6570\u7684\u7c7b\uff09\u90fd\u4f1a\u6709\u4ed6\u7684\u865a\u8868\u3002\u8fd9\u4e2a\u8868\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u9759\u6001\u6570\u7ec4\uff0c\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u5c31\u9884\u7559\u597d\u4e86\u3002\u4e00\u4e2a\u865a\u8868\u5305\u542b\u4e86\u6bcf\u4e00\u4e2a\u53ef\u4ee5\u88ab\u901a\u8fc7\u7c7b\u7684\u5bf9\u8c61\u8c03\u7528\u7684\u865a\u51fd\u6570\u7684\u5165\u53e3\u3002\u8868\u4e2d\u7684\u6bcf\u4e2a\u5165\u53e3\u90fd\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u51fd\u6570\u6307\u9488\u6307\u5411\u4e86\u8be5\u7c7b\u80fd\u521d\u7ea7\u7684\u6700\u7ec8\u6d3e\u751f\u7684\u51fd\u6570\u3002 \u5176\u6b21\uff0c\u7f16\u8bd1\u5668\u4e5f\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u9690\u85cf\u7684\u6307\u9488\u5230\u57fa\u7c7b\u4e2d\uff0c\u6211\u4eec\u53eb\u4ed6 *__vptr. \u3002\u5f53\u4e00\u4e2a\u7c7b\u5b9e\u4f8b\u521b\u5efa\u65f6\uff0c *__vptr \u88ab\u81ea\u52a8\u8bbe\u7f6e\uff0c\u4ee5\u4fbf\u5b83\u6307\u5411\u90a3\u4e2a\u7c7b\u5b9e\u4f8b\u7684\u865a\u8868\u3002\u4e0d\u50cf *this \u6307\u9488\uff0c\u4f1a\u81ea\u52a8\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\uff0c\u80fd\u591f\u8ba9\u7f16\u8bd1\u5668\u89e3\u6790\u81ea\u5df1\uff0c *__vptr \u662f\u4e00\u4e2a\u771f\u5b9e\u7684\u6307\u9488\u3002\u56e0\u6b64\uff0c\u5b83\u4f7f\u5f97\u6bcf\u4e2a\u7c7b\u5bf9\u8c61\u5206\u914d\u6bd4\u81ea\u5df1\u7a0d\u5fae\u5927\u4e00\u4e9b\u7684\u7a7a\u95f4\u3002\u8fd9\u610f\u5473\u7740 *__vptr \u80fd\u88ab\u6d3e\u751f\u7c7b\u7ee7\u627f\uff0c\u975e\u5e38\u91cd\u8981\u3002 \u73b0\u5728\uff0c\u4f60\u53ef\u80fd\u7591\u60d1\u8fd9\u4e9b\u4e1c\u897f\u662f\u5982\u4f55\u642d\u914d\u5728\u4e00\u8d77\u7684\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a class Base { public : virtual void function1 () {}; virtual void function2 () {}; }; class D1 : public Base { public : virtual void function1 () {}; }; class D2 : public Base { public : virtual void function2 () {}; }; \u56e0\u4e3a\u8fd9\u91cc\u6709\u4e09\u4e2a\u7c7b\uff0c\u7f16\u8bd1\u5668\u4f1a\u8bbe\u7f6e3\u4e2a\u865a\u8868\uff1a\u4e00\u4e2a\u7ed9 Base\uff0c\u4e00\u4e2a\u7ed9 D1\uff0c\u53e6\u4e00\u4e2a\u7ed9 D2\u3002 \u7f16\u8bd1\u5668\u4e5f\u6dfb\u52a0\u4e86\u4e00\u4e2a\u9690\u85cf\u7684\u6307\u9488\u5230\u4f7f\u7528\u865a\u51fd\u6570\u7684\u6700\u57fa\u7c7b\u3002\u5c3d\u7ba1\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u5b9e\u73b0\uff0c\u6211\u4eec\u4e5f\u4f1a\u5728\u4e0b\u4e00\u4e2a\u4f8b\u5b50\u4e2d\u5c55\u793a\u5b83\u6dfb\u52a0\u5728\u54ea\u91cc\uff1a class Base { public : FunctionPointer * __vptr ; virtual void function1 () {}; virtual void function2 () {}; }; class D1 : public Base { public : virtual void function1 () {}; }; class D2 : public Base { public : virtual void function2 () {}; }; \u5f53\u4e00\u4e2a\u7c7b\u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c *__vptr \u88ab\u6307\u5411\u8be5\u7c7b\u7684\u865a\u8868\u3002\u4f8b\u5982\uff0c\u5f53\u4e00\u4e2a\u57fa\u7c7b\u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c *__vptr \u88ab\u6307\u5411\u57fa\u7c7b\u7684\u865a\u8868\u3002\u5f53\u5bf9\u8c61 D1 \u6216 D2 \u88ab\u6784\u5efa\u7684\u65f6\u5019\uff0c *__vptr \u5206\u522b\u6307\u5411\u4e86 D1 \u6216\u8005 D2\u7684\u865a\u8868\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u8ba8\u8bba\u4e00\u4e0b\u865a\u8868\u5982\u4f55\u88ab\u586b\u5145\u7684\u3002\u56e0\u4e3a\u6709\u4e24\u4e2a\u865a\u51fd\u6570\uff0c\u56e0\u6b64\u6bcf\u4e2a\u865a\u8868\u5c06\u4f1a\u6709\u4e24\u4e2a\u5165\u53e3\uff08\u4e00\u4e2a\u7ed9 function1() \uff0c\u53e6\u4e00\u4e2a\u7ed9 function2() \uff09\u3002\u8bb0\u4f4f\u5f53\u8fd9\u4e9b\u865a\u8868\u88ab\u586b\u5145\u7684\u65f6\u5019\uff0c\u6bcf\u4e00\u4e2a\u5165\u53e3\u90fd\u586b\u5145\u8be5\u7c7b\u80fd\u5141\u8bb8\u8c03\u7528\u7684\u6700\u7ec8\u6d3e\u751f\u7684\u51fd\u6570\u7248\u672c\uff08the most-derived function an object of that class type can call\uff09\u3002 \u57fa\u7c7b\u7684\u865a\u8868\u662f\u975e\u5e38\u7b80\u5355\u7684\u3002\u4e00\u4e2a\u57fa\u7c7b\u7684\u5bf9\u8c61\u53ea\u80fd\u57fa\u7c7b\u7684\u6210\u5458\u3002\u57fa\u7c7b\u6ca1\u6709\u529e\u6cd5\u8bbf\u95ee D1 \u6216\u8005 D2 \u7684\u51fd\u6570\u3002\u56e0\u6b64\uff0c function1 \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function1() \u800c function2 \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function2() \u3002 D1 \u7684\u865a\u8868\u7a0d\u5fae\u66f4\u52a0\u590d\u6742\u4e00\u4e9b\uff0c\u4e00\u4e2a D1 \u7c7b\u578b\u7684\u5bf9\u8c61\u65e2\u80fd\u591f\u8bbf\u95ee D1 \u4e5f\u80fd\u8bbf\u95ee Base \u3002\u7136\u800c\uff0c D1 \u91cd\u5199\u4e86\u51fd\u6570 function1() \uff0c\u4f7f\u5f97 D1::function1() \u6bd4 Base::function1() \u6d3e\u751f\u7a0b\u5ea6\u66f4\u5927\uff08more derived\uff09\u3002\u56e0\u6b64\uff0c function1 \u5165\u53e3\u6307\u5411\u4e86 D1::function1() \u3002 D1 \u6ca1\u6709\u91cd\u5199 function2() \uff0c\u56e0\u6b64 function2 \u7684\u5165\u53e3\u5c06\u4f1a\u6307\u5411 `Base::function2()\u3002 D2 \u7684\u865a\u8868\u548c D1 \u662f\u76f8\u4f3c\u7684\uff0c\u5176\u4e2d function1 \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function1() \uff0c\u5e76\u4e14 function2 \u7684\u5165\u53e3\u6307\u5411\u4e86 D2::function2() \u3002 \u8fd9\u91cc\u6709\u4e2a\u56fe\u50cf\u53ef\u4ee5\u63cf\u8ff0\uff1a \u5c3d\u7ba1\u8fd9\u56fe\u770b\u8d77\u6765\u6709\u70b9\u75af\u72c2\uff0c\u4f46\u5176\u5b9e\u975e\u5e38\u7b80\u5355\uff1a\u6bcf\u4e2a\u7c7b\u4e2d\u7684 *__vptr \u6307\u5411\u8be5\u7c7b\u7684\u865a\u8868\u3002\u865a\u8868\u7684\u5165\u53e3\u6307\u5411\u4e86\u8be5\u7c7b\u80fd\u5141\u8bb8\u8c03\u7528\u7684\u6700\u7ec8\u6d3e\u751f\u7684\u51fd\u6570\u7248\u672c\u3002 \u4ee5\u4f60\u601d\u8003\u4e00\u4e0b\u5f53\u6211\u4eec\u521b\u5efa\u4e00\u4e2a D1 \u7684\u65f6\u5019\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { D1 d1 ; } \u56e0\u4e3a d1 \u662f\u4e00\u4e2a D1 \u5bf9\u8c61\uff0c d1 \u6709\u5b83\u7684 *__vptr \u6307\u5411 D1 \u865a\u8868\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u8bbe\u7f6e\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u5230 D1 : int main () { D1 d1 ; Base * dPtr = & d1 ; return 0 ; } \u6ce8\u610f\u56e0\u4e3a dPtr \u662f\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u4ed6\u4ec5\u4ec5\u6307\u5411\u4e86 d1 \u7684\u57fa\u7c7b\u90e8\u5206\u7684\u3002\u7136\u800c\uff0c\u4e5f\u6ce8\u610f\u5230 *__vptr \u662f\u5728\u8be5\u7c7b\u7684\u57fa\u7c7b\u90e8\u5206\uff0c\u56e0\u6b64 dPtr \u53ef\u4ee5\u8bbf\u95ee\u8fd9\u4e2a\u6307\u9488\u3002\u6700\u7ec8\uff0c\u6ce8\u610f dPtr->__vptr \u6307\u5411\u4e86 D1 \u7684\u865a\u8868\uff01\u56e0\u6b64\uff0c\u5373\u4fbf dPtr \u662f\u57fa\u7c7b\u7684\uff0c\u5b83\u4ecd\u7136\u80fd\u591f\u8bbf\u95ee D1 \u7684\u865a\u8868\uff08\u901a\u8fc7 __vptr \uff09\u3002 \u56e0\u6b64\u5f53\u6211\u4eec\u5c1d\u8bd5\u8c03\u7528 dPtr->function1() \u7684\u65f6\u5019\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { D1 d1 ; Base * dPtr = & d1 ; dPtr -> function1 (); return 0 ; } \u9996\u5148\uff0c\u7a0b\u5e8f\u610f\u8bc6\u5230 function1() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u5176\u6b21\uff0c\u7a0b\u5e8f\u4f7f\u7528 dPtr->__vptr \u6765\u5f97\u5230 D1 \u7684\u865a\u8868\u3002\u7136\u540e\uff0c\u5b83\u67e5\u770b D1 \u7684\u865a\u8868\u4e2d\u5e94\u8be5\u8c03\u7528\u54ea\u4e2a\u7248\u672c\u7684 function1() \u3002\u8fd9\u5df2\u7ecf\u6307\u5411\u4e86 D1::function1() \u3002\u56e0\u6b64 dPtr->function1() \u6307\u5411\u4e86 D1::function1() \uff01 \u73b0\u5728\uff0c\u4f60\u53ef\u80fd\u4f1a\u8bf4\u4e86\uff0c\u201d\u4f46\u5982\u679c dPtr \u771f\u7684\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u800c\u4e0d\u662f D1 \u5bf9\u8c61\uff0c\u4ecd\u7136\u4f1a\u8c03\u7528 D1::function1() \u5417\uff1f\u201c\u3002\u7b54\u6848\u662f\u5426\u5b9a\u7684\u3002 int main () { Base b ; Base * bPtr = & b ; bPtr -> function1 (); return 0 ; } \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5f53 b \u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c __vptr \u6307\u5411\u4e86 Base \u7c7b\u7684\u865a\u8868\uff0c\u800c\u4e0d\u662f D1 \u7684\u865a\u8868\u3002\u56e0\u6b64\uff0c dPtr->__vptr \u5c06\u4e5f\u4f1a\u6307\u5411 Base \u7684\u865a\u8868\u3002 Base \u7684\u865a\u8868\u4e2d\uff0c function1() \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function1() \u3002\u56e0\u6b64\uff0c dPtr->function1() \u89e3\u6790\u5230\u4e86 Base::function1() \uff0c\u4e5f\u662f\u57fa\u7c7b\u80fd\u591f\u8c03\u7528\u7684\u6700\u7ec8\u7ee7\u627f\u7248\u672c\u7684 function1() \u901a\u8fc7\u4f7f\u7528\u8fd9\u4e9b\u8868\uff0c\u7f16\u8bd1\u5668\u548c\u7a0b\u5e8f\u80fd\u591f\u786e\u4fdd\u51fd\u6570\u8c03\u7528\u89e3\u6790\u5230\u5408\u9002\u7684\u865a\u51fd\u6570\u4e2d\uff0c\u51e0\u5341\u4f60\u4ec5\u4ec5\u4f7f\u7528\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\uff01 \u8c03\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u6bd4\u8c03\u7528\u4e00\u4e2a\u975e\u865a\u51fd\u6570\u66f4\u6162\uff0c\u56e0\u4e3a\u51e0\u4e2a\u539f\u56e0\u3002\u7b2c\u4e00\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u4f7f\u7528 *__vptr \u53bb\u83b7\u5f97\u5408\u9002\u7684\u865a\u8868\u3002\u7b2c\u4e8c\uff0c\u6211\u4eec\u4e0d\u5f97\u7d22\u5f15\u865a\u8868\u6765\u627e\u5230\u5408\u9002\u7684\u9700\u8981\u8c03\u7528\u7684\u51fd\u6570\u3002\u53ea\u6709\u90a3\u6837\u6211\u4eec\u624d\u80fd\u8c03\u7528\u51fd\u6570\u3002\u7ed3\u679c\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u505a\u4e09\u4e2a\u64cd\u4f5c\u6765\u627e\u5230\u8981\u8c03\u7528\u7684\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u666e\u901a\u7684\u95f4\u63a5\u51fd\u6570\u8c03\u7528\u7684\u4e24\u6b21\u64cd\u4f5c\uff0c\u6216\u8005\u76f4\u63a5\u8c03\u7528\u7684\u5355\u72ec\u64cd\u4f5c\u3002\u7136\u800c\uff0c\u5728\u73b0\u4ee3\u7684\u8ba1\u7b97\u673a\u91cc\uff0c\u8fd9\u989d\u5916\u7684\u65f6\u95f4\u901a\u5e38\u76f8\u5f53\u65e0\u5173\u7d27\u8981\u3002 \u63d0\u9192\u4e00\u4e0b\uff0c\u4efb\u4f55\u4f7f\u7528\u865a\u51fd\u6570\u7684\u7c7b\u90fd\u6709\u4e00\u4e2a *__vptr \uff0c\u5e76\u4e14\u56e0\u6b64\u5bf9\u8c61\u4f1a\u6bd4\u8bbe\u60f3\u7684\u672c\u8eab\u7a0d\u5927\u4e00\u4e9b\u3002\u865a\u51fd\u6570\u662f\u5f3a\u5927\u7684\uff0c\u4f46\u662f\u4ed6\u4eec\u786e\u5b9e\u5b58\u5728\u6027\u80fd\u635f\u8017\u3002","title":"18.6 \u865a\u8868"},{"location":"18-virtual-functions/18.6-the-virtual-table/#186","text":"By Alex on February 8 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 by dashjay 2020-12-24 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-24 \u4e3a\u4e86\u5b9e\u73b0\u865a\u51fd\u6570\uff0cC++ \u4f7f\u7528\u4e86\u4e00\u79cd\u7279\u6b8a\u7684\u5f62\u5f0f\u7684\u540e\u671f\u7ed1\u5b9a\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u6240\u4e86\u89e3\u7684\u865a\u8868\u3002\u865a\u8868\u662f\u4e00\u4e2a\u51fd\u6570\u5feb\u901f\u67e5\u8be2\u8868\uff0c\u7528\u6765\u5728\u540e\u671f\u7ed1\u5b9a\u7684\u65b9\u5f0f\u89e3\u6790\u51fd\u6570\u8c03\u7528\u3002\u865a\u8868\u6709\u65f6\u5019\u4e5f\u53eb\u5176\u4ed6\u540d\u5b57\uff0c\u4f8b\u5982 \"vtable\", \"virtual function table\", \"virtual method table\" \u6216\u8005 \"dispatch table\"\u3002 \u56e0\u4e3a\u77e5\u9053\u865a\u51fd\u6570\u5982\u4f55\u5de5\u4f5c\u6ca1\u6709\u5fc5\u8981\u4f7f\u7528\u865a\u51fd\u6570\uff0c\u8fd9\u90e8\u5206\u53ef\u4ee5\u5f53\u505a\u9009\u8bfb\u3002 \u865a\u8868\u5b9e\u9645\u4e0a\u975e\u5e38\u7b80\u5355\uff0c\u867d\u7136\u7528\u8bed\u8a00\u63cf\u8ff0\u8d77\u6765\u6709\u70b9\u590d\u6742\u3002\u9996\u5148\uff0c\u6bcf\u4e2a\u4f7f\u7528\u865a\u51fd\u6570\u7684\u7c7b\uff08\u6216\u8005\u7ee7\u627f\u4e86\u53c8\u865a\u51fd\u6570\u7684\u7c7b\uff09\u90fd\u4f1a\u6709\u4ed6\u7684\u865a\u8868\u3002\u8fd9\u4e2a\u8868\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u9759\u6001\u6570\u7ec4\uff0c\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u5c31\u9884\u7559\u597d\u4e86\u3002\u4e00\u4e2a\u865a\u8868\u5305\u542b\u4e86\u6bcf\u4e00\u4e2a\u53ef\u4ee5\u88ab\u901a\u8fc7\u7c7b\u7684\u5bf9\u8c61\u8c03\u7528\u7684\u865a\u51fd\u6570\u7684\u5165\u53e3\u3002\u8868\u4e2d\u7684\u6bcf\u4e2a\u5165\u53e3\u90fd\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u51fd\u6570\u6307\u9488\u6307\u5411\u4e86\u8be5\u7c7b\u80fd\u521d\u7ea7\u7684\u6700\u7ec8\u6d3e\u751f\u7684\u51fd\u6570\u3002 \u5176\u6b21\uff0c\u7f16\u8bd1\u5668\u4e5f\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u9690\u85cf\u7684\u6307\u9488\u5230\u57fa\u7c7b\u4e2d\uff0c\u6211\u4eec\u53eb\u4ed6 *__vptr. \u3002\u5f53\u4e00\u4e2a\u7c7b\u5b9e\u4f8b\u521b\u5efa\u65f6\uff0c *__vptr \u88ab\u81ea\u52a8\u8bbe\u7f6e\uff0c\u4ee5\u4fbf\u5b83\u6307\u5411\u90a3\u4e2a\u7c7b\u5b9e\u4f8b\u7684\u865a\u8868\u3002\u4e0d\u50cf *this \u6307\u9488\uff0c\u4f1a\u81ea\u52a8\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\uff0c\u80fd\u591f\u8ba9\u7f16\u8bd1\u5668\u89e3\u6790\u81ea\u5df1\uff0c *__vptr \u662f\u4e00\u4e2a\u771f\u5b9e\u7684\u6307\u9488\u3002\u56e0\u6b64\uff0c\u5b83\u4f7f\u5f97\u6bcf\u4e2a\u7c7b\u5bf9\u8c61\u5206\u914d\u6bd4\u81ea\u5df1\u7a0d\u5fae\u5927\u4e00\u4e9b\u7684\u7a7a\u95f4\u3002\u8fd9\u610f\u5473\u7740 *__vptr \u80fd\u88ab\u6d3e\u751f\u7c7b\u7ee7\u627f\uff0c\u975e\u5e38\u91cd\u8981\u3002 \u73b0\u5728\uff0c\u4f60\u53ef\u80fd\u7591\u60d1\u8fd9\u4e9b\u4e1c\u897f\u662f\u5982\u4f55\u642d\u914d\u5728\u4e00\u8d77\u7684\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a class Base { public : virtual void function1 () {}; virtual void function2 () {}; }; class D1 : public Base { public : virtual void function1 () {}; }; class D2 : public Base { public : virtual void function2 () {}; }; \u56e0\u4e3a\u8fd9\u91cc\u6709\u4e09\u4e2a\u7c7b\uff0c\u7f16\u8bd1\u5668\u4f1a\u8bbe\u7f6e3\u4e2a\u865a\u8868\uff1a\u4e00\u4e2a\u7ed9 Base\uff0c\u4e00\u4e2a\u7ed9 D1\uff0c\u53e6\u4e00\u4e2a\u7ed9 D2\u3002 \u7f16\u8bd1\u5668\u4e5f\u6dfb\u52a0\u4e86\u4e00\u4e2a\u9690\u85cf\u7684\u6307\u9488\u5230\u4f7f\u7528\u865a\u51fd\u6570\u7684\u6700\u57fa\u7c7b\u3002\u5c3d\u7ba1\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u5b9e\u73b0\uff0c\u6211\u4eec\u4e5f\u4f1a\u5728\u4e0b\u4e00\u4e2a\u4f8b\u5b50\u4e2d\u5c55\u793a\u5b83\u6dfb\u52a0\u5728\u54ea\u91cc\uff1a class Base { public : FunctionPointer * __vptr ; virtual void function1 () {}; virtual void function2 () {}; }; class D1 : public Base { public : virtual void function1 () {}; }; class D2 : public Base { public : virtual void function2 () {}; }; \u5f53\u4e00\u4e2a\u7c7b\u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c *__vptr \u88ab\u6307\u5411\u8be5\u7c7b\u7684\u865a\u8868\u3002\u4f8b\u5982\uff0c\u5f53\u4e00\u4e2a\u57fa\u7c7b\u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c *__vptr \u88ab\u6307\u5411\u57fa\u7c7b\u7684\u865a\u8868\u3002\u5f53\u5bf9\u8c61 D1 \u6216 D2 \u88ab\u6784\u5efa\u7684\u65f6\u5019\uff0c *__vptr \u5206\u522b\u6307\u5411\u4e86 D1 \u6216\u8005 D2\u7684\u865a\u8868\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u8ba8\u8bba\u4e00\u4e0b\u865a\u8868\u5982\u4f55\u88ab\u586b\u5145\u7684\u3002\u56e0\u4e3a\u6709\u4e24\u4e2a\u865a\u51fd\u6570\uff0c\u56e0\u6b64\u6bcf\u4e2a\u865a\u8868\u5c06\u4f1a\u6709\u4e24\u4e2a\u5165\u53e3\uff08\u4e00\u4e2a\u7ed9 function1() \uff0c\u53e6\u4e00\u4e2a\u7ed9 function2() \uff09\u3002\u8bb0\u4f4f\u5f53\u8fd9\u4e9b\u865a\u8868\u88ab\u586b\u5145\u7684\u65f6\u5019\uff0c\u6bcf\u4e00\u4e2a\u5165\u53e3\u90fd\u586b\u5145\u8be5\u7c7b\u80fd\u5141\u8bb8\u8c03\u7528\u7684\u6700\u7ec8\u6d3e\u751f\u7684\u51fd\u6570\u7248\u672c\uff08the most-derived function an object of that class type can call\uff09\u3002 \u57fa\u7c7b\u7684\u865a\u8868\u662f\u975e\u5e38\u7b80\u5355\u7684\u3002\u4e00\u4e2a\u57fa\u7c7b\u7684\u5bf9\u8c61\u53ea\u80fd\u57fa\u7c7b\u7684\u6210\u5458\u3002\u57fa\u7c7b\u6ca1\u6709\u529e\u6cd5\u8bbf\u95ee D1 \u6216\u8005 D2 \u7684\u51fd\u6570\u3002\u56e0\u6b64\uff0c function1 \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function1() \u800c function2 \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function2() \u3002 D1 \u7684\u865a\u8868\u7a0d\u5fae\u66f4\u52a0\u590d\u6742\u4e00\u4e9b\uff0c\u4e00\u4e2a D1 \u7c7b\u578b\u7684\u5bf9\u8c61\u65e2\u80fd\u591f\u8bbf\u95ee D1 \u4e5f\u80fd\u8bbf\u95ee Base \u3002\u7136\u800c\uff0c D1 \u91cd\u5199\u4e86\u51fd\u6570 function1() \uff0c\u4f7f\u5f97 D1::function1() \u6bd4 Base::function1() \u6d3e\u751f\u7a0b\u5ea6\u66f4\u5927\uff08more derived\uff09\u3002\u56e0\u6b64\uff0c function1 \u5165\u53e3\u6307\u5411\u4e86 D1::function1() \u3002 D1 \u6ca1\u6709\u91cd\u5199 function2() \uff0c\u56e0\u6b64 function2 \u7684\u5165\u53e3\u5c06\u4f1a\u6307\u5411 `Base::function2()\u3002 D2 \u7684\u865a\u8868\u548c D1 \u662f\u76f8\u4f3c\u7684\uff0c\u5176\u4e2d function1 \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function1() \uff0c\u5e76\u4e14 function2 \u7684\u5165\u53e3\u6307\u5411\u4e86 D2::function2() \u3002 \u8fd9\u91cc\u6709\u4e2a\u56fe\u50cf\u53ef\u4ee5\u63cf\u8ff0\uff1a \u5c3d\u7ba1\u8fd9\u56fe\u770b\u8d77\u6765\u6709\u70b9\u75af\u72c2\uff0c\u4f46\u5176\u5b9e\u975e\u5e38\u7b80\u5355\uff1a\u6bcf\u4e2a\u7c7b\u4e2d\u7684 *__vptr \u6307\u5411\u8be5\u7c7b\u7684\u865a\u8868\u3002\u865a\u8868\u7684\u5165\u53e3\u6307\u5411\u4e86\u8be5\u7c7b\u80fd\u5141\u8bb8\u8c03\u7528\u7684\u6700\u7ec8\u6d3e\u751f\u7684\u51fd\u6570\u7248\u672c\u3002 \u4ee5\u4f60\u601d\u8003\u4e00\u4e0b\u5f53\u6211\u4eec\u521b\u5efa\u4e00\u4e2a D1 \u7684\u65f6\u5019\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { D1 d1 ; } \u56e0\u4e3a d1 \u662f\u4e00\u4e2a D1 \u5bf9\u8c61\uff0c d1 \u6709\u5b83\u7684 *__vptr \u6307\u5411 D1 \u865a\u8868\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u8bbe\u7f6e\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u5230 D1 : int main () { D1 d1 ; Base * dPtr = & d1 ; return 0 ; } \u6ce8\u610f\u56e0\u4e3a dPtr \u662f\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u4ed6\u4ec5\u4ec5\u6307\u5411\u4e86 d1 \u7684\u57fa\u7c7b\u90e8\u5206\u7684\u3002\u7136\u800c\uff0c\u4e5f\u6ce8\u610f\u5230 *__vptr \u662f\u5728\u8be5\u7c7b\u7684\u57fa\u7c7b\u90e8\u5206\uff0c\u56e0\u6b64 dPtr \u53ef\u4ee5\u8bbf\u95ee\u8fd9\u4e2a\u6307\u9488\u3002\u6700\u7ec8\uff0c\u6ce8\u610f dPtr->__vptr \u6307\u5411\u4e86 D1 \u7684\u865a\u8868\uff01\u56e0\u6b64\uff0c\u5373\u4fbf dPtr \u662f\u57fa\u7c7b\u7684\uff0c\u5b83\u4ecd\u7136\u80fd\u591f\u8bbf\u95ee D1 \u7684\u865a\u8868\uff08\u901a\u8fc7 __vptr \uff09\u3002 \u56e0\u6b64\u5f53\u6211\u4eec\u5c1d\u8bd5\u8c03\u7528 dPtr->function1() \u7684\u65f6\u5019\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { D1 d1 ; Base * dPtr = & d1 ; dPtr -> function1 (); return 0 ; } \u9996\u5148\uff0c\u7a0b\u5e8f\u610f\u8bc6\u5230 function1() \u662f\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u5176\u6b21\uff0c\u7a0b\u5e8f\u4f7f\u7528 dPtr->__vptr \u6765\u5f97\u5230 D1 \u7684\u865a\u8868\u3002\u7136\u540e\uff0c\u5b83\u67e5\u770b D1 \u7684\u865a\u8868\u4e2d\u5e94\u8be5\u8c03\u7528\u54ea\u4e2a\u7248\u672c\u7684 function1() \u3002\u8fd9\u5df2\u7ecf\u6307\u5411\u4e86 D1::function1() \u3002\u56e0\u6b64 dPtr->function1() \u6307\u5411\u4e86 D1::function1() \uff01 \u73b0\u5728\uff0c\u4f60\u53ef\u80fd\u4f1a\u8bf4\u4e86\uff0c\u201d\u4f46\u5982\u679c dPtr \u771f\u7684\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u800c\u4e0d\u662f D1 \u5bf9\u8c61\uff0c\u4ecd\u7136\u4f1a\u8c03\u7528 D1::function1() \u5417\uff1f\u201c\u3002\u7b54\u6848\u662f\u5426\u5b9a\u7684\u3002 int main () { Base b ; Base * bPtr = & b ; bPtr -> function1 (); return 0 ; } \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5f53 b \u88ab\u521b\u5efa\u7684\u65f6\u5019\uff0c __vptr \u6307\u5411\u4e86 Base \u7c7b\u7684\u865a\u8868\uff0c\u800c\u4e0d\u662f D1 \u7684\u865a\u8868\u3002\u56e0\u6b64\uff0c dPtr->__vptr \u5c06\u4e5f\u4f1a\u6307\u5411 Base \u7684\u865a\u8868\u3002 Base \u7684\u865a\u8868\u4e2d\uff0c function1() \u7684\u5165\u53e3\u6307\u5411\u4e86 Base::function1() \u3002\u56e0\u6b64\uff0c dPtr->function1() \u89e3\u6790\u5230\u4e86 Base::function1() \uff0c\u4e5f\u662f\u57fa\u7c7b\u80fd\u591f\u8c03\u7528\u7684\u6700\u7ec8\u7ee7\u627f\u7248\u672c\u7684 function1() \u901a\u8fc7\u4f7f\u7528\u8fd9\u4e9b\u8868\uff0c\u7f16\u8bd1\u5668\u548c\u7a0b\u5e8f\u80fd\u591f\u786e\u4fdd\u51fd\u6570\u8c03\u7528\u89e3\u6790\u5230\u5408\u9002\u7684\u865a\u51fd\u6570\u4e2d\uff0c\u51e0\u5341\u4f60\u4ec5\u4ec5\u4f7f\u7528\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\uff01 \u8c03\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u6bd4\u8c03\u7528\u4e00\u4e2a\u975e\u865a\u51fd\u6570\u66f4\u6162\uff0c\u56e0\u4e3a\u51e0\u4e2a\u539f\u56e0\u3002\u7b2c\u4e00\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u4f7f\u7528 *__vptr \u53bb\u83b7\u5f97\u5408\u9002\u7684\u865a\u8868\u3002\u7b2c\u4e8c\uff0c\u6211\u4eec\u4e0d\u5f97\u7d22\u5f15\u865a\u8868\u6765\u627e\u5230\u5408\u9002\u7684\u9700\u8981\u8c03\u7528\u7684\u51fd\u6570\u3002\u53ea\u6709\u90a3\u6837\u6211\u4eec\u624d\u80fd\u8c03\u7528\u51fd\u6570\u3002\u7ed3\u679c\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u505a\u4e09\u4e2a\u64cd\u4f5c\u6765\u627e\u5230\u8981\u8c03\u7528\u7684\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u666e\u901a\u7684\u95f4\u63a5\u51fd\u6570\u8c03\u7528\u7684\u4e24\u6b21\u64cd\u4f5c\uff0c\u6216\u8005\u76f4\u63a5\u8c03\u7528\u7684\u5355\u72ec\u64cd\u4f5c\u3002\u7136\u800c\uff0c\u5728\u73b0\u4ee3\u7684\u8ba1\u7b97\u673a\u91cc\uff0c\u8fd9\u989d\u5916\u7684\u65f6\u95f4\u901a\u5e38\u76f8\u5f53\u65e0\u5173\u7d27\u8981\u3002 \u63d0\u9192\u4e00\u4e0b\uff0c\u4efb\u4f55\u4f7f\u7528\u865a\u51fd\u6570\u7684\u7c7b\u90fd\u6709\u4e00\u4e2a *__vptr \uff0c\u5e76\u4e14\u56e0\u6b64\u5bf9\u8c61\u4f1a\u6bd4\u8bbe\u60f3\u7684\u672c\u8eab\u7a0d\u5927\u4e00\u4e9b\u3002\u865a\u51fd\u6570\u662f\u5f3a\u5927\u7684\uff0c\u4f46\u662f\u4ed6\u4eec\u786e\u5b9e\u5b58\u5728\u6027\u80fd\u635f\u8017\u3002","title":"18.6 \u865a\u8868"},{"location":"18-virtual-functions/18.7-virtual-base-classes/","text":"18.7 \u865a\u57fa\u7c7b (Virtual base classes) \u00b6 \u4e0a\u4e00\u7ae0\uff0c\u5728 \u7b2c11.7\u8bfe\u2014\u2014\u591a\u91cd\u7ee7\u627f\u4e2d \uff0c\u6211\u4eec\u7559\u4e0b\u4e86\u4e00\u4e2a\u201c\u94bb\u77f3\u95ee\u9898\u201d\u3002\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u8ba8\u8bba\u3002 \u6ce8\u610f\uff1a \u672c\u8282\u662f\u4e00\u4e2a\u9ad8\u7ea7\u4e3b\u9898\uff0c\u5982\u679c\u9700\u8981\u53ef\u4ee5\u8df3\u8fc7\u6216\u7565\u8fc7\u3002 \u94bb\u77f3\u95ee\u9898 (The diamond problem) \u00b6 \u4ee5\u4e0b\u662f\u4e0a\u4e00\u8bfe\u4e2d\u7684\u793a\u4f8b\uff08\u4f7f\u7528\u4e00\u4e9b\u6784\u9020\u51fd\u6570\uff09\u6765\u8bf4\u660e\u83f1\u5f62\u95ee\u9898\uff1a class PoweredDevice { public : PoweredDevice ( int power ) { cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : public PoweredDevice { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) { cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : public PoweredDevice { public : Printer ( int printer , int power ) : PoweredDevice ( power ) { cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u5c3d\u7ba1\u4f60\u53ef\u80fd\u89c9\u5f97\u6211\u4eec\u5f97\u5230\u4e86\u8fd9\u6837\u7684\u56fe\u5f62\uff1a \u5982\u679c\u8981\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u60a8\u5c06\u5f97\u5230PoweredDevice\u7c7b\u7684\u4e24\u4e2a\u526f\u672c\uff0c\u4e00\u4e2a\u6765\u81eaPrinter\uff0c\u4e00\u4e2a\u6765\u81eaScanner\u3002\u5176\u7ed3\u6784\u5982\u4e0b\uff1a \u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u7b80\u77ed\u7684\u6d4b\u8bd5\u6765\u8bf4\u660e\u8fd9\u4e00\u70b9\uff1a int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 PoweredDevice: 3 Printer: 2 \u5982\u4f60\u6240\u89c1\uff0cPoweredDevice\u88ab\u6784\u9020\u4e86\u4e24\u6b21\u3002 \u867d\u7136\u8fd9\u662f\u7ecf\u5e38\u9700\u8981\u7684\uff0c\u4f46\u6709\u65f6\u60a8\u53ef\u80fd\u53ea\u5e0c\u671b\u626b\u63cf\u4eea\u548c\u6253\u5370\u673a\u5171\u4eabPoweredDevice\u7684\u4e00\u4e2a\u526f\u672c\u3002 \u865a\u57fa\u7c7b (Virtual base classes) \u00b6 \u8981\u5171\u4eab\u57fa\u7c7b\uff0c\u53ea\u9700\u5728\u6d3e\u751f\u7c7b\u7684\u7ee7\u627f\u5217\u8868\u4e2d\u63d2\u5165\u201cvirtual\u201d\u5173\u952e\u5b57\u3002\u8fd9\u5c06\u521b\u5efa\u6240\u8c13\u7684\u865a\u62df\u57fa\u7c7b\uff0c\u8fd9\u610f\u5473\u7740\u53ea\u6709\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u57fa\u5bf9\u8c61\u5728\u7ee7\u627f\u6811\u4e2d\u7684\u6240\u6709\u5bf9\u8c61\u4e4b\u95f4\u5171\u4eab\uff0c\u5e76\u4e14\u53ea\u6784\u9020\u4e00\u6b21\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\uff08\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u4e0d\u4f7f\u7528\u6784\u9020\u51fd\u6570\uff09\u6f14\u793a\u5982\u4f55\u4f7f\u7528virtual\u5173\u952e\u5b57\u521b\u5efa\u5171\u4eab\u57fa\u7c7b\uff1a class PoweredDevice { }; class Scanner : virtual public PoweredDevice { }; class Printer : virtual public PoweredDevice { }; class Copier : public Scanner , public Printer { }; \u73b0\u5728\uff0c\u5f53\u60a8\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\u65f6\uff0c\u6bcf\u4e2a Copier \u53ea\u4f1a\u5f97\u5230\u4e00\u4e2a PoweredDevice \u526f\u672c\uff0c\u8be5\u526f\u672c\u5c06\u7531 Scanner \u548c Printer \u5171\u4eab\u3002 \u7136\u800c\uff0c\u8fd9\u53c8\u5f15\u51fa\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a\u5982\u679c Scanner \u548c Printer \u5171\u4eabPoweredDevice\u57fa\u7c7b\uff0c\u8c01\u8d1f\u8d23\u521b\u5efa\u5b83\uff1f\u4e8b\u5b9e\u8bc1\u660e\uff0c\u7b54\u6848\u662f Copier\u3002Copier \u6784\u9020\u51fd\u6570\u8d1f\u8d23\u521b\u5efa PoweredDevice\u3002\u56e0\u6b64\uff0c\u8fd9\u5141\u8bb8 Copier \u76f4\u63a5\u8c03\u7528 \u975e\u76f4\u63a5 (non-immediate-parent) \u6784\u9020\u51fd\u6570\uff1a #include <iostream> class PoweredDevice { public : PoweredDevice ( int power ) { std :: cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Scanner \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Printer ( int printer , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Printer \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : PoweredDevice ( power ), // PoweredDevice \u5728\u8fd9\u91cc\u8fdb\u884c\u6784\u9020 Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u8fd8\u662f\u7528\u524d\u9762\u7684\u4f8b\u5b50 int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 Printer: 2 \u5982\u60a8\u6240\u89c1\uff0cPoweredDevice\u53ea\u6784\u5efa\u4e00\u6b21\u3002 \u6709\u4e00\u4e9b\u7ec6\u8282\uff0c\u5982\u679c\u6211\u4eec\u6211\u4eec\u5fc5\u987b\u8981\u8bf4\u660e \u9996\u5148\uff1a \u865a\u57fa\u7c7b\u603b\u662f\u5728\u975e\u865a\u57fa\u7c7b\u4e4b\u524d\u521b\u5efa\uff0c\u8fd9\u786e\u4fdd\u6240\u6709\u57fa\u7c7b\u5728\u6d3e\u751f\u7c7b\u4e4b\u524d\u521b\u5efa\u3002 \u5176\u6b21\uff1a \u8bf7\u6ce8\u610f Scanner \u548c Printer \u6784\u9020\u51fd\u6570\u4ecd\u6709\u8c03\u7528 PoweredDevice \u7684\u6784\u9020\u51fd\u6570\u3002\u521b\u5efa Copier \u5b9e\u4f8b\u65f6\uff0c\u8fd9\u4e9b\u6784\u9020\u51fd\u6570\u8c03\u7528\u88ab\u5ffd\u7565\uff0c\u56e0\u4e3a Copier \u8d1f\u8d23\u521b\u5efa PoweredDevice \uff0c\u800c\u4e0d\u662f Scanner \u6216 Printer \u3002\u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u8981\u521b\u5efa Scanner \u6216 Printer \u7684\u5b9e\u4f8b\uff0c\u90a3\u4e48\u8c03\u7528\u90a3\u4e9b\u6784\u9020\u51fd\u6570\uff0c\u5e76\u5e94\u7528\u5e38\u89c4\u7ee7\u627f\u89c4\u5219\u3002 \u7b2c\u4e09\uff1a \u5982\u679c\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u4e00\u4e2a\u6216\u591a\u4e2a\u5177\u6709\u865a\u57fa\u7c7b\u7684\u7c7b\uff0c\u5219 \u672b\u7aef\u6d3e\u751f(most derived) \u7684\u7c7b\u8d1f\u8d23\u6784\u9020\u865a\u57fa\u7c7b\u3002\u5728\u672c\u4f8b\u4e2d\uff0cCopier \u7ee7\u627f Printer \u548c Scanner \uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a PoweredDevice \u865a\u62df\u57fa\u7c7b\u3002Copier \u662f\u6700\u6d3e\u751f\u7684\u7c7b\uff0c\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002\u8bf7\u6ce8\u610f\uff0c\u5373\u4f7f\u5728\u5355\u4e00\u7ee7\u627f\u60c5\u51b5\u4e0b\u4e5f\u662f\u5982\u6b64\uff1a\u5982\u679c Copier \u662f\u4ece Printer \u5355\u72ec\u7ee7\u627f\u7684\uff0c\u800c Printer \u5b9e\u9645\u4e0a\u662f\u4ece PoweredDevice \u7ee7\u627f\u7684\uff0cCopier \u4ecd\u7136\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002 \u7b2c\u56db\uff1a \u7ee7\u627f\u4e00\u4e2a\u865a\u62df\u57fa\u7c7b\u7684\u6240\u6709\u7c7b\u90fd\u5c06\u6709\u4e00\u4e2a\u865a\u62df\u8868\uff0c\u5373\u4f7f\u5b83\u4eec\u901a\u5e38\u4e0d\u4f1a\u6709\uff0c\u5b9e\u4f8b\u5316\u7684\u5bf9\u8c61\u4f1a\u56e0\u4e3a\u8fd9\u4e2a\u6307\u9488\u589e\u52a0\u4e00\u4e9b\u5c3a\u5bf8\u3002 \u56e0\u4e3a Scanner \u548c Printer \u662f\u4ece PoweredDevice \u865a\u7ee7\u627f\u51fa\u6765\u7684\uff0c\u6240\u4ee5 \u53ea\u6709\u4e00\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\u3002Scanner \u548c Printer \u90fd\u9700\u8981\u77e5\u9053\u5982\u4f55\u627e\u5230\u8fd9\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\uff0c\u4ee5\u4fbf\u8bbf\u95ee\u5b83\u7684\u6210\u5458\uff08\u56e0\u4e3a\u6bd5\u7adf\uff0c\u5b83\u4eec\u662f\u4ece\u5b83\u6d3e\u751f\u7684\uff09\u3002\u8fd9\u901a\u5e38\u662f\u901a\u8fc7\u4e00\u4e9b\u865a\u8868\u6765\u5b9e\u73b0\u7684\uff08\u5b83\u5b9e\u9645\u4e0a\u5b58\u50a8\u4e86\u4ece\u6bcf\u4e2a\u5b50\u7c7b\u5230 PoweredDevice \u5b50\u5bf9\u8c61\u7684\u504f\u79fb\u91cf\uff09\u3002","title":"18.7 \u865a\u57fa\u7c7b (Virtual base classes)"},{"location":"18-virtual-functions/18.7-virtual-base-classes/#187-virtual-base-classes","text":"\u4e0a\u4e00\u7ae0\uff0c\u5728 \u7b2c11.7\u8bfe\u2014\u2014\u591a\u91cd\u7ee7\u627f\u4e2d \uff0c\u6211\u4eec\u7559\u4e0b\u4e86\u4e00\u4e2a\u201c\u94bb\u77f3\u95ee\u9898\u201d\u3002\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u8ba8\u8bba\u3002 \u6ce8\u610f\uff1a \u672c\u8282\u662f\u4e00\u4e2a\u9ad8\u7ea7\u4e3b\u9898\uff0c\u5982\u679c\u9700\u8981\u53ef\u4ee5\u8df3\u8fc7\u6216\u7565\u8fc7\u3002","title":"18.7 \u865a\u57fa\u7c7b (Virtual base classes)"},{"location":"18-virtual-functions/18.7-virtual-base-classes/#the-diamond-problem","text":"\u4ee5\u4e0b\u662f\u4e0a\u4e00\u8bfe\u4e2d\u7684\u793a\u4f8b\uff08\u4f7f\u7528\u4e00\u4e9b\u6784\u9020\u51fd\u6570\uff09\u6765\u8bf4\u660e\u83f1\u5f62\u95ee\u9898\uff1a class PoweredDevice { public : PoweredDevice ( int power ) { cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : public PoweredDevice { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) { cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : public PoweredDevice { public : Printer ( int printer , int power ) : PoweredDevice ( power ) { cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u5c3d\u7ba1\u4f60\u53ef\u80fd\u89c9\u5f97\u6211\u4eec\u5f97\u5230\u4e86\u8fd9\u6837\u7684\u56fe\u5f62\uff1a \u5982\u679c\u8981\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u60a8\u5c06\u5f97\u5230PoweredDevice\u7c7b\u7684\u4e24\u4e2a\u526f\u672c\uff0c\u4e00\u4e2a\u6765\u81eaPrinter\uff0c\u4e00\u4e2a\u6765\u81eaScanner\u3002\u5176\u7ed3\u6784\u5982\u4e0b\uff1a \u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u7b80\u77ed\u7684\u6d4b\u8bd5\u6765\u8bf4\u660e\u8fd9\u4e00\u70b9\uff1a int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 PoweredDevice: 3 Printer: 2 \u5982\u4f60\u6240\u89c1\uff0cPoweredDevice\u88ab\u6784\u9020\u4e86\u4e24\u6b21\u3002 \u867d\u7136\u8fd9\u662f\u7ecf\u5e38\u9700\u8981\u7684\uff0c\u4f46\u6709\u65f6\u60a8\u53ef\u80fd\u53ea\u5e0c\u671b\u626b\u63cf\u4eea\u548c\u6253\u5370\u673a\u5171\u4eabPoweredDevice\u7684\u4e00\u4e2a\u526f\u672c\u3002","title":"\u94bb\u77f3\u95ee\u9898 (The diamond problem)"},{"location":"18-virtual-functions/18.7-virtual-base-classes/#virtual-base-classes","text":"\u8981\u5171\u4eab\u57fa\u7c7b\uff0c\u53ea\u9700\u5728\u6d3e\u751f\u7c7b\u7684\u7ee7\u627f\u5217\u8868\u4e2d\u63d2\u5165\u201cvirtual\u201d\u5173\u952e\u5b57\u3002\u8fd9\u5c06\u521b\u5efa\u6240\u8c13\u7684\u865a\u62df\u57fa\u7c7b\uff0c\u8fd9\u610f\u5473\u7740\u53ea\u6709\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u57fa\u5bf9\u8c61\u5728\u7ee7\u627f\u6811\u4e2d\u7684\u6240\u6709\u5bf9\u8c61\u4e4b\u95f4\u5171\u4eab\uff0c\u5e76\u4e14\u53ea\u6784\u9020\u4e00\u6b21\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\uff08\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u4e0d\u4f7f\u7528\u6784\u9020\u51fd\u6570\uff09\u6f14\u793a\u5982\u4f55\u4f7f\u7528virtual\u5173\u952e\u5b57\u521b\u5efa\u5171\u4eab\u57fa\u7c7b\uff1a class PoweredDevice { }; class Scanner : virtual public PoweredDevice { }; class Printer : virtual public PoweredDevice { }; class Copier : public Scanner , public Printer { }; \u73b0\u5728\uff0c\u5f53\u60a8\u521b\u5efa\u4e00\u4e2aCopier\u7c7b\u5bf9\u8c61\u65f6\uff0c\u6bcf\u4e2a Copier \u53ea\u4f1a\u5f97\u5230\u4e00\u4e2a PoweredDevice \u526f\u672c\uff0c\u8be5\u526f\u672c\u5c06\u7531 Scanner \u548c Printer \u5171\u4eab\u3002 \u7136\u800c\uff0c\u8fd9\u53c8\u5f15\u51fa\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a\u5982\u679c Scanner \u548c Printer \u5171\u4eabPoweredDevice\u57fa\u7c7b\uff0c\u8c01\u8d1f\u8d23\u521b\u5efa\u5b83\uff1f\u4e8b\u5b9e\u8bc1\u660e\uff0c\u7b54\u6848\u662f Copier\u3002Copier \u6784\u9020\u51fd\u6570\u8d1f\u8d23\u521b\u5efa PoweredDevice\u3002\u56e0\u6b64\uff0c\u8fd9\u5141\u8bb8 Copier \u76f4\u63a5\u8c03\u7528 \u975e\u76f4\u63a5 (non-immediate-parent) \u6784\u9020\u51fd\u6570\uff1a #include <iostream> class PoweredDevice { public : PoweredDevice ( int power ) { std :: cout << \"PoweredDevice: \" << power << '\\n' ; } }; class Scanner : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Scanner ( int scanner , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Scanner \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Scanner: \" << scanner << '\\n' ; } }; class Printer : virtual public PoweredDevice // note: PoweredDevice \u73b0\u5728\u662f\u4e00\u4e2a\u865a\u57fa\u7c7b { public : Printer ( int printer , int power ) : PoweredDevice ( power ) // \u8fd9\u884c\u662f\u521b\u5efa Printer \u5fc5\u8981\u7684\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u3002 { std :: cout << \"Printer: \" << printer << '\\n' ; } }; class Copier : public Scanner , public Printer { public : Copier ( int scanner , int printer , int power ) : PoweredDevice ( power ), // PoweredDevice \u5728\u8fd9\u91cc\u8fdb\u884c\u6784\u9020 Scanner ( scanner , power ), Printer ( printer , power ) { } }; \u8fd8\u662f\u7528\u524d\u9762\u7684\u4f8b\u5b50 int main () { Copier copier ( 1 , 2 , 3 ); return 0 ; } \u4ea7\u751f\u7ed3\u679c PoweredDevice: 3 Scanner: 1 Printer: 2 \u5982\u60a8\u6240\u89c1\uff0cPoweredDevice\u53ea\u6784\u5efa\u4e00\u6b21\u3002 \u6709\u4e00\u4e9b\u7ec6\u8282\uff0c\u5982\u679c\u6211\u4eec\u6211\u4eec\u5fc5\u987b\u8981\u8bf4\u660e \u9996\u5148\uff1a \u865a\u57fa\u7c7b\u603b\u662f\u5728\u975e\u865a\u57fa\u7c7b\u4e4b\u524d\u521b\u5efa\uff0c\u8fd9\u786e\u4fdd\u6240\u6709\u57fa\u7c7b\u5728\u6d3e\u751f\u7c7b\u4e4b\u524d\u521b\u5efa\u3002 \u5176\u6b21\uff1a \u8bf7\u6ce8\u610f Scanner \u548c Printer \u6784\u9020\u51fd\u6570\u4ecd\u6709\u8c03\u7528 PoweredDevice \u7684\u6784\u9020\u51fd\u6570\u3002\u521b\u5efa Copier \u5b9e\u4f8b\u65f6\uff0c\u8fd9\u4e9b\u6784\u9020\u51fd\u6570\u8c03\u7528\u88ab\u5ffd\u7565\uff0c\u56e0\u4e3a Copier \u8d1f\u8d23\u521b\u5efa PoweredDevice \uff0c\u800c\u4e0d\u662f Scanner \u6216 Printer \u3002\u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u8981\u521b\u5efa Scanner \u6216 Printer \u7684\u5b9e\u4f8b\uff0c\u90a3\u4e48\u8c03\u7528\u90a3\u4e9b\u6784\u9020\u51fd\u6570\uff0c\u5e76\u5e94\u7528\u5e38\u89c4\u7ee7\u627f\u89c4\u5219\u3002 \u7b2c\u4e09\uff1a \u5982\u679c\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u4e00\u4e2a\u6216\u591a\u4e2a\u5177\u6709\u865a\u57fa\u7c7b\u7684\u7c7b\uff0c\u5219 \u672b\u7aef\u6d3e\u751f(most derived) \u7684\u7c7b\u8d1f\u8d23\u6784\u9020\u865a\u57fa\u7c7b\u3002\u5728\u672c\u4f8b\u4e2d\uff0cCopier \u7ee7\u627f Printer \u548c Scanner \uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a PoweredDevice \u865a\u62df\u57fa\u7c7b\u3002Copier \u662f\u6700\u6d3e\u751f\u7684\u7c7b\uff0c\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002\u8bf7\u6ce8\u610f\uff0c\u5373\u4f7f\u5728\u5355\u4e00\u7ee7\u627f\u60c5\u51b5\u4e0b\u4e5f\u662f\u5982\u6b64\uff1a\u5982\u679c Copier \u662f\u4ece Printer \u5355\u72ec\u7ee7\u627f\u7684\uff0c\u800c Printer \u5b9e\u9645\u4e0a\u662f\u4ece PoweredDevice \u7ee7\u627f\u7684\uff0cCopier \u4ecd\u7136\u8d1f\u8d23\u521b\u5efa PoweredDevice \u3002 \u7b2c\u56db\uff1a \u7ee7\u627f\u4e00\u4e2a\u865a\u62df\u57fa\u7c7b\u7684\u6240\u6709\u7c7b\u90fd\u5c06\u6709\u4e00\u4e2a\u865a\u62df\u8868\uff0c\u5373\u4f7f\u5b83\u4eec\u901a\u5e38\u4e0d\u4f1a\u6709\uff0c\u5b9e\u4f8b\u5316\u7684\u5bf9\u8c61\u4f1a\u56e0\u4e3a\u8fd9\u4e2a\u6307\u9488\u589e\u52a0\u4e00\u4e9b\u5c3a\u5bf8\u3002 \u56e0\u4e3a Scanner \u548c Printer \u662f\u4ece PoweredDevice \u865a\u7ee7\u627f\u51fa\u6765\u7684\uff0c\u6240\u4ee5 \u53ea\u6709\u4e00\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\u3002Scanner \u548c Printer \u90fd\u9700\u8981\u77e5\u9053\u5982\u4f55\u627e\u5230\u8fd9\u4e2a PoweredDevice \u5b50\u5bf9\u8c61\uff0c\u4ee5\u4fbf\u8bbf\u95ee\u5b83\u7684\u6210\u5458\uff08\u56e0\u4e3a\u6bd5\u7adf\uff0c\u5b83\u4eec\u662f\u4ece\u5b83\u6d3e\u751f\u7684\uff09\u3002\u8fd9\u901a\u5e38\u662f\u901a\u8fc7\u4e00\u4e9b\u865a\u8868\u6765\u5b9e\u73b0\u7684\uff08\u5b83\u5b9e\u9645\u4e0a\u5b58\u50a8\u4e86\u4ece\u6bcf\u4e2a\u5b50\u7c7b\u5230 PoweredDevice \u5b50\u5bf9\u8c61\u7684\u504f\u79fb\u91cf\uff09\u3002","title":"\u865a\u57fa\u7c7b (Virtual base classes)"},{"location":"18-virtual-functions/18.8-object-slicing/","text":"18.8 \u5bf9\u8c61\u5207\u5272 \u00b6 \u4ec0\u4e48\u662f\u5bf9\u8c61\u5207\u5272 \u00b6 \u8ba9\u6211\u4eec\u56de\u5230\u4e4b\u524d\u7684\u4e00\u4e2a\u4f8b\u5b50 class Base { protected : int m_value {}; public : Base ( int value ) : m_value { value } { } virtual const char * getName () const { return \"Base\" ; } int getValue () const { return m_value ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived derived { 5 }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; Base & ref { derived }; std :: cout << \"ref is a \" << ref . getName () << \" and has value \" << ref . getValue () << '\\n' ; Base * ptr { & derived }; std :: cout << \"ptr is a \" << ptr -> getName () << \" and has value \" << ptr -> getValue () << '\\n' ; return 0 ; } \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0cref \u5f15\u7528\u548c ptr \u6307\u9488 \u6307\u5411\u4e86\u5177\u6709 Base \u90e8\u5206\u548c\u884d\u751f\u90e8\u5206\u7684\u5bf9\u8c61\u3002\u56e0\u4e3a ref \u548c ptr \u7684\u7c7b\u578b\u662f Base\uff0cref \u548c ptr \u53ea\u80fd\u770b\u5230(access)\u6d3e\u751f\u7684\u57fa\u90e8\u5206\u2014\u2014\u6d3e\u751f\u7684\u6d3e\u751f\u90e8\u5206\u4ecd\u7136\u5b58\u5728\uff0c\u4f46\u4e0d\u80fd\u901a\u8fc7 ref \u6216 ptr \u770b\u5230\u3002\u4f46\u662f\uff0c\u901a\u8fc7\u4f7f\u7528\u865a\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u51fd\u6570\u7684\u6700\u6d3e\u751f\u7248\u672c\u3002\u56e0\u6b64\uff0c\u4e0a\u8ff0\u7a0b\u5e8f\u6253\u5370\uff1a derived is a Derived and has value 5 ref is a Derived and has value 5 ptr is a Derived and has value 5 \u4f46\u662f\u5982\u679c\u4e0d\u8bbe\u7f6e\u5f15\u7528\u6216\u8005\u6307\u9488\uff0c\u6211\u4eec\u76f4\u63a5\u628a Derived \u5bf9\u8c61\u8d4b\u503c\u7ed9\u57fa Base \u5bf9\u8c61\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { Derived derived { 5 }; Base base { derived }; // what happens here? std :: cout << \"base is a \" << base . getName () << \" and has value \" << base . getValue () << '\\n' ; return 0 ; } \u8bb0\u4f4f\u6d3e\u751f\u5bf9\u8c61\u6709\u4e00\u4e2a\u57fa\u90e8\u5206\u548c\u4e00\u4e2a\u6d3e\u751f\u90e8\u5206\uff0c\u5f53\u6211\u4eec\u8d4b\u503cDerived\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\uff0c\u53ea\u6709 Base \u90e8\u5206\u4f1a\u88ab\u590d\u5236\uff0cDerived \u90e8\u5206\u5219\u4e0d\u4f1a\u3002\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u57fa\u5bf9\u8c61\u63a5\u6536\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\u7684 Base \u90e8\u5206\u7684copy\uff0c\u4f46\u662f\u5ffd\u7565\u4e86 Derived \u90e8\u5206\u3002\u6d3e\u751f\u90e8\u5206\u88ab\u5207\u6389 (sliced off)\u4e86\u3002 \u56e0\u6b64\uff0c\u8fd9\u79cd\u5bf9\u6d3e\u751f\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\u7684\u8d4b\u503c\u53eb\u505a\uff0c\u5bf9\u8c61\u5207\u5272\u3002 \u56e0\u4e3a Base \u6ca1\u6709\u5305\u542b Derived \u90e8\u5206\uff0c\u56e0\u6b64 base.getName() \u4f1a\u51b3\u5b9a\u8c03\u7528 Base::getName() \u3002 \u4ee5\u4e0a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a base is a Base and has value 5 \u7528\u7684\u4ed4\u7ec6\uff0c\u5207\u5272\u4f1a\u662f\u4e00\u79cd\u4f18\u79c0\u7684\u64cd\u4f5c\u3002\u7136\u800c\u82e5\u7c97\u5fc3\u4f7f\u7528\u4f1a\u917f\u6210\u5927\u7978\uff0c\u5207\u5272\u4f1a\u9020\u6210\u4e0d\u53ef\u9884\u6599\u7684\u7ed3\u679c\uff0c\u4ee5\u5f88\u591a\u4e0d\u540c\u7684\u65b9\u5f0f\uff0c\u8ba9\u6211\u4eec\u6765\u9a8c\u8bc1\u8fd9\u4e9b\u4f8b\u5b50\u3002 \u7cdf\u7cd5\u7684\u7528\u6cd5 \u00b6 Slicing and functions \u00b6 \u73b0\u5728\u4f60\u53ef\u80fd\u8ba4\u4e3a\u4e0a\u65b9\u7684\u4f8b\u5b50\u6709\u70b9\u8822\uff0c\u6bd5\u7adf\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u50cf\u90a3\u6837\u628a\u6d3e\u751f\u7c7b\u8d4b\u503c\u5230\u57fa\u7c7b\u5462\uff1f\u4f60\u53ef\u80fd\u4e0d\u4f1a\u90a3\u4e48\u505a\uff0c\u7136\u800c\u5207\u5272\u5e38\u5e38\u610f\u5916\u7684\u53d1\u751f\uff0c\u5f53\u914d\u5408\u51fd\u6570\u98df\u7528\u65f6\u3002 \u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570 void printName ( const Base base ) // note: base \u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u800c\u4e0d\u662f\u5f15\u7528 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } \u8fd9\u662f\u4e00\u4e2a\u76f8\u5f53\u7b80\u5355\u7684\u5e26\u6709\u5e38\u91cf\u57fa\u5bf9\u8c61\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u5982\u679c\u6211\u4eec\u50cf\u8fd9\u6837\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff1a int main () { Derived d { 5 }; printName ( d ); // oops, \u6ca1\u6709\u610f\u8bc6\u5230\u8fd9\u662f\u901a\u8fc7\u503c\u4f20\u53c2\u3002 return 0 ; } \u5f53\u4f60\u5199\u4e0b\u8fd9\u4e2a\u7a0b\u5e8f\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u6ca1\u610f\u8bc6\u5230 base \u662f\u4e00\u4e2a\u503c\u53c2\u6570\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5f15\u7528\u3002\u56e0\u6b64\u5f53\u6211\u4eec\u8c03\u7528 printName(d) \u65f6\uff0c\u6211\u4eec\u4e5f\u8bb8\u4f1a\u671f\u5f85 base.getName() \u6765\u8c03\u7528\u865a\u51fd\u6570 getName() \u5e76\u4e14\u6253\u5370 \"I am a Derived\"\uff0c\u4f46\u662f\u90a3\u4e0d\u4f1a\u53d1\u751f\u3002\u76f8\u53cd\uff0cDerived \u7684\u5bf9\u8c61 d \u4f1a\u88ab\u5207\u5272\uff0c\u53ea\u6709 Base \u90e8\u5206\u88ab\u62f7\u8d1d\u4f5c\u4e3a base \u53c2\u6570\u3002\u5f53 base.getName() \u6267\u884c\u65f6\uff0c\u5c3d\u7ba1 getName() \u51fd\u6570\u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f46\u662f\u8fd9\u4e2a\u5bf9\u8c61\u6ca1\u6709\u6d3e\u751f\u90e8\u5206\u6765\u89e3\u6790\uff0c\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\u5982\u4e0b\uff1a I am a Base \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u663e\u800c\u6613\u89c1\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u4f46\u662f\u5982\u679c\u4f60\u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u6ca1\u6709\u6253\u5370\u4efb\u4f55\u8fd9\u6837\u7684\u8bc6\u522b\u4fe1\u606f\uff0c\u5dee\u9519\u5c06\u53d8\u5f97\u975e\u5e38\u6709\u6311\u6218\u3002 \u5f53\u7136\uff0c\u8fd9\u91cc\u53d1\u751f\u7684\u5207\u5272\uff0c\u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u901a\u8fc7\u8bbe\u7f6e\u51fd\u6570\u53c2\u6570\u4e3a\u5f15\u7528\u6765\u907f\u514d\uff0c\u800c\u4e0d\u662f\u4f20\u503c\u3002\uff08\u53e6\u4e00\u4e2a\u539f\u56e0\u4e3a\u4ec0\u4e48\u5efa\u8bae\u4f20\u5f15\u7528\u7684good idea\uff09\u3002 void printName ( const Base & base ) // note: base \u901a\u8fc7\u5f15\u7528\u4f20\u53c2 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } int main () { Derived d { 5 }; printName ( d ); return 0 ; } \u8fd9\u5c06\u6253\u5370 I am a Derived \u5207\u5272Vector (Slicing vectors) \u00b6 Yet another area where new programmers run into trouble with slicing is trying to implement polymorphism with std::vector. Consider the following program: \u53e6\u4e00\u4e2a\u7a0b\u5e8f\u65b0\u624b\u5728\u4f7f\u7528 std::vector \u6765\u5b9e\u73b0\u591a\u6001\u6027\u65f6\u5e38\u5e38\u9047\u5230\u7684\u95ee\u9898\u662f\u3002\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a #include <vector> int main () { std :: vector < Base > v {}; v . push_back ( Base { 5 }); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230vector v . push_back ( Derived { 6 }); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230vector // \u6253\u5370\u6240\u6709vector\u4e2d\u7684\u5bf9\u8c61 for ( const auto & element : v ) std :: cout << \"I am a \" << element . getName () << \" with value \" << element . getValue () << '\\n' ; return 0 ; } \u7a0b\u5e8f\u7f16\u8bd1\u6ca1\u95ee\u9898\uff0c\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Base with value 6 \u548c\u4e4b\u524d\u7684\u4f8b\u5b50\u76f8\u4f3c\uff0c\u56e0\u4e3a std::vector \u88ab\u58f0\u660e\u4e3a Base \u7c7b\u578b\uff0c\u5f53 Derived(6) \u6dfb\u52a0\u5230vector\u65f6\uff0c\u5b83\u5df2\u7ecf\u88ab\u5207\u5272\u4e86\u3002 \u4fee\u590d\u8fd9\u4e2a\u95ee\u9898\u6709\u4e00\u4e9b\u56f0\u96be\uff0c\u5f88\u591a\u65b0\u624b\u7a0b\u5e8f\u5458\u5c1d\u8bd5\u521b\u5efa\u4e00\u4e2a \u5f15\u7528\u7c7b\u578b\u7684 std::vector \u50cf\u8fd9\u6837\u3002 std :: vector < Base &> v {}; \u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u5c06\u4e0d\u4f1a\u7f16\u8bd1\uff0c std::vector \u7684\u5bf9\u8c61\u5fc5\u987b\u662f\u53ef\u8d4b\u503c\u7684\uff0c\u7136\u800c\u5f15\u7528\u4e0d\u80fd\u88ab\u8d4b\u503c\uff08\u53ea\u6709\u5728\u521d\u59cb\u5316\u65f6\u5f15\u7528\u80fd\u88ab\u8d4b\u503c\uff09 \u89e3\u51b3\u8fd9\u4e2a\u8fd9\u4e2a\u95ee\u9898\u7684\u4e00\u4e2a\u65b9\u5f0f\u5c31\u662f\u521b\u5efa\u6307\u9488\u7c7b\u578b\u7684 std::vector # include <iostream> # include <vector> int main () { std :: vector < Base *> v {}; Base b { 5 }; // b and d \u4e0d\u80fd\u662f\u533f\u540d\u5bf9\u8c61\uff0c\u5fc5\u987b\u5148\u5b9e\u4f8b\u5316\u51fa\u6765 Derived d { 6 }; v . push_back ( & b ); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230 vector v . push_back ( & d ); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230 vector // \u6253\u5370\u6240\u6709 for ( const auto * element : v ) std :: cout << \"I am a \" << element -> getName () << \" with value \" << element -> getValue () << '\\n' ; return 0 ; } \u8fd9\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Derived with value 6 \u5b83\u5de5\u4f5c\u4e86\uff01\u8fd9\u91cc\u8bf4\u4e00\u4e9b\u5173\u4e8e\u8fd9\u4e2a\u4f8b\u5b50\u7684\u4e00\u4e9b\u8bf4\u660e\uff0c \u7b2c\u4e00 \uff0cnullpter \u73b0\u5728\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u9009\u9879\uff0c\u4e5f\u8bb8\u6216\u4e5f\u8bb8\u4e0d\u5408\u4f60\u7684\u4f7f\u7528\u573a\u666f\u3002 \u7b2c\u4e8c \uff0c\u4f60\u73b0\u5728\u4e0d\u5f97\u4e0d\u8fdb\u884c\u6307\u9488\u64cd\u4f5c\uff0c\u53ef\u80fd\u662f\u7b28\u91cd(awkward)\u7684\u3002\u4f46\u662f\u4ece\u597d\u7684\u65b9\u9762\u6765\u8bf4\uff0c\u8fd9\u4e5f\u5141\u8bb8\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u53ef\u80fd\u6027\uff0c\u5982\u679c\u4f60\u7684\u5bf9\u8c61\u8d85\u51fa\u8303\u56f4\u90a3\u5c06\u662f\u975e\u5e38\u6709\u7528\u7684\u3002(But on the upside, this also allows the possibility of dynamic memory allocation, which is useful if your objects might otherwise go out of scope.) The Frankenobject \u00b6 \u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86\u5bf9\u8c61\u5207\u5272\u7531\u4e8e\u6d3e\u751f\u7c7b\u90e8\u5206\u88ab\u5207\u9664\u9020\u6210\u7684\u4e00\u4e9b\u5751\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u6d3e\u751f\u5bf9\u8c61\u4ecd\u7136\u5b58\u5728\u7684\u53e6\u4e00\u4e2a\u5371\u9669\u60c5\u51b5\uff01 \u601d\u8003\u5982\u4e0b\u4ee3\u7801\uff1a int main () { Derived d1 { 5 }; Derived d2 { 6 }; Base & b { d2 }; b = d1 ; // \u8fd9\u884c\u5c31\u662f\u95ee\u9898\u6240\u5728 return 0 ; } \u5f00\u59cb\u4e09\u884c\u5f88\u7b80\u5355\u76f4\u63a5\uff0c\u521b\u5efa\u4e24\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u521b\u5efa\u4e00\u4e2a\u5f15\u7528\u5230 d2 \u7b2c\u56db\u884c\u5c31\u662f\u5bfc\u81f4\u9519\u8bef\u7684\u4e00\u884c\uff0c\u5f53 b \u6307\u5411 d2 \u65f6\uff0c\u6211\u4eec\u8d4b\u503c d1 \u7ed9 b , \u4f60\u53ef\u80fd\u8ba4\u4e3a\u7ed3\u679c\u5c31\u662f d1 \u88ab\u62f7\u8d1d\u5230\u4e86d2 \u2014\u2014 \u5982\u679c b \u662f \u4e00\u4e2aDerived \u5bf9\u8c61\uff0c\u90a3\u4e48\u7ed3\u679c\u662f\u8fd9\u6837\u7684\u3002\u4f46\u662f b \u662f\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u5e76\u4e14 c++ \u63d0\u4f9b\u7684\u64cd\u4f5c\u7b26 = \u5e76\u4e0d\u662f\u865a\u51fd\u6570\u3002\u56e0\u6b64\uff0c\u53ea\u6709 d1 \u7684Base \u90e8\u5206\u88ab\u62f7\u8d1d\u5230\u4e86 d2 \u3002 \u7ed3\u679c\uff0c\u4f60\u4f1a\u53d1\u73b0 d2 \u73b0\u5728\u6709 d1 \u7684 Base \u90e8\u5206\u548c d2 \u7684 Derived \u90e8\u5206\u3002\u5728\u8fd9\u4e2a\u7279\u5b9a\u7684\u4f8b\u5b50\u4e2d\uff0c\u51fa\u73b0\u8fd9\u4e2a\u60c5\u51b5\u5e76\u6ca1\u6709\u95ee\u9898\u3002\uff08\u56e0\u4e3a Derived \u7c7b\u5e76\u6ca1\u6709\u5b83\u81ea\u5df1\u7684\u6570\u636e\uff09\uff0c\u4f46\u662f\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u5c06\u4f1a\u521b\u5efa\u4e00\u4e2a Frankenobject \u2014\u2014 \u7531\u591a\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\u7684\u4e0d\u540c\u90e8\u5206\u7ec4\u6210\u7684\u5bf9\u8c61\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u6ca1\u6709\u5bb9\u6613\u7684\u65b9\u6cd5\u6765\u963b\u6b62\u8fd9\u4e2a\u60c5\u51b5\u7684\u53d1\u751f\u3002\uff08\u9664\u4e86\u5c3d\u53ef\u80fd\u907f\u514d\u50cf\u8fd9\u6837\u7684\u8d4b\u503c\u64cd\u4f5c\uff09 \u7ed3\u8bba \u00b6 \u5c3d\u7ba1 C++ \u652f\u6301\u5c06 base \u5bf9\u8c61\u8d4b\u503c\u7ed9 derived \u5bf9\u8c61\uff0c\u901a\u8fc7\u5bf9\u8c61\u5207\u5272\uff0c\u4f46\u662f\u901a\u5e38\u8fd9\u5f88\u53ef\u80fd\u4f1a\u6ca1\u5565\u5e2e\u52a9\uff0c\u9664\u4e86\u8ba9\u4f60\u5934\u75bc\u4e4b\u5916\uff0c\u4f60\u5e73\u65f6\u5e94\u8be5\u907f\u514d\u5bf9\u8c61\u5207\u5272\u7684\u53d1\u751f\u3002\u786e\u4fdd\u4f60\u7684\u51fd\u6570\u53c2\u6570\u662f\u5f15\u7528\uff08\u6216\u6307\u9488\uff09\u5e76\u4e14\u5c1d\u8bd5\u907f\u514d\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u4f20\u53c2\uff0c\u5f53\u4f7f\u7528\u6d3e\u751f\u7c7b\u7684\u65f6\u5019\u3002","title":"18.8 \u5bf9\u8c61\u5207\u5272"},{"location":"18-virtual-functions/18.8-object-slicing/#188","text":"","title":"18.8 \u5bf9\u8c61\u5207\u5272"},{"location":"18-virtual-functions/18.8-object-slicing/#_1","text":"\u8ba9\u6211\u4eec\u56de\u5230\u4e4b\u524d\u7684\u4e00\u4e2a\u4f8b\u5b50 class Base { protected : int m_value {}; public : Base ( int value ) : m_value { value } { } virtual const char * getName () const { return \"Base\" ; } int getValue () const { return m_value ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived derived { 5 }; std :: cout << \"derived is a \" << derived . getName () << \" and has value \" << derived . getValue () << '\\n' ; Base & ref { derived }; std :: cout << \"ref is a \" << ref . getName () << \" and has value \" << ref . getValue () << '\\n' ; Base * ptr { & derived }; std :: cout << \"ptr is a \" << ptr -> getName () << \" and has value \" << ptr -> getValue () << '\\n' ; return 0 ; } \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0cref \u5f15\u7528\u548c ptr \u6307\u9488 \u6307\u5411\u4e86\u5177\u6709 Base \u90e8\u5206\u548c\u884d\u751f\u90e8\u5206\u7684\u5bf9\u8c61\u3002\u56e0\u4e3a ref \u548c ptr \u7684\u7c7b\u578b\u662f Base\uff0cref \u548c ptr \u53ea\u80fd\u770b\u5230(access)\u6d3e\u751f\u7684\u57fa\u90e8\u5206\u2014\u2014\u6d3e\u751f\u7684\u6d3e\u751f\u90e8\u5206\u4ecd\u7136\u5b58\u5728\uff0c\u4f46\u4e0d\u80fd\u901a\u8fc7 ref \u6216 ptr \u770b\u5230\u3002\u4f46\u662f\uff0c\u901a\u8fc7\u4f7f\u7528\u865a\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u8bbf\u95ee\u51fd\u6570\u7684\u6700\u6d3e\u751f\u7248\u672c\u3002\u56e0\u6b64\uff0c\u4e0a\u8ff0\u7a0b\u5e8f\u6253\u5370\uff1a derived is a Derived and has value 5 ref is a Derived and has value 5 ptr is a Derived and has value 5 \u4f46\u662f\u5982\u679c\u4e0d\u8bbe\u7f6e\u5f15\u7528\u6216\u8005\u6307\u9488\uff0c\u6211\u4eec\u76f4\u63a5\u628a Derived \u5bf9\u8c61\u8d4b\u503c\u7ed9\u57fa Base \u5bf9\u8c61\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { Derived derived { 5 }; Base base { derived }; // what happens here? std :: cout << \"base is a \" << base . getName () << \" and has value \" << base . getValue () << '\\n' ; return 0 ; } \u8bb0\u4f4f\u6d3e\u751f\u5bf9\u8c61\u6709\u4e00\u4e2a\u57fa\u90e8\u5206\u548c\u4e00\u4e2a\u6d3e\u751f\u90e8\u5206\uff0c\u5f53\u6211\u4eec\u8d4b\u503cDerived\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\uff0c\u53ea\u6709 Base \u90e8\u5206\u4f1a\u88ab\u590d\u5236\uff0cDerived \u90e8\u5206\u5219\u4e0d\u4f1a\u3002\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u57fa\u5bf9\u8c61\u63a5\u6536\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\u7684 Base \u90e8\u5206\u7684copy\uff0c\u4f46\u662f\u5ffd\u7565\u4e86 Derived \u90e8\u5206\u3002\u6d3e\u751f\u90e8\u5206\u88ab\u5207\u6389 (sliced off)\u4e86\u3002 \u56e0\u6b64\uff0c\u8fd9\u79cd\u5bf9\u6d3e\u751f\u5bf9\u8c61\u5230\u57fa\u5bf9\u8c61\u7684\u8d4b\u503c\u53eb\u505a\uff0c\u5bf9\u8c61\u5207\u5272\u3002 \u56e0\u4e3a Base \u6ca1\u6709\u5305\u542b Derived \u90e8\u5206\uff0c\u56e0\u6b64 base.getName() \u4f1a\u51b3\u5b9a\u8c03\u7528 Base::getName() \u3002 \u4ee5\u4e0a\u4f8b\u5b50\u4f1a\u6253\u5370\uff1a base is a Base and has value 5 \u7528\u7684\u4ed4\u7ec6\uff0c\u5207\u5272\u4f1a\u662f\u4e00\u79cd\u4f18\u79c0\u7684\u64cd\u4f5c\u3002\u7136\u800c\u82e5\u7c97\u5fc3\u4f7f\u7528\u4f1a\u917f\u6210\u5927\u7978\uff0c\u5207\u5272\u4f1a\u9020\u6210\u4e0d\u53ef\u9884\u6599\u7684\u7ed3\u679c\uff0c\u4ee5\u5f88\u591a\u4e0d\u540c\u7684\u65b9\u5f0f\uff0c\u8ba9\u6211\u4eec\u6765\u9a8c\u8bc1\u8fd9\u4e9b\u4f8b\u5b50\u3002","title":"\u4ec0\u4e48\u662f\u5bf9\u8c61\u5207\u5272"},{"location":"18-virtual-functions/18.8-object-slicing/#_2","text":"","title":"\u7cdf\u7cd5\u7684\u7528\u6cd5"},{"location":"18-virtual-functions/18.8-object-slicing/#slicing-and-functions","text":"\u73b0\u5728\u4f60\u53ef\u80fd\u8ba4\u4e3a\u4e0a\u65b9\u7684\u4f8b\u5b50\u6709\u70b9\u8822\uff0c\u6bd5\u7adf\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u50cf\u90a3\u6837\u628a\u6d3e\u751f\u7c7b\u8d4b\u503c\u5230\u57fa\u7c7b\u5462\uff1f\u4f60\u53ef\u80fd\u4e0d\u4f1a\u90a3\u4e48\u505a\uff0c\u7136\u800c\u5207\u5272\u5e38\u5e38\u610f\u5916\u7684\u53d1\u751f\uff0c\u5f53\u914d\u5408\u51fd\u6570\u98df\u7528\u65f6\u3002 \u601d\u8003\u4e0b\u9762\u7684\u51fd\u6570 void printName ( const Base base ) // note: base \u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u800c\u4e0d\u662f\u5f15\u7528 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } \u8fd9\u662f\u4e00\u4e2a\u76f8\u5f53\u7b80\u5355\u7684\u5e26\u6709\u5e38\u91cf\u57fa\u5bf9\u8c61\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7\u503c\u4f20\u53c2\uff0c\u5982\u679c\u6211\u4eec\u50cf\u8fd9\u6837\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff1a int main () { Derived d { 5 }; printName ( d ); // oops, \u6ca1\u6709\u610f\u8bc6\u5230\u8fd9\u662f\u901a\u8fc7\u503c\u4f20\u53c2\u3002 return 0 ; } \u5f53\u4f60\u5199\u4e0b\u8fd9\u4e2a\u7a0b\u5e8f\u7684\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u6ca1\u610f\u8bc6\u5230 base \u662f\u4e00\u4e2a\u503c\u53c2\u6570\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5f15\u7528\u3002\u56e0\u6b64\u5f53\u6211\u4eec\u8c03\u7528 printName(d) \u65f6\uff0c\u6211\u4eec\u4e5f\u8bb8\u4f1a\u671f\u5f85 base.getName() \u6765\u8c03\u7528\u865a\u51fd\u6570 getName() \u5e76\u4e14\u6253\u5370 \"I am a Derived\"\uff0c\u4f46\u662f\u90a3\u4e0d\u4f1a\u53d1\u751f\u3002\u76f8\u53cd\uff0cDerived \u7684\u5bf9\u8c61 d \u4f1a\u88ab\u5207\u5272\uff0c\u53ea\u6709 Base \u90e8\u5206\u88ab\u62f7\u8d1d\u4f5c\u4e3a base \u53c2\u6570\u3002\u5f53 base.getName() \u6267\u884c\u65f6\uff0c\u5c3d\u7ba1 getName() \u51fd\u6570\u662f\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f46\u662f\u8fd9\u4e2a\u5bf9\u8c61\u6ca1\u6709\u6d3e\u751f\u90e8\u5206\u6765\u89e3\u6790\uff0c\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370\u5982\u4e0b\uff1a I am a Base \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u663e\u800c\u6613\u89c1\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u4f46\u662f\u5982\u679c\u4f60\u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u6ca1\u6709\u6253\u5370\u4efb\u4f55\u8fd9\u6837\u7684\u8bc6\u522b\u4fe1\u606f\uff0c\u5dee\u9519\u5c06\u53d8\u5f97\u975e\u5e38\u6709\u6311\u6218\u3002 \u5f53\u7136\uff0c\u8fd9\u91cc\u53d1\u751f\u7684\u5207\u5272\uff0c\u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u901a\u8fc7\u8bbe\u7f6e\u51fd\u6570\u53c2\u6570\u4e3a\u5f15\u7528\u6765\u907f\u514d\uff0c\u800c\u4e0d\u662f\u4f20\u503c\u3002\uff08\u53e6\u4e00\u4e2a\u539f\u56e0\u4e3a\u4ec0\u4e48\u5efa\u8bae\u4f20\u5f15\u7528\u7684good idea\uff09\u3002 void printName ( const Base & base ) // note: base \u901a\u8fc7\u5f15\u7528\u4f20\u53c2 { std :: cout << \"I am a \" << base . getName () << '\\n' ; } int main () { Derived d { 5 }; printName ( d ); return 0 ; } \u8fd9\u5c06\u6253\u5370 I am a Derived","title":"Slicing and functions"},{"location":"18-virtual-functions/18.8-object-slicing/#vector-slicing-vectors","text":"Yet another area where new programmers run into trouble with slicing is trying to implement polymorphism with std::vector. Consider the following program: \u53e6\u4e00\u4e2a\u7a0b\u5e8f\u65b0\u624b\u5728\u4f7f\u7528 std::vector \u6765\u5b9e\u73b0\u591a\u6001\u6027\u65f6\u5e38\u5e38\u9047\u5230\u7684\u95ee\u9898\u662f\u3002\u601d\u8003\u4e0b\u5217\u7a0b\u5e8f\uff1a #include <vector> int main () { std :: vector < Base > v {}; v . push_back ( Base { 5 }); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230vector v . push_back ( Derived { 6 }); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230vector // \u6253\u5370\u6240\u6709vector\u4e2d\u7684\u5bf9\u8c61 for ( const auto & element : v ) std :: cout << \"I am a \" << element . getName () << \" with value \" << element . getValue () << '\\n' ; return 0 ; } \u7a0b\u5e8f\u7f16\u8bd1\u6ca1\u95ee\u9898\uff0c\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Base with value 6 \u548c\u4e4b\u524d\u7684\u4f8b\u5b50\u76f8\u4f3c\uff0c\u56e0\u4e3a std::vector \u88ab\u58f0\u660e\u4e3a Base \u7c7b\u578b\uff0c\u5f53 Derived(6) \u6dfb\u52a0\u5230vector\u65f6\uff0c\u5b83\u5df2\u7ecf\u88ab\u5207\u5272\u4e86\u3002 \u4fee\u590d\u8fd9\u4e2a\u95ee\u9898\u6709\u4e00\u4e9b\u56f0\u96be\uff0c\u5f88\u591a\u65b0\u624b\u7a0b\u5e8f\u5458\u5c1d\u8bd5\u521b\u5efa\u4e00\u4e2a \u5f15\u7528\u7c7b\u578b\u7684 std::vector \u50cf\u8fd9\u6837\u3002 std :: vector < Base &> v {}; \u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u5c06\u4e0d\u4f1a\u7f16\u8bd1\uff0c std::vector \u7684\u5bf9\u8c61\u5fc5\u987b\u662f\u53ef\u8d4b\u503c\u7684\uff0c\u7136\u800c\u5f15\u7528\u4e0d\u80fd\u88ab\u8d4b\u503c\uff08\u53ea\u6709\u5728\u521d\u59cb\u5316\u65f6\u5f15\u7528\u80fd\u88ab\u8d4b\u503c\uff09 \u89e3\u51b3\u8fd9\u4e2a\u8fd9\u4e2a\u95ee\u9898\u7684\u4e00\u4e2a\u65b9\u5f0f\u5c31\u662f\u521b\u5efa\u6307\u9488\u7c7b\u578b\u7684 std::vector # include <iostream> # include <vector> int main () { std :: vector < Base *> v {}; Base b { 5 }; // b and d \u4e0d\u80fd\u662f\u533f\u540d\u5bf9\u8c61\uff0c\u5fc5\u987b\u5148\u5b9e\u4f8b\u5316\u51fa\u6765 Derived d { 6 }; v . push_back ( & b ); // \u6dfb\u52a0\u4e00\u4e2a Base \u5bf9\u8c61\u5230 vector v . push_back ( & d ); // \u6dfb\u52a0\u4e00\u4e2a Derived \u5bf9\u8c61\u5230 vector // \u6253\u5370\u6240\u6709 for ( const auto * element : v ) std :: cout << \"I am a \" << element -> getName () << \" with value \" << element -> getValue () << '\\n' ; return 0 ; } \u8fd9\u4f1a\u6253\u5370\uff1a I am a Base with value 5 I am a Derived with value 6 \u5b83\u5de5\u4f5c\u4e86\uff01\u8fd9\u91cc\u8bf4\u4e00\u4e9b\u5173\u4e8e\u8fd9\u4e2a\u4f8b\u5b50\u7684\u4e00\u4e9b\u8bf4\u660e\uff0c \u7b2c\u4e00 \uff0cnullpter \u73b0\u5728\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u9009\u9879\uff0c\u4e5f\u8bb8\u6216\u4e5f\u8bb8\u4e0d\u5408\u4f60\u7684\u4f7f\u7528\u573a\u666f\u3002 \u7b2c\u4e8c \uff0c\u4f60\u73b0\u5728\u4e0d\u5f97\u4e0d\u8fdb\u884c\u6307\u9488\u64cd\u4f5c\uff0c\u53ef\u80fd\u662f\u7b28\u91cd(awkward)\u7684\u3002\u4f46\u662f\u4ece\u597d\u7684\u65b9\u9762\u6765\u8bf4\uff0c\u8fd9\u4e5f\u5141\u8bb8\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\u53ef\u80fd\u6027\uff0c\u5982\u679c\u4f60\u7684\u5bf9\u8c61\u8d85\u51fa\u8303\u56f4\u90a3\u5c06\u662f\u975e\u5e38\u6709\u7528\u7684\u3002(But on the upside, this also allows the possibility of dynamic memory allocation, which is useful if your objects might otherwise go out of scope.)","title":"\u5207\u5272Vector (Slicing vectors)"},{"location":"18-virtual-functions/18.8-object-slicing/#the-frankenobject","text":"\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86\u5bf9\u8c61\u5207\u5272\u7531\u4e8e\u6d3e\u751f\u7c7b\u90e8\u5206\u88ab\u5207\u9664\u9020\u6210\u7684\u4e00\u4e9b\u5751\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u6d3e\u751f\u5bf9\u8c61\u4ecd\u7136\u5b58\u5728\u7684\u53e6\u4e00\u4e2a\u5371\u9669\u60c5\u51b5\uff01 \u601d\u8003\u5982\u4e0b\u4ee3\u7801\uff1a int main () { Derived d1 { 5 }; Derived d2 { 6 }; Base & b { d2 }; b = d1 ; // \u8fd9\u884c\u5c31\u662f\u95ee\u9898\u6240\u5728 return 0 ; } \u5f00\u59cb\u4e09\u884c\u5f88\u7b80\u5355\u76f4\u63a5\uff0c\u521b\u5efa\u4e24\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u521b\u5efa\u4e00\u4e2a\u5f15\u7528\u5230 d2 \u7b2c\u56db\u884c\u5c31\u662f\u5bfc\u81f4\u9519\u8bef\u7684\u4e00\u884c\uff0c\u5f53 b \u6307\u5411 d2 \u65f6\uff0c\u6211\u4eec\u8d4b\u503c d1 \u7ed9 b , \u4f60\u53ef\u80fd\u8ba4\u4e3a\u7ed3\u679c\u5c31\u662f d1 \u88ab\u62f7\u8d1d\u5230\u4e86d2 \u2014\u2014 \u5982\u679c b \u662f \u4e00\u4e2aDerived \u5bf9\u8c61\uff0c\u90a3\u4e48\u7ed3\u679c\u662f\u8fd9\u6837\u7684\u3002\u4f46\u662f b \u662f\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u5e76\u4e14 c++ \u63d0\u4f9b\u7684\u64cd\u4f5c\u7b26 = \u5e76\u4e0d\u662f\u865a\u51fd\u6570\u3002\u56e0\u6b64\uff0c\u53ea\u6709 d1 \u7684Base \u90e8\u5206\u88ab\u62f7\u8d1d\u5230\u4e86 d2 \u3002 \u7ed3\u679c\uff0c\u4f60\u4f1a\u53d1\u73b0 d2 \u73b0\u5728\u6709 d1 \u7684 Base \u90e8\u5206\u548c d2 \u7684 Derived \u90e8\u5206\u3002\u5728\u8fd9\u4e2a\u7279\u5b9a\u7684\u4f8b\u5b50\u4e2d\uff0c\u51fa\u73b0\u8fd9\u4e2a\u60c5\u51b5\u5e76\u6ca1\u6709\u95ee\u9898\u3002\uff08\u56e0\u4e3a Derived \u7c7b\u5e76\u6ca1\u6709\u5b83\u81ea\u5df1\u7684\u6570\u636e\uff09\uff0c\u4f46\u662f\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u5c06\u4f1a\u521b\u5efa\u4e00\u4e2a Frankenobject \u2014\u2014 \u7531\u591a\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\u7684\u4e0d\u540c\u90e8\u5206\u7ec4\u6210\u7684\u5bf9\u8c61\u3002\u66f4\u7cdf\u7cd5\u7684\u662f\uff0c\u6ca1\u6709\u5bb9\u6613\u7684\u65b9\u6cd5\u6765\u963b\u6b62\u8fd9\u4e2a\u60c5\u51b5\u7684\u53d1\u751f\u3002\uff08\u9664\u4e86\u5c3d\u53ef\u80fd\u907f\u514d\u50cf\u8fd9\u6837\u7684\u8d4b\u503c\u64cd\u4f5c\uff09","title":"The Frankenobject"},{"location":"18-virtual-functions/18.8-object-slicing/#_3","text":"\u5c3d\u7ba1 C++ \u652f\u6301\u5c06 base \u5bf9\u8c61\u8d4b\u503c\u7ed9 derived \u5bf9\u8c61\uff0c\u901a\u8fc7\u5bf9\u8c61\u5207\u5272\uff0c\u4f46\u662f\u901a\u5e38\u8fd9\u5f88\u53ef\u80fd\u4f1a\u6ca1\u5565\u5e2e\u52a9\uff0c\u9664\u4e86\u8ba9\u4f60\u5934\u75bc\u4e4b\u5916\uff0c\u4f60\u5e73\u65f6\u5e94\u8be5\u907f\u514d\u5bf9\u8c61\u5207\u5272\u7684\u53d1\u751f\u3002\u786e\u4fdd\u4f60\u7684\u51fd\u6570\u53c2\u6570\u662f\u5f15\u7528\uff08\u6216\u6307\u9488\uff09\u5e76\u4e14\u5c1d\u8bd5\u907f\u514d\u4efb\u4f55\u7c7b\u578b\u7684\u503c\u4f20\u53c2\uff0c\u5f53\u4f7f\u7528\u6d3e\u751f\u7c7b\u7684\u65f6\u5019\u3002","title":"\u7ed3\u8bba"},{"location":"18-virtual-functions/18.9-dynamic-casting/","text":"18.9 \u52a8\u6001\u7c7b\u578b\u8f6c\u6362 \u00b6 \u65e9\u5728 \u7b2c6.16\u8bfe\u2014\u2014\u663e\u5f0f\u7c7b\u578b\u8f6c\u6362\uff08casting\uff09\u548cstatic_cast \u4e2d\uff0c\u6211\u4eec\u7814\u7a76\u4e86 casting \u7684\u6982\u5ff5\uff0c\u4ee5\u53ca\u4f7f\u7528 static_cast \u5c06\u53d8\u91cf\u4ece\u4e00\u79cd\u7c7b\u578b\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u7c7b\u578b\u3002 \u5728\u672c\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u7814\u7a76\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u5f3a\u5236\u8f6c\u6362\uff1a\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 (Dynamic cast) \u4f55\u65f6\u9700\u8981\u8fdb\u884c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 \u00b6 \u5728\u5904\u7406\u591a\u6001\u6027\u65f6\uff0c\u60a8\u7ecf\u5e38\u4f1a\u9047\u5230\u8fd9\u6837\u7684\u60c5\u51b5\uff1a\u4f60\u6709\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\uff0c\u4f46\u4f60\u5e0c\u671b\u8bbf\u95ee\u4ec5\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\u4e2d\u7684\u67d0\u4e9b\u4fe1\u606f\u3002 \u601d\u8003\u4e0b\u5217\u8fd9\u4e2a\uff08\u4e0d\u592a\u81ea\u7136\u7684\uff09\u4f8b\u5b50 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); // \u6211\u4eec\u5e94\u8be5\u5982\u4f55\u6253\u5370\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u540d\u5b57\uff1f\u53ea\u6709\u57fa\u7c7b\u6307\u9488 delete b ; return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u51fd\u6570 getObject() \u603b\u662f\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u4f46\u662f\u8fd9\u4e2a\u6307\u9488\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u4e5f\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u5728\u4f8b\u5b50\u4e2d\u7684 Base \u6307\u9488 b \u5b9e\u9645\u6307\u5411\u7684\u662f\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5e94\u8be5\u5982\u4f55\u8c03\u7528 Derived::getName() \uff1f \u4e00\u4e2a\u65b9\u6cd5\u4f1a\u662f\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230 Base \u7c7b\uff0c\u53eb getName() \uff08\u8fd9\u6837\u505a\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u5b83\uff0c\u901a\u8fc7 Base \u7684\u6307\u9488\u6216\u5f15\u7528\uff0c\u5b83\u90fd\u4f1a\u52a8\u6001\u5b9a\u5411\u5230 Derived::getName() \uff09\u3002\u4f46\u662f\u5982\u679c\u4f60\u8c03\u7528\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a Base \u7c7b\u7684\u6307\u9488\u4f1a\u5f15\u7528\uff0c\u6307\u5411\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u90a3\u5c06\u4f1a\u8fd4\u56de\u4ec0\u4e48\uff1f\u6ca1\u6709\u4efb\u4f55\u503c\u771f\u6b63\u6709\u4ef7\u503c\u3002\u6b64\u5916\uff0c\u6211\u4eec\u5c06\u4f1a\u7528\u4e00\u4e9b\u4e1c\u897f\u6c61\u67d3\u6211\u4eec\u7684 Base \u7c7b\uff0c\u8fd9\u4e9b\u7684\u4e1c\u897f\u672c\u6765\u5e94\u8be5\u53ea\u5728\u6d3e\u751f\u7c7b\u4e2d\u5b58\u5728\u3002 \u6211\u4eec\u90fd\u77e5\u9053\uff0c C++ \u5c06\u4f1a\u9690\u5f0f\u7684\u8ba9\u4f60\u8f6c\u5316\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u4e3a\u4e00\u4e2a\u57fa\u7c7b\u6307\u6b63\u3002\uff08\u4e8b\u5b9e\u4e0a\uff0c getObjectt() \u5c31\u505a\u4e86\u90a3\u6837\u7684\u4e8b\u60c5\uff09\u3002\u8fd9\u79cd\u8fc7\u7a0b\u6709\u65f6\u5019\u88ab\u53eb\u505a\u5411\u4e0a\u8f6c\u5316\u3002\u7136\u800c\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u65b9\u6cd5\u628a Base \u6307\u9488\u8f6c\u6362\u56de Derived \u6307\u9488\u4f1a\u600e\u4e48\u6837\uff1f\u7136\u540e\u6211\u4eec\u80fd\u591f\u76f4\u63a5\u901a\u8fc7\u90a3\u4e2a\u6307\u9488\u6765\u8c03\u7528 Derived::getName() \uff0c\u8fd9\u6837\u5c31\u6839\u672c\u4e0d\u7528\u5173\u5fc3\u865a\u51fd\u6570\u89e3\u6790\u3002 \u52a8\u6001\u7c7b\u578b\u8f6c\u5316 (Dynamic Cast) \u00b6 C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a\u8f6c\u6362\u64cd\u4f5c\u7b26\uff0c\u53eb\u505a\u52a8\u6001\u8f6c\u5316\uff0c\u5c31\u53ef\u4ee5\u5728\u8fd9\u4e2a\u6761\u4ef6\u4e0b\u4f7f\u7528\u3002\u5c3d\u7ba1\u52a8\u6001\u8f6c\u5316\u6709\u5f88\u591a\u4e0d\u540c\u7684\u80fd\u529b\uff0c\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u6700\u5e38\u89c1\u7684\u4f7f\u7528\u573a\u666f\u5c31\u662f\u4e3a\u4e86\u8f6c\u5316\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6210\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u53eb\u505a\u5411\u4e0b\u7c7b\u578b\u8f6c\u6362\u3002 Using dynamic_cast works just like static_cast. Here\u2019s our example main() from above, using a dynamic_cast to convert our Base pointer back into a Derived pointer: \u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c31\u50cf\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u4e00\u6837\u3002\u8fd9\u662f\u6211\u4eec\u4e0a\u9762\u7684 main() \u51fd\u6570\u7684\u4f8b\u5b50\uff0c\u4f7f\u7528\u52a8\u6001\u7c7b\u578b\u8f6c\u5316\uff0c\u5c06 Base \u6307\u9488\u7c7b\u578b\u8f6c\u5316\u6210 Derived \u6307\u9488\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; delete b ; return 0 ; } \u8fd9\u4e2a\u7528\u4f8b\u6253\u5370\u51fa\uff1a The name of the Derived is: Apple \u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5931\u8d25 (Dynamic Cast Failure) \u00b6 \u4e0a\u9762\u7684\u4f8b\u5b50\u80fd\u8fd0\u884c\u56e0\u4e3a b \u786e\u5b9e\u6307\u5411\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\uff0c\u56e0\u6b64\u8f6c\u5316 b \u6210\u4e3a\u4e00\u4e2a\u6d3e\u751f\u6307\u9488\u4f1a\u6210\u529f\u3002 \u7136\u800c\uff0c\u6211\u4eec\u505a\u4e86\u4e00\u4e2a\u76f8\u5f53\u5371\u9669\u7684\u5047\u8bbe\uff1a\u90a3\u5c31\u662f b \u786e\u5b9e\u662f\u6307\u5411\u4e86\u6d3e\u751f\u7c7b\u3002\u5982\u679c b \u4e0d\u662f\u6307\u5411\u6d3e\u751f\u5bf9\u8c61\u7684\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u8fd9\u5f88\u5bb9\u6613\u9a8c\u8bc1\uff0c\u5c06 getObject() \u7684\u53c2\u6570\u4ece true \u6539\u4e3a false \u3002\u5728\u90a3\u4e2a\u4f8b\u5b50\u91cc\uff0c getObject() \u5c06\u4f1a\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 dynamic_cast \u8f6c\u5316\u6210\u4e00\u4e2a\u6d3e\u751f\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5c06\u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a\u8f6c\u5316\u4e0d\u53ef\u80fd\u6210\u529f\u3002 \u5982\u679c\u52a8\u6001\u8f6c\u5316\u5931\u8d25\uff0c\u8f6c\u5316\u7ed3\u679c\u4f1a\u662f\u4e00\u4e2a null \u6307\u9488\u3002 \u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u68c0\u67e5\u7ed3\u679c\u662f\u5426\u662f\u7a7a\u6307\u9488\uff0c\u6211\u4eec\u8bbf\u95ee d->getName() \uff0c\u5c06\u4f1a\u5c1d\u8bd5\u95f4\u5740\u4e00\u4e2a\u7a7a\u6307\u9488\uff0c\u5c06\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u672a\u5b9a\u4e49\u7684\u64cd\u4f5c\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u5d29\u6e83\u3002 \u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u7a0b\u5e8f\u5b89\u5168\u8fd0\u884c\uff0c\u6211\u4eec\u9700\u8981\u53bb\u786e\u8ba4\u52a8\u6001\u8f6c\u6362\u786e\u5b9e\u6210\u529f\u4e86\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer if ( d ){ // make sure d is non-null std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u89c4\u5219\uff1a \u603b\u662f\u901a\u8fc7\u68c0\u67e5\u7a7a\u6307\u9488\u6765\u786e\u4fdd\u7684\u52a8\u6001\u8f6c\u6362\u6210\u529f\u4e86\u3002 \u6ce8\u610f\u5230\u56e0\u4e3a\u52a8\u6001\u8f6c\u6362\u5728\u8fd0\u884c\u65f6\u505a\u4e86\u4e00\u4e9b\u4e00\u81f4\u6027(consisitency)\u68c0\u67e5\uff08\u6765\u786e\u4fdd\u8f6c\u6362\u662f\u53ef\u884c\u7684\uff09\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362\u4f1a\u5f15\u8d77\u4e00\u4e9b\u6027\u80fd\u635f\u5931(performance penalty). \u4e5f\u8bf7\u6ce8\u610f\uff0c\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u8fdb\u884c\u5411\u4e0b\u8f6c\u6362 (downcasting)\u65f6\u5c06\u65e0\u6cd5\u5de5\u4f5c\uff1a 1\uff09\u4f7f\u7528 protected \u6216\u8005 private \u7ee7\u627f\u7684\u3002 2\uff09\u6ca1\u6709\u7533\u660e\u6216\u8005\u7ee7\u627f\u4efb\u4f55\u865a\u51fd\u6570\u7684\uff08\u5e76\u4e14\u56e0\u6b64\u6ca1\u6709\u865a\u8868\uff09\u3002 3\uff09\u5728\u7279\u5b9a\u7684\u4f8b\u5b50\u4e0b\u8bbe\u8ba1\u865a\u57fa\u7c7b\u7684\u8f6c\u5316\u3002\uff08\u770b\u8fd9\u9875\u7684\u4f8b\u5b50\u4e2d\u4f7f\u7528\u7684\u8fd9\u4e9b\u7c7b\uff0c\u548c\u5982\u4f55 resove \u4ed6\u4eec\uff09\u3002 \u4f7f\u7528\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u8fdb\u884c\u5411\u4e0b\u8f6c\u5316 (Downcasting with static_cast) \u00b6 \u4e8b\u5b9e\u8bc1\u660e\uff0c\u5411\u4e0b\u8f6c\u6362\u4e5f\u53ef\u4ee5\u7531\u9759\u6001\u8f6c\u6362 static_cast \u6765\u5b8c\u6210\u3002\u5b83\u4eec\u4e8c\u8005\u7684\u4e3b\u8981\u7684\u533a\u522b\u5c31\u662f static_cast \u4e0d\u505a\u8fd0\u884c\u65f6\u7c7b\u578b\u68c0\u67e5\u6765\u786e\u4fdd\u4f60\u6240\u505a\u7684\u4e8b\u6709\u610f\u4e49\u3002\u8fd9\u4f7f\u5f97\u4f7f\u7528 static_cast \u66f4\u5feb\uff0c\u4f46\u662f\u66f4\u5371\u9669\uff0c\u5982\u679c\u4f60\u5c1d\u8bd5\u8f6c\u5316 Base* \u6210\u4e00\u4e2a Derived* \uff0c\u53ef\u80fd\u4f1a\u201c\u6210\u529f\u201d\u5373\u4f7f Base \u6307\u9488\u5e76\u6ca1\u6709\u6307\u5411 Derived \u5bf9\u8c61\u3002\u8fd9\u4f1a\u9020\u6210\u672a\u77e5\u7684\u884c\u4e3a\uff0c\u5f53\u4f60\u5c1d\u8bd5\u8bbf\u95ee\u8f6c\u5316\u7ed3\u679c\u65f6\u3002\uff08\u6307\u9488\u4ecd\u7136\u6307\u5411 Base \u5bf9\u8c61\uff09\u3002 \u5982\u679c\u4f60\u5f88\u660e\u786e\u4f60\u6240\u4f7f\u7528\u7684\u6307\u9488\u5411\u4e0b\u8f6c\u6362\u5c06\u4f1a\u6210\u529f\uff0c\u76f4\u63a5\u4f7f\u7528 static_cast \u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002\u552f\u4e00\u80fd\u786e\u4fdd\u4f60\u77e5\u9053\u6307\u9488\u6307\u5411\u7684\u7c7b\u578b\u7684\u65b9\u6cd5\uff0c\u5c31\u662f\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\uff08\u4e0d\u662f\u5f88\u597d\uff0c\u4f7f\u7528\u4e86\u5168\u5c40\u53d8\u91cf\uff09\u7684\u65b9\u6cd5\u6765\u505a\u8fd9\u4ef6\u4e8b\u3002 # include <iostream> # include <string> // Class identifier enum ClassID { BASE , DERIVED // Others can be added here later }; class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} virtual ClassID getClassID () const { return BASE ; } }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } virtual ClassID getClassID () const { return DERIVED ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); if ( b -> getClassID () == DERIVED ) { // \u6211\u4eec\u65e9\u5c31\u8bc1\u660e\u4e86 b \u662f\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u5bf9\u8c61\uff0c\u6240\u4ee5\u8fd9\u4e2a\u603b\u662f\u6210\u529f\u3002 Derived * d = static_cast < Derived *> ( b ); std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u4f46\u662f\u5982\u679c\u4f60\u60f3\u7ecf\u5386\u6240\u6709\u9ebb\u70e6\u6765\u5b9e\u73b0\u8fd9\u4e2a\uff08\u5e76\u4e14\u82b1\u8d39\u8c03\u7528\u865a\u51fd\u6570\u5e76\u4e14\u5904\u7406\u7ed3\u679c\u7684\u7cbe\u529b\uff09\uff0c\u6211\u60f3\u4f60\u8fd8\u662f\u5c31\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u6bd4\u8f83\u597d\u3002 \u52a8\u6001\u8f6c\u5316\u548c\u5f15\u7528 (dynamic_cast and references) \u00b6 \u5c3d\u7ba1\u6240\u6709\u4ee5\u4e0a\u7684\u4f8b\u5b50\u90fd\u63cf\u8ff0\u4e86\u52a8\u6001\u8f6c\u5316\u6307\u9488\uff08\u8fd9\u5f88\u5e38\u7528\uff09\uff0c\u52a8\u6001\u8f6c\u5316\u4e5f\u53ef\u4ee5\u88ab\u7528\u5728\u5f15\u7528\u4e0a\u3002\u8fd9\u4e2a\u7684\u7528\u6cd5\u548c\u7528\u5728\u6307\u9488\u4e0a\u5dee\u4e0d\u591a\u3002 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; int main () { Derived apple ( 1 , \"Apple\" ); // create an apple Base & b = apple ; // set base reference to object Derived & d = dynamic_cast < Derived &> ( b ); // dynamic cast using a reference instead of a pointer std :: cout << \"The name of the Derived is: \" << d . getName () << '\\n' ; // we can access Derived::getName through d return 0 ; } \u56e0\u4e3a C++ \u6ca1\u6709\u201c\u7a7a\u5f15\u7528\u201d\u7684\u8bf4\u6cd5\uff0c\u52a8\u6001\u8f6c\u5316\u4e0d\u53ef\u80fd\u8fd4\u56de\u4e00\u4e2a\u7a7a\u5f15\u7528\u5982\u679c\u906d\u9047\u5931\u8d25\u3002\u76f8\u53cd\u7684\uff0c\u5982\u679c\u52a8\u6001\u8f6c\u5316\u4e00\u4e2a\u5f15\u7528\u5931\u8d25\u4e86\uff0c\u4e00\u4e2a\u5f02\u5e38 std::bad_cast \u5c06\u4f1a\u629b\u51fa\u3002\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u6559\u7a0b\u8ba8\u8bba\u5f02\u5e38\u3002 \u52a8\u9759\u6001\u8f6c\u5316\u7684\u5bf9\u6bd4 (dynamic_cast vs static_cast) \u00b6 \u65b0\u7684\u7a0b\u5e8f\u5458\u6709\u65f6\u5019\u5f88\u8ff7\u60d1\u5565\u65f6\u5019\u7528\u52a8\u6001\u8f6c\u6362\uff0c\u5565\u65f6\u5019\u7528\u9759\u6001\u8f6c\u6362\u3002\u7b54\u6848\u975e\u5e38\u7b80\u5355\uff1a\u4f7f\u7528 static_cast \u9664\u975e\u4f60\u6b63\u5728\u5411\u4e0b\u8f6c\u6362\uff0c\u8fd9\u662f\u4f7f\u7528 dynamic_cast \u901a\u5e38\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\u3002\u7136\u800c\uff0c\u4f60\u4e5f\u5c05\u4e00\u8003\u8651\u907f\u514d\u8f6c\u6362\uff0c\u5c31\u662f\u7528\u865a\u51fd\u6570\u3002 \u5411\u4e0b\u8f6c\u6362\u548c\u865a\u51fd\u6570\u7684\u5bf9\u6bd4 \u00b6 \u6709\u4e9b\u5f00\u53d1\u8005\u76f8\u4fe1\u52a8\u6001\u8f6c\u6362\u662f\u6076\u9b54\ud83d\udc7f\u5e76\u4e14\u662f\u574f\u7684\u7c7b\u578b\u8bbe\u8ba1\uff0c\u8fd9\u4e9b\u7a0b\u5e8f\u5458\u8bf4\u6c38\u8fdc\u5e94\u8be5\u4f7f\u7528\u865a\u51fd\u6570\u3002 \u5927\u4f53\u4e0a\uff0c\u4f7f\u7528\u865a\u51fd\u6570\u5e94\u8be5\u66f4\u53d7\u6b22\u8fce\u6bd4\u8d77\u5411\u4e0b\u8f6c\u6362\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u5411\u4e0b\u8f6c\u6362\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff1a \u5f53\u4f60\u4e0d\u80fd\u4fee\u6539\u57fa\u7c7b\u6765\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u65f6\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u57fa\u7c7b\u662f\u6807\u51c6\u5e93\u4e2d\u7684\u4e00\u79cd\uff09 \u5f53\u4f60\u4ecd\u7136\u9700\u8981\u8bbf\u95ee\u4e00\u4e9b\u53ea\u6709\u6d3e\u751f\u7c7b\u72ec\u6709\u7684\u4e1c\u897f\u65f6\uff08\u4f8b\u5982\uff1a\u67d0\u4e2a\u8bbf\u95ee\u51fd\u6570\u53ea\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\uff09 \u5f53\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230\u4f60\u7684\u57fa\u7c7b\u6beb\u65e0\u610f\u4e49\u65f6\uff08\u4f8b\u5982\uff1a\u6ca1\u6709\u4e00\u4e2a\u5408\u9002\u7684\u503c\u8ba9\u57fa\u7c7b\u8fd4\u56de\uff09\u4f7f\u7528\u7eaf\u865a\u51fd\u6570\u4e5f\u8bb8\u53ef\u4ee5\u7eb3\u5165\u8003\u8651\uff0c\u5982\u679c\u4f60\u4e0d\u8981\u5b9e\u4f8b\u5316\u57fa\u7c7b\u3002 \u4e00\u4e2a\u6709\u5173\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u548cRTTI\u7684\u8b66\u544a (A warning about dynamic_cast and RTTI) \u00b6 \u8fd0\u884c\u65f6\u7c7b\u578b\u4fe1\u606f\uff08RTTI\uff09\u662f\u4e00\u4e2a C++ \u7684\u7279\u6027\uff0c\u7528\u4e8e\u5728\u8fd0\u884c\u65f6\u66b4\u9732\u4e00\u4e2a\u5bf9\u8c61\u7684\u6570\u636e\u7c7b\u578b\u3002\u8fd9\u8fd9\u4e2a\u80fd\u529b dynamic_cast \u8d4b\u4e88\u7684\u3002\u56e0\u4e3a\u8fd0\u884c\u65f6\u6709\u76f8\u5f53\u53ef\u89c2\u7684\u7a7a\u95f4\u6027\u80fd\u6210\u672c\uff0c\u4e00\u4e9b\u7f16\u8bd1\u5668\u5141\u8bb8\u4f60\u5173\u95ed RTTI \u6765\u505a\u4e3a\u4e00\u4e2a\u4f18\u5316\uff0c\u4e0d\u7528\u8bf4\uff0c\u5982\u679c\u4f60\u90a3\u4e48\u505a\uff0c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c06\u4e0d\u4f1a\u6b63\u5e38\u5de5\u4f5c\u3002","title":"18.9 \u52a8\u6001\u7c7b\u578b\u8f6c\u6362"},{"location":"18-virtual-functions/18.9-dynamic-casting/#189","text":"\u65e9\u5728 \u7b2c6.16\u8bfe\u2014\u2014\u663e\u5f0f\u7c7b\u578b\u8f6c\u6362\uff08casting\uff09\u548cstatic_cast \u4e2d\uff0c\u6211\u4eec\u7814\u7a76\u4e86 casting \u7684\u6982\u5ff5\uff0c\u4ee5\u53ca\u4f7f\u7528 static_cast \u5c06\u53d8\u91cf\u4ece\u4e00\u79cd\u7c7b\u578b\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u7c7b\u578b\u3002 \u5728\u672c\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u7814\u7a76\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u5f3a\u5236\u8f6c\u6362\uff1a\u52a8\u6001\u7c7b\u578b\u8f6c\u6362 (Dynamic cast)","title":"18.9 \u52a8\u6001\u7c7b\u578b\u8f6c\u6362"},{"location":"18-virtual-functions/18.9-dynamic-casting/#_1","text":"\u5728\u5904\u7406\u591a\u6001\u6027\u65f6\uff0c\u60a8\u7ecf\u5e38\u4f1a\u9047\u5230\u8fd9\u6837\u7684\u60c5\u51b5\uff1a\u4f60\u6709\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\uff0c\u4f46\u4f60\u5e0c\u671b\u8bbf\u95ee\u4ec5\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\u4e2d\u7684\u67d0\u4e9b\u4fe1\u606f\u3002 \u601d\u8003\u4e0b\u5217\u8fd9\u4e2a\uff08\u4e0d\u592a\u81ea\u7136\u7684\uff09\u4f8b\u5b50 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); // \u6211\u4eec\u5e94\u8be5\u5982\u4f55\u6253\u5370\u6d3e\u751f\u7c7b\u5bf9\u8c61\u7684\u540d\u5b57\uff1f\u53ea\u6709\u57fa\u7c7b\u6307\u9488 delete b ; return 0 ; } \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u51fd\u6570 getObject() \u603b\u662f\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u4f46\u662f\u8fd9\u4e2a\u6307\u9488\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u4e5f\u53ef\u80fd\u6307\u5411\u4e00\u4e2a\u6d3e\u751f\u7c7b\u3002\u5728\u4f8b\u5b50\u4e2d\u7684 Base \u6307\u9488 b \u5b9e\u9645\u6307\u5411\u7684\u662f\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u5e94\u8be5\u5982\u4f55\u8c03\u7528 Derived::getName() \uff1f \u4e00\u4e2a\u65b9\u6cd5\u4f1a\u662f\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230 Base \u7c7b\uff0c\u53eb getName() \uff08\u8fd9\u6837\u505a\u6211\u4eec\u53ef\u4ee5\u8c03\u7528\u5b83\uff0c\u901a\u8fc7 Base \u7684\u6307\u9488\u6216\u5f15\u7528\uff0c\u5b83\u90fd\u4f1a\u52a8\u6001\u5b9a\u5411\u5230 Derived::getName() \uff09\u3002\u4f46\u662f\u5982\u679c\u4f60\u8c03\u7528\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a Base \u7c7b\u7684\u6307\u9488\u4f1a\u5f15\u7528\uff0c\u6307\u5411\u4e00\u4e2a Base \u5bf9\u8c61\uff0c\u90a3\u5c06\u4f1a\u8fd4\u56de\u4ec0\u4e48\uff1f\u6ca1\u6709\u4efb\u4f55\u503c\u771f\u6b63\u6709\u4ef7\u503c\u3002\u6b64\u5916\uff0c\u6211\u4eec\u5c06\u4f1a\u7528\u4e00\u4e9b\u4e1c\u897f\u6c61\u67d3\u6211\u4eec\u7684 Base \u7c7b\uff0c\u8fd9\u4e9b\u7684\u4e1c\u897f\u672c\u6765\u5e94\u8be5\u53ea\u5728\u6d3e\u751f\u7c7b\u4e2d\u5b58\u5728\u3002 \u6211\u4eec\u90fd\u77e5\u9053\uff0c C++ \u5c06\u4f1a\u9690\u5f0f\u7684\u8ba9\u4f60\u8f6c\u5316\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u4e3a\u4e00\u4e2a\u57fa\u7c7b\u6307\u6b63\u3002\uff08\u4e8b\u5b9e\u4e0a\uff0c getObjectt() \u5c31\u505a\u4e86\u90a3\u6837\u7684\u4e8b\u60c5\uff09\u3002\u8fd9\u79cd\u8fc7\u7a0b\u6709\u65f6\u5019\u88ab\u53eb\u505a\u5411\u4e0a\u8f6c\u5316\u3002\u7136\u800c\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u65b9\u6cd5\u628a Base \u6307\u9488\u8f6c\u6362\u56de Derived \u6307\u9488\u4f1a\u600e\u4e48\u6837\uff1f\u7136\u540e\u6211\u4eec\u80fd\u591f\u76f4\u63a5\u901a\u8fc7\u90a3\u4e2a\u6307\u9488\u6765\u8c03\u7528 Derived::getName() \uff0c\u8fd9\u6837\u5c31\u6839\u672c\u4e0d\u7528\u5173\u5fc3\u865a\u51fd\u6570\u89e3\u6790\u3002","title":"\u4f55\u65f6\u9700\u8981\u8fdb\u884c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362"},{"location":"18-virtual-functions/18.9-dynamic-casting/#dynamic-cast","text":"C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a\u8f6c\u6362\u64cd\u4f5c\u7b26\uff0c\u53eb\u505a\u52a8\u6001\u8f6c\u5316\uff0c\u5c31\u53ef\u4ee5\u5728\u8fd9\u4e2a\u6761\u4ef6\u4e0b\u4f7f\u7528\u3002\u5c3d\u7ba1\u52a8\u6001\u8f6c\u5316\u6709\u5f88\u591a\u4e0d\u540c\u7684\u80fd\u529b\uff0c\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u6700\u5e38\u89c1\u7684\u4f7f\u7528\u573a\u666f\u5c31\u662f\u4e3a\u4e86\u8f6c\u5316\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6210\u4e00\u4e2a\u6d3e\u751f\u7c7b\u6307\u9488\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u53eb\u505a\u5411\u4e0b\u7c7b\u578b\u8f6c\u6362\u3002 Using dynamic_cast works just like static_cast. Here\u2019s our example main() from above, using a dynamic_cast to convert our Base pointer back into a Derived pointer: \u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c31\u50cf\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u4e00\u6837\u3002\u8fd9\u662f\u6211\u4eec\u4e0a\u9762\u7684 main() \u51fd\u6570\u7684\u4f8b\u5b50\uff0c\u4f7f\u7528\u52a8\u6001\u7c7b\u578b\u8f6c\u5316\uff0c\u5c06 Base \u6307\u9488\u7c7b\u578b\u8f6c\u5316\u6210 Derived \u6307\u9488\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; delete b ; return 0 ; } \u8fd9\u4e2a\u7528\u4f8b\u6253\u5370\u51fa\uff1a The name of the Derived is: Apple","title":"\u52a8\u6001\u7c7b\u578b\u8f6c\u5316 (Dynamic Cast)"},{"location":"18-virtual-functions/18.9-dynamic-casting/#dynamic-cast-failure","text":"\u4e0a\u9762\u7684\u4f8b\u5b50\u80fd\u8fd0\u884c\u56e0\u4e3a b \u786e\u5b9e\u6307\u5411\u4e86\u4e00\u4e2a Derived \u5bf9\u8c61\uff0c\u56e0\u6b64\u8f6c\u5316 b \u6210\u4e3a\u4e00\u4e2a\u6d3e\u751f\u6307\u9488\u4f1a\u6210\u529f\u3002 \u7136\u800c\uff0c\u6211\u4eec\u505a\u4e86\u4e00\u4e2a\u76f8\u5f53\u5371\u9669\u7684\u5047\u8bbe\uff1a\u90a3\u5c31\u662f b \u786e\u5b9e\u662f\u6307\u5411\u4e86\u6d3e\u751f\u7c7b\u3002\u5982\u679c b \u4e0d\u662f\u6307\u5411\u6d3e\u751f\u5bf9\u8c61\u7684\uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u8fd9\u5f88\u5bb9\u6613\u9a8c\u8bc1\uff0c\u5c06 getObject() \u7684\u53c2\u6570\u4ece true \u6539\u4e3a false \u3002\u5728\u90a3\u4e2a\u4f8b\u5b50\u91cc\uff0c getObject() \u5c06\u4f1a\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\u6307\u5411\u4e00\u4e2a\u57fa\u7c7b\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 dynamic_cast \u8f6c\u5316\u6210\u4e00\u4e2a\u6d3e\u751f\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u5c06\u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a\u8f6c\u5316\u4e0d\u53ef\u80fd\u6210\u529f\u3002 \u5982\u679c\u52a8\u6001\u8f6c\u5316\u5931\u8d25\uff0c\u8f6c\u5316\u7ed3\u679c\u4f1a\u662f\u4e00\u4e2a null \u6307\u9488\u3002 \u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u68c0\u67e5\u7ed3\u679c\u662f\u5426\u662f\u7a7a\u6307\u9488\uff0c\u6211\u4eec\u8bbf\u95ee d->getName() \uff0c\u5c06\u4f1a\u5c1d\u8bd5\u95f4\u5740\u4e00\u4e2a\u7a7a\u6307\u9488\uff0c\u5c06\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u672a\u5b9a\u4e49\u7684\u64cd\u4f5c\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u5d29\u6e83\u3002 \u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u7a0b\u5e8f\u5b89\u5168\u8fd0\u884c\uff0c\u6211\u4eec\u9700\u8981\u53bb\u786e\u8ba4\u52a8\u6001\u8f6c\u6362\u786e\u5b9e\u6210\u529f\u4e86\u3002 int main () { Base * b = getObject ( true ); Derived * d = dynamic_cast < Derived *> ( b ); // use dynamic cast to convert Base pointer into Derived pointer if ( d ){ // make sure d is non-null std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u89c4\u5219\uff1a \u603b\u662f\u901a\u8fc7\u68c0\u67e5\u7a7a\u6307\u9488\u6765\u786e\u4fdd\u7684\u52a8\u6001\u8f6c\u6362\u6210\u529f\u4e86\u3002 \u6ce8\u610f\u5230\u56e0\u4e3a\u52a8\u6001\u8f6c\u6362\u5728\u8fd0\u884c\u65f6\u505a\u4e86\u4e00\u4e9b\u4e00\u81f4\u6027(consisitency)\u68c0\u67e5\uff08\u6765\u786e\u4fdd\u8f6c\u6362\u662f\u53ef\u884c\u7684\uff09\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362\u4f1a\u5f15\u8d77\u4e00\u4e9b\u6027\u80fd\u635f\u5931(performance penalty). \u4e5f\u8bf7\u6ce8\u610f\uff0c\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u8fdb\u884c\u5411\u4e0b\u8f6c\u6362 (downcasting)\u65f6\u5c06\u65e0\u6cd5\u5de5\u4f5c\uff1a 1\uff09\u4f7f\u7528 protected \u6216\u8005 private \u7ee7\u627f\u7684\u3002 2\uff09\u6ca1\u6709\u7533\u660e\u6216\u8005\u7ee7\u627f\u4efb\u4f55\u865a\u51fd\u6570\u7684\uff08\u5e76\u4e14\u56e0\u6b64\u6ca1\u6709\u865a\u8868\uff09\u3002 3\uff09\u5728\u7279\u5b9a\u7684\u4f8b\u5b50\u4e0b\u8bbe\u8ba1\u865a\u57fa\u7c7b\u7684\u8f6c\u5316\u3002\uff08\u770b\u8fd9\u9875\u7684\u4f8b\u5b50\u4e2d\u4f7f\u7528\u7684\u8fd9\u4e9b\u7c7b\uff0c\u548c\u5982\u4f55 resove \u4ed6\u4eec\uff09\u3002","title":"\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5931\u8d25 (Dynamic Cast Failure)"},{"location":"18-virtual-functions/18.9-dynamic-casting/#downcasting-with-static_cast","text":"\u4e8b\u5b9e\u8bc1\u660e\uff0c\u5411\u4e0b\u8f6c\u6362\u4e5f\u53ef\u4ee5\u7531\u9759\u6001\u8f6c\u6362 static_cast \u6765\u5b8c\u6210\u3002\u5b83\u4eec\u4e8c\u8005\u7684\u4e3b\u8981\u7684\u533a\u522b\u5c31\u662f static_cast \u4e0d\u505a\u8fd0\u884c\u65f6\u7c7b\u578b\u68c0\u67e5\u6765\u786e\u4fdd\u4f60\u6240\u505a\u7684\u4e8b\u6709\u610f\u4e49\u3002\u8fd9\u4f7f\u5f97\u4f7f\u7528 static_cast \u66f4\u5feb\uff0c\u4f46\u662f\u66f4\u5371\u9669\uff0c\u5982\u679c\u4f60\u5c1d\u8bd5\u8f6c\u5316 Base* \u6210\u4e00\u4e2a Derived* \uff0c\u53ef\u80fd\u4f1a\u201c\u6210\u529f\u201d\u5373\u4f7f Base \u6307\u9488\u5e76\u6ca1\u6709\u6307\u5411 Derived \u5bf9\u8c61\u3002\u8fd9\u4f1a\u9020\u6210\u672a\u77e5\u7684\u884c\u4e3a\uff0c\u5f53\u4f60\u5c1d\u8bd5\u8bbf\u95ee\u8f6c\u5316\u7ed3\u679c\u65f6\u3002\uff08\u6307\u9488\u4ecd\u7136\u6307\u5411 Base \u5bf9\u8c61\uff09\u3002 \u5982\u679c\u4f60\u5f88\u660e\u786e\u4f60\u6240\u4f7f\u7528\u7684\u6307\u9488\u5411\u4e0b\u8f6c\u6362\u5c06\u4f1a\u6210\u529f\uff0c\u76f4\u63a5\u4f7f\u7528 static_cast \u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002\u552f\u4e00\u80fd\u786e\u4fdd\u4f60\u77e5\u9053\u6307\u9488\u6307\u5411\u7684\u7c7b\u578b\u7684\u65b9\u6cd5\uff0c\u5c31\u662f\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\uff08\u4e0d\u662f\u5f88\u597d\uff0c\u4f7f\u7528\u4e86\u5168\u5c40\u53d8\u91cf\uff09\u7684\u65b9\u6cd5\u6765\u505a\u8fd9\u4ef6\u4e8b\u3002 # include <iostream> # include <string> // Class identifier enum ClassID { BASE , DERIVED // Others can be added here later }; class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} virtual ClassID getClassID () const { return BASE ; } }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } virtual ClassID getClassID () const { return DERIVED ; } }; Base * getObject ( bool bReturnDerived ) { if ( bReturnDerived ) return new Derived ( 1 , \"Apple\" ); else return new Base ( 2 ); } int main () { Base * b = getObject ( true ); if ( b -> getClassID () == DERIVED ) { // \u6211\u4eec\u65e9\u5c31\u8bc1\u660e\u4e86 b \u662f\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u5bf9\u8c61\uff0c\u6240\u4ee5\u8fd9\u4e2a\u603b\u662f\u6210\u529f\u3002 Derived * d = static_cast < Derived *> ( b ); std :: cout << \"The name of the Derived is: \" << d -> getName () << '\\n' ; } delete b ; return 0 ; } \u4f46\u662f\u5982\u679c\u4f60\u60f3\u7ecf\u5386\u6240\u6709\u9ebb\u70e6\u6765\u5b9e\u73b0\u8fd9\u4e2a\uff08\u5e76\u4e14\u82b1\u8d39\u8c03\u7528\u865a\u51fd\u6570\u5e76\u4e14\u5904\u7406\u7ed3\u679c\u7684\u7cbe\u529b\uff09\uff0c\u6211\u60f3\u4f60\u8fd8\u662f\u5c31\u7528\u52a8\u6001\u8f6c\u6362 (dynamic_cast) \u6bd4\u8f83\u597d\u3002","title":"\u4f7f\u7528\u9759\u6001\u7c7b\u578b\u8f6c\u6362\u8fdb\u884c\u5411\u4e0b\u8f6c\u5316 (Downcasting with static_cast)"},{"location":"18-virtual-functions/18.9-dynamic-casting/#dynamic_cast-and-references","text":"\u5c3d\u7ba1\u6240\u6709\u4ee5\u4e0a\u7684\u4f8b\u5b50\u90fd\u63cf\u8ff0\u4e86\u52a8\u6001\u8f6c\u5316\u6307\u9488\uff08\u8fd9\u5f88\u5e38\u7528\uff09\uff0c\u52a8\u6001\u8f6c\u5316\u4e5f\u53ef\u4ee5\u88ab\u7528\u5728\u5f15\u7528\u4e0a\u3002\u8fd9\u4e2a\u7684\u7528\u6cd5\u548c\u7528\u5728\u6307\u9488\u4e0a\u5dee\u4e0d\u591a\u3002 # include <iostream> # include <string> class Base { protected : int m_value ; public : Base ( int value ) : m_value ( value ) { } virtual ~ Base () {} }; class Derived : public Base { protected : std :: string m_name ; public : Derived ( int value , std :: string name ) : Base ( value ), m_name ( name ) { } const std :: string & getName () const { return m_name ; } }; int main () { Derived apple ( 1 , \"Apple\" ); // create an apple Base & b = apple ; // set base reference to object Derived & d = dynamic_cast < Derived &> ( b ); // dynamic cast using a reference instead of a pointer std :: cout << \"The name of the Derived is: \" << d . getName () << '\\n' ; // we can access Derived::getName through d return 0 ; } \u56e0\u4e3a C++ \u6ca1\u6709\u201c\u7a7a\u5f15\u7528\u201d\u7684\u8bf4\u6cd5\uff0c\u52a8\u6001\u8f6c\u5316\u4e0d\u53ef\u80fd\u8fd4\u56de\u4e00\u4e2a\u7a7a\u5f15\u7528\u5982\u679c\u906d\u9047\u5931\u8d25\u3002\u76f8\u53cd\u7684\uff0c\u5982\u679c\u52a8\u6001\u8f6c\u5316\u4e00\u4e2a\u5f15\u7528\u5931\u8d25\u4e86\uff0c\u4e00\u4e2a\u5f02\u5e38 std::bad_cast \u5c06\u4f1a\u629b\u51fa\u3002\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u6559\u7a0b\u8ba8\u8bba\u5f02\u5e38\u3002","title":"\u52a8\u6001\u8f6c\u5316\u548c\u5f15\u7528 (dynamic_cast and references)"},{"location":"18-virtual-functions/18.9-dynamic-casting/#dynamic_cast-vs-static_cast","text":"\u65b0\u7684\u7a0b\u5e8f\u5458\u6709\u65f6\u5019\u5f88\u8ff7\u60d1\u5565\u65f6\u5019\u7528\u52a8\u6001\u8f6c\u6362\uff0c\u5565\u65f6\u5019\u7528\u9759\u6001\u8f6c\u6362\u3002\u7b54\u6848\u975e\u5e38\u7b80\u5355\uff1a\u4f7f\u7528 static_cast \u9664\u975e\u4f60\u6b63\u5728\u5411\u4e0b\u8f6c\u6362\uff0c\u8fd9\u662f\u4f7f\u7528 dynamic_cast \u901a\u5e38\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\u3002\u7136\u800c\uff0c\u4f60\u4e5f\u5c05\u4e00\u8003\u8651\u907f\u514d\u8f6c\u6362\uff0c\u5c31\u662f\u7528\u865a\u51fd\u6570\u3002","title":"\u52a8\u9759\u6001\u8f6c\u5316\u7684\u5bf9\u6bd4 (dynamic_cast vs static_cast)"},{"location":"18-virtual-functions/18.9-dynamic-casting/#_2","text":"\u6709\u4e9b\u5f00\u53d1\u8005\u76f8\u4fe1\u52a8\u6001\u8f6c\u6362\u662f\u6076\u9b54\ud83d\udc7f\u5e76\u4e14\u662f\u574f\u7684\u7c7b\u578b\u8bbe\u8ba1\uff0c\u8fd9\u4e9b\u7a0b\u5e8f\u5458\u8bf4\u6c38\u8fdc\u5e94\u8be5\u4f7f\u7528\u865a\u51fd\u6570\u3002 \u5927\u4f53\u4e0a\uff0c\u4f7f\u7528\u865a\u51fd\u6570\u5e94\u8be5\u66f4\u53d7\u6b22\u8fce\u6bd4\u8d77\u5411\u4e0b\u8f6c\u6362\u3002\u7136\u800c\uff0c\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u5411\u4e0b\u8f6c\u6362\u662f\u4e00\u4e2a\u66f4\u597d\u7684\u9009\u62e9\uff1a \u5f53\u4f60\u4e0d\u80fd\u4fee\u6539\u57fa\u7c7b\u6765\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u65f6\uff08\u4f8b\u5982\uff1a\u56e0\u4e3a\u57fa\u7c7b\u662f\u6807\u51c6\u5e93\u4e2d\u7684\u4e00\u79cd\uff09 \u5f53\u4f60\u4ecd\u7136\u9700\u8981\u8bbf\u95ee\u4e00\u4e9b\u53ea\u6709\u6d3e\u751f\u7c7b\u72ec\u6709\u7684\u4e1c\u897f\u65f6\uff08\u4f8b\u5982\uff1a\u67d0\u4e2a\u8bbf\u95ee\u51fd\u6570\u53ea\u5b58\u5728\u4e8e\u6d3e\u751f\u7c7b\uff09 \u5f53\u6dfb\u52a0\u4e00\u4e2a\u865a\u51fd\u6570\u5230\u4f60\u7684\u57fa\u7c7b\u6beb\u65e0\u610f\u4e49\u65f6\uff08\u4f8b\u5982\uff1a\u6ca1\u6709\u4e00\u4e2a\u5408\u9002\u7684\u503c\u8ba9\u57fa\u7c7b\u8fd4\u56de\uff09\u4f7f\u7528\u7eaf\u865a\u51fd\u6570\u4e5f\u8bb8\u53ef\u4ee5\u7eb3\u5165\u8003\u8651\uff0c\u5982\u679c\u4f60\u4e0d\u8981\u5b9e\u4f8b\u5316\u57fa\u7c7b\u3002","title":"\u5411\u4e0b\u8f6c\u6362\u548c\u865a\u51fd\u6570\u7684\u5bf9\u6bd4"},{"location":"18-virtual-functions/18.9-dynamic-casting/#rtti-a-warning-about-dynamic_cast-and-rtti","text":"\u8fd0\u884c\u65f6\u7c7b\u578b\u4fe1\u606f\uff08RTTI\uff09\u662f\u4e00\u4e2a C++ \u7684\u7279\u6027\uff0c\u7528\u4e8e\u5728\u8fd0\u884c\u65f6\u66b4\u9732\u4e00\u4e2a\u5bf9\u8c61\u7684\u6570\u636e\u7c7b\u578b\u3002\u8fd9\u8fd9\u4e2a\u80fd\u529b dynamic_cast \u8d4b\u4e88\u7684\u3002\u56e0\u4e3a\u8fd0\u884c\u65f6\u6709\u76f8\u5f53\u53ef\u89c2\u7684\u7a7a\u95f4\u6027\u80fd\u6210\u672c\uff0c\u4e00\u4e9b\u7f16\u8bd1\u5668\u5141\u8bb8\u4f60\u5173\u95ed RTTI \u6765\u505a\u4e3a\u4e00\u4e2a\u4f18\u5316\uff0c\u4e0d\u7528\u8bf4\uff0c\u5982\u679c\u4f60\u90a3\u4e48\u505a\uff0c\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u5c06\u4e0d\u4f1a\u6b63\u5e38\u5de5\u4f5c\u3002","title":"\u4e00\u4e2a\u6709\u5173\u52a8\u6001\u7c7b\u578b\u8f6c\u6362\u548cRTTI\u7684\u8b66\u544a (A warning about dynamic_cast and RTTI)"},{"location":"18-virtual-functions/18.x%20chapter-18-comprehensice-quiz/","text":"18.x \u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60 \u00b6 \u6211\u4eec\u7684 C++ \u65c5\u7a0b\u5728\u7ee7\u627f\u548c\u865a\u51fd\u6570\u8fd9\u5757\u5df2\u7ecf\u7ed3\u675f\u4e86\u3002\u4e0d\u8981\u62c5\u5fc3\uff0c\u4eb2\u7231\u7684\u8bfb\u8005\uff0c\u56e0\u4e3a\u8fd8\u6709\u5927\u91cf\u5176\u4ed6 C++ \u7684\u9886\u57df\u7b49\u5f85\u6211\u4eec\u524d\u8fdb\uff0c\u63a2\u7d22\uff01 \u7ae0\u8282\u603b\u7ed3 \u00b6 C++ \u5141\u8bb8\u4f60\u8bbe\u7f6e\u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528\u5230\u6d3e\u751f\u5bf9\u8c61\u3002\u8fd9\u662f\u5f88\u6709\u7528\u7684\uff0c\u5f53\u6211\u4eec\u60f3\u8981\u5199\u4e00\u4e2a\u51fd\u6570\u6216\u8005\u6570\u7ec4\uff0c\u53ef\u4ee5\u548c\u4efb\u4f55\u7c7b\u578b\u7684\u4ece\u57fa\u7c7b\u6d3e\u751f\u7684\u5bf9\u8c61\u642d\u914d\u3002\uff08This is useful when we want to write a function or array that can work with any type of object derived from a base class.\uff09 \u5982\u679c\u6ca1\u6709\u865a\u51fd\u6570\uff0c\u57fa\u7c7b\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\u548c\u5f15\u7528\u5c06\u4f1a\u53ea\u80fd\u8bbf\u95ee\u57fa\u7c7b\u6210\u5458\uff0c\u548c\u51fd\u6570\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u51fd\u6570\u80fd\u89e3\u6790\u5230\u7ee7\u627f\u672b\u7aef\u7248\u672c\u7684\u51fd\u6570\uff08\u53eb\u505a\u91cd\u5199\uff09\u5b58\u5728\u4e8e\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e4b\u95f4\u3002\u60f3\u8981\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u91cd\u5199\uff0c\u6d3e\u751f\u7c7b\u5fc5\u987b\u548c\u57fa\u7c7b\u865a\u51fd\u6570\u6709\u540c\u6837\u7684\u7b7e\u540d\u548c\u8fd4\u56de\u7c7b\u578b\u3002\u4e00\u4e2a\u4f8b\u5916\u5c31\u662f covariant return types \uff0c\u80fd\u591f\u5141\u8bb8\u4e00\u4e2a\u91cd\u5199\u8fd4\u56de\u4e00\u4e2a\u6307\u6d3e\u751f\u7c7b\u7684\u9488\u6216\u5f15\u7528\u5982\u679c\u57fa\u7c7b\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u3002 \u4e00\u4e2a\u51fd\u6570\u51fd\u6570\u60f3\u8981\u88ab\u91cd\u5199\uff0c\u5e94\u8be5\u6dfb\u52a0\u91cd\u5199\u6307\u793a\u7b26\u6765\u786e\u4fdd\u5b83\u786e\u5b9e\u91cd\u5199\u4e86\u3002 final \u6307\u793a\u7b26\u80fd\u591f\u88ab\u7528\u4f5c\u963b\u6b62\u4ece\u4e00\u4e2a\u8be5\u7c7b\u7684\u51fd\u6570\u88ab\u91cd\u5199\u3002 \u5982\u679c\u4f60\u60f3\u8981\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f60\u5e94\u8be5\u4f7f\u4f60\u7684\u6790\u6784\u51fd\u6570\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u5982\u679c\u4f60\u5220\u9664\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u8fd9\u6837\u505a\u53ef\u4ee5\u4f7f\u5408\u9002\u7684\u6790\u6784\u51fd\u6570\u88ab\u8c03\u7528\u3002 \u4f60\u53ef\u4ee5\u5ffd\u7565\u4e00\u4e2a\u865a\u51fd\u6570\u89e3\u6790\u901a\u8fc7\u4f7f\u7528 scope resolution opearator \u6765\u76f4\u63a5\u6307\u5b9a\u90a3\u4e2a\u7c7b\u7684\u51fd\u6570\u4f60\u60f3\u8981\u8c03\u7528\uff1a\u4f8b\u5982 base.Base::getName() Early binding \u65e9\u7ed1\u5b9a\u53d1\u751f\u5728\u7f16\u8bd1\u65f6\u76f4\u63a5\u68c0\u6d4b\u5230\u51fd\u6570\u8c03\u7528\uff0c\u7f16\u8bd1\u5668\u6216\u8005\u8fde\u63a5\u5668\u53ef\u4ee5\u76f4\u63a5\u89e3\u6790\u8fd9\u4e9b\u51fd\u6570\u8c03\u7528\u3002 Late binding \u53d1\u751f\u5728\u5f53\u4e00\u4e2a\u51fd\u6570\u6307\u9488\u88ab\u8c03\u7528\u662f\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u54ea\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u4e0d\u53ef\u80fd\u5728\u8fd0\u884c\u4e4b\u524d\u786e\u5b9a\u3002\u865a\u51fd\u6570\u4f7f\u7528\u4e86 late binding \u548c\u4e00\u4e2a\u865a\u8868\u6765\u51b3\u5b9a\u54ea\u4e2a\u7248\u672c\u7684\u51fd\u6570\u5c06\u88ab\u8c03\u7528\u3002 \u4f7f\u7528\u865a\u51fd\u6570\u6709\u4e00\u5b9a\u7684\u82b1\u8d39\uff0c\u865a\u51fd\u6570\u7684\u8c03\u7528\u5c06\u82b1\u8d39\u66f4\u591a\u65f6\u95f4\uff0c\u5e76\u4e14\u865a\u8868\u4f1a\u5360\u7528\u4e00\u5b9a\u7684\u7a7a\u95f4\uff0c\u5728\u6bcf\u4e2a\u5305\u542b\u865a\u51fd\u6570\u7684\u5bf9\u8c61\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2a\u6307\u9488\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\u53ef\u4ee5\u88ab\u5b9a\u4e49\u4e3a\u7eaf\u865a\u51fd\u6570\uff08\u62bd\u8c61\u51fd\u6570\uff09\u901a\u8fc7\u6dfb\u52a0 =0 \u5728\u865a\u51fd\u6570\u7684\u5b9a\u4e49\u540e\u65b9\u3002\u5305\u542b\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u88ab\u53eb\u505a\u62bd\u8c61\u7c7b\uff0c\u8fd9\u79cd\u7c7b\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e8e\u62bd\u8c61\u7c7b\uff0c\u90a3\u4e48\u7eaf\u865a\u51fd\u6570\u5fc5\u987b\u88ab\u6b63\u786e\u7684\u5b9a\u4e49\uff0c\u5426\u5219\u8be5\u7c7b\u4e5f\u5c06\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7c7b\u3002\u7eaf\u865a\u51fd\u6570\u4e5f\u53ef\u4ee5\u6709\u4e00\u4e2a\u51fd\u6570\u4f53\uff0c\u4f46\u662f\u4ed6\u4eec\u4ecd\u7136\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7684\u3002 \u63a5\u53e3\u7c7b\u662f\u4e00\u4e2a\u6ca1\u6709\u6210\u5458\u53d8\u91cf\u5e76\u4e14\u5168\u662f\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u3002\u8fd9\u6837\u7684\u7c7b\u7684\u540d\u79f0\u901a\u5e38\u4ee5\u5927\u5199\u7684 I \u5f00\u5934\u3002 \u4e00\u4e2a\u865a\u57fa\u7c7b\u5728\u4e00\u4e2a\u5bf9\u8c61\u4e2d\u53ea\u80fd\u88ab\u5305\u542b\u4e00\u6b21\uff0c\u65e0\u8bba\u88ab\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u591a\u5c11\u6b21\u3002 \u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u88ab\u8d4b\u503c\u5230\u57fa\u7c7b\u5bf9\u8c61\u65f6\uff0c\u57fa\u7c7b\u53ea\u80fd\u63a5\u6536\u5230\u6d3e\u751f\u7c7b\u4e2d\u57fa\u7c7b\u90e8\u5206\u7684\u62f7\u8d1d\u3002\u8fd9\u88ab\u53eb\u505a\u5bf9\u8c61\u5207\u5272\u3002 \u52a8\u6001\u8f6c\u6362\u53ef\u4ee5\u88ab\u7528\u6765\u8f6c\u6362\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6210\u4e3a\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\uff0c\u8fd9\u88ab\u53eb\u505a\u5411\u4e0b\u8f6c\u6362 (downcasting)\u3002\u4e00\u4e2a\u5931\u8d25\u7684\u8f6c\u6362\u4f1a\u8fd4\u56de\u4e00\u4e2a\u7a7a\u6307\u9488\u3002 \u6d3e\u751f\u7c7b\u6700\u7b80\u5355\u7684\u91cd\u8f7d << \u8fd0\u7b97\u7b26\u7684\u65b9\u5f0f\u662f\u5199\u4e00\u4e2a\u91cd\u8f7d << \u4e3a\u6700\u9876\u90e8\u7684\u57fa\u7c7b\uff0c\u7136\u540e\u6dfb\u52a0\u4e00\u4e2a\u865a\u6210\u5458\u51fd\u6570\u6765\u6253\u5370\u3002 // \u8bd1\u8005\u6dfb\u52a0\u7684\u4ee3\u7801\u7247\u6bb5\uff1a virtual std :: ostream & print ( std :: ostream & in ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Base & b ) { return b . print ( out ); } // \u7ee7\u627f\u5bf9\u8c61\u90fd\u53ea\u9700\u8981\u91cd\u5199print\u5373\u53ef\u3002 Quiz time \u00b6 Quiz1 \u00b6 \u4ee5\u4e0b\u7684\u6bcf\u4e2a\u7a0b\u5e8f\u90fd\u6709\u4e00\u4e9b\u7f3a\u9677\uff0c\u68c0\u67e5\u6bcf\u4e2a\u7a0b\u5e8f\uff08\u7528\u773c\u775b\u68c0\u67e5\uff0c\u4e0d\u8981\u7f16\u8bd1\uff09\u5e76\u4e14\u8bca\u65ad\u51fa\u8fd9\u4e2a\u7a0b\u5e8f\u6709\u4ec0\u4e48\u95ee\u9898\u3002\u6bcf\u4e2a\u7a0b\u5e8f\u7684\u8f93\u51fa\u90fd\u5e94\u8be5\u662f Derived \u3002 \u8bd1\u8005\u6ce8\uff1a\u539f\u7f51\u7ad9\u662f\u54cd\u5e94\u5f0f\u7684\u9690\u85cf\uff0c\u6298\u53e0\u4e86\u7b54\u6848\uff0c\u672c\u7f51\u7ad9\u65e0\u6cd5\u505a\u5230\uff0c\u56e0\u6b64\u8bf7\u5148\u5b8c\u6210\u4ee3\u7801\u9605\u8bfb\u518d\u5f80\u4e0b\u770b\u7b54\u6848\u63cf\u8ff0\uff0c\u6bcf\u4e2a\u9898\u7684\u7b54\u6848\u90fd\u5728\u4ee3\u7801\u63cf\u8ff0\u4e0b\u65b9\u3002 1a) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } const char * getName () const { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481a Base::getName() \u4e0d\u662f\u865a\u51fd\u6570\uff0c \u56e0\u6b64 b.getName() \u4e0d\u4f1a\u89e3\u6790\u5e76\u8c03\u7528 Derived::getName(). 1b) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481b Base::geetName() \u5e76\u6ca1\u6709\u5b9a\u4e49\u4e3aconst\uff0c\u800c Derived::getName() \u662f\u4e00\u4e2aconst\u51fd\u6570\uff0c\u56e0\u6b64 Derived::getName() \u4e0d\u662f\u4e00\u4e2a\u91cd\u5199(override) 1c) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481c d \u662f\u503c\u8d4b\u503c\u5230 b \uff0c\u5bfc\u81f4 d \u88ab\u5207\u5272\u3002 1d) #include <iostream> class Base final { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481d Base \u88ab\u5b9a\u4e49\u4e3a final \uff0c\u56e0\u6b64 Derived \u4e0d\u80fd\u4ece\u5b83\u7ee7\u627f\u3002\u8fd9\u5c06\u4f1a\u9020\u6210\u7f16\u8bd1\u9519\u8bef\u3002 1e) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () = 0 ; }; const char * Derived :: getName () { return \"Derived\" ; } int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481e Derived::getName() \u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff08\u65e0\u51fd\u6570\u4f53\uff09\uff0c\u5e76\u4e14\u56e0\u6b64 Derived \u662f\u4e00\u4e2a\u62bd\u8c61\u7c7b (abstract class) \u56e0\u6b64\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002 1f) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base ( value ) { } virtual const char * getName () { return \"Derived\" ; } }; int main () { auto * d { new Derived ( 5 ) }; Base * b { d }; std :: cout << b -> getName () << '\\n' ; delete b ; return 0 ; } \u7b54\u68481f \u8fd9\u4e2a\u7a0b\u5e8f\u5b9e\u9645\u4e0a\u7684\u786e\u53ef\u4ee5\u5f97\u5230\u6b63\u786e\u7684\u8f93\u51fa\uff0c\u4f46\u662f\u53c8\u4e0d\u540c\u7684\u7684\u95ee\u9898\u3002\u5f53\u6211\u4eec delete b \u662f\uff0c b \u662f\u4e00\u4e2a Base \u6307\u9488\uff0c\u4f46\u662f\u4ece\u6765\u6ca1\u6dfb\u52a0\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570 (virtual destructor) \u5230\u57fa\u7c7b\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5220\u9664\u4e86 Derived \u5bf9\u8c61\u4e2d\u7684 Base \u90e8\u5206\uff0c\u5e76\u4e14 Derived \u90e8\u5206\u7559\u5728\u5185\u5b58\u4e2d\uff08\u6cc4\u9732\uff09\u3002 Quiz2 \u00b6 2a) \u521b\u5efa\u4e00\u4e2a\u53eb\u505a\u5f62\u72b6\u7684\u62bd\u8c61\u7c7b\uff0c\u8fd9\u4e2a\u7c7b\u5e94\u8be5\u6709\u4e09\u4e2a\u51fd\u6570\uff1a\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570 print \u4f20\u5165\u5e76\u4e14\u8fd4\u56de\u4e00\u4e2a std::ostream \uff0c\u91cd\u8f7d <<\u64cd\u4f5c\u7b26 operator<< \u548c\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570\u3002 \u7b54\u6848 class Shape { public : // virtual const char* getShapeName() const = 0; virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () {} }; 2b) \u4ece Shape \u6d3e\u751f\u4e24\u4e2a\u7c7b\uff1a\u4e00\u4e2a Triangle \u548c\u4e00\u4e2a Circle \u3002 Triangle \u5e94\u8be5\u6709\u4e09\u4e2a Point \u4f5c\u4e3a\u6210\u5458\u3002 Circle \u5e94\u8be5\u6709\u4e00\u4e2a Point \u5706\u5fc3\uff0c\u548c\u4e00\u4e2a\u6574\u6570\u534a\u5f84 radius \uff0c\u91cd\u8f7d print() \u51fd\u6570\u4f7f\u5f97\u4ee5\u4e0b\u7a0b\u5e8f\u80fd\u591f\u8fd0\u884c\u3002 int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } \u6837\u4f8b\u5e94\u8be5\u6253\u5370\uff1a Circle(Point(1, 2, 3), radius 7) Triangle(Point(1, 2, 3), Point(4, 5, 6), Point(7, 8, 9)) \u8fd9\u662f Point \u7c7b\uff1a class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; \u7b54\u6848\uff1a #include <iostream> class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center ; int m_radius ; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } }; int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } 2c) \u5728\u4ee5\u4e0a\u7c7b( Point, Shape, Circle and Triangle )\u7684\u57fa\u7840\u4e0a\uff0c\u5b8c\u6210\u4ee5\u4e0b\u7a0b\u5e8f\uff1a #include <vector> #include <iostream> int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; // \u6253\u5370 vector \u4e2d\u7684\u6bcf\u4e2a `Shape` \uff0c\u5728\u8fd9\u91cc\u3002 std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; // write this function // \u5220\u9664\u6bcf\u4e2avector\u4e2d\u7684\u5bf9\u8c61\uff0c\u5728\u8fd9\u91cc\u3002 return 0 ; } \u63d0\u793a\uff1a\u4f60\u5c06\u4f1a\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a getRadius() \u51fd\u6570\u5230 Circle \u7c7b\uff0c\u5e76\u4e14\u5411\u4e0b\u8f6c\u5316 Shape* \u6210\u4e3a\u4e00\u4e2a Circle* \u6765\u8bbf\u95ee\u5b83\u3002 \u7b54\u6848\uff1a #include <vector> #include <iostream> class Point { private : int m_x {}; int m_y {}; int m_z {}; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center {}; int m_radius {}; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } int getRadius () const { return m_radius ; } }; // h/t to reader Olivier for this updated solution int getLargestRadius ( const std :: vector < Shape *> & v ) { int largestRadius { 0 }; // Loop through all the shapes in the vector for ( const auto * element : v ) { // // Ensure the dynamic cast succeeds by checking for a null pointer result if ( auto * c { dynamic_cast < Circle *> ( element ) }) { if ( c -> getRadius () > largestRadius ) largestRadius = c -> getRadius (); } } return largestRadius ; } int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; for ( const auto * element : v ) // element will be a Shape* std :: cout << * element << '\\n' ; std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; for ( const auto * element : v ) delete element ; return 0 ; } -> 13.1-Function templates <- 12.10-Printing inherited classes using operator<<","title":"18.x \u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60"},{"location":"18-virtual-functions/18.x%20chapter-18-comprehensice-quiz/#18x","text":"\u6211\u4eec\u7684 C++ \u65c5\u7a0b\u5728\u7ee7\u627f\u548c\u865a\u51fd\u6570\u8fd9\u5757\u5df2\u7ecf\u7ed3\u675f\u4e86\u3002\u4e0d\u8981\u62c5\u5fc3\uff0c\u4eb2\u7231\u7684\u8bfb\u8005\uff0c\u56e0\u4e3a\u8fd8\u6709\u5927\u91cf\u5176\u4ed6 C++ \u7684\u9886\u57df\u7b49\u5f85\u6211\u4eec\u524d\u8fdb\uff0c\u63a2\u7d22\uff01","title":"18.x \u5341\u4e8c\u7ae0\u7406\u89e3\u548c\u7ec3\u4e60"},{"location":"18-virtual-functions/18.x%20chapter-18-comprehensice-quiz/#_1","text":"C++ \u5141\u8bb8\u4f60\u8bbe\u7f6e\u57fa\u7c7b\u6307\u9488\u548c\u5f15\u7528\u5230\u6d3e\u751f\u5bf9\u8c61\u3002\u8fd9\u662f\u5f88\u6709\u7528\u7684\uff0c\u5f53\u6211\u4eec\u60f3\u8981\u5199\u4e00\u4e2a\u51fd\u6570\u6216\u8005\u6570\u7ec4\uff0c\u53ef\u4ee5\u548c\u4efb\u4f55\u7c7b\u578b\u7684\u4ece\u57fa\u7c7b\u6d3e\u751f\u7684\u5bf9\u8c61\u642d\u914d\u3002\uff08This is useful when we want to write a function or array that can work with any type of object derived from a base class.\uff09 \u5982\u679c\u6ca1\u6709\u865a\u51fd\u6570\uff0c\u57fa\u7c7b\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\u548c\u5f15\u7528\u5c06\u4f1a\u53ea\u80fd\u8bbf\u95ee\u57fa\u7c7b\u6210\u5458\uff0c\u548c\u51fd\u6570\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u51fd\u6570\u80fd\u89e3\u6790\u5230\u7ee7\u627f\u672b\u7aef\u7248\u672c\u7684\u51fd\u6570\uff08\u53eb\u505a\u91cd\u5199\uff09\u5b58\u5728\u4e8e\u57fa\u7c7b\u548c\u6d3e\u751f\u7c7b\u4e4b\u95f4\u3002\u60f3\u8981\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u91cd\u5199\uff0c\u6d3e\u751f\u7c7b\u5fc5\u987b\u548c\u57fa\u7c7b\u865a\u51fd\u6570\u6709\u540c\u6837\u7684\u7b7e\u540d\u548c\u8fd4\u56de\u7c7b\u578b\u3002\u4e00\u4e2a\u4f8b\u5916\u5c31\u662f covariant return types \uff0c\u80fd\u591f\u5141\u8bb8\u4e00\u4e2a\u91cd\u5199\u8fd4\u56de\u4e00\u4e2a\u6307\u6d3e\u751f\u7c7b\u7684\u9488\u6216\u5f15\u7528\u5982\u679c\u57fa\u7c7b\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u57fa\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u3002 \u4e00\u4e2a\u51fd\u6570\u51fd\u6570\u60f3\u8981\u88ab\u91cd\u5199\uff0c\u5e94\u8be5\u6dfb\u52a0\u91cd\u5199\u6307\u793a\u7b26\u6765\u786e\u4fdd\u5b83\u786e\u5b9e\u91cd\u5199\u4e86\u3002 final \u6307\u793a\u7b26\u80fd\u591f\u88ab\u7528\u4f5c\u963b\u6b62\u4ece\u4e00\u4e2a\u8be5\u7c7b\u7684\u51fd\u6570\u88ab\u91cd\u5199\u3002 \u5982\u679c\u4f60\u60f3\u8981\u4f7f\u7528\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u4f60\u5e94\u8be5\u4f7f\u4f60\u7684\u6790\u6784\u51fd\u6570\u4e3a\u4e00\u4e2a\u865a\u51fd\u6570\uff0c\u5982\u679c\u4f60\u5220\u9664\u4e00\u4e2a\u57fa\u7c7b\u6307\u9488\uff0c\u8fd9\u6837\u505a\u53ef\u4ee5\u4f7f\u5408\u9002\u7684\u6790\u6784\u51fd\u6570\u88ab\u8c03\u7528\u3002 \u4f60\u53ef\u4ee5\u5ffd\u7565\u4e00\u4e2a\u865a\u51fd\u6570\u89e3\u6790\u901a\u8fc7\u4f7f\u7528 scope resolution opearator \u6765\u76f4\u63a5\u6307\u5b9a\u90a3\u4e2a\u7c7b\u7684\u51fd\u6570\u4f60\u60f3\u8981\u8c03\u7528\uff1a\u4f8b\u5982 base.Base::getName() Early binding \u65e9\u7ed1\u5b9a\u53d1\u751f\u5728\u7f16\u8bd1\u65f6\u76f4\u63a5\u68c0\u6d4b\u5230\u51fd\u6570\u8c03\u7528\uff0c\u7f16\u8bd1\u5668\u6216\u8005\u8fde\u63a5\u5668\u53ef\u4ee5\u76f4\u63a5\u89e3\u6790\u8fd9\u4e9b\u51fd\u6570\u8c03\u7528\u3002 Late binding \u53d1\u751f\u5728\u5f53\u4e00\u4e2a\u51fd\u6570\u6307\u9488\u88ab\u8c03\u7528\u662f\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u54ea\u4e2a\u51fd\u6570\u5c06\u4f1a\u88ab\u8c03\u7528\u4e0d\u53ef\u80fd\u5728\u8fd0\u884c\u4e4b\u524d\u786e\u5b9a\u3002\u865a\u51fd\u6570\u4f7f\u7528\u4e86 late binding \u548c\u4e00\u4e2a\u865a\u8868\u6765\u51b3\u5b9a\u54ea\u4e2a\u7248\u672c\u7684\u51fd\u6570\u5c06\u88ab\u8c03\u7528\u3002 \u4f7f\u7528\u865a\u51fd\u6570\u6709\u4e00\u5b9a\u7684\u82b1\u8d39\uff0c\u865a\u51fd\u6570\u7684\u8c03\u7528\u5c06\u82b1\u8d39\u66f4\u591a\u65f6\u95f4\uff0c\u5e76\u4e14\u865a\u8868\u4f1a\u5360\u7528\u4e00\u5b9a\u7684\u7a7a\u95f4\uff0c\u5728\u6bcf\u4e2a\u5305\u542b\u865a\u51fd\u6570\u7684\u5bf9\u8c61\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2a\u6307\u9488\u3002 \u4e00\u4e2a\u865a\u51fd\u6570\u53ef\u4ee5\u88ab\u5b9a\u4e49\u4e3a\u7eaf\u865a\u51fd\u6570\uff08\u62bd\u8c61\u51fd\u6570\uff09\u901a\u8fc7\u6dfb\u52a0 =0 \u5728\u865a\u51fd\u6570\u7684\u5b9a\u4e49\u540e\u65b9\u3002\u5305\u542b\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u88ab\u53eb\u505a\u62bd\u8c61\u7c7b\uff0c\u8fd9\u79cd\u7c7b\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e8e\u62bd\u8c61\u7c7b\uff0c\u90a3\u4e48\u7eaf\u865a\u51fd\u6570\u5fc5\u987b\u88ab\u6b63\u786e\u7684\u5b9a\u4e49\uff0c\u5426\u5219\u8be5\u7c7b\u4e5f\u5c06\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7c7b\u3002\u7eaf\u865a\u51fd\u6570\u4e5f\u53ef\u4ee5\u6709\u4e00\u4e2a\u51fd\u6570\u4f53\uff0c\u4f46\u662f\u4ed6\u4eec\u4ecd\u7136\u88ab\u8ba4\u4e3a\u662f\u62bd\u8c61\u7684\u3002 \u63a5\u53e3\u7c7b\u662f\u4e00\u4e2a\u6ca1\u6709\u6210\u5458\u53d8\u91cf\u5e76\u4e14\u5168\u662f\u7eaf\u865a\u51fd\u6570\u7684\u7c7b\u3002\u8fd9\u6837\u7684\u7c7b\u7684\u540d\u79f0\u901a\u5e38\u4ee5\u5927\u5199\u7684 I \u5f00\u5934\u3002 \u4e00\u4e2a\u865a\u57fa\u7c7b\u5728\u4e00\u4e2a\u5bf9\u8c61\u4e2d\u53ea\u80fd\u88ab\u5305\u542b\u4e00\u6b21\uff0c\u65e0\u8bba\u88ab\u4e00\u4e2a\u7c7b\u7ee7\u627f\u4e86\u591a\u5c11\u6b21\u3002 \u5f53\u4e00\u4e2a\u6d3e\u751f\u7c7b\u88ab\u8d4b\u503c\u5230\u57fa\u7c7b\u5bf9\u8c61\u65f6\uff0c\u57fa\u7c7b\u53ea\u80fd\u63a5\u6536\u5230\u6d3e\u751f\u7c7b\u4e2d\u57fa\u7c7b\u90e8\u5206\u7684\u62f7\u8d1d\u3002\u8fd9\u88ab\u53eb\u505a\u5bf9\u8c61\u5207\u5272\u3002 \u52a8\u6001\u8f6c\u6362\u53ef\u4ee5\u88ab\u7528\u6765\u8f6c\u6362\u4e00\u4e2a\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u6210\u4e3a\u4e00\u4e2a\u6307\u5411\u6d3e\u751f\u7c7b\u7684\u6307\u9488\uff0c\u8fd9\u88ab\u53eb\u505a\u5411\u4e0b\u8f6c\u6362 (downcasting)\u3002\u4e00\u4e2a\u5931\u8d25\u7684\u8f6c\u6362\u4f1a\u8fd4\u56de\u4e00\u4e2a\u7a7a\u6307\u9488\u3002 \u6d3e\u751f\u7c7b\u6700\u7b80\u5355\u7684\u91cd\u8f7d << \u8fd0\u7b97\u7b26\u7684\u65b9\u5f0f\u662f\u5199\u4e00\u4e2a\u91cd\u8f7d << \u4e3a\u6700\u9876\u90e8\u7684\u57fa\u7c7b\uff0c\u7136\u540e\u6dfb\u52a0\u4e00\u4e2a\u865a\u6210\u5458\u51fd\u6570\u6765\u6253\u5370\u3002 // \u8bd1\u8005\u6dfb\u52a0\u7684\u4ee3\u7801\u7247\u6bb5\uff1a virtual std :: ostream & print ( std :: ostream & in ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Base & b ) { return b . print ( out ); } // \u7ee7\u627f\u5bf9\u8c61\u90fd\u53ea\u9700\u8981\u91cd\u5199print\u5373\u53ef\u3002","title":"\u7ae0\u8282\u603b\u7ed3"},{"location":"18-virtual-functions/18.x%20chapter-18-comprehensice-quiz/#quiz-time","text":"","title":"Quiz time"},{"location":"18-virtual-functions/18.x%20chapter-18-comprehensice-quiz/#quiz1","text":"\u4ee5\u4e0b\u7684\u6bcf\u4e2a\u7a0b\u5e8f\u90fd\u6709\u4e00\u4e9b\u7f3a\u9677\uff0c\u68c0\u67e5\u6bcf\u4e2a\u7a0b\u5e8f\uff08\u7528\u773c\u775b\u68c0\u67e5\uff0c\u4e0d\u8981\u7f16\u8bd1\uff09\u5e76\u4e14\u8bca\u65ad\u51fa\u8fd9\u4e2a\u7a0b\u5e8f\u6709\u4ec0\u4e48\u95ee\u9898\u3002\u6bcf\u4e2a\u7a0b\u5e8f\u7684\u8f93\u51fa\u90fd\u5e94\u8be5\u662f Derived \u3002 \u8bd1\u8005\u6ce8\uff1a\u539f\u7f51\u7ad9\u662f\u54cd\u5e94\u5f0f\u7684\u9690\u85cf\uff0c\u6298\u53e0\u4e86\u7b54\u6848\uff0c\u672c\u7f51\u7ad9\u65e0\u6cd5\u505a\u5230\uff0c\u56e0\u6b64\u8bf7\u5148\u5b8c\u6210\u4ee3\u7801\u9605\u8bfb\u518d\u5f80\u4e0b\u770b\u7b54\u6848\u63cf\u8ff0\uff0c\u6bcf\u4e2a\u9898\u7684\u7b54\u6848\u90fd\u5728\u4ee3\u7801\u63cf\u8ff0\u4e0b\u65b9\u3002 1a) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } const char * getName () const { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481a Base::getName() \u4e0d\u662f\u865a\u51fd\u6570\uff0c \u56e0\u6b64 b.getName() \u4e0d\u4f1a\u89e3\u6790\u5e76\u8c03\u7528 Derived::getName(). 1b) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () const { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481b Base::geetName() \u5e76\u6ca1\u6709\u5b9a\u4e49\u4e3aconst\uff0c\u800c Derived::getName() \u662f\u4e00\u4e2aconst\u51fd\u6570\uff0c\u56e0\u6b64 Derived::getName() \u4e0d\u662f\u4e00\u4e2a\u91cd\u5199(override) 1c) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481c d \u662f\u503c\u8d4b\u503c\u5230 b \uff0c\u5bfc\u81f4 d \u88ab\u5207\u5272\u3002 1d) #include <iostream> class Base final { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () override { return \"Derived\" ; } }; int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481d Base \u88ab\u5b9a\u4e49\u4e3a final \uff0c\u56e0\u6b64 Derived \u4e0d\u80fd\u4ece\u5b83\u7ee7\u627f\u3002\u8fd9\u5c06\u4f1a\u9020\u6210\u7f16\u8bd1\u9519\u8bef\u3002 1e) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base { value } { } virtual const char * getName () = 0 ; }; const char * Derived :: getName () { return \"Derived\" ; } int main () { Derived d { 5 }; Base & b { d }; std :: cout << b . getName () << '\\n' ; return 0 ; } \u7b54\u68481e Derived::getName() \u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff08\u65e0\u51fd\u6570\u4f53\uff09\uff0c\u5e76\u4e14\u56e0\u6b64 Derived \u662f\u4e00\u4e2a\u62bd\u8c61\u7c7b (abstract class) \u56e0\u6b64\u4e0d\u80fd\u88ab\u5b9e\u4f8b\u5316\u3002 1f) #include <iostream> class Base { protected : int m_value ; public : Base ( int value ) : m_value { value } { } virtual const char * getName () { return \"Base\" ; } }; class Derived : public Base { public : Derived ( int value ) : Base ( value ) { } virtual const char * getName () { return \"Derived\" ; } }; int main () { auto * d { new Derived ( 5 ) }; Base * b { d }; std :: cout << b -> getName () << '\\n' ; delete b ; return 0 ; } \u7b54\u68481f \u8fd9\u4e2a\u7a0b\u5e8f\u5b9e\u9645\u4e0a\u7684\u786e\u53ef\u4ee5\u5f97\u5230\u6b63\u786e\u7684\u8f93\u51fa\uff0c\u4f46\u662f\u53c8\u4e0d\u540c\u7684\u7684\u95ee\u9898\u3002\u5f53\u6211\u4eec delete b \u662f\uff0c b \u662f\u4e00\u4e2a Base \u6307\u9488\uff0c\u4f46\u662f\u4ece\u6765\u6ca1\u6dfb\u52a0\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570 (virtual destructor) \u5230\u57fa\u7c7b\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u5220\u9664\u4e86 Derived \u5bf9\u8c61\u4e2d\u7684 Base \u90e8\u5206\uff0c\u5e76\u4e14 Derived \u90e8\u5206\u7559\u5728\u5185\u5b58\u4e2d\uff08\u6cc4\u9732\uff09\u3002","title":"Quiz1"},{"location":"18-virtual-functions/18.x%20chapter-18-comprehensice-quiz/#quiz2","text":"2a) \u521b\u5efa\u4e00\u4e2a\u53eb\u505a\u5f62\u72b6\u7684\u62bd\u8c61\u7c7b\uff0c\u8fd9\u4e2a\u7c7b\u5e94\u8be5\u6709\u4e09\u4e2a\u51fd\u6570\uff1a\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570 print \u4f20\u5165\u5e76\u4e14\u8fd4\u56de\u4e00\u4e2a std::ostream \uff0c\u91cd\u8f7d <<\u64cd\u4f5c\u7b26 operator<< \u548c\u4e00\u4e2a\u865a\u6790\u6784\u51fd\u6570\u3002 \u7b54\u6848 class Shape { public : // virtual const char* getShapeName() const = 0; virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () {} }; 2b) \u4ece Shape \u6d3e\u751f\u4e24\u4e2a\u7c7b\uff1a\u4e00\u4e2a Triangle \u548c\u4e00\u4e2a Circle \u3002 Triangle \u5e94\u8be5\u6709\u4e09\u4e2a Point \u4f5c\u4e3a\u6210\u5458\u3002 Circle \u5e94\u8be5\u6709\u4e00\u4e2a Point \u5706\u5fc3\uff0c\u548c\u4e00\u4e2a\u6574\u6570\u534a\u5f84 radius \uff0c\u91cd\u8f7d print() \u51fd\u6570\u4f7f\u5f97\u4ee5\u4e0b\u7a0b\u5e8f\u80fd\u591f\u8fd0\u884c\u3002 int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } \u6837\u4f8b\u5e94\u8be5\u6253\u5370\uff1a Circle(Point(1, 2, 3), radius 7) Triangle(Point(1, 2, 3), Point(4, 5, 6), Point(7, 8, 9)) \u8fd9\u662f Point \u7c7b\uff1a class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; \u7b54\u6848\uff1a #include <iostream> class Point { private : int m_x { 0 }; int m_y { 0 }; int m_z { 0 }; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center ; int m_radius ; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } }; int main () { Circle c { Point { 1 , 2 , 3 }, 7 }; std :: cout << c << '\\n' ; Triangle t { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}; std :: cout << t << '\\n' ; return 0 ; } 2c) \u5728\u4ee5\u4e0a\u7c7b( Point, Shape, Circle and Triangle )\u7684\u57fa\u7840\u4e0a\uff0c\u5b8c\u6210\u4ee5\u4e0b\u7a0b\u5e8f\uff1a #include <vector> #include <iostream> int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; // \u6253\u5370 vector \u4e2d\u7684\u6bcf\u4e2a `Shape` \uff0c\u5728\u8fd9\u91cc\u3002 std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; // write this function // \u5220\u9664\u6bcf\u4e2avector\u4e2d\u7684\u5bf9\u8c61\uff0c\u5728\u8fd9\u91cc\u3002 return 0 ; } \u63d0\u793a\uff1a\u4f60\u5c06\u4f1a\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a getRadius() \u51fd\u6570\u5230 Circle \u7c7b\uff0c\u5e76\u4e14\u5411\u4e0b\u8f6c\u5316 Shape* \u6210\u4e3a\u4e00\u4e2a Circle* \u6765\u8bbf\u95ee\u5b83\u3002 \u7b54\u6848\uff1a #include <vector> #include <iostream> class Point { private : int m_x {}; int m_y {}; int m_z {}; public : Point ( int x , int y , int z ) : m_x { x }, m_y { y }, m_z { z } { } friend std :: ostream & operator << ( std :: ostream & out , const Point & p ) { out << \"Point(\" << p . m_x << \", \" << p . m_y << \", \" << p . m_z << ')' ; return out ; } }; class Shape { public : virtual std :: ostream & print ( std :: ostream & out ) const = 0 ; friend std :: ostream & operator << ( std :: ostream & out , const Shape & p ) { return p . print ( out ); } virtual ~ Shape () = default ; }; class Triangle : public Shape { private : Point m_p1 {}; Point m_p2 {}; Point m_p3 {}; public : Triangle ( const Point & p1 , const Point & p2 , const Point & p3 ) : m_p1 { p1 }, m_p2 { p2 }, m_p3 { p3 } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Triangle(\" << m_p1 << \", \" << m_p2 << \", \" << m_p3 << ')' ; return out ; } }; class Circle : public Shape { private : Point m_center {}; int m_radius {}; public : Circle ( const Point & center , int radius ) : m_center { center }, m_radius { radius } { } virtual std :: ostream & print ( std :: ostream & out ) const override { out << \"Circle(\" << m_center << \", radius \" << m_radius << ')' ; return out ; } int getRadius () const { return m_radius ; } }; // h/t to reader Olivier for this updated solution int getLargestRadius ( const std :: vector < Shape *> & v ) { int largestRadius { 0 }; // Loop through all the shapes in the vector for ( const auto * element : v ) { // // Ensure the dynamic cast succeeds by checking for a null pointer result if ( auto * c { dynamic_cast < Circle *> ( element ) }) { if ( c -> getRadius () > largestRadius ) largestRadius = c -> getRadius (); } } return largestRadius ; } int main () { std :: vector < Shape *> v { new Circle { Point { 1 , 2 , 3 }, 7 }, new Triangle { Point { 1 , 2 , 3 }, Point { 4 , 5 , 6 }, Point { 7 , 8 , 9 }}, new Circle { Point { 4 , 5 , 6 }, 3 } }; for ( const auto * element : v ) // element will be a Shape* std :: cout << * element << '\\n' ; std :: cout << \"The largest radius is: \" << getLargestRadius ( v ) << '\\n' ; for ( const auto * element : v ) delete element ; return 0 ; } -> 13.1-Function templates <- 12.10-Printing inherited classes using operator<<","title":"Quiz2"},{"location":"19-templates/","text":"\u5341\u4e5d\u7ae0 \u6a21\u677f \u00b6 19.1-\u51fd\u6570\u6a21\u677f 19.2-\u7c7b\u6a21\u677f\u5b9e\u4f8b 19.3-\u7c7b\u6a21\u677f 19.4-\u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570 19.5-\u51fd\u6570\u6a21\u677f\u7279\u5316 19.6-\u7c7b\u6a21\u677f\u7279\u5316 19.7-\u6a21\u677f\u5c40\u90e8\u7279\u5316 19.8-\u6307\u9488\u7684\u5c40\u90e8\u6a21\u677f\u7279\u5316 19.x-19\u7ae0\u7ec3\u4e60","title":"\u5341\u4e5d\u7ae0 \u6a21\u677f"},{"location":"19-templates/#_1","text":"19.1-\u51fd\u6570\u6a21\u677f 19.2-\u7c7b\u6a21\u677f\u5b9e\u4f8b 19.3-\u7c7b\u6a21\u677f 19.4-\u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570 19.5-\u51fd\u6570\u6a21\u677f\u7279\u5316 19.6-\u7c7b\u6a21\u677f\u7279\u5316 19.7-\u6a21\u677f\u5c40\u90e8\u7279\u5316 19.8-\u6307\u9488\u7684\u5c40\u90e8\u6a21\u677f\u7279\u5316 19.x-19\u7ae0\u7ec3\u4e60","title":"\u5341\u4e5d\u7ae0 \u6a21\u677f"},{"location":"19-templates/19.1-function-templates/","text":"19.1 \u51fd\u6570\u6a21\u677f Function templates \u00b6 By Alex on April 18 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 7\u670810\u65e5 \u4e3a\u4ec0\u4e48\u9700\u8981\u51fd\u6570\u6a21\u677f \u00b6 \u5728\u4e4b\u524d\u7684\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5b66\u5230\u4e86\u5982\u4f55\u5199\u51fd\u6570\u548c\u7c7b\uff0c\u8fd9\u4e9b\u53ef\u4ee5\u5e2e\u52a9\u6210\u5458\u4eec\u66f4\u5bb9\u6613\u548c\u66f4\u5b89\u5168\u7684\u5199\u4ee3\u7801\uff0c\u5199\u51fa\u66f4\u52a0\u6613\u4e8e\u7ef4\u62a4\u7684\u4ee3\u7801\u3002\u5bf9\u4e8e\u9ad8\u6548\u7f16\u7a0b\uff0c\u51fd\u6570\u548c\u7c7b\u90fd\u975e\u5e38\u5f3a\u5927\u548c\u65b9\u4fbf\u7684\u5de5\u5177\uff0c\u5728\u4e00\u4e9b\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\uff0c\u4ed6\u4eec\u53ef\u80fd\u4ecd\u7136\u6709\u70b9\u53d7\u9650\u5236\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u6240\u6709\u53c2\u6570\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u5047\u5982\u4f60\u60f3\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u8ba1\u7b97\u4e24\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u503c\uff0c\u4f60\u53ef\u80fd\u4f1a\u50cf\u8fd9\u6837\u505a int max ( int x , int y ) { return ( x > y ) ? x : y ; } \u8fd9\u4e2a\u51fd\u6570\u5b8c\u7f8e\u80dc\u4efb\u5de5\u4f5c\u2014\u2014\u5bf9\u4e8e\u6574\u578b\u6765\u8bf4\u3002\u5982\u679c\u4e4b\u540e\u4f60\u60f3\u5b9e\u73b0\u4e00\u4e2a max() \u51fd\u6570\uff0c\u9700\u8981\u5728 doubles \u4e0b\u5de5\u4f5c\uff1f\u6839\u636e\u4f20\u7edf\uff0c\u7b54\u6848\u53ef\u80fd\u662f\u91cd\u8f7dmac\u51fd\u6570\uff0c\u5e76\u4e14\u521b\u9020\u4e00\u4e2a\u65b0\u7684 doubles \u7684\u7248\u672c\uff1a double max ( double x , double y ) { return ( x > y ) ? x : y ; } \u6211\u4eec\u6ce8\u610f\u5230 double \u7248\u672c\u7684 maximum() \u548c int \u7248\u672c\u5b8c\u5168\u76f8\u540c\uff01\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u5b9e\u73b0\u4f1a\u5728\u6240\u6709\u4e0d\u540c\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff1achars\uff0cints\uff0cdoubles\uff0c\u5e76\u4e14\u5982\u679c\u4f60\u5df2\u7ecf\u91cd\u8f7d\u4e86 > \u8fd0\u7b97\u7b26\uff0c\u8fd9\u4e9b\u7c7b\u578b\u4e5f\u53ef\u4ee5\uff01\u7136\u800c\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u51fd\u6570\u7684\u53d8\u91cf\uff0c\u4f60\u5c31\u4f1a\u56f0\u5728\u7ed9\u6bcf\u4e00\u4e2a\u4f60\u8981\u7528\u5230\u7684\u7c7b\u578b\u5199\u4e00\u4e2a\u540c\u6837\u7684\u51fd\u6570\u3002 \u5b9e\u73b0\u4e00\u7cfb\u5217\u4e0d\u540c\u201c\u98ce\u5473\u201d\u7684\u76f8\u540c\u51fd\u6570\u2014\u2014\u4ec5\u4ec5\u53ea\u662f\u53c2\u6570\u7c7b\u578b\u4e0d\u540c\uff0c\u8fd9\u4ef6\u4e8b\u53ef\u80fd\u4f1a\u5728\u7ef4\u62a4\u4e0a\u4f1a\u975e\u5e38\u4ee4\u4eba\u5934\u75bc\uff0c\u4e5f\u5341\u5206\u6d6a\u8d39\u65f6\u95f4\uff0c\u8fd9\u4e5f\u8fdd\u53cd\u4e86\u901a\u5e38\u7f16\u7a0b\u7684\u7eb2\u8981\uff0c\u91cd\u590d\u7684\u4ee3\u7801\u5e94\u8be5\u88ab\u5c3d\u53ef\u80fd\u7684\u51cf\u5c0f\u3002\u5982\u679c\u80fd\u591f\u5199\u4e00\u4e2a\u51fd\u6570\u5c31\u5728\u4efb\u610f\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff0c\u90a3\u4f1a\u4e0d\u4f1a\u5f88\u68d2\uff1f \u6b22\u8fce\u6765\u5230\u6a21\u677f\u7684\u4e16\u754c\u3002 \u4ec0\u4e48\u662f\u51fd\u6570\u6a21\u677f \u00b6 \u5982\u679c\u4f60\u5728\u8bcd\u5178\u91cc\u67e5\u201c\u6a21\u677f\u201d\u8fd9\u4e2a\u8bfb\u5355\u8bcd\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u7684\u5b9a\u4e49\u4f1a\u50cf\u8fd9\u6837\uff1a\u201c\u6a21\u677f\u662f\u4e00\u79cd\u6a21\u578b\uff0c\u4f5c\u4e3a\u521b\u5efa\u7c7b\u4f3c\u5bf9\u8c61\u7684\u6a21\u5f0f\u201d\u3002\u4e00\u79cd\u975e\u5e38\u5bb9\u6613\u7406\u89e3\u7684\u6a21\u677f\u7c7b\u578b\u5c31\u662f\u6f0f\u5b57\u677f\uff08stencil\uff09\u3002\u4e00\u4e2a\u6f0f\u5b57\u677f\u662f\u4e00\u4e2a\u5bf9\u8c61\uff08\u4f8b\u5982\uff1a\u4e00\u5f20\u786c\u7eb8\u677f\uff09\u4e0a\u9762\u523b\u4e86\u4e00\u4e2a\u5f62\u72b6\uff08\u4f8b\u5982\u5b57\u6bcdJ\uff09\u3002\u628a\u6f0f\u5b57\u677f\u6446\u653e\u5728\u5176\u4ed6\u5bf9\u8c61\u7684\u4e0a\u65b9\uff0c\u7136\u540e\u55b7\u6d82\u901a\u8fc7\u8fd9\u4e2a\u5f62\u72b6\uff0c\u4f60\u53ef\u4ee5\u5feb\u901f\u7684\u4ea7\u751f\u4e0d\u540c\u989c\u8272\u7684\u9542\u7a7a\u90e8\u5206\u7684\u5f62\u72b6\uff01\u6ce8\u610f\u4f60\u4ec5\u4ec5\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7ed9\u5b9a\u7684\u6f0f\u5b57\u677f\u4e00\u6b21 \u2014\u2014 \u53ea\u8981\u4f60\u559c\u6b22\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528\u5b83\u5f88\u591a\u6b21\u6765\u521b\u5efa\u4f60\u559c\u6b22\u7684\u989c\u8272\u7684\u3002\u66f4\u597d\u7684\u662f\uff0c\u4f60\u4e0d\u9700\u8981\u5728\u5236\u4f5c\u6f0f\u5b57\u677f\u7684\u65f6\u5019\uff0c\u63d0\u524d\u60f3\u597d\u5f62\u72b6\u7684\u989c\u8272\uff0c\u4f60\u53ef\u4ee5\u518d\u5b9e\u9645\u4f7f\u7528\u7684\u65f6\u5019\u518d\u51b3\u5b9a\u3002 \u5728 C++ \u4e2d\uff0c\u51fd\u6570\u6a21\u677f\u662f\u4f5c\u4e3a\u521b\u5efa\u5176\u4ed6\u7c7b\u578b\u6a21\u677f\u7684\u51fd\u6570\u3002\u5728\u51fd\u6570\u6a21\u677f\u4e4b\u524d\u7684\u4e00\u4e2a\u66f4\u57fa\u7840\u7684\u60f3\u6cd5\u5c31\u662f\u6765\u521b\u5efa\u4e00\u4e2a\u4e0d\u6307\u5b9a\u786e\u5207\u7c7b\u578b\u7684\u51fd\u6570\u3002\u76f8\u53cd\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86\u4f7f\u7528\u5360\u4f4d\u7b26\u7c7b\u578b\u7684\u51fd\u6570\uff0c\u53eb\u505a\u672b\u73ed\u7c7b\u578b\u9910\u6731\u3002\u4e00\u65e6\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u51fd\u6570\u4f7f\u7528\u4e86\u989d\u8fd9\u4e9b\u5360\u4f4d\u7b26\uff0c\u6211\u4eec\u5c31\u80fd\u9ad8\u6548\u7684\u521b\u5efa\u4e00\u4e2a\u201d\u51fd\u6570\u6f0f\u5b57\u677f\u201c\u3002 \u5f53\u4f60\u8c03\u7528\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u4f7f\u7528 \u201d\u6f0f\u5b57\u677f\u201c \u751f\u6210\u4e86\u4e00\u4e2a\u6a21\u677f\u7684\u62f7\u8d1d\uff0c\u7136\u540e\u4f7f\u7528\u5b9e\u9645\u7c7b\u578b\u66ff\u6362\u4e86\u6240\u6709\u7684\u5360\u4f4d\u7b26\u7c7b\u578b\u53c2\u6570\uff01\u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u7f16\u8bd1\u5668\u53ef\u4ee5\u4ece\u4e00\u4e2a\u6a21\u677f\u521b\u5efa\u51fa\u5f88\u591a\u4e0d\u540c\u201d\u98ce\u5473\u201c\u51fd\u6570\uff01\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u8be6\u7ec6\u63a2\u8ba8\u8fd9\u4e2a\u5185\u5bb9\u3002 \u5728 C++ \u4e2d\u521b\u5efa\u51fd\u6570\u6a21\u677f \u00b6 \u8fd9\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u5728\u60f3\u5982\u4f55\u5728 C++ \u4e2d\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u3002\u5176\u5b9e\uff0c\u5e76\u4e0d\u590d\u6742\u3002 \u8ba9\u6211\u4eec\u518d\u770b\u4e00\u773c int \u7248\u672c\u7684 max() \u7684\u4f8b\u5b50\uff1a int max ( int x , int y ) { return ( x > y ) ? x : y ; } \u6211\u4eec\u6ce8\u610f\u5230\u6709\u4e09\u4e2a\u4f4d\u7f6e\u9700\u8981\u6307\u5b9a\u5177\u4f53\u7684\u7c7b\u578b\uff1a\u53c2\u6570 x, y \u548c\u8fd4\u56de\u503c\u90fd\u5fc5\u987b\u6307\u5b9a\u4e3a\u6574\u578b\u3002\u60f3\u8981\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528\u5360\u4f4d\u7b26\u7c7b\u578b\u66ff\u6362\u8fd9\u4e9b\u7279\u5b9a\u7684\u7c7b\u578b\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u66ff\u6362 int \u7c7b\u578b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u3002 \u4f60\u53ef\u4ee5\u5c06\u5360\u4f4d\u7b26\u7c7b\u578b\u547d\u540d\u4e3a\u4efb\u4f55\u4f60\u60f3\u8981\u7684\uff0c\u53ea\u8981\u4ed6\u4e0d\u662f\u4e00\u4e2a C++ \u9884\u7559\u7684\u5b57\u6bb5\u3002\u7136\u800c\uff0c\u5728 C++ \u4e2d\uff0c\u901a\u5e38\u4e60\u60ef\u4f7f\u7528\u5b57\u6bcd T \uff08Type \u7684\u7f29\u5199\uff09\u6765\u547d\u540d\u6a21\u677f\u7c7b\u3002 \u4e0b\u9762\u662f\u5e26\u6709\u5360\u4f4d\u7b26\u7c7b\u578b\u7684\u65b0\u51fd\u6570\uff1a T max ( T x , T y ) { return ( x > y ) ? x : y ; } \u8fd9\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u5f00\u59cb \u2014\u2014 \u7136\u800c\uff0c\u5b83\u5e76\u4e0d\u80fd\u901a\u8fc7\u7f16\u8bd1\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u5e76\u4e0d\u77e5\u9053 \u201dT\u201c \u662f\u4ec0\u4e48\uff01 \u60f3\u8981\u4f7f\u5f97\u8fd9\u4e2a\u8d77\u4f5c\u7528\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9\u7f16\u8bd1\u5668\u4e24\u4ef6\u4e8b\uff1a\u7b2c\u4e00\uff0c\u8fd9\u662f\u4e00\u4e2a\u5e26\u6a21\u677f\u7684\u5b9a\u4e49\uff1b\u7b2c\u4e8c\uff0cT \u662f\u4e00\u4e2a\u5360\u4f4d\u7b26\u7c7b\u578b\u3002\u6211\u4eec\u53ef\u4ee5\u5728\u4e00\u884c\u4e2d\u505a\u8fd9\u4e24\u4ef6\u4e8b\uff0c\u4ec5\u4ec5\u662f\u9700\u8981\u4f7f\u7528\u4e00\u4e2a\u53eb\u505a\u6a21\u677f\u53c2\u6570\u58f0\u660e\u7684\u8bed\u6cd5\uff1a template < typename T > // this is the template parameter declaration T max ( T x , T y ) { return ( x > y ) ? x : y ; } \u4e0d\u7ba1\u4f60\u4fe1\u4e0d\u4fe1\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u9700\u8981\u505a\u7684\uff0c\u8fd9\u5c06\u4f1a\u901a\u8fc7\u7f16\u8bd1\uff01 \u73b0\u5728\u8ba9\u6211\u4eec\u7a0d\u5fae\u4ed4\u7ec6\u770b\u4e00\u4e0b\u6a21\u677f\u53c2\u6570\u7684\u58f0\u660e\u3002\u6211\u4eec\u5f00\u59cb\u4e8e\u5173\u952e\u8bcd template \u2014\u2014 \u8fd9\u4f1a\u544a\u8bc9\u7f16\u8bd1\u5668\u63a5\u4e0b\u6765\u662f\u4e00\u7cfb\u5217\u7684\u6a21\u677f\u53c2\u6570\u3002\u6211\u4eec\u653e\u7f6e\u6240\u6709\u7684\u53c2\u6570\u5728\u4e00\u4e2a\u5c16\u62ec\u53f7\uff08<>\uff09\u4e2d\u3002\u60f3\u8981\u521b\u5efa\u4e00\u4e2a\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff0c\u8981\u540c\u65f6\u4f7f\u7528\u7c7b\u540d\u6216\u8005 class \u5173\u952e\u8bcd\u3002\u8fd9\u4e24\u79cd\u5173\u952e\u8bcd\u5728\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\u6ca1\u6709\u4ec0\u4e48\u4e0d\u540c\uff0c\u4f60\u60f3\u7528\u5565\u53d6\u51b3\u4e8e\u4f60\u3002\u6ce8\u610f\u5982\u679c\u4f60\u60f3\u8981\u4f7f\u7528 class \u5173\u952e\u8bcd\uff0c\u4f60\u4f20\u5165\u7684 type \u5b9e\u9645\u4e0a\u6ca1\u5fc5\u8981\u662f\u4e00\u4e2a\u7c7b\uff08\u4ed6\u53ef\u80fd\u662f\u4e00\u4e2a\u57fa\u7840\u53d8\u91cf\uff0c\u6307\u9488\uff0c\u6216\u8005\u4efb\u4f55\u5176\u4ed6\u7684\u5339\u914d\uff09\u3002\u7136\u540e\u4f60\u547d\u540d\u4f60\u7684\u7c7b\u578b\uff08\u901a\u5e38\u662f \u201cT\u201d\uff09\u3002 \uff08\u539f\u6587\uff0c\u7a0d\u590d\u6742\uff09Now, let\u2019s take a slightly closer look at the template parameter declaration. We start with the keyword template -- this tells the compiler that what follows is going to be a list of template parameters. We place all of our parameters inside angled brackets (<>). To create a template type parameter, use either the keyword typename or class. There is no difference between the two keywords in this context, so which you use is up to you. Note that if you use the class keyword, the type passed in does not actually have to be a class (it can be a fundamental variable, pointer, or anything else that matches). Then you name your type (usually \u201cT\u201d). \u5982\u679c\u6a21\u677f\u51fd\u6570\u7528\u4e86\u591a\u4e2a\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff0c\u53ef\u4ee5\u4f7f\u7528\u9017\u53f7\u5206\u9694\u5f00\uff1a template < typename T1 , typename T2 > // template function here \u4f7f\u7528\u8d85\u8fc7\u4e00\u4e2a\u7c7b\u578b\u7684\u90a3\u4e9b\u7c7b\uff0c\u5e38\u89c1\u7684\u5c06\u4ed6\u4eec\u547d\u540d\u4e3a T1 \u548c T2 \uff0c\u6216\u8005\u5176\u4ed6\u5355\u72ec\u7684\u9996\u5b57\u6bcd\u5927\u5199\u7684\u540d\u5b57\uff0c\u4f8b\u5982 \u201cS\u201d\u3002 \u4e00\u4e2a\u6700\u540e\u9700\u8981\u6ce8\u610f\u7684\u70b9\uff1a\u56e0\u4e3a\u4f20\u5165\u7684\u51fd\u6570\u53c2\u6570\u53ef\u80fd\u662f\u4e00\u4e2a\u7c7b\u578b\uff0c\u5e76\u4e14\u901a\u8fc7value\u4f20\u503c\u901a\u5e38\u4e0d\u662f\u4e00\u4e2a\u597d\u4e3b\u610f\uff0c\u6700\u597d\u662f\u80fd\u8ba9\u6a21\u677f\u7684\u53c2\u6570\u548c\u8fd4\u56de\u503c\u7c7b\u578b\u4e3a\u5e38\u5f15\u7528\uff1a template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } \u4f7f\u7528\u51fd\u6570\u6a21\u677f \u00b6 \u4f7f\u7528\u51fd\u6570\u6a21\u677f\u662f\u76f8\u5f53\u76f4\u63a5\u7684 \u2014\u2014 \u4f60\u53ef\u4ee5\u5c31\u50cf\u7528\u5176\u4ed6\u51fd\u6570\u90a3\u6837\u4f7f\u7528\u5b83\u3002\u8fd9\u6709\u4e00\u4e2a\u6574\u4f53\u4f7f\u7528\u7684\u4f8b\u5b50\uff1a # include <iostream> template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } int main () { int i = max ( 3 , 7 ); // returns 7 std :: cout << i << '\\n' ; double d = max ( 6.34 , 18.523 ); // returns 18.523 std :: cout << d << '\\n' ; char ch = max ( 'a' , '6' ); // returns 'a' std :: cout << ch << '\\n' ; return 0 ; } \u6253\u5370\uff1a 7 18.523 a \u6ce8\u610f\u6240\u6709\u7684\u8fd9\u4e09\u4e2a max() \u7684\u8c03\u7528\u6709\u7740\u4e0d\u540c\u7684\u53c2\u6570\uff01\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u5206\u522b\u7528\u4e0d\u540c\u7684\u53c2\u6570\u8c03\u7528\u4e86\u4e09\u6b21\u8be5\u51fd\u6570\u3002\u7f16\u8bd1\u5668\u5c06\u4f1a\u4f7f\u7528\u6a21\u677f\u6765\u521b\u5efa\u4e09\u4e2a\u4e0d\u540c\u7248\u672c\u7684\u51fd\u6570\uff0c\u4e00\u4e2a\u662f\u5e26\u6709 int \u53c2\u6570\u7684\uff08\u547d\u540d\u4e3a max<int> \uff09\uff0c\u4e00\u4e2a\u662f double \u53c2\u6570\u7684\uff08\u547d\u540d\u4e3a max<double> \uff09\uff0c\u5e76\u4e14\u8fd8\u6709\u4e00\u4e2a\u662f char \u53c2\u6570\u7684\uff08\u547d\u540d\u4e3a max<char> \uff09\u3002 \u6ce8\u610f\uff0c\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5728\u51fd\u6570\u540d\u79f0\u4e2d\uff0c\u4f60\u65e0\u9700\u663e\u5f0f\u7684\u6307\u5b9a\u7279\u5b9a\u7684\u6a21\u677f\u7c7b\u578b\uff08\u4f8b\u5982 max<int> \uff09\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u4ece\u53c2\u6570\u7c7b\u578b\u6765\u63a8\u65ad\u3002 \u603b\u7ed3 \u00b6 \u5982\u4f60\u6240\u89c1\uff0c\u6a21\u677f\u51fd\u6570\u53ef\u4ee5\u8282\u7701\u5927\u91cf\u7684\u65f6\u95f4\uff0c\u56e0\u4e3a\u4f60\u53ea\u9700\u8981\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u5e76\u4e14\u5b83\u80fd\u5f88\u597d\u7684\u5de5\u4f5c\u5728\u4e0d\u901a\u96f7\u7fd4\u4e0b\u3002\u4e00\u65e6\u4f60\u719f\u6089\u5199\u51fd\u6570\u6a21\u677f\u4e86\uff0c\u60a8\u4f1a\u53d1\u73b0\u5b83\u4eec\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u6bd4\u5b9e\u9645\u7c7b\u578b\u7684\u51fd\u6570\u7f16\u5199\u66f4\u957f\u7684\u65f6\u95f4\u3002\u6a21\u677f\u51fd\u6570\u51cf\u5c11\u4e86\u4ee3\u7801\u7684\u7ef4\u62a4\u96be\u5ea6\uff0c\u56e0\u4e3a\u51cf\u5c11\u4e86\u5927\u91cf\u76f8\u540c\u7684\u4ee3\u7801\u3002\u6700\u7ec8\uff0c\u6a21\u677f\u51fd\u6570\u53ef\u80fd\u66f4\u52a0\u5b89\u5168\uff0c\u56e0\u4e3a\u5f53\u4f60\u9700\u8981\u8be5\u51fd\u6570\u5728\u53e6\u4e00\u4e2a\u7c7b\u578b\u4e0b\u5de5\u4f5c\u7684\u65f6\u5019\uff0c\u4e0d\u7528\u62f7\u8d1d\u51fd\u6570\u7136\u540e\u624b\u52a8\u6539\u53d8\u53c2\u6570\u7c7b\u578b\u3002 \u6a21\u677f\u51fd\u6570\u4e5f\u7684\u786e\u6709\u4e9b\u7f3a\u70b9\uff0c\u5982\u679c\u6211\u4eec\u4e0d\u63d0\u5c31\u592a\u4e0d\u79f0\u804c\u4e86\u3002\u7b2c\u4e00\uff0c\u4e00\u4e9b\u8001\u7684\u7f16\u8bd1\u5668\u4e0d\u80fd\u5f88\u597d\u7684\u652f\u6301\u6a21\u677f\u3002\u7136\u800c\u8fd9\u4e2a\u7f3a\u70b9\u5df2\u7ecf\u4e0d\u518d\u50cf\u8fc7\u53bb\u4e00\u6837\u662f\u4e2a\u5927\u95ee\u9898\u3002\u7b2c\u4e8c\uff0c\u6a21\u677f\u51fd\u6570\u76f8\u6bd4\u666e\u901a\u51fd\u6570\u901a\u5e38\u4f1a\u9020\u6210\u75af\u72c2\u7684\u9519\u8bef\u4fe1\u606f\uff0c\u975e\u5e38\u96be\u4ee5\u89e3\u8bfb\u3002\uff08\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u770b\u5230\u4e00\u4e2a\u4f8b\u5b50\uff09\u3002\u7b2c\u4e09\uff0c\u6a21\u677f\u51fd\u6570\u53ef\u4ee5\u51cf\u5c11\u4f60\u7684\u7f16\u8bd1\u65f6\u95f4\u548c\u4ee3\u7801\u5c3a\u5bf8\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5355\u6a21\u677f\u53ef\u80fd\u88ab\u201c\u8bc6\u522b\u201d\u5e76\u4e14\u5728\u5f88\u591a\u6587\u4ef6\u4e2d\u88ab\u91cd\u65b0\u7f16\u8bd1\uff08\u6709\u5f88\u591a\u65b9\u5f0f\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff09\u3002 \u7136\u800c\uff0c\u8fd9\u4e9b\u7f3a\u70b9\u6bd4\u8d77\u9ad8\u6548\u800c\u7075\u6d3b\u7684\u6a21\u677f\u5e26\u6765\u7684\u4f18\u70b9\u90fd\u662f\u4e0d\u503c\u4e00\u63d0\u3002 \u6ce8\u610f\uff1a\u6807\u51c6\u5e93\u65e9\u5c31\u643a\u5e26\u4e86\u4e00\u4e2a\u590d\u6742\u7684 max() \u51fd\u6570\uff08\u5728 algorithm \u5934\u4e2d\uff09\uff0c\u56e0\u6b64\u4f60\u4e0d\u9700\u8981\u81ea\u5df1\u5199\u4e00\u4e2a\uff08\u9664\u975e\u4f60\u60f3\u5199\uff09\u3002\u5982\u679c\u4f60\u5199\u4e86\u4f60\u81ea\u5df1\u7684\uff0c\u6ce8\u610f\u6f5c\u5728\u7684\u547d\u540d\u51b2\u7a81\u5982\u679c\u4f60\u4f7f\u7528\u4e86\u8bed\u53e5 \"using namespace std;\", \u56e0\u4e3a\u7f16\u8bd1\u5668\u5c06\u4e0d\u80fd\u544a\u8bc9\u51b3\u5b9a\u4f60\u60f3\u8c03\u7528\u4f60\u7684\u7248\u672c\u7684 max \u8fd8\u662f std::max() \u3002 \u5728\u5269\u4e0b\u7684\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u7ee7\u7eed\u63a2\u7d22\u6a21\u677f\u7684\u8bdd\u9898\u3002","title":"19.1 \u51fd\u6570\u6a21\u677f Function templates"},{"location":"19-templates/19.1-function-templates/#191-function-templates","text":"By Alex on April 18 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1by dashjay 7\u670810\u65e5","title":"19.1 \u51fd\u6570\u6a21\u677f Function templates"},{"location":"19-templates/19.1-function-templates/#_1","text":"\u5728\u4e4b\u524d\u7684\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5b66\u5230\u4e86\u5982\u4f55\u5199\u51fd\u6570\u548c\u7c7b\uff0c\u8fd9\u4e9b\u53ef\u4ee5\u5e2e\u52a9\u6210\u5458\u4eec\u66f4\u5bb9\u6613\u548c\u66f4\u5b89\u5168\u7684\u5199\u4ee3\u7801\uff0c\u5199\u51fa\u66f4\u52a0\u6613\u4e8e\u7ef4\u62a4\u7684\u4ee3\u7801\u3002\u5bf9\u4e8e\u9ad8\u6548\u7f16\u7a0b\uff0c\u51fd\u6570\u548c\u7c7b\u90fd\u975e\u5e38\u5f3a\u5927\u548c\u65b9\u4fbf\u7684\u5de5\u5177\uff0c\u5728\u4e00\u4e9b\u7279\u6b8a\u7684\u60c5\u51b5\u4e0b\uff0c\u4ed6\u4eec\u53ef\u80fd\u4ecd\u7136\u6709\u70b9\u53d7\u9650\u5236\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u6240\u6709\u53c2\u6570\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u5047\u5982\u4f60\u60f3\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u8ba1\u7b97\u4e24\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u503c\uff0c\u4f60\u53ef\u80fd\u4f1a\u50cf\u8fd9\u6837\u505a int max ( int x , int y ) { return ( x > y ) ? x : y ; } \u8fd9\u4e2a\u51fd\u6570\u5b8c\u7f8e\u80dc\u4efb\u5de5\u4f5c\u2014\u2014\u5bf9\u4e8e\u6574\u578b\u6765\u8bf4\u3002\u5982\u679c\u4e4b\u540e\u4f60\u60f3\u5b9e\u73b0\u4e00\u4e2a max() \u51fd\u6570\uff0c\u9700\u8981\u5728 doubles \u4e0b\u5de5\u4f5c\uff1f\u6839\u636e\u4f20\u7edf\uff0c\u7b54\u6848\u53ef\u80fd\u662f\u91cd\u8f7dmac\u51fd\u6570\uff0c\u5e76\u4e14\u521b\u9020\u4e00\u4e2a\u65b0\u7684 doubles \u7684\u7248\u672c\uff1a double max ( double x , double y ) { return ( x > y ) ? x : y ; } \u6211\u4eec\u6ce8\u610f\u5230 double \u7248\u672c\u7684 maximum() \u548c int \u7248\u672c\u5b8c\u5168\u76f8\u540c\uff01\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u5b9e\u73b0\u4f1a\u5728\u6240\u6709\u4e0d\u540c\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff1achars\uff0cints\uff0cdoubles\uff0c\u5e76\u4e14\u5982\u679c\u4f60\u5df2\u7ecf\u91cd\u8f7d\u4e86 > \u8fd0\u7b97\u7b26\uff0c\u8fd9\u4e9b\u7c7b\u578b\u4e5f\u53ef\u4ee5\uff01\u7136\u800c\uff0c\u56e0\u4e3a C++ \u8981\u6c42\u4f60\u6307\u5b9a\u51fd\u6570\u7684\u53d8\u91cf\uff0c\u4f60\u5c31\u4f1a\u56f0\u5728\u7ed9\u6bcf\u4e00\u4e2a\u4f60\u8981\u7528\u5230\u7684\u7c7b\u578b\u5199\u4e00\u4e2a\u540c\u6837\u7684\u51fd\u6570\u3002 \u5b9e\u73b0\u4e00\u7cfb\u5217\u4e0d\u540c\u201c\u98ce\u5473\u201d\u7684\u76f8\u540c\u51fd\u6570\u2014\u2014\u4ec5\u4ec5\u53ea\u662f\u53c2\u6570\u7c7b\u578b\u4e0d\u540c\uff0c\u8fd9\u4ef6\u4e8b\u53ef\u80fd\u4f1a\u5728\u7ef4\u62a4\u4e0a\u4f1a\u975e\u5e38\u4ee4\u4eba\u5934\u75bc\uff0c\u4e5f\u5341\u5206\u6d6a\u8d39\u65f6\u95f4\uff0c\u8fd9\u4e5f\u8fdd\u53cd\u4e86\u901a\u5e38\u7f16\u7a0b\u7684\u7eb2\u8981\uff0c\u91cd\u590d\u7684\u4ee3\u7801\u5e94\u8be5\u88ab\u5c3d\u53ef\u80fd\u7684\u51cf\u5c0f\u3002\u5982\u679c\u80fd\u591f\u5199\u4e00\u4e2a\u51fd\u6570\u5c31\u5728\u4efb\u610f\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff0c\u90a3\u4f1a\u4e0d\u4f1a\u5f88\u68d2\uff1f \u6b22\u8fce\u6765\u5230\u6a21\u677f\u7684\u4e16\u754c\u3002","title":"\u4e3a\u4ec0\u4e48\u9700\u8981\u51fd\u6570\u6a21\u677f"},{"location":"19-templates/19.1-function-templates/#_2","text":"\u5982\u679c\u4f60\u5728\u8bcd\u5178\u91cc\u67e5\u201c\u6a21\u677f\u201d\u8fd9\u4e2a\u8bfb\u5355\u8bcd\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u7684\u5b9a\u4e49\u4f1a\u50cf\u8fd9\u6837\uff1a\u201c\u6a21\u677f\u662f\u4e00\u79cd\u6a21\u578b\uff0c\u4f5c\u4e3a\u521b\u5efa\u7c7b\u4f3c\u5bf9\u8c61\u7684\u6a21\u5f0f\u201d\u3002\u4e00\u79cd\u975e\u5e38\u5bb9\u6613\u7406\u89e3\u7684\u6a21\u677f\u7c7b\u578b\u5c31\u662f\u6f0f\u5b57\u677f\uff08stencil\uff09\u3002\u4e00\u4e2a\u6f0f\u5b57\u677f\u662f\u4e00\u4e2a\u5bf9\u8c61\uff08\u4f8b\u5982\uff1a\u4e00\u5f20\u786c\u7eb8\u677f\uff09\u4e0a\u9762\u523b\u4e86\u4e00\u4e2a\u5f62\u72b6\uff08\u4f8b\u5982\u5b57\u6bcdJ\uff09\u3002\u628a\u6f0f\u5b57\u677f\u6446\u653e\u5728\u5176\u4ed6\u5bf9\u8c61\u7684\u4e0a\u65b9\uff0c\u7136\u540e\u55b7\u6d82\u901a\u8fc7\u8fd9\u4e2a\u5f62\u72b6\uff0c\u4f60\u53ef\u4ee5\u5feb\u901f\u7684\u4ea7\u751f\u4e0d\u540c\u989c\u8272\u7684\u9542\u7a7a\u90e8\u5206\u7684\u5f62\u72b6\uff01\u6ce8\u610f\u4f60\u4ec5\u4ec5\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u7ed9\u5b9a\u7684\u6f0f\u5b57\u677f\u4e00\u6b21 \u2014\u2014 \u53ea\u8981\u4f60\u559c\u6b22\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528\u5b83\u5f88\u591a\u6b21\u6765\u521b\u5efa\u4f60\u559c\u6b22\u7684\u989c\u8272\u7684\u3002\u66f4\u597d\u7684\u662f\uff0c\u4f60\u4e0d\u9700\u8981\u5728\u5236\u4f5c\u6f0f\u5b57\u677f\u7684\u65f6\u5019\uff0c\u63d0\u524d\u60f3\u597d\u5f62\u72b6\u7684\u989c\u8272\uff0c\u4f60\u53ef\u4ee5\u518d\u5b9e\u9645\u4f7f\u7528\u7684\u65f6\u5019\u518d\u51b3\u5b9a\u3002 \u5728 C++ \u4e2d\uff0c\u51fd\u6570\u6a21\u677f\u662f\u4f5c\u4e3a\u521b\u5efa\u5176\u4ed6\u7c7b\u578b\u6a21\u677f\u7684\u51fd\u6570\u3002\u5728\u51fd\u6570\u6a21\u677f\u4e4b\u524d\u7684\u4e00\u4e2a\u66f4\u57fa\u7840\u7684\u60f3\u6cd5\u5c31\u662f\u6765\u521b\u5efa\u4e00\u4e2a\u4e0d\u6307\u5b9a\u786e\u5207\u7c7b\u578b\u7684\u51fd\u6570\u3002\u76f8\u53cd\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86\u4f7f\u7528\u5360\u4f4d\u7b26\u7c7b\u578b\u7684\u51fd\u6570\uff0c\u53eb\u505a\u672b\u73ed\u7c7b\u578b\u9910\u6731\u3002\u4e00\u65e6\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u51fd\u6570\u4f7f\u7528\u4e86\u989d\u8fd9\u4e9b\u5360\u4f4d\u7b26\uff0c\u6211\u4eec\u5c31\u80fd\u9ad8\u6548\u7684\u521b\u5efa\u4e00\u4e2a\u201d\u51fd\u6570\u6f0f\u5b57\u677f\u201c\u3002 \u5f53\u4f60\u8c03\u7528\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u4f7f\u7528 \u201d\u6f0f\u5b57\u677f\u201c \u751f\u6210\u4e86\u4e00\u4e2a\u6a21\u677f\u7684\u62f7\u8d1d\uff0c\u7136\u540e\u4f7f\u7528\u5b9e\u9645\u7c7b\u578b\u66ff\u6362\u4e86\u6240\u6709\u7684\u5360\u4f4d\u7b26\u7c7b\u578b\u53c2\u6570\uff01\u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u7f16\u8bd1\u5668\u53ef\u4ee5\u4ece\u4e00\u4e2a\u6a21\u677f\u521b\u5efa\u51fa\u5f88\u591a\u4e0d\u540c\u201d\u98ce\u5473\u201c\u51fd\u6570\uff01\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u8be6\u7ec6\u63a2\u8ba8\u8fd9\u4e2a\u5185\u5bb9\u3002","title":"\u4ec0\u4e48\u662f\u51fd\u6570\u6a21\u677f"},{"location":"19-templates/19.1-function-templates/#c","text":"\u8fd9\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u5728\u60f3\u5982\u4f55\u5728 C++ \u4e2d\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u3002\u5176\u5b9e\uff0c\u5e76\u4e0d\u590d\u6742\u3002 \u8ba9\u6211\u4eec\u518d\u770b\u4e00\u773c int \u7248\u672c\u7684 max() \u7684\u4f8b\u5b50\uff1a int max ( int x , int y ) { return ( x > y ) ? x : y ; } \u6211\u4eec\u6ce8\u610f\u5230\u6709\u4e09\u4e2a\u4f4d\u7f6e\u9700\u8981\u6307\u5b9a\u5177\u4f53\u7684\u7c7b\u578b\uff1a\u53c2\u6570 x, y \u548c\u8fd4\u56de\u503c\u90fd\u5fc5\u987b\u6307\u5b9a\u4e3a\u6574\u578b\u3002\u60f3\u8981\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528\u5360\u4f4d\u7b26\u7c7b\u578b\u66ff\u6362\u8fd9\u4e9b\u7279\u5b9a\u7684\u7c7b\u578b\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u66ff\u6362 int \u7c7b\u578b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e00\u4e2a\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u3002 \u4f60\u53ef\u4ee5\u5c06\u5360\u4f4d\u7b26\u7c7b\u578b\u547d\u540d\u4e3a\u4efb\u4f55\u4f60\u60f3\u8981\u7684\uff0c\u53ea\u8981\u4ed6\u4e0d\u662f\u4e00\u4e2a C++ \u9884\u7559\u7684\u5b57\u6bb5\u3002\u7136\u800c\uff0c\u5728 C++ \u4e2d\uff0c\u901a\u5e38\u4e60\u60ef\u4f7f\u7528\u5b57\u6bcd T \uff08Type \u7684\u7f29\u5199\uff09\u6765\u547d\u540d\u6a21\u677f\u7c7b\u3002 \u4e0b\u9762\u662f\u5e26\u6709\u5360\u4f4d\u7b26\u7c7b\u578b\u7684\u65b0\u51fd\u6570\uff1a T max ( T x , T y ) { return ( x > y ) ? x : y ; } \u8fd9\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u5f00\u59cb \u2014\u2014 \u7136\u800c\uff0c\u5b83\u5e76\u4e0d\u80fd\u901a\u8fc7\u7f16\u8bd1\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u5e76\u4e0d\u77e5\u9053 \u201dT\u201c \u662f\u4ec0\u4e48\uff01 \u60f3\u8981\u4f7f\u5f97\u8fd9\u4e2a\u8d77\u4f5c\u7528\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9\u7f16\u8bd1\u5668\u4e24\u4ef6\u4e8b\uff1a\u7b2c\u4e00\uff0c\u8fd9\u662f\u4e00\u4e2a\u5e26\u6a21\u677f\u7684\u5b9a\u4e49\uff1b\u7b2c\u4e8c\uff0cT \u662f\u4e00\u4e2a\u5360\u4f4d\u7b26\u7c7b\u578b\u3002\u6211\u4eec\u53ef\u4ee5\u5728\u4e00\u884c\u4e2d\u505a\u8fd9\u4e24\u4ef6\u4e8b\uff0c\u4ec5\u4ec5\u662f\u9700\u8981\u4f7f\u7528\u4e00\u4e2a\u53eb\u505a\u6a21\u677f\u53c2\u6570\u58f0\u660e\u7684\u8bed\u6cd5\uff1a template < typename T > // this is the template parameter declaration T max ( T x , T y ) { return ( x > y ) ? x : y ; } \u4e0d\u7ba1\u4f60\u4fe1\u4e0d\u4fe1\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u9700\u8981\u505a\u7684\uff0c\u8fd9\u5c06\u4f1a\u901a\u8fc7\u7f16\u8bd1\uff01 \u73b0\u5728\u8ba9\u6211\u4eec\u7a0d\u5fae\u4ed4\u7ec6\u770b\u4e00\u4e0b\u6a21\u677f\u53c2\u6570\u7684\u58f0\u660e\u3002\u6211\u4eec\u5f00\u59cb\u4e8e\u5173\u952e\u8bcd template \u2014\u2014 \u8fd9\u4f1a\u544a\u8bc9\u7f16\u8bd1\u5668\u63a5\u4e0b\u6765\u662f\u4e00\u7cfb\u5217\u7684\u6a21\u677f\u53c2\u6570\u3002\u6211\u4eec\u653e\u7f6e\u6240\u6709\u7684\u53c2\u6570\u5728\u4e00\u4e2a\u5c16\u62ec\u53f7\uff08<>\uff09\u4e2d\u3002\u60f3\u8981\u521b\u5efa\u4e00\u4e2a\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff0c\u8981\u540c\u65f6\u4f7f\u7528\u7c7b\u540d\u6216\u8005 class \u5173\u952e\u8bcd\u3002\u8fd9\u4e24\u79cd\u5173\u952e\u8bcd\u5728\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\u6ca1\u6709\u4ec0\u4e48\u4e0d\u540c\uff0c\u4f60\u60f3\u7528\u5565\u53d6\u51b3\u4e8e\u4f60\u3002\u6ce8\u610f\u5982\u679c\u4f60\u60f3\u8981\u4f7f\u7528 class \u5173\u952e\u8bcd\uff0c\u4f60\u4f20\u5165\u7684 type \u5b9e\u9645\u4e0a\u6ca1\u5fc5\u8981\u662f\u4e00\u4e2a\u7c7b\uff08\u4ed6\u53ef\u80fd\u662f\u4e00\u4e2a\u57fa\u7840\u53d8\u91cf\uff0c\u6307\u9488\uff0c\u6216\u8005\u4efb\u4f55\u5176\u4ed6\u7684\u5339\u914d\uff09\u3002\u7136\u540e\u4f60\u547d\u540d\u4f60\u7684\u7c7b\u578b\uff08\u901a\u5e38\u662f \u201cT\u201d\uff09\u3002 \uff08\u539f\u6587\uff0c\u7a0d\u590d\u6742\uff09Now, let\u2019s take a slightly closer look at the template parameter declaration. We start with the keyword template -- this tells the compiler that what follows is going to be a list of template parameters. We place all of our parameters inside angled brackets (<>). To create a template type parameter, use either the keyword typename or class. There is no difference between the two keywords in this context, so which you use is up to you. Note that if you use the class keyword, the type passed in does not actually have to be a class (it can be a fundamental variable, pointer, or anything else that matches). Then you name your type (usually \u201cT\u201d). \u5982\u679c\u6a21\u677f\u51fd\u6570\u7528\u4e86\u591a\u4e2a\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff0c\u53ef\u4ee5\u4f7f\u7528\u9017\u53f7\u5206\u9694\u5f00\uff1a template < typename T1 , typename T2 > // template function here \u4f7f\u7528\u8d85\u8fc7\u4e00\u4e2a\u7c7b\u578b\u7684\u90a3\u4e9b\u7c7b\uff0c\u5e38\u89c1\u7684\u5c06\u4ed6\u4eec\u547d\u540d\u4e3a T1 \u548c T2 \uff0c\u6216\u8005\u5176\u4ed6\u5355\u72ec\u7684\u9996\u5b57\u6bcd\u5927\u5199\u7684\u540d\u5b57\uff0c\u4f8b\u5982 \u201cS\u201d\u3002 \u4e00\u4e2a\u6700\u540e\u9700\u8981\u6ce8\u610f\u7684\u70b9\uff1a\u56e0\u4e3a\u4f20\u5165\u7684\u51fd\u6570\u53c2\u6570\u53ef\u80fd\u662f\u4e00\u4e2a\u7c7b\u578b\uff0c\u5e76\u4e14\u901a\u8fc7value\u4f20\u503c\u901a\u5e38\u4e0d\u662f\u4e00\u4e2a\u597d\u4e3b\u610f\uff0c\u6700\u597d\u662f\u80fd\u8ba9\u6a21\u677f\u7684\u53c2\u6570\u548c\u8fd4\u56de\u503c\u7c7b\u578b\u4e3a\u5e38\u5f15\u7528\uff1a template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; }","title":"\u5728 C++ \u4e2d\u521b\u5efa\u51fd\u6570\u6a21\u677f"},{"location":"19-templates/19.1-function-templates/#_3","text":"\u4f7f\u7528\u51fd\u6570\u6a21\u677f\u662f\u76f8\u5f53\u76f4\u63a5\u7684 \u2014\u2014 \u4f60\u53ef\u4ee5\u5c31\u50cf\u7528\u5176\u4ed6\u51fd\u6570\u90a3\u6837\u4f7f\u7528\u5b83\u3002\u8fd9\u6709\u4e00\u4e2a\u6574\u4f53\u4f7f\u7528\u7684\u4f8b\u5b50\uff1a # include <iostream> template < typename T > const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } int main () { int i = max ( 3 , 7 ); // returns 7 std :: cout << i << '\\n' ; double d = max ( 6.34 , 18.523 ); // returns 18.523 std :: cout << d << '\\n' ; char ch = max ( 'a' , '6' ); // returns 'a' std :: cout << ch << '\\n' ; return 0 ; } \u6253\u5370\uff1a 7 18.523 a \u6ce8\u610f\u6240\u6709\u7684\u8fd9\u4e09\u4e2a max() \u7684\u8c03\u7528\u6709\u7740\u4e0d\u540c\u7684\u53c2\u6570\uff01\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u5206\u522b\u7528\u4e0d\u540c\u7684\u53c2\u6570\u8c03\u7528\u4e86\u4e09\u6b21\u8be5\u51fd\u6570\u3002\u7f16\u8bd1\u5668\u5c06\u4f1a\u4f7f\u7528\u6a21\u677f\u6765\u521b\u5efa\u4e09\u4e2a\u4e0d\u540c\u7248\u672c\u7684\u51fd\u6570\uff0c\u4e00\u4e2a\u662f\u5e26\u6709 int \u53c2\u6570\u7684\uff08\u547d\u540d\u4e3a max<int> \uff09\uff0c\u4e00\u4e2a\u662f double \u53c2\u6570\u7684\uff08\u547d\u540d\u4e3a max<double> \uff09\uff0c\u5e76\u4e14\u8fd8\u6709\u4e00\u4e2a\u662f char \u53c2\u6570\u7684\uff08\u547d\u540d\u4e3a max<char> \uff09\u3002 \u6ce8\u610f\uff0c\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5728\u51fd\u6570\u540d\u79f0\u4e2d\uff0c\u4f60\u65e0\u9700\u663e\u5f0f\u7684\u6307\u5b9a\u7279\u5b9a\u7684\u6a21\u677f\u7c7b\u578b\uff08\u4f8b\u5982 max<int> \uff09\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u53ef\u4ee5\u4ece\u53c2\u6570\u7c7b\u578b\u6765\u63a8\u65ad\u3002","title":"\u4f7f\u7528\u51fd\u6570\u6a21\u677f"},{"location":"19-templates/19.1-function-templates/#_4","text":"\u5982\u4f60\u6240\u89c1\uff0c\u6a21\u677f\u51fd\u6570\u53ef\u4ee5\u8282\u7701\u5927\u91cf\u7684\u65f6\u95f4\uff0c\u56e0\u4e3a\u4f60\u53ea\u9700\u8981\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u5e76\u4e14\u5b83\u80fd\u5f88\u597d\u7684\u5de5\u4f5c\u5728\u4e0d\u901a\u96f7\u7fd4\u4e0b\u3002\u4e00\u65e6\u4f60\u719f\u6089\u5199\u51fd\u6570\u6a21\u677f\u4e86\uff0c\u60a8\u4f1a\u53d1\u73b0\u5b83\u4eec\u5b9e\u9645\u4e0a\u4e0d\u9700\u8981\u6bd4\u5b9e\u9645\u7c7b\u578b\u7684\u51fd\u6570\u7f16\u5199\u66f4\u957f\u7684\u65f6\u95f4\u3002\u6a21\u677f\u51fd\u6570\u51cf\u5c11\u4e86\u4ee3\u7801\u7684\u7ef4\u62a4\u96be\u5ea6\uff0c\u56e0\u4e3a\u51cf\u5c11\u4e86\u5927\u91cf\u76f8\u540c\u7684\u4ee3\u7801\u3002\u6700\u7ec8\uff0c\u6a21\u677f\u51fd\u6570\u53ef\u80fd\u66f4\u52a0\u5b89\u5168\uff0c\u56e0\u4e3a\u5f53\u4f60\u9700\u8981\u8be5\u51fd\u6570\u5728\u53e6\u4e00\u4e2a\u7c7b\u578b\u4e0b\u5de5\u4f5c\u7684\u65f6\u5019\uff0c\u4e0d\u7528\u62f7\u8d1d\u51fd\u6570\u7136\u540e\u624b\u52a8\u6539\u53d8\u53c2\u6570\u7c7b\u578b\u3002 \u6a21\u677f\u51fd\u6570\u4e5f\u7684\u786e\u6709\u4e9b\u7f3a\u70b9\uff0c\u5982\u679c\u6211\u4eec\u4e0d\u63d0\u5c31\u592a\u4e0d\u79f0\u804c\u4e86\u3002\u7b2c\u4e00\uff0c\u4e00\u4e9b\u8001\u7684\u7f16\u8bd1\u5668\u4e0d\u80fd\u5f88\u597d\u7684\u652f\u6301\u6a21\u677f\u3002\u7136\u800c\u8fd9\u4e2a\u7f3a\u70b9\u5df2\u7ecf\u4e0d\u518d\u50cf\u8fc7\u53bb\u4e00\u6837\u662f\u4e2a\u5927\u95ee\u9898\u3002\u7b2c\u4e8c\uff0c\u6a21\u677f\u51fd\u6570\u76f8\u6bd4\u666e\u901a\u51fd\u6570\u901a\u5e38\u4f1a\u9020\u6210\u75af\u72c2\u7684\u9519\u8bef\u4fe1\u606f\uff0c\u975e\u5e38\u96be\u4ee5\u89e3\u8bfb\u3002\uff08\u6211\u4eec\u5c06\u4f1a\u5728\u4e0b\u8282\u8bfe\u4e2d\u770b\u5230\u4e00\u4e2a\u4f8b\u5b50\uff09\u3002\u7b2c\u4e09\uff0c\u6a21\u677f\u51fd\u6570\u53ef\u4ee5\u51cf\u5c11\u4f60\u7684\u7f16\u8bd1\u65f6\u95f4\u548c\u4ee3\u7801\u5c3a\u5bf8\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5355\u6a21\u677f\u53ef\u80fd\u88ab\u201c\u8bc6\u522b\u201d\u5e76\u4e14\u5728\u5f88\u591a\u6587\u4ef6\u4e2d\u88ab\u91cd\u65b0\u7f16\u8bd1\uff08\u6709\u5f88\u591a\u65b9\u5f0f\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff09\u3002 \u7136\u800c\uff0c\u8fd9\u4e9b\u7f3a\u70b9\u6bd4\u8d77\u9ad8\u6548\u800c\u7075\u6d3b\u7684\u6a21\u677f\u5e26\u6765\u7684\u4f18\u70b9\u90fd\u662f\u4e0d\u503c\u4e00\u63d0\u3002 \u6ce8\u610f\uff1a\u6807\u51c6\u5e93\u65e9\u5c31\u643a\u5e26\u4e86\u4e00\u4e2a\u590d\u6742\u7684 max() \u51fd\u6570\uff08\u5728 algorithm \u5934\u4e2d\uff09\uff0c\u56e0\u6b64\u4f60\u4e0d\u9700\u8981\u81ea\u5df1\u5199\u4e00\u4e2a\uff08\u9664\u975e\u4f60\u60f3\u5199\uff09\u3002\u5982\u679c\u4f60\u5199\u4e86\u4f60\u81ea\u5df1\u7684\uff0c\u6ce8\u610f\u6f5c\u5728\u7684\u547d\u540d\u51b2\u7a81\u5982\u679c\u4f60\u4f7f\u7528\u4e86\u8bed\u53e5 \"using namespace std;\", \u56e0\u4e3a\u7f16\u8bd1\u5668\u5c06\u4e0d\u80fd\u544a\u8bc9\u51b3\u5b9a\u4f60\u60f3\u8c03\u7528\u4f60\u7684\u7248\u672c\u7684 max \u8fd8\u662f std::max() \u3002 \u5728\u5269\u4e0b\u7684\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u7ee7\u7eed\u63a2\u7d22\u6a21\u677f\u7684\u8bdd\u9898\u3002","title":"\u603b\u7ed3"},{"location":"19-templates/19.2-function-template-instances/","text":"19.2 \u7c7b\u6a21\u677f\u5b9e\u4f8b \u00b6 By Alex on April 29 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 By dashjay 2020-12-26 | last modified by 2020-12-26 \u6a21\u677f\u51fd\u6570\u5728 C++ \u4e2d\u7684\u5b9e\u73b0\u662f\u4e00\u4ef6\u5f88\u6709\u503c\u5f97\u7684\u4e8b\u60c5\uff0c\u56e0\u4e3a\u672a\u6765\u7684\u8bfe\u7a0b\u5c06\u4f1a\u5728\u8fd9\u4e9b\u57fa\u4e8e\u8fd9\u4e9b\u6982\u5ff5\u3002\u4e8b\u5b9e\u8bc1\u660e C++ \u4e0d\u4f1a\u76f4\u63a5\u76f4\u63a5\u7f16\u8bd1\u51fd\u6570\u3002\u76f8\u53cd\uff0c\u5728\u7f16\u8bd1\u7684\u65f6\uff0c\u5f53\u7f16\u8bd1\u5668\u9047\u5230\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u590d\u5236\u6a21\u677f\u51fd\u6570\u5e76\u4e14\u66ff\u6362\u6a21\u677f\u7c7b\u53c2\u6570\u4e3a\u5b9e\u9645\u7c7b\u578b\u3002\u5e26\u6709\u5b9e\u9645\u7c7b\u578b\u7684\u51fd\u6570\u88ab\u79f0\u4e3a \u51fd\u6570\u6a21\u677f\u5b9e\u4f8b \u3002 \u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u9996\u5148\uff0c\u6211\u4eec\u5199\u4e86\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\uff1a template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } \u5f53\u7f16\u8bd1\u4f60\u7684\u7a0b\u5e8f\u7684\u65f6\u5019\uff0c\u5982\u679c\u7f16\u8bd1\u5668\u9047\u5230\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u8c03\u7528\uff1a int i { max ( 3 , 7 ) }; // calls max(int, int) \u7f16\u8bd1\u5668\u8bf4\uff0c\u201c\u597d\u5427\uff0c\u6211\u4eec\u60f3\u8981\u8c03\u7528 max(int, int) \u201d\u3002\u7f16\u8bd1\u5668\u62f7\u8d1d\u4e86\u51fd\u6570\u6a21\u677f\uff0c\u7136\u540e\u521b\u5efa\u6a21\u677f\u5b9e\u4f8b max(int, int) \uff1a const int & max ( const int & x , const int & y ) { return ( x > y ) ? x : y ; } \u8fd9\u73b0\u5728\u662f\u4e00\u4e2a \u201c\u6b63\u5e38\u7684\u51fd\u6570\u201d \u53ef\u4ee5\u88ab\u7f16\u8bd1\u6210\u673a\u5668\u8bed\u8a00\u7684\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5728\u7a0d\u540e\u7684\u4ee3\u7801\u4e2d\uff0c\u4f60\u518d\u6b21\u8c03\u7528\u4e86 max() \u4f7f\u7528\u4e0d\u540c\u7684\u7c7b\u578b\uff1a double d { max ( 6.34 , 18.523 ) }; // calls max(double, double) C++ \u4e3a max(double, double) \u81ea\u52a8\u7684\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u677f\u5b9e\u4f8b\uff1a const double & max ( const double & x , const double & y ) { return ( x > y ) ? x : y ; } \u5e76\u4e14\u7136\u540e\u7f16\u8bd1\u5b83\u3002 \u7f16\u8bd1\u5668\u8db3\u591f\u806a\u660e\uff0c\u77e5\u9053\u5b83\u53ea\u9700\u8981\u4e3a\u6bcf\u7ec4\u552f\u4e00\u7c7b\u578b\u53c2\u6570\uff08\u6bcf\u4e2a\u6587\u4ef6\uff09\u521b\u5efa\u4e00\u4e2a\u6a21\u677f\u5b9e\u4f8b\u3002\u4e5f\u503c\u5f97\u6ce8\u610f\u5982\u679c\u4f60\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u4f46\u662f\u6ca1\u6709\u8c03\u7528\u5b83\uff0c\u6ca1\u6709\u6a21\u677f\u5b9e\u4f8b\u4f1a\u88ab\u521b\u5efa\u3002 Operators, function calls, and function templates \u64cd\u4f5c\u7b26\uff0c\u51fd\u6570\u8c03\u7528\u548c\u51fd\u6570\u6a21\u677f \u00b6 \u6709\u4e00\u4e2a\u524d\u63d0\uff0c\u6a21\u677f\u51fd\u6570\u4f1a\u65e2\u80fd\u548c\u5185\u7f6e\u7684\u7c7b\u578b\u5de5\u4f5c\uff08\u4f8b\u5982\uff1achar\uff0cint\uff0cdouble \u7b49\u7b49\uff09\u548c\u7c7b\u3002\u5f53\u7f16\u8bd1\u5668\u7f16\u8bd1\u6a21\u677f\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u5b83\u7f16\u8bd1\u5c31\u50cf\u666e\u901a\u51fd\u6570\u90a3\u6837\u3002\u5728\u666e\u901a\u51fd\u6570\u4e2d\uff0c\u5fc5\u987b\u5b9a\u4e49\u4e0e\u7c7b\u578b\u4e00\u8d77\u4f7f\u7528\u7684\u4efb\u4f55\u8fd0\u7b97\u7b26\u6216\u51fd\u6570\u8c03\u7528\uff0c\u5426\u5219\u4f60\u4f1a\u5f97\u5230\u7f16\u8bd1\u9519\u8bef\u3002\u7c7b\u4f3c\u5730\uff0c\u6a21\u677f\u51fd\u6570\u4e2d\u7684\u4efb\u4f55\u8fd0\u7b97\u7b26\u6216\u51fd\u6570\u8c03\u7528\u90fd\u5fc5\u987b\u4e3a\u5b9e\u4f8b\u5316\u51fd\u6570\u6a21\u677f\u7684\u4efb\u4f55\u7c7b\u578b\u5b9a\u4e49\u3002\u8ba9\u6211\u4eec\u66f4\u8be6\u7ec6\u5730\u770b\u770b\u8fd9\u4e2a\u4f8b\u5b50\u3002 \u9996\u5148\uff0c\u6211\u4eec\u80fd\u521b\u5efa\u4e00\u4e2a\u7b80\u5355\u7684\u7c7b\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 Cents \u7c7b\u6765\u8c03\u7528\u6211\u4eec\u7684\u6a21\u677f\u51fd\u6570 max() \uff1a template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; int main () { Cents nickle { 5 }; Cents dime { 10 }; Cents bigger { max ( nickle , dime ) }; return 0 ; } C++ \u4f1a\u521b\u5efa\u4e00\u4e2a max() \u50cf\u8fd9\u6837\u7684\u6a21\u677f\u5b9e\u4f8b\uff1a const Cents & max ( const Cents & x , const Cents & y ) { return ( x > y ) ? x : y ; } \u7136\u540e\u7d27\u63a5\u7740\u4ed6\u4f1a\u5c1d\u8bd5\u7f16\u8bd1\u8fd9\u4e2a\u51fd\u6570\uff0c\u770b\u5230\u95ee\u9898\u4e86\u4e48\uff1fC++ \u4e0d\u80fd\u8bc4\u4f30 x > y \uff0c\u56e0\u4e3a x \u548c y \u90fd\u662f Cents \u7c7b\u5bf9\u8c61\uff0c\u800c\u4e14\u4e0d\u80fd\u77e5\u9053\u5982\u4f55\u7f16\u8bd1\u4ed6\u4eec\u3002\u56e0\u6b64\uff0c\u8fd9\u4f1a\u4ea7\u751f\u4e00\u4e2a\u5f88\u96be\u770b\u7684\u7f16\u8bd1\u9519\u8bef\uff0c\u50cf\u8fd9\u6837\uff1a 1 > c : \\ consoleapplication1 \\ main . cpp ( 4 ) : error C2676 : binary '>' : ' const Cents ' does not define this operator or a conversion to a type acceptable to the predefined operator 1 > c : \\ consoleapplication1 \\ main . cpp ( 23 ) : note : see reference to function template instantiation ' const T & max ( const T & , const T & ) ' being compiled 1 > with 1 > [ 1 > T = Cents 1 > ] \u6700\u4e0a\u65b9\u7684\u9519\u8bef\u4fe1\u606f\u6307\u51fa\u6ca1\u6709Cents\u8fd9\u4e2a\u7c7b\u7684 > \u64cd\u4f5c\u7b26\u91cd\u8f7d\u3002\u5e95\u90e8\u7684\u9519\u8bef\u6307\u51fa\u6a21\u677f\u51fd\u6570\u8c03\u7528\u62a5\u9519\u4e86\uff0c\u4ee5\u53ca\u6a21\u677f\u5316\u53c2\u6570\u7684\u7c7b\u578b\u3002 \u60f3\u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u7b80\u5355\u7684\u7ed9\u6bcf\u4e2a\u4f60\u60f3\u8981\u4f7f\u7528 max() \u7684\u4efb\u4f55\u7c7b\u91cd\u8f7d > \u64cd\u4f5c\u7b26\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; \u73b0\u5728 C++ \u80fd\u77e5\u9053\u5982\u4f55\u6bd4\u8f83 x > y \u5f53 x \u548c y \u662f Cents\uff01\u7ed3\u679c\uff0c\u6211\u4eec\u7684 max() \u73b0\u5728\u53ef\u4ee5\u548c\u4e24\u4e2a Cents \u7c7b\u7684\u4e24\u4e2a\u5bf9\u8c61\u3002 \u53e6\u4e00\u4e2a\u4f8b\u5b50 \u00b6 \u8ba9\u6211\u4eec\u5728\u770b\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u7684\u4f8b\u5b50\u3002\u63a5\u4e0b\u6765\u7684\u51fd\u6570\u6a21\u677f\u5c06\u4f1a\u8ba1\u7b97\u6570\u7ec4\u4e2d\u5bf9\u8c61\u7684\u5e73\u5747\u503c\uff1a template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } \u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b9e\u9645\u4f7f\u7528\uff1a #include <iostream> template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { int array1 []{ 5 , 3 , 2 , 1 , 4 }; std :: cout << average ( array1 , 5 ) << '\\n' ; double array2 []{ 3.12 , 3.45 , 9.23 , 6.34 }; std :: cout << average ( array2 , 4 ) << '\\n' ; return 0 ; } \u7ed3\u679c\u4ea7\u751f\u4e86\u503c\uff1a 3 5.535 \u5982\u4f60\u6240\u89c1\uff0c\u4ed6\u80fd\u5f88\u597d\u5728\u5185\u7f6e\u7684\u7c7b\u578b\u4e0a\u8fd0\u884c\uff01 \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u56e0\u4e3a\u8fd4\u56de\u7c7b\u578b\u4e0e\u6570\u7ec4\u5143\u7d20\u662f\u76f8\u540c\u7684\u6a21\u677f\u5316\u7c7b\u578b\uff0c\u505a\u6574\u578b\u5e73\u5747\u503c\u4f1a\u4ea7\u751f\u4e00\u4e2a\u6574\u578b\u7ed3\u679c\uff08\u4e22\u5f03\u4efb\u4f55\uff09\u3002\u8fd9\u4e0e\u6574\u6570\u9664\u6cd5\u4ea7\u751f\u6574\u6570\u7ed3\u679c\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002\u6211\u4eec\u5c06\u4e8b\u7269\u5b9a\u4e49\u4e3a\u8fd9\u6837\u662f\u53ef\u4ee5\u5de5\u4f5c\u7684\uff0c\u4f46\u662f\u8fd9\u53ef\u80fd\u662f\u4e0d\u53ef\u9884\u671f\u7684\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u5199\u4e00\u4e9b\u6ce8\u91ca\u7ed9\u7c7b\u7684\u7528\u6237\u4e5f\u633a\u597d\u3002 \u73b0\u5728\u5f53\u6211\u4eec\u4f7f\u7528\u5728 Cents \u7c7b\u4e0a\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1a #include <iostream> class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { Cents array3 []{ Cents ( 5 ), Cents ( 10 ), Cents ( 15 ), Cents ( 14 ) }; std :: cout << average ( array3 , 4 ) << '\\n' ; return 0 ; } \u7f16\u8bd1\u5668\u9677\u5165\u75af\u72c2\u62a5\u4e86\u4e00\u5806\u9519\uff01 example . cpp ( 33 ) : error C2679 : binary ' << ' : no operator found which takes a right - hand operand of type 'T' ( or there is no acceptable conversion ) with [ T = Cents ] C : / data / msvc / 14.22.27905 / include \\ ostream ( 437 ) : note : could be ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_streambuf > * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 412 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( const void * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 394 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 376 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 358 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( float ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 340 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 322 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 304 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 286 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 268 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 248 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 230 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 202 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 184 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( bool ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 179 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: ios_base & ( __cdecl * )( std :: ios_base & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 174 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ios > & ( __cdecl * )( std :: basic_ios > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 169 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ostream > & ( __cdecl * )( std :: basic_ostream > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 613 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 658 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 694 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 739 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 858 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const signed char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 864 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , signed char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 870 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const unsigned char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 876 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , unsigned char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 931 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const std :: error_code & ) ' ( 33 ) : note : while trying to match the argument list ' ( std :: ostream , T ) ' with [ T = Cents ] Compiler returned : 2 \u8bb0\u5f97\u6211\u8bf4\u8fc7\u7684\u75af\u72c2\u62a5\u9519\u4fe1\u606f\u4e48\uff1fWe hit the motherlode\uff01\u5c3d\u7ba1\u770b\u8d77\u6765\u5f88\u5413\u4eba\uff0c\u8fd9\u4e9b\u5b9e\u9645\u4e0a\u76f8\u5f53\u76f4\u63a5\u3002\u7b2c\u4e00\u884c\u544a\u8bc9\u4f60\u4e0d\u80fd\u5728 Cents \u7c7b\u4e2d\u627e\u5230\u4e00\u4e2a\u91cd\u8f7d\u7684 << \u64cd\u4f5c\u7b26\u3002\u4e2d\u95f4\u662f\u6240\u6709\u60f3\u8981\u7528\u6765\u5339\u914d\u7684\u51fd\u6570\uff0c\u4f46\u662f\u90fd\u5931\u8d25\u4e86\u3002\u6700\u540e\u4e00\u4e2a\u9519\u8bef\u6307\u51fa\u4e86\u4ea7\u751f\u8fd9\u4e00\u5806\u9519\u7684\u7684\u51fd\u6570\u8c03\u7528\u3002 \u8bb0\u4f4f average() \u8fd4\u56de\u4e86\u4e00\u4e2a Cents \u5bf9\u8c61\uff0c\u5e76\u4e14\u6211\u4eec\u6b63\u5728\u5c1d\u8bd5\u53bb\u8f93\u51fa\u90a3\u4e2a\u5bf9\u8c61\u5230 std::cout \u4f7f\u7528 << \u64cd\u4f5c\u7b26\u3002\u7136\u800c\uff0c\u6211\u4eec\u5df2\u7ecf\u4e3a\u6211\u4eec\u7684 Cents \u7c7b\u578b\u5b9a\u4e49\u4e86 << \u4ece\u64cd\u4f5c\u7b26\u3002\u8ba9\u6211\u4eec\u90a3\u6837\u505a\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } }; \u5982\u679c\u6211\u4eec\u518d\u6b21\u7f16\u8bd1\uff0c\u6211\u4eec\u5c31\u4f1a\u5f97\u5230\u53e6\u4e00\u4e2a\u9519\u8bef\uff1a c : test . cpp ( 14 ) : error C2676 : binary ' += ' : ' Cents ' does not define this operator or a conversion to a type acceptable to the predefined operator \u8fd9\u4e2a\u9519\u8bef\u5b9e\u9645\u4e0a\u662f\u5f53\u6211\u4eec\u8c03\u7528 average(Cents* int) \u7684\u65f6\u5019\u521b\u5efa\u7684\u51fd\u6570\u6a21\u677f\u5b9e\u4f8b\u9020\u6210\u7684\u3002\u8bb0\u4f4f\u5f53\u6211\u4eec\u8c03\u7528\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u4f7f\u7528\u6f0f\u5b57\u677f\u53ef\u51fa\u4e00\u4e2a\u51fd\u6570\u7684\u62f7\u8d1d\uff0c\u5e76\u4e14\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff08\u5360\u4f4d\u7b26\u7c7b\u578b\uff09\u5df2\u7ecf\u88ab\u66ff\u6362\u4e3a\u5b9e\u9645\u4e0a\u51fd\u6570\u8c03\u7528\u65f6\u7684\u7c7b\u578b\u3002\u8fd9\u662f\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u5b9e\u4f8b\u5316\u65f6\uff0c\u5f53 T \u66ff\u6362\u4e3a\u4e00\u4e2a Cents \u5bf9\u8c61\u65f6\uff0c\u518d\u8c03\u7528 average() \u7684\u4f8b\u5b50\uff1a template < class T > Cents average ( Cents * array , int length ) { Cents sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } \u6211\u4eec\u5f97\u5230\u9519\u8bef\u4fe1\u606f\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u4e0b\u9762\u8fd9\u884c\uff1a sum += array [ count ]; \u5728\u8fd9\u4e2a\u4f8b\u5b50\u5f53\u4e2d\uff0csum \u662f\u4e00\u4e2a Cents \u5bf9\u8c61\uff0c\u4f46\u662f\u6211\u4eec\u4e3a Cents \u5bf9\u8c61\u53bb\u6ca1\u6709\u5b9a\u4e49 += \u64cd\u4f5c\u7b26\uff01\u4e3a\u4e86\u8ba9 average() \u80fd\u5728 Cents \u7c7b\u4e0b\u8c03\u7528\uff0c\u6211\u4eec\u9700\u8981\u53bb\u5b9a\u4e49\u8fd9\u4e2a\u51fd\u6570\u3002\u5f80\u540e\u770b\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230 average() \u4e5f\u4f7f\u7528\u4e86 /= \u64cd\u4f5c\u7b26\uff0c\u56e0\u6b64\u6211\u4eec\u4e5f\u8981\u7ee7\u7eed\u5b9a\u4e49\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } Cents & operator += ( const Cents & cents ) { m_cents += cents . m_cents ; return * this ; } Cents & operator /= ( int value ) { m_cents /= value ; return * this ; } }; \u6700\u7ec8\u6211\u4eec\u7684\u4ee3\u7801\u4f1a\u7f16\u8bd1\u5e76\u4e14\u8fd0\u884c\uff01\u8fd9\u662f\u7ed3\u679c\uff1a 11 cents \u5982\u679c\u8fd9\u770b\u8d77\u6765\u5f88\u8d39\u4e8b\uff0c\u90a3\u53ea\u662f\u56e0\u4e3a\u6211\u4eec\u7684 Cents \u7c7b\u662f\u4e00\u4e2a\u5982\u6b64\u57fa\u7840\u7684\u5f00\u59cb\u3002\u8fd9\u91cc\u7684\u5173\u952e\u70b9\u662f\u5b9e\u9645\u4e0a\u6211\u4eec\u6839\u672c\u6ca1\u6709\u5fc5\u8981\u53bb\u4fee\u6539 average() \u6765\u4fdd\u8bc1\u5b83\u5728 Cents \u7c7b\u4e0b\u5de5\u4f5c\uff08\u6216\u8005\u4e3a\u4efb\u4f55\u5176\u4ed6\u7c7b\u578b\uff09\u3002\u6211\u4eec\u7b80\u5355\u5730\u4e3a Cents \u7c7b\u5b9a\u4e49\u5b9e\u73b0 average() \u8981\u7528\u5230\u7684\u64cd\u4f5c\u7b26\uff0c\u7136\u540e\u7f16\u8bd1\u5668\u505a\u4e86\u5269\u4e0b\u90e8\u5206\u7684\u5de5\u4f5c\uff01","title":"19.2 \u7c7b\u6a21\u677f\u5b9e\u4f8b"},{"location":"19-templates/19.2-function-template-instances/#192","text":"By Alex on April 29 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 By dashjay 2020-12-26 | last modified by 2020-12-26 \u6a21\u677f\u51fd\u6570\u5728 C++ \u4e2d\u7684\u5b9e\u73b0\u662f\u4e00\u4ef6\u5f88\u6709\u503c\u5f97\u7684\u4e8b\u60c5\uff0c\u56e0\u4e3a\u672a\u6765\u7684\u8bfe\u7a0b\u5c06\u4f1a\u5728\u8fd9\u4e9b\u57fa\u4e8e\u8fd9\u4e9b\u6982\u5ff5\u3002\u4e8b\u5b9e\u8bc1\u660e C++ \u4e0d\u4f1a\u76f4\u63a5\u76f4\u63a5\u7f16\u8bd1\u51fd\u6570\u3002\u76f8\u53cd\uff0c\u5728\u7f16\u8bd1\u7684\u65f6\uff0c\u5f53\u7f16\u8bd1\u5668\u9047\u5230\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u590d\u5236\u6a21\u677f\u51fd\u6570\u5e76\u4e14\u66ff\u6362\u6a21\u677f\u7c7b\u53c2\u6570\u4e3a\u5b9e\u9645\u7c7b\u578b\u3002\u5e26\u6709\u5b9e\u9645\u7c7b\u578b\u7684\u51fd\u6570\u88ab\u79f0\u4e3a \u51fd\u6570\u6a21\u677f\u5b9e\u4f8b \u3002 \u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u9996\u5148\uff0c\u6211\u4eec\u5199\u4e86\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\uff1a template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } \u5f53\u7f16\u8bd1\u4f60\u7684\u7a0b\u5e8f\u7684\u65f6\u5019\uff0c\u5982\u679c\u7f16\u8bd1\u5668\u9047\u5230\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u8c03\u7528\uff1a int i { max ( 3 , 7 ) }; // calls max(int, int) \u7f16\u8bd1\u5668\u8bf4\uff0c\u201c\u597d\u5427\uff0c\u6211\u4eec\u60f3\u8981\u8c03\u7528 max(int, int) \u201d\u3002\u7f16\u8bd1\u5668\u62f7\u8d1d\u4e86\u51fd\u6570\u6a21\u677f\uff0c\u7136\u540e\u521b\u5efa\u6a21\u677f\u5b9e\u4f8b max(int, int) \uff1a const int & max ( const int & x , const int & y ) { return ( x > y ) ? x : y ; } \u8fd9\u73b0\u5728\u662f\u4e00\u4e2a \u201c\u6b63\u5e38\u7684\u51fd\u6570\u201d \u53ef\u4ee5\u88ab\u7f16\u8bd1\u6210\u673a\u5668\u8bed\u8a00\u7684\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5728\u7a0d\u540e\u7684\u4ee3\u7801\u4e2d\uff0c\u4f60\u518d\u6b21\u8c03\u7528\u4e86 max() \u4f7f\u7528\u4e0d\u540c\u7684\u7c7b\u578b\uff1a double d { max ( 6.34 , 18.523 ) }; // calls max(double, double) C++ \u4e3a max(double, double) \u81ea\u52a8\u7684\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u677f\u5b9e\u4f8b\uff1a const double & max ( const double & x , const double & y ) { return ( x > y ) ? x : y ; } \u5e76\u4e14\u7136\u540e\u7f16\u8bd1\u5b83\u3002 \u7f16\u8bd1\u5668\u8db3\u591f\u806a\u660e\uff0c\u77e5\u9053\u5b83\u53ea\u9700\u8981\u4e3a\u6bcf\u7ec4\u552f\u4e00\u7c7b\u578b\u53c2\u6570\uff08\u6bcf\u4e2a\u6587\u4ef6\uff09\u521b\u5efa\u4e00\u4e2a\u6a21\u677f\u5b9e\u4f8b\u3002\u4e5f\u503c\u5f97\u6ce8\u610f\u5982\u679c\u4f60\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u4f46\u662f\u6ca1\u6709\u8c03\u7528\u5b83\uff0c\u6ca1\u6709\u6a21\u677f\u5b9e\u4f8b\u4f1a\u88ab\u521b\u5efa\u3002 Operators, function calls, and function templates","title":"19.2 \u7c7b\u6a21\u677f\u5b9e\u4f8b"},{"location":"19-templates/19.2-function-template-instances/#_1","text":"\u6709\u4e00\u4e2a\u524d\u63d0\uff0c\u6a21\u677f\u51fd\u6570\u4f1a\u65e2\u80fd\u548c\u5185\u7f6e\u7684\u7c7b\u578b\u5de5\u4f5c\uff08\u4f8b\u5982\uff1achar\uff0cint\uff0cdouble \u7b49\u7b49\uff09\u548c\u7c7b\u3002\u5f53\u7f16\u8bd1\u5668\u7f16\u8bd1\u6a21\u677f\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u5b83\u7f16\u8bd1\u5c31\u50cf\u666e\u901a\u51fd\u6570\u90a3\u6837\u3002\u5728\u666e\u901a\u51fd\u6570\u4e2d\uff0c\u5fc5\u987b\u5b9a\u4e49\u4e0e\u7c7b\u578b\u4e00\u8d77\u4f7f\u7528\u7684\u4efb\u4f55\u8fd0\u7b97\u7b26\u6216\u51fd\u6570\u8c03\u7528\uff0c\u5426\u5219\u4f60\u4f1a\u5f97\u5230\u7f16\u8bd1\u9519\u8bef\u3002\u7c7b\u4f3c\u5730\uff0c\u6a21\u677f\u51fd\u6570\u4e2d\u7684\u4efb\u4f55\u8fd0\u7b97\u7b26\u6216\u51fd\u6570\u8c03\u7528\u90fd\u5fc5\u987b\u4e3a\u5b9e\u4f8b\u5316\u51fd\u6570\u6a21\u677f\u7684\u4efb\u4f55\u7c7b\u578b\u5b9a\u4e49\u3002\u8ba9\u6211\u4eec\u66f4\u8be6\u7ec6\u5730\u770b\u770b\u8fd9\u4e2a\u4f8b\u5b50\u3002 \u9996\u5148\uff0c\u6211\u4eec\u80fd\u521b\u5efa\u4e00\u4e2a\u7b80\u5355\u7684\u7c7b\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 Cents \u7c7b\u6765\u8c03\u7528\u6211\u4eec\u7684\u6a21\u677f\u51fd\u6570 max() \uff1a template < typename T > // this is the template parameter declaration const T & max ( const T & x , const T & y ) { return ( x > y ) ? x : y ; } class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } }; int main () { Cents nickle { 5 }; Cents dime { 10 }; Cents bigger { max ( nickle , dime ) }; return 0 ; } C++ \u4f1a\u521b\u5efa\u4e00\u4e2a max() \u50cf\u8fd9\u6837\u7684\u6a21\u677f\u5b9e\u4f8b\uff1a const Cents & max ( const Cents & x , const Cents & y ) { return ( x > y ) ? x : y ; } \u7136\u540e\u7d27\u63a5\u7740\u4ed6\u4f1a\u5c1d\u8bd5\u7f16\u8bd1\u8fd9\u4e2a\u51fd\u6570\uff0c\u770b\u5230\u95ee\u9898\u4e86\u4e48\uff1fC++ \u4e0d\u80fd\u8bc4\u4f30 x > y \uff0c\u56e0\u4e3a x \u548c y \u90fd\u662f Cents \u7c7b\u5bf9\u8c61\uff0c\u800c\u4e14\u4e0d\u80fd\u77e5\u9053\u5982\u4f55\u7f16\u8bd1\u4ed6\u4eec\u3002\u56e0\u6b64\uff0c\u8fd9\u4f1a\u4ea7\u751f\u4e00\u4e2a\u5f88\u96be\u770b\u7684\u7f16\u8bd1\u9519\u8bef\uff0c\u50cf\u8fd9\u6837\uff1a 1 > c : \\ consoleapplication1 \\ main . cpp ( 4 ) : error C2676 : binary '>' : ' const Cents ' does not define this operator or a conversion to a type acceptable to the predefined operator 1 > c : \\ consoleapplication1 \\ main . cpp ( 23 ) : note : see reference to function template instantiation ' const T & max ( const T & , const T & ) ' being compiled 1 > with 1 > [ 1 > T = Cents 1 > ] \u6700\u4e0a\u65b9\u7684\u9519\u8bef\u4fe1\u606f\u6307\u51fa\u6ca1\u6709Cents\u8fd9\u4e2a\u7c7b\u7684 > \u64cd\u4f5c\u7b26\u91cd\u8f7d\u3002\u5e95\u90e8\u7684\u9519\u8bef\u6307\u51fa\u6a21\u677f\u51fd\u6570\u8c03\u7528\u62a5\u9519\u4e86\uff0c\u4ee5\u53ca\u6a21\u677f\u5316\u53c2\u6570\u7684\u7c7b\u578b\u3002 \u60f3\u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u7b80\u5355\u7684\u7ed9\u6bcf\u4e2a\u4f60\u60f3\u8981\u4f7f\u7528 max() \u7684\u4efb\u4f55\u7c7b\u91cd\u8f7d > \u64cd\u4f5c\u7b26\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; \u73b0\u5728 C++ \u80fd\u77e5\u9053\u5982\u4f55\u6bd4\u8f83 x > y \u5f53 x \u548c y \u662f Cents\uff01\u7ed3\u679c\uff0c\u6211\u4eec\u7684 max() \u73b0\u5728\u53ef\u4ee5\u548c\u4e24\u4e2a Cents \u7c7b\u7684\u4e24\u4e2a\u5bf9\u8c61\u3002","title":"\u64cd\u4f5c\u7b26\uff0c\u51fd\u6570\u8c03\u7528\u548c\u51fd\u6570\u6a21\u677f"},{"location":"19-templates/19.2-function-template-instances/#_2","text":"\u8ba9\u6211\u4eec\u5728\u770b\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u7684\u4f8b\u5b50\u3002\u63a5\u4e0b\u6765\u7684\u51fd\u6570\u6a21\u677f\u5c06\u4f1a\u8ba1\u7b97\u6570\u7ec4\u4e2d\u5bf9\u8c61\u7684\u5e73\u5747\u503c\uff1a template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } \u8ba9\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b9e\u9645\u4f7f\u7528\uff1a #include <iostream> template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { int array1 []{ 5 , 3 , 2 , 1 , 4 }; std :: cout << average ( array1 , 5 ) << '\\n' ; double array2 []{ 3.12 , 3.45 , 9.23 , 6.34 }; std :: cout << average ( array2 , 4 ) << '\\n' ; return 0 ; } \u7ed3\u679c\u4ea7\u751f\u4e86\u503c\uff1a 3 5.535 \u5982\u4f60\u6240\u89c1\uff0c\u4ed6\u80fd\u5f88\u597d\u5728\u5185\u7f6e\u7684\u7c7b\u578b\u4e0a\u8fd0\u884c\uff01 \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u56e0\u4e3a\u8fd4\u56de\u7c7b\u578b\u4e0e\u6570\u7ec4\u5143\u7d20\u662f\u76f8\u540c\u7684\u6a21\u677f\u5316\u7c7b\u578b\uff0c\u505a\u6574\u578b\u5e73\u5747\u503c\u4f1a\u4ea7\u751f\u4e00\u4e2a\u6574\u578b\u7ed3\u679c\uff08\u4e22\u5f03\u4efb\u4f55\uff09\u3002\u8fd9\u4e0e\u6574\u6570\u9664\u6cd5\u4ea7\u751f\u6574\u6570\u7ed3\u679c\u7684\u65b9\u5f0f\u7c7b\u4f3c\u3002\u6211\u4eec\u5c06\u4e8b\u7269\u5b9a\u4e49\u4e3a\u8fd9\u6837\u662f\u53ef\u4ee5\u5de5\u4f5c\u7684\uff0c\u4f46\u662f\u8fd9\u53ef\u80fd\u662f\u4e0d\u53ef\u9884\u671f\u7684\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u5199\u4e00\u4e9b\u6ce8\u91ca\u7ed9\u7c7b\u7684\u7528\u6237\u4e5f\u633a\u597d\u3002 \u73b0\u5728\u5f53\u6211\u4eec\u4f7f\u7528\u5728 Cents \u7c7b\u4e0a\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1a #include <iostream> class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } }; template < class T > T average ( T * array , int length ) { T sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } int main () { Cents array3 []{ Cents ( 5 ), Cents ( 10 ), Cents ( 15 ), Cents ( 14 ) }; std :: cout << average ( array3 , 4 ) << '\\n' ; return 0 ; } \u7f16\u8bd1\u5668\u9677\u5165\u75af\u72c2\u62a5\u4e86\u4e00\u5806\u9519\uff01 example . cpp ( 33 ) : error C2679 : binary ' << ' : no operator found which takes a right - hand operand of type 'T' ( or there is no acceptable conversion ) with [ T = Cents ] C : / data / msvc / 14.22.27905 / include \\ ostream ( 437 ) : note : could be ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_streambuf > * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 412 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( const void * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 394 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 376 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( double ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 358 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( float ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 340 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 322 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( __int64 ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 304 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 286 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( long ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 268 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 248 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( int ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 230 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( unsigned short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 202 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( short ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 184 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( bool ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 179 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: ios_base & ( __cdecl * )( std :: ios_base & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 174 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ios > & ( __cdecl * )( std :: basic_ios > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 169 ) : note : or ' std :: basic_ostream > & std :: basic_ostream >:: operator << ( std :: basic_ostream > & ( __cdecl * )( std :: basic_ostream > & )) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 613 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 658 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 694 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 739 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 858 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const signed char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 864 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , signed char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 870 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const unsigned char * ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 876 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , unsigned char ) ' C : / data / msvc / 14.22.27905 / include \\ ostream ( 931 ) : note : or ' std :: basic_ostream > & std :: operator <<> ( std :: basic_ostream > & , const std :: error_code & ) ' ( 33 ) : note : while trying to match the argument list ' ( std :: ostream , T ) ' with [ T = Cents ] Compiler returned : 2 \u8bb0\u5f97\u6211\u8bf4\u8fc7\u7684\u75af\u72c2\u62a5\u9519\u4fe1\u606f\u4e48\uff1fWe hit the motherlode\uff01\u5c3d\u7ba1\u770b\u8d77\u6765\u5f88\u5413\u4eba\uff0c\u8fd9\u4e9b\u5b9e\u9645\u4e0a\u76f8\u5f53\u76f4\u63a5\u3002\u7b2c\u4e00\u884c\u544a\u8bc9\u4f60\u4e0d\u80fd\u5728 Cents \u7c7b\u4e2d\u627e\u5230\u4e00\u4e2a\u91cd\u8f7d\u7684 << \u64cd\u4f5c\u7b26\u3002\u4e2d\u95f4\u662f\u6240\u6709\u60f3\u8981\u7528\u6765\u5339\u914d\u7684\u51fd\u6570\uff0c\u4f46\u662f\u90fd\u5931\u8d25\u4e86\u3002\u6700\u540e\u4e00\u4e2a\u9519\u8bef\u6307\u51fa\u4e86\u4ea7\u751f\u8fd9\u4e00\u5806\u9519\u7684\u7684\u51fd\u6570\u8c03\u7528\u3002 \u8bb0\u4f4f average() \u8fd4\u56de\u4e86\u4e00\u4e2a Cents \u5bf9\u8c61\uff0c\u5e76\u4e14\u6211\u4eec\u6b63\u5728\u5c1d\u8bd5\u53bb\u8f93\u51fa\u90a3\u4e2a\u5bf9\u8c61\u5230 std::cout \u4f7f\u7528 << \u64cd\u4f5c\u7b26\u3002\u7136\u800c\uff0c\u6211\u4eec\u5df2\u7ecf\u4e3a\u6211\u4eec\u7684 Cents \u7c7b\u578b\u5b9a\u4e49\u4e86 << \u4ece\u64cd\u4f5c\u7b26\u3002\u8ba9\u6211\u4eec\u90a3\u6837\u505a\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } }; \u5982\u679c\u6211\u4eec\u518d\u6b21\u7f16\u8bd1\uff0c\u6211\u4eec\u5c31\u4f1a\u5f97\u5230\u53e6\u4e00\u4e2a\u9519\u8bef\uff1a c : test . cpp ( 14 ) : error C2676 : binary ' += ' : ' Cents ' does not define this operator or a conversion to a type acceptable to the predefined operator \u8fd9\u4e2a\u9519\u8bef\u5b9e\u9645\u4e0a\u662f\u5f53\u6211\u4eec\u8c03\u7528 average(Cents* int) \u7684\u65f6\u5019\u521b\u5efa\u7684\u51fd\u6570\u6a21\u677f\u5b9e\u4f8b\u9020\u6210\u7684\u3002\u8bb0\u4f4f\u5f53\u6211\u4eec\u8c03\u7528\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u7684\u65f6\u5019\uff0c\u7f16\u8bd1\u5668\u4f7f\u7528\u6f0f\u5b57\u677f\u53ef\u51fa\u4e00\u4e2a\u51fd\u6570\u7684\u62f7\u8d1d\uff0c\u5e76\u4e14\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff08\u5360\u4f4d\u7b26\u7c7b\u578b\uff09\u5df2\u7ecf\u88ab\u66ff\u6362\u4e3a\u5b9e\u9645\u4e0a\u51fd\u6570\u8c03\u7528\u65f6\u7684\u7c7b\u578b\u3002\u8fd9\u662f\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u5b9e\u4f8b\u5316\u65f6\uff0c\u5f53 T \u66ff\u6362\u4e3a\u4e00\u4e2a Cents \u5bf9\u8c61\u65f6\uff0c\u518d\u8c03\u7528 average() \u7684\u4f8b\u5b50\uff1a template < class T > Cents average ( Cents * array , int length ) { Cents sum ( 0 ); for ( int count { 0 }; count < length ; ++ count ) sum += array [ count ]; sum /= length ; return sum ; } \u6211\u4eec\u5f97\u5230\u9519\u8bef\u4fe1\u606f\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u4e0b\u9762\u8fd9\u884c\uff1a sum += array [ count ]; \u5728\u8fd9\u4e2a\u4f8b\u5b50\u5f53\u4e2d\uff0csum \u662f\u4e00\u4e2a Cents \u5bf9\u8c61\uff0c\u4f46\u662f\u6211\u4eec\u4e3a Cents \u5bf9\u8c61\u53bb\u6ca1\u6709\u5b9a\u4e49 += \u64cd\u4f5c\u7b26\uff01\u4e3a\u4e86\u8ba9 average() \u80fd\u5728 Cents \u7c7b\u4e0b\u8c03\u7528\uff0c\u6211\u4eec\u9700\u8981\u53bb\u5b9a\u4e49\u8fd9\u4e2a\u51fd\u6570\u3002\u5f80\u540e\u770b\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230 average() \u4e5f\u4f7f\u7528\u4e86 /= \u64cd\u4f5c\u7b26\uff0c\u56e0\u6b64\u6211\u4eec\u4e5f\u8981\u7ee7\u7eed\u5b9a\u4e49\uff1a class Cents { private : int m_cents ; public : Cents ( int cents ) : m_cents { cents } { } friend bool operator > ( const Cents & c1 , const Cents & c2 ) { return ( c1 . m_cents > c2 . m_cents ); } friend std :: ostream & operator << ( std :: ostream & out , const Cents & cents ) { out << cents . m_cents << \" cents \" ; return out ; } Cents & operator += ( const Cents & cents ) { m_cents += cents . m_cents ; return * this ; } Cents & operator /= ( int value ) { m_cents /= value ; return * this ; } }; \u6700\u7ec8\u6211\u4eec\u7684\u4ee3\u7801\u4f1a\u7f16\u8bd1\u5e76\u4e14\u8fd0\u884c\uff01\u8fd9\u662f\u7ed3\u679c\uff1a 11 cents \u5982\u679c\u8fd9\u770b\u8d77\u6765\u5f88\u8d39\u4e8b\uff0c\u90a3\u53ea\u662f\u56e0\u4e3a\u6211\u4eec\u7684 Cents \u7c7b\u662f\u4e00\u4e2a\u5982\u6b64\u57fa\u7840\u7684\u5f00\u59cb\u3002\u8fd9\u91cc\u7684\u5173\u952e\u70b9\u662f\u5b9e\u9645\u4e0a\u6211\u4eec\u6839\u672c\u6ca1\u6709\u5fc5\u8981\u53bb\u4fee\u6539 average() \u6765\u4fdd\u8bc1\u5b83\u5728 Cents \u7c7b\u4e0b\u5de5\u4f5c\uff08\u6216\u8005\u4e3a\u4efb\u4f55\u5176\u4ed6\u7c7b\u578b\uff09\u3002\u6211\u4eec\u7b80\u5355\u5730\u4e3a Cents \u7c7b\u5b9a\u4e49\u5b9e\u73b0 average() \u8981\u7528\u5230\u7684\u64cd\u4f5c\u7b26\uff0c\u7136\u540e\u7f16\u8bd1\u5668\u505a\u4e86\u5269\u4e0b\u90e8\u5206\u7684\u5de5\u4f5c\uff01","title":"\u53e6\u4e00\u4e2a\u4f8b\u5b50"},{"location":"19-templates/19.3-template-classes/","text":"19.3 \u6a21\u677f\u7c7b \u00b6 By Alex on June 16 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 By dashjay 2020-12-27 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-27 \u5728\u4e4b\u524d\u7684\u4e24\u8282\u8bfe\u4e2d\uff0c\u4f60\u5b66\u4e60\u4e86 19.1 -- Function templates \u7136\u540e\u5b9e\u4f8b\u5316\u6210\u4e86 19.2 -- Function template instances \uff0c\u5141\u8bb8\u6211\u4eec\u751f\u6210\u51fd\u6570\u6765\u5728\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\u3002\u5c3d\u7ba1\u8fd9\u662f\u4e00\u4e2a\u5230\u5e7f\u4e49\u7684\u7f16\u7a0b\uff08generalized programming\uff09\u7684\u5f88\u68d2\u7684\u5f00\u59cb\uff0c\u4f46\u662f\u5b83\u4e0d\u80fd\u89e3\u51b3\u6211\u4eec\u6240\u6709\u7684\u95ee\u9898\u3002\u8ba9\u6211\u4eec\u770b\u4e00\u770b\u5176\u4ed6\u95ee\u9898\u7684\u4f8b\u5b50\uff0c\u770b\u770b\u6a21\u677f\u8fd8\u53ef\u4ee5\u4e3a\u6211\u4eec\u505a\u4ec0\u4e48\u3002 \u6a21\u677f\u548c\u5bb9\u5668\u7c7b \u00b6 \u5728 16.6 -- Container classes \u4e2d\uff0c\u4f60\u5b66\u4e60\u4e86\u5982\u4f55\u590d\u5408\u6765\u5b9e\u73b0\u5305\u542b\u591a\u4e2a\u5176\u4ed6\u7c7b\u7684\u5b9e\u4f8b\u7684\u7684\u7c7b\u3002\u4f5c\u4e3a\u4e00\u4e2a\u8fd9\u6837\u7684\u5bb9\u5668\uff0c\u6211\u4eec\u770b\u4e00\u773c IntArray \u7c7b\u3002\u8fd9\u6709\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a #ifndef INTARRAY_H #define INTARRAY_H #include <cassert> class IntArray { private : int m_length {}; int * m_data {}; public : IntArray ( int length ) { assert ( length > 0 ); m_data = new int [ length ]{}; m_length = length ; } // We don't want to allow copies of IntArray to be created. IntArray ( const IntArray & ) = delete ; IntArray & operator = ( const IntArray & ) = delete ; ~ IntArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } int & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; #endif \u8fd9\u4e2a\u7c7b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5bb9\u6613\u7684\u65b9\u5f0f\u6765\u521b\u5efa\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\uff0c\u5982\u679c\u4f60\u60f3\u521b\u5efa\u4e00\u4e2a double \u7c7b\u578b\u7684\u6570\u7ec4\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u4f7f\u7528\u4f20\u7edf\u7684\u7f16\u7a0b\u65b9\u6cd5\u6211\u4eec\u4e0d\u5f97\u4e0d\u521b\u5efa\u4e00\u6574\u4e2a\u65b0\u7684\u7c7b\uff01\u8fd9\u662f\u4e00\u4e2aDouble \u6570\u7ec4\u7684\u4f8b\u5b50\uff0c\u4e00\u4e2a\u6570\u7ec4\u7528\u6765\u5b58\u50a8 doubles\u3002 # ifndef DOUBLEARRAY_H # define DOUBLEARRAY_H # include <cassert> class DoubleArray { private : int m_length {}; double * m_data {}; public : DoubleArray ( int length ) { assert ( length > 0 ); m_data = new double [ length ]{}; m_length = length ; } DoubleArray ( const DoubleArray & ) = delete ; DoubleArray & operator = ( const DoubleArray & ) = delete ; ~ DoubleArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } double & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; # endif \u5c3d\u7ba1\u4ee3\u7801\u5197\u957f\uff0c\u4f60\u4f1a\u6ce8\u610f\u8fd9\u4e24\u4e2a\u7c7b\u51e0\u4e4e\u662f\u4e00\u6837\u7684\uff01\u4e8b\u5b9e\u4e0a\uff0c\u5b9e\u8d28\u4e0a\u4e0d\u540c\u7684\u53ea\u662f\u6570\u636e\u7c7b\u578b\uff08int vs double\uff09\u3002\u4f60\u53ef\u80fd\u4f1a\u50cf\uff0c\u8fd9\u662f\u53e6\u4e00\u4e2a\u6a21\u677f\u53ef\u4ee5\u751f\u6548\u7684\u5730\u65b9\u5427\uff0c\u4e3a\u4e86\u8ba9\u6211\u4eec\u8f7b\u677e\u7684\u521b\u5efa\u4efb\u4f55\u6570\u636e\u7c7b\u578b\u7684\u6570\u7ec4\u3002 \u521b\u5efa\u6a21\u677f\u7c7b\u548c\u6a21\u677f\u51fd\u6570\u51e0\u4e4e\u662f\u76f8\u540c\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u5c31\u653e\u4e00\u4e2a\u4f8b\u5b50\u5c31\u597d\u3002\u8fd9\u662f\u4e00\u4e2a\u6211\u4eec\u7684\u7c7b\u6a21\u677f\u7684\u7248\u672c\uff1a Array . h : # ifndef ARRAY_H # define ARRAY_H # include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } // templated getLength() function defined below int getLength () const ; }; // member functions defined outside the class need their own template declaration template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } # endif \u5982\u4f60\u6240\u89c1\uff0c\u8fd9\u4e2a\u7248\u672c\u548c IntArray \u51e0\u4e4e\u662f\u76f8\u540c\u7684\uff0c\u9664\u4e86\u6211\u4eec\u6dfb\u52a0\u4e86\u6a21\u677f\u58f0\u660e\uff0c\u5e76\u4e14\u6539\u53d8\u4e86\u6570\u636e\u7c7b\u578b\u4ece int \u5230 T \u3002 \u6ce8\u610f\u6211\u4eec\u4e5f\u5728\u7c7b\u5916\u5b9a\u4e49\u4e86 getLength() \u51fd\u6570\u3002\u8fd9\u4e0d\u662f\u5fc5\u987b\u7684\uff0c\u4f46\u662f\u65b0\u7684\u7a0b\u5e8f\u5458\u7ecf\u5e38\u4f1a\u5728\u7b2c\u4e00\u6b21\u8fd9\u6837\u505a\u7684\u65f6\u5019\u5931\u8d25\uff0c\u56e0\u4e3a\u590d\u6742\u7684\u8bed\u6cd5\uff0c\u56e0\u6b64\u8fd9\u4e2a\u4f8b\u5b50\u53ef\u4ee5\u7ed9\u4f60\u4e00\u4e9b\u542f\u53d1\u3002\u6bcf\u4e2a\u6a21\u677f\u6210\u5458\u51fd\u6570\u5b9a\u4e49\u5728\u7c7b\u5916\u9700\u8981\u5b83\u81ea\u5df1\u7684\u6a21\u677f\u5b9a\u4e49\u3002\u540c\u65f6\u6ce8\u610f\u6a21\u677f\u6570\u7ec4\u7c7b\u662f Array<T> \u800c\u4e0d\u662f Array \u2014\u2014 Array \u4f1a\u5f15\u7528\u5230\u6ca1\u6709\u6a21\u677f\u7684\u7c7b\u7248\u672c\uff0c\u9664\u975e Array \u5728\u7c7b\u4e2d\u88ab\u4f7f\u7528\u3002\u4f8b\u5982\uff0c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u590d\u5236\u64cd\u4f5c\u7b26\u5c31\u53ef\u4ee5\u4f7f\u7528 Array \u800c\u4e0d\u662f Array<T> \u3002\u5f53\u7c7b\u540d\u5728\u7c7b\u4e2d\u4f7f\u7528\u800c\u4e0d\u5e26\u6a21\u677f\u53c2\u6570\u7684\u65f6\u5019\uff0c\u53c2\u6570\u4e0e\u5f53\u524d\u5b9e\u4f8b\u5316\u7684\u53c2\u6570\u76f8\u540c\u3002 \u6709\u4e00\u4e2a\u77ed\u7684\u4f8b\u5b50\u4f7f\u7528\u4e0a\u9762\u7684\u6a21\u677f\u6570\u7ec4\u7c7b\uff1a # include <iostream> # include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } \u4f8b\u5b50\u6253\u5370\u5982\u4e0b\uff1a 11 11.5 10 10.5 9 9.5 8 8.5 7 7.5 6 6.5 5 5.5 4 4.5 3 3.5 2 2.5 1 1.5 0 0.5 \u6a21\u677f\u7c7b\u548c\u6a21\u677f\u51fd\u6570\u4e00\u6837\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u5b9e\u4f8b\u5316\u2014\u2014\u7f16\u8bd1\u5668\u5728\u6309\u9700\u62f7\u8d1d\u4e00\u4efd\uff0c\u4f7f\u7528\u5b9e\u9645\u7528\u6237\u9700\u8981\u7684\u7c7b\u578b\u6765\u66ff\u6362\u6a21\u677f\u7c7b\u578b\uff0c\u5e76\u4e14\u7f16\u8bd1\u8fd9\u4e2a\u62f7\u8d1d\u3002\u5982\u679c\u4f60\u6ca1\u6709\u5728\u4efb\u4f55\u5730\u65b9\u4f7f\u7528\u6a21\u677f\u7c7b\uff0c\u7f16\u8bd1\u5668\u4e0d\u4f1a\u7f16\u8bd1\u5b83\u3002 \u6a21\u677f\u7c7b\u662f\u4e00\u79cd\u7406\u60f3\u7684\u5bb9\u5668\u7c7b\u7684\u5b9e\u73b0\uff0c\u56e0\u4e3a\u8ba9\u5bb9\u5668\u7c7b\u5728\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u4e0a\u5de5\u4f5c\u662f\u53ef\u53d6\u7684\uff0c\u5e76\u4e14\u6a21\u677f\u5141\u8bb8\u4f60\u65e0\u9700\u62f7\u8d1d\u4ee3\u7801\u7684\u60c5\u51b5\u4e0b\u8fd9\u6837\u505a\u3002\u5c3d\u7ba1\u8bed\u6cd5\u6709\u70b9\u4e11\uff0c\u5e76\u4e14\u62a5\u9519\u4fe1\u606f\u6709\u70b9\u9690\u6666\uff0c\u6a21\u677f\u7c7b\u771f\u7684\u662f C++ \u6700\u597d\u6700\u6709\u7528\u7684\u7279\u6027\u4e4b\u4e00\u3002 \u6807\u51c6\u5e93\u4e2d\u7684\u6a21\u677f\u7c7b \u00b6 \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b66\u5230\u4e86\u6a21\u677f\u7c7b\uff0c\u4f60\u9700\u8981\u7406\u89e3 std::vector<int> \u610f\u601d\u662f\u5565 \u2014\u2014 std::vector \u5b9e\u9645\u4e0a\u5c31\u662f\u4e00\u4e2a\u6a21\u677f\u7c7b\uff0c\u5e76\u4e14 int \u662f\u4ed6\u7684\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff01\u6807\u51c6\u5e93\u9884\u5b9a\u4e49\u4e86\u5f88\u591a\u6a21\u677f\u7c7b\u7ed9\u4f60\u7528\uff0c\u6211\u4eec\u4f1a\u5728\u7a0d\u540e\u7684\u7ae0\u8282\u4e2d\u5b66\u5230\u8fd9\u4e9b\u3002 \u5206\u5272\u6a21\u677f\u7c7b \u00b6 \u4e00\u4e2a\u6a21\u677f\u4e0d\u662f\u4e00\u4e2a\u7c7b\u6216\u8005\u4e00\u4e2a\u51fd\u6570 \u2014\u2014 \u662f\u4e00\u4e2a \u201c\u6f0f\u5b57\u677f\u201d \u7528\u6765\u521b\u5efa\u7c7b\u6216\u8005\u51fd\u6570\u3002\u56e0\u6b64\uff0c\u4ed6\u4eec\u548c\u666e\u901a\u7684\u51fd\u6570\u6216\u8005\u7c7b\u5de5\u4f5c\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u8fd9\u6ca1\u5565\u5927\u95ee\u9898\u3002\u7136\u800c\u6709\u4e00\u4e2a\u5f88\u5e38\u89c1\u7684\u95ee\u9898\u4f1a\u7ed9\u5f00\u53d1\u8005\u5e26\u6765\u95ee\u9898\u3002 \u4f7f\u7528\u5e9f\u6a21\u677f\u7c7b\uff0c\u5e38\u89c1\u7684\u8fc7\u7a0b\u5c31\u5c31\u662f\u5c06\u7c7b\u5b9a\u4e49\u653e\u5728\u5934\u6587\u4ef6\uff0c\u7136\u540e\u6210\u5458\u51fd\u6570\u653e\u5728\u4e00\u4e2a\u540d\u5b57\u76f8\u4f3c\u7684\u6587\u4ef6\u4e2d\u3002\u4ee5\u8fd9\u79cd\u65b9\u5f0f\uff0c\u7c7b\u7684\u6e90\u4ee3\u7801\u5728\u5206\u79bb\u7684\u9879\u76ee\u6587\u4ef6\u4e2d\u88ab\u7f16\u8bd1\u3002\u7136\u800c\u5982\u679c\u4f60\u4f7f\u7528\u6a21\u677f\uff0c\u8fd9\u5c31\u4e0d\u4f1a\u5de5\u4f5c\u4e86\uff0c\u770b\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a Array.h: # ifndef ARRAY_H # define ARRAY_H # include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const ; }; # endif Array.cpp: # include \"Array.h\" template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } main.cpp: # include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } \u4ee5\u4e0a\u7a0b\u5e8f\u80fd\u901a\u8fc7\u7f16\u8bd1\uff0c\u4f46\u662f\u94fe\u63a5\u5668\u4f1a\u62a5\u9519\uff1a unresolved external symbol \"public: int __thiscall Array::getLength(void)\" ( ? GetLength @ ? $Array @ H @@ QAEHXZ ) \u4e3a\u4e86\u8ba9\u7f16\u8bd1\u5668\u4f7f\u7528\u4e00\u4e2a\u6a21\u677f\uff0c\u5fc5\u987b\u8981\u540c\u65f6\u80fd\u770b\u5230\u6a21\u677f\u5b9a\u4e49\uff08\u4e0d\u4ec5\u4ec5\u662f\u58f0\u660e\uff09\u5e76\u4e14\u6a21\u677f\u7c7b\u88ab\u88ab\u7528\u6765\u5b9e\u4f8b\u5316\u6210\u4e86\u6a21\u677f\u3002\u540c\u65f6\u8bb0\u4f4f\uff0cC++ \u5355\u72ec\u7f16\u8bd1\u6587\u4ef6\u3002\u5f53 Array.h \u5934\u6587\u4ef6\u5728 main \u4e2d\u88ab #include \u4e4b\u540e\uff0c\u6a21\u677f\u7c7b\u7684\u5b9a\u4e49\u5c31\u88ab\u62f7\u8d1d\u5230\u4e86 main.cpp \u3002\u5f53\u7f16\u8bd1\u5668\u53d1\u73b0\u6211\u4eec\u9700\u8981\u6a21\u677f\u5b9e\u4f8b\u5316 Array<int>, Array<double> \u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u5b9e\u4f8b\u5316\u8fd9\u4e9b\uff0c\u5e76\u4e14\u7f16\u8bd1\u4ed6\u4eec\u4f5c\u4e3a main.cpp \u3002\u7136\u800c\uff0c\u5f53\u5b83\u7ed5\u8fc7\u5355\u72ec\u7f16\u8bd1 Array.cpp \u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u5fd8\u8bb0\u6211\u4eec\u9700\u8981\u4e00\u4e2a Array<int> \u548c Array<double> \uff0c\u56e0\u6b64\u6a21\u677f\u51fd\u6570\u4ece\u6765\u4e0d\u4f1a\u5457\u5b9e\u4f8b\u5316\u3002\u56e0\u6b64\u6211\u4eec\u5f97\u5230\u4e00\u4e2a\u8fde\u63a5\u9519\u8bef\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u4e0d\u80fd\u53d1\u73b0 Array<int>::getLength() \u6216\u8005 Array<double>::getLength() \u7684\u5b9a\u4e49\u3002 \u6709\u5f88\u591a\u65b9\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u6700\u7b80\u5355\u7684\u65b9\u6cd5\u5c31\u662f\u5427\u6a21\u677f\u7c7b\u7684\u6240\u6709\u4ee3\u7801\u90fd\u653e\u5728\u5934\u6587\u4ef6\u91cc\uff08\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5427 Array.cpp \u4e2d\u7684\u5185\u5bb9\u653e\u8fdb Array.h \u4e2d\uff0c\u5728\u7c7b\u7684\u58f0\u660e\u4e0b\u65b9\uff09\u3002\u4ee5\u8fd9\u79cd\u65b9\u5f0f\uff0c\u5f53\u4f60 #include \u8fd9\u4e2a\u5934\u6587\u4ef6\u7684\u65f6\u5019\uff0c\u6240\u6709\u7684\u6a21\u677f\u4ee3\u7801\u5c31\u4f1a\u5728\u540c\u4e00\u4e2a\u5730\u65b9\u3002\u8fd9\u6837\u89e3\u51b3\u7684\u4f18\u70b9\u5c31\u662f\u975e\u5e38\u7b80\u5355\u3002\u7f3a\u70b9\u5c31\u662f\u5982\u679c\u6a21\u677f\u7c7b\u5728\u5f88\u591a\u5730\u65b9\u88ab\u4f7f\u7528\u7684\u8bdd\uff0c\u4f60\u5c31\u4f1a\u6700\u7ec8\u6709\u5f88\u591a\u6a21\u677f\u7c7b\u7684\u672c\u5730\u62f7\u8d1d\uff0c\u4f1a\u589e\u52a0\u4f60\u7684\u7f16\u8bd1\u548c\u8fde\u63a5\u7684\u8017\u65f6\uff08\u4f60\u7684\u8fde\u63a5\u5668\u4f1a\u79fb\u9664\u91cd\u590d\u7684\u5b9a\u4e49\uff0c\u56e0\u6b64\u4ed6\u4e0d\u4f1a\u8ba9\u53ef\u6267\u884c\u7a0b\u5e8f\u81a8\u80c0\uff09\u3002\u8fd9\u662f\u6211\u4eec\u7684\u5efa\u8bae\u505a\u6cd5\uff0c\u9664\u975e\u7f16\u8bd1\u5668\u6216\u8005\u8fde\u63a5\u5668\u6d88\u8017\u7684\u65f6\u95f4\u6210\u4e3a\u95ee\u9898\u3002 \u5982\u679c\u4f60\u89c9\u5f97\u628a Array.cpp \u7684\u4ee3\u7801\u653e\u8fdb Array.h \u5934\u90e8\u4f7f\u5f97\u4f60\u7684\u5934\u6587\u4ef6\u592a\u957f/\u4e71\uff0c\u4e00\u4e2a\u53ef\u9009\u7684\u65b9\u6848\u5c31\u662f\u5c06 Array.cpp \u547d\u540d\u4e3a Array.inl (.inl \u4ee3\u8868\u5185\u8054)\uff0c\u7136\u540e\u7d27\u63a5\u7740 \u5728 Array.h \u5934\u6587\u4ef6\u7684\u5e95\u90e8 include Array.inl \u3002\u548c\u628a\u4ee3\u7801\u653e\u5230\u5934\u6587\u4ef6\u7684\u7ed3\u679c\u662f\u4e00\u6837\u7684\uff0c\u4f46\u662f\u76f8\u5bf9\u6765\u8bf4\u66f4\u52a0\u5e72\u51c0\u3002 \u5176\u4ed6\u7684\u89e3\u51b3\u65b9\u6848\u6d89\u53ca #including .cpp \u6587\u4ef6\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u5efa\u8bae\u8fd9\u6837\u505a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u662f #include \u7684\u6807\u51c6\u7528\u6cd5\u3002 \u5176\u4ed6\u65b9\u6cd5\u662f\u4f7f\u7528\u4e09\u6587\u4ef6\u65b9\u6cd5\u3002\u6a21\u677f\u7c7b\u5b9a\u4e49\u5728 header \u5934\u6587\u4ef6\u4e2d\u3002\u6a21\u677f\u7c7b\u6210\u5458\u51fd\u6570\u7f16\u5199\u5728\u4ee3\u7801\u6587\u4ef6\u4e2d\u3002\u7136\u540e\u4f60\u6dfb\u52a0\u4e00\u4e2a \u201c\u7b2c\u4e09\u65b9\u201d \u6587\u4ef6\uff0c\u5c06\u8fd9\u4e24\u4e2a\u4f60\u5b9e\u4f8b\u5316\u7684\u7c7b\u6309\u9700\u5305\u542b\uff1a templates.cpp: // Ensure the full Array template definition can be seen # include \"Array.h\" # include \"Array.cpp\" // we're breaking best practices here, but only in this one place // #include other .h and .cpp template definitions you need here template class Array < int > ; // Explicitly instantiate template Array<int> template class Array < double > ; // Explicitly instantiate template Array<double> // instantiate other templates here \u201ctemplate class\u201d \u8ba9\u7f16\u8bd1\u5668\u6765\u663e\u5f0f\u7684\u5b9e\u4f8b\u5316\u6a21\u677f\u7c7b\u3002\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u7f16\u8bd1\u5668\u4f1a\u540c\u65f6\u751f\u6210 Array<int> \u548c Array<double> \u5728 template.cpp \u4e2d\u3002\u56e0\u4e3a templates.cpp \u5728\u6211\u4eec\u7684\u9879\u76ee\u4e2d\uff0c\u8fd9\u4e2a\u7d27\u63a5\u7740\u5c31\u4f1a\u88ab\u7f16\u8bd1\u3002\u7136\u540e\u8fd9\u4e9b\u51fd\u6570\u53ef\u4ee5\u88ab\u4ece\u5176\u4ed6\u5730\u65b9\u8fde\u63a5\u5230\u3002 \u8fd9\u65b9\u6cd5\u66f4\u9ad8\u6548\uff0c\u4f46\u662f\u9700\u8981\u4e3a\u6bcf\u4e2a\u7a0b\u5e8f\u7ba1\u7406 templaes.cpp \u6587\u4ef6\u3002","title":"19.3 \u6a21\u677f\u7c7b"},{"location":"19-templates/19.3-template-classes/#193","text":"By Alex on June 16 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 By dashjay 2020-12-27 | \u6700\u540e\u4fee\u6539\u4e8e 2020-12-27 \u5728\u4e4b\u524d\u7684\u4e24\u8282\u8bfe\u4e2d\uff0c\u4f60\u5b66\u4e60\u4e86 19.1 -- Function templates \u7136\u540e\u5b9e\u4f8b\u5316\u6210\u4e86 19.2 -- Function template instances \uff0c\u5141\u8bb8\u6211\u4eec\u751f\u6210\u51fd\u6570\u6765\u5728\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\u3002\u5c3d\u7ba1\u8fd9\u662f\u4e00\u4e2a\u5230\u5e7f\u4e49\u7684\u7f16\u7a0b\uff08generalized programming\uff09\u7684\u5f88\u68d2\u7684\u5f00\u59cb\uff0c\u4f46\u662f\u5b83\u4e0d\u80fd\u89e3\u51b3\u6211\u4eec\u6240\u6709\u7684\u95ee\u9898\u3002\u8ba9\u6211\u4eec\u770b\u4e00\u770b\u5176\u4ed6\u95ee\u9898\u7684\u4f8b\u5b50\uff0c\u770b\u770b\u6a21\u677f\u8fd8\u53ef\u4ee5\u4e3a\u6211\u4eec\u505a\u4ec0\u4e48\u3002","title":"19.3 \u6a21\u677f\u7c7b"},{"location":"19-templates/19.3-template-classes/#_1","text":"\u5728 16.6 -- Container classes \u4e2d\uff0c\u4f60\u5b66\u4e60\u4e86\u5982\u4f55\u590d\u5408\u6765\u5b9e\u73b0\u5305\u542b\u591a\u4e2a\u5176\u4ed6\u7c7b\u7684\u5b9e\u4f8b\u7684\u7684\u7c7b\u3002\u4f5c\u4e3a\u4e00\u4e2a\u8fd9\u6837\u7684\u5bb9\u5668\uff0c\u6211\u4eec\u770b\u4e00\u773c IntArray \u7c7b\u3002\u8fd9\u6709\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff1a #ifndef INTARRAY_H #define INTARRAY_H #include <cassert> class IntArray { private : int m_length {}; int * m_data {}; public : IntArray ( int length ) { assert ( length > 0 ); m_data = new int [ length ]{}; m_length = length ; } // We don't want to allow copies of IntArray to be created. IntArray ( const IntArray & ) = delete ; IntArray & operator = ( const IntArray & ) = delete ; ~ IntArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } int & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; #endif \u8fd9\u4e2a\u7c7b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5bb9\u6613\u7684\u65b9\u5f0f\u6765\u521b\u5efa\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\uff0c\u5982\u679c\u4f60\u60f3\u521b\u5efa\u4e00\u4e2a double \u7c7b\u578b\u7684\u6570\u7ec4\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u4f7f\u7528\u4f20\u7edf\u7684\u7f16\u7a0b\u65b9\u6cd5\u6211\u4eec\u4e0d\u5f97\u4e0d\u521b\u5efa\u4e00\u6574\u4e2a\u65b0\u7684\u7c7b\uff01\u8fd9\u662f\u4e00\u4e2aDouble \u6570\u7ec4\u7684\u4f8b\u5b50\uff0c\u4e00\u4e2a\u6570\u7ec4\u7528\u6765\u5b58\u50a8 doubles\u3002 # ifndef DOUBLEARRAY_H # define DOUBLEARRAY_H # include <cassert> class DoubleArray { private : int m_length {}; double * m_data {}; public : DoubleArray ( int length ) { assert ( length > 0 ); m_data = new double [ length ]{}; m_length = length ; } DoubleArray ( const DoubleArray & ) = delete ; DoubleArray & operator = ( const DoubleArray & ) = delete ; ~ DoubleArray () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } double & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const { return m_length ; } }; # endif \u5c3d\u7ba1\u4ee3\u7801\u5197\u957f\uff0c\u4f60\u4f1a\u6ce8\u610f\u8fd9\u4e24\u4e2a\u7c7b\u51e0\u4e4e\u662f\u4e00\u6837\u7684\uff01\u4e8b\u5b9e\u4e0a\uff0c\u5b9e\u8d28\u4e0a\u4e0d\u540c\u7684\u53ea\u662f\u6570\u636e\u7c7b\u578b\uff08int vs double\uff09\u3002\u4f60\u53ef\u80fd\u4f1a\u50cf\uff0c\u8fd9\u662f\u53e6\u4e00\u4e2a\u6a21\u677f\u53ef\u4ee5\u751f\u6548\u7684\u5730\u65b9\u5427\uff0c\u4e3a\u4e86\u8ba9\u6211\u4eec\u8f7b\u677e\u7684\u521b\u5efa\u4efb\u4f55\u6570\u636e\u7c7b\u578b\u7684\u6570\u7ec4\u3002 \u521b\u5efa\u6a21\u677f\u7c7b\u548c\u6a21\u677f\u51fd\u6570\u51e0\u4e4e\u662f\u76f8\u540c\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u5c31\u653e\u4e00\u4e2a\u4f8b\u5b50\u5c31\u597d\u3002\u8fd9\u662f\u4e00\u4e2a\u6211\u4eec\u7684\u7c7b\u6a21\u677f\u7684\u7248\u672c\uff1a Array . h : # ifndef ARRAY_H # define ARRAY_H # include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; // We need to make sure we set m_data to 0 here, otherwise it will // be left pointing at deallocated memory! m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } // templated getLength() function defined below int getLength () const ; }; // member functions defined outside the class need their own template declaration template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } # endif \u5982\u4f60\u6240\u89c1\uff0c\u8fd9\u4e2a\u7248\u672c\u548c IntArray \u51e0\u4e4e\u662f\u76f8\u540c\u7684\uff0c\u9664\u4e86\u6211\u4eec\u6dfb\u52a0\u4e86\u6a21\u677f\u58f0\u660e\uff0c\u5e76\u4e14\u6539\u53d8\u4e86\u6570\u636e\u7c7b\u578b\u4ece int \u5230 T \u3002 \u6ce8\u610f\u6211\u4eec\u4e5f\u5728\u7c7b\u5916\u5b9a\u4e49\u4e86 getLength() \u51fd\u6570\u3002\u8fd9\u4e0d\u662f\u5fc5\u987b\u7684\uff0c\u4f46\u662f\u65b0\u7684\u7a0b\u5e8f\u5458\u7ecf\u5e38\u4f1a\u5728\u7b2c\u4e00\u6b21\u8fd9\u6837\u505a\u7684\u65f6\u5019\u5931\u8d25\uff0c\u56e0\u4e3a\u590d\u6742\u7684\u8bed\u6cd5\uff0c\u56e0\u6b64\u8fd9\u4e2a\u4f8b\u5b50\u53ef\u4ee5\u7ed9\u4f60\u4e00\u4e9b\u542f\u53d1\u3002\u6bcf\u4e2a\u6a21\u677f\u6210\u5458\u51fd\u6570\u5b9a\u4e49\u5728\u7c7b\u5916\u9700\u8981\u5b83\u81ea\u5df1\u7684\u6a21\u677f\u5b9a\u4e49\u3002\u540c\u65f6\u6ce8\u610f\u6a21\u677f\u6570\u7ec4\u7c7b\u662f Array<T> \u800c\u4e0d\u662f Array \u2014\u2014 Array \u4f1a\u5f15\u7528\u5230\u6ca1\u6709\u6a21\u677f\u7684\u7c7b\u7248\u672c\uff0c\u9664\u975e Array \u5728\u7c7b\u4e2d\u88ab\u4f7f\u7528\u3002\u4f8b\u5982\uff0c\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u62f7\u8d1d\u590d\u5236\u64cd\u4f5c\u7b26\u5c31\u53ef\u4ee5\u4f7f\u7528 Array \u800c\u4e0d\u662f Array<T> \u3002\u5f53\u7c7b\u540d\u5728\u7c7b\u4e2d\u4f7f\u7528\u800c\u4e0d\u5e26\u6a21\u677f\u53c2\u6570\u7684\u65f6\u5019\uff0c\u53c2\u6570\u4e0e\u5f53\u524d\u5b9e\u4f8b\u5316\u7684\u53c2\u6570\u76f8\u540c\u3002 \u6709\u4e00\u4e2a\u77ed\u7684\u4f8b\u5b50\u4f7f\u7528\u4e0a\u9762\u7684\u6a21\u677f\u6570\u7ec4\u7c7b\uff1a # include <iostream> # include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } \u4f8b\u5b50\u6253\u5370\u5982\u4e0b\uff1a 11 11.5 10 10.5 9 9.5 8 8.5 7 7.5 6 6.5 5 5.5 4 4.5 3 3.5 2 2.5 1 1.5 0 0.5 \u6a21\u677f\u7c7b\u548c\u6a21\u677f\u51fd\u6570\u4e00\u6837\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u5b9e\u4f8b\u5316\u2014\u2014\u7f16\u8bd1\u5668\u5728\u6309\u9700\u62f7\u8d1d\u4e00\u4efd\uff0c\u4f7f\u7528\u5b9e\u9645\u7528\u6237\u9700\u8981\u7684\u7c7b\u578b\u6765\u66ff\u6362\u6a21\u677f\u7c7b\u578b\uff0c\u5e76\u4e14\u7f16\u8bd1\u8fd9\u4e2a\u62f7\u8d1d\u3002\u5982\u679c\u4f60\u6ca1\u6709\u5728\u4efb\u4f55\u5730\u65b9\u4f7f\u7528\u6a21\u677f\u7c7b\uff0c\u7f16\u8bd1\u5668\u4e0d\u4f1a\u7f16\u8bd1\u5b83\u3002 \u6a21\u677f\u7c7b\u662f\u4e00\u79cd\u7406\u60f3\u7684\u5bb9\u5668\u7c7b\u7684\u5b9e\u73b0\uff0c\u56e0\u4e3a\u8ba9\u5bb9\u5668\u7c7b\u5728\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u4e0a\u5de5\u4f5c\u662f\u53ef\u53d6\u7684\uff0c\u5e76\u4e14\u6a21\u677f\u5141\u8bb8\u4f60\u65e0\u9700\u62f7\u8d1d\u4ee3\u7801\u7684\u60c5\u51b5\u4e0b\u8fd9\u6837\u505a\u3002\u5c3d\u7ba1\u8bed\u6cd5\u6709\u70b9\u4e11\uff0c\u5e76\u4e14\u62a5\u9519\u4fe1\u606f\u6709\u70b9\u9690\u6666\uff0c\u6a21\u677f\u7c7b\u771f\u7684\u662f C++ \u6700\u597d\u6700\u6709\u7528\u7684\u7279\u6027\u4e4b\u4e00\u3002","title":"\u6a21\u677f\u548c\u5bb9\u5668\u7c7b"},{"location":"19-templates/19.3-template-classes/#_2","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u5b66\u5230\u4e86\u6a21\u677f\u7c7b\uff0c\u4f60\u9700\u8981\u7406\u89e3 std::vector<int> \u610f\u601d\u662f\u5565 \u2014\u2014 std::vector \u5b9e\u9645\u4e0a\u5c31\u662f\u4e00\u4e2a\u6a21\u677f\u7c7b\uff0c\u5e76\u4e14 int \u662f\u4ed6\u7684\u6a21\u677f\u7c7b\u578b\u53c2\u6570\uff01\u6807\u51c6\u5e93\u9884\u5b9a\u4e49\u4e86\u5f88\u591a\u6a21\u677f\u7c7b\u7ed9\u4f60\u7528\uff0c\u6211\u4eec\u4f1a\u5728\u7a0d\u540e\u7684\u7ae0\u8282\u4e2d\u5b66\u5230\u8fd9\u4e9b\u3002","title":"\u6807\u51c6\u5e93\u4e2d\u7684\u6a21\u677f\u7c7b"},{"location":"19-templates/19.3-template-classes/#_3","text":"\u4e00\u4e2a\u6a21\u677f\u4e0d\u662f\u4e00\u4e2a\u7c7b\u6216\u8005\u4e00\u4e2a\u51fd\u6570 \u2014\u2014 \u662f\u4e00\u4e2a \u201c\u6f0f\u5b57\u677f\u201d \u7528\u6765\u521b\u5efa\u7c7b\u6216\u8005\u51fd\u6570\u3002\u56e0\u6b64\uff0c\u4ed6\u4eec\u548c\u666e\u901a\u7684\u51fd\u6570\u6216\u8005\u7c7b\u5de5\u4f5c\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u8fd9\u6ca1\u5565\u5927\u95ee\u9898\u3002\u7136\u800c\u6709\u4e00\u4e2a\u5f88\u5e38\u89c1\u7684\u95ee\u9898\u4f1a\u7ed9\u5f00\u53d1\u8005\u5e26\u6765\u95ee\u9898\u3002 \u4f7f\u7528\u5e9f\u6a21\u677f\u7c7b\uff0c\u5e38\u89c1\u7684\u8fc7\u7a0b\u5c31\u5c31\u662f\u5c06\u7c7b\u5b9a\u4e49\u653e\u5728\u5934\u6587\u4ef6\uff0c\u7136\u540e\u6210\u5458\u51fd\u6570\u653e\u5728\u4e00\u4e2a\u540d\u5b57\u76f8\u4f3c\u7684\u6587\u4ef6\u4e2d\u3002\u4ee5\u8fd9\u79cd\u65b9\u5f0f\uff0c\u7c7b\u7684\u6e90\u4ee3\u7801\u5728\u5206\u79bb\u7684\u9879\u76ee\u6587\u4ef6\u4e2d\u88ab\u7f16\u8bd1\u3002\u7136\u800c\u5982\u679c\u4f60\u4f7f\u7528\u6a21\u677f\uff0c\u8fd9\u5c31\u4e0d\u4f1a\u5de5\u4f5c\u4e86\uff0c\u770b\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a Array.h: # ifndef ARRAY_H # define ARRAY_H # include <cassert> template < class T > class Array { private : int m_length {}; T * m_data {}; public : Array ( int length ) { assert ( length > 0 ); m_data = new T [ length ]{}; m_length = length ; } Array ( const Array & ) = delete ; Array & operator = ( const Array & ) = delete ; ~ Array () { delete [] m_data ; } void Erase () { delete [] m_data ; m_data = nullptr ; m_length = 0 ; } T & operator []( int index ) { assert ( index >= 0 && index < m_length ); return m_data [ index ]; } int getLength () const ; }; # endif Array.cpp: # include \"Array.h\" template < class T > int Array < T >:: getLength () const // note class name is Array<T>, not Array { return m_length ; } main.cpp: # include \"Array.h\" int main () { Array < int > intArray ( 12 ); Array < double > doubleArray ( 12 ); for ( int count { 0 }; count < intArray . getLength (); ++ count ) { intArray [ count ] = count ; doubleArray [ count ] = count + 0.5 ; } for ( int count { intArray . getLength () - 1 }; count >= 0 ; -- count ) std :: cout << intArray [ count ] << '\\t' << doubleArray [ count ] << '\\n' ; return 0 ; } \u4ee5\u4e0a\u7a0b\u5e8f\u80fd\u901a\u8fc7\u7f16\u8bd1\uff0c\u4f46\u662f\u94fe\u63a5\u5668\u4f1a\u62a5\u9519\uff1a unresolved external symbol \"public: int __thiscall Array::getLength(void)\" ( ? GetLength @ ? $Array @ H @@ QAEHXZ ) \u4e3a\u4e86\u8ba9\u7f16\u8bd1\u5668\u4f7f\u7528\u4e00\u4e2a\u6a21\u677f\uff0c\u5fc5\u987b\u8981\u540c\u65f6\u80fd\u770b\u5230\u6a21\u677f\u5b9a\u4e49\uff08\u4e0d\u4ec5\u4ec5\u662f\u58f0\u660e\uff09\u5e76\u4e14\u6a21\u677f\u7c7b\u88ab\u88ab\u7528\u6765\u5b9e\u4f8b\u5316\u6210\u4e86\u6a21\u677f\u3002\u540c\u65f6\u8bb0\u4f4f\uff0cC++ \u5355\u72ec\u7f16\u8bd1\u6587\u4ef6\u3002\u5f53 Array.h \u5934\u6587\u4ef6\u5728 main \u4e2d\u88ab #include \u4e4b\u540e\uff0c\u6a21\u677f\u7c7b\u7684\u5b9a\u4e49\u5c31\u88ab\u62f7\u8d1d\u5230\u4e86 main.cpp \u3002\u5f53\u7f16\u8bd1\u5668\u53d1\u73b0\u6211\u4eec\u9700\u8981\u6a21\u677f\u5b9e\u4f8b\u5316 Array<int>, Array<double> \u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u5b9e\u4f8b\u5316\u8fd9\u4e9b\uff0c\u5e76\u4e14\u7f16\u8bd1\u4ed6\u4eec\u4f5c\u4e3a main.cpp \u3002\u7136\u800c\uff0c\u5f53\u5b83\u7ed5\u8fc7\u5355\u72ec\u7f16\u8bd1 Array.cpp \u7684\u65f6\u5019\uff0c\u4ed6\u4f1a\u5fd8\u8bb0\u6211\u4eec\u9700\u8981\u4e00\u4e2a Array<int> \u548c Array<double> \uff0c\u56e0\u6b64\u6a21\u677f\u51fd\u6570\u4ece\u6765\u4e0d\u4f1a\u5457\u5b9e\u4f8b\u5316\u3002\u56e0\u6b64\u6211\u4eec\u5f97\u5230\u4e00\u4e2a\u8fde\u63a5\u9519\u8bef\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u4e0d\u80fd\u53d1\u73b0 Array<int>::getLength() \u6216\u8005 Array<double>::getLength() \u7684\u5b9a\u4e49\u3002 \u6709\u5f88\u591a\u65b9\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u6700\u7b80\u5355\u7684\u65b9\u6cd5\u5c31\u662f\u5427\u6a21\u677f\u7c7b\u7684\u6240\u6709\u4ee3\u7801\u90fd\u653e\u5728\u5934\u6587\u4ef6\u91cc\uff08\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5427 Array.cpp \u4e2d\u7684\u5185\u5bb9\u653e\u8fdb Array.h \u4e2d\uff0c\u5728\u7c7b\u7684\u58f0\u660e\u4e0b\u65b9\uff09\u3002\u4ee5\u8fd9\u79cd\u65b9\u5f0f\uff0c\u5f53\u4f60 #include \u8fd9\u4e2a\u5934\u6587\u4ef6\u7684\u65f6\u5019\uff0c\u6240\u6709\u7684\u6a21\u677f\u4ee3\u7801\u5c31\u4f1a\u5728\u540c\u4e00\u4e2a\u5730\u65b9\u3002\u8fd9\u6837\u89e3\u51b3\u7684\u4f18\u70b9\u5c31\u662f\u975e\u5e38\u7b80\u5355\u3002\u7f3a\u70b9\u5c31\u662f\u5982\u679c\u6a21\u677f\u7c7b\u5728\u5f88\u591a\u5730\u65b9\u88ab\u4f7f\u7528\u7684\u8bdd\uff0c\u4f60\u5c31\u4f1a\u6700\u7ec8\u6709\u5f88\u591a\u6a21\u677f\u7c7b\u7684\u672c\u5730\u62f7\u8d1d\uff0c\u4f1a\u589e\u52a0\u4f60\u7684\u7f16\u8bd1\u548c\u8fde\u63a5\u7684\u8017\u65f6\uff08\u4f60\u7684\u8fde\u63a5\u5668\u4f1a\u79fb\u9664\u91cd\u590d\u7684\u5b9a\u4e49\uff0c\u56e0\u6b64\u4ed6\u4e0d\u4f1a\u8ba9\u53ef\u6267\u884c\u7a0b\u5e8f\u81a8\u80c0\uff09\u3002\u8fd9\u662f\u6211\u4eec\u7684\u5efa\u8bae\u505a\u6cd5\uff0c\u9664\u975e\u7f16\u8bd1\u5668\u6216\u8005\u8fde\u63a5\u5668\u6d88\u8017\u7684\u65f6\u95f4\u6210\u4e3a\u95ee\u9898\u3002 \u5982\u679c\u4f60\u89c9\u5f97\u628a Array.cpp \u7684\u4ee3\u7801\u653e\u8fdb Array.h \u5934\u90e8\u4f7f\u5f97\u4f60\u7684\u5934\u6587\u4ef6\u592a\u957f/\u4e71\uff0c\u4e00\u4e2a\u53ef\u9009\u7684\u65b9\u6848\u5c31\u662f\u5c06 Array.cpp \u547d\u540d\u4e3a Array.inl (.inl \u4ee3\u8868\u5185\u8054)\uff0c\u7136\u540e\u7d27\u63a5\u7740 \u5728 Array.h \u5934\u6587\u4ef6\u7684\u5e95\u90e8 include Array.inl \u3002\u548c\u628a\u4ee3\u7801\u653e\u5230\u5934\u6587\u4ef6\u7684\u7ed3\u679c\u662f\u4e00\u6837\u7684\uff0c\u4f46\u662f\u76f8\u5bf9\u6765\u8bf4\u66f4\u52a0\u5e72\u51c0\u3002 \u5176\u4ed6\u7684\u89e3\u51b3\u65b9\u6848\u6d89\u53ca #including .cpp \u6587\u4ef6\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u5efa\u8bae\u8fd9\u6837\u505a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u662f #include \u7684\u6807\u51c6\u7528\u6cd5\u3002 \u5176\u4ed6\u65b9\u6cd5\u662f\u4f7f\u7528\u4e09\u6587\u4ef6\u65b9\u6cd5\u3002\u6a21\u677f\u7c7b\u5b9a\u4e49\u5728 header \u5934\u6587\u4ef6\u4e2d\u3002\u6a21\u677f\u7c7b\u6210\u5458\u51fd\u6570\u7f16\u5199\u5728\u4ee3\u7801\u6587\u4ef6\u4e2d\u3002\u7136\u540e\u4f60\u6dfb\u52a0\u4e00\u4e2a \u201c\u7b2c\u4e09\u65b9\u201d \u6587\u4ef6\uff0c\u5c06\u8fd9\u4e24\u4e2a\u4f60\u5b9e\u4f8b\u5316\u7684\u7c7b\u6309\u9700\u5305\u542b\uff1a templates.cpp: // Ensure the full Array template definition can be seen # include \"Array.h\" # include \"Array.cpp\" // we're breaking best practices here, but only in this one place // #include other .h and .cpp template definitions you need here template class Array < int > ; // Explicitly instantiate template Array<int> template class Array < double > ; // Explicitly instantiate template Array<double> // instantiate other templates here \u201ctemplate class\u201d \u8ba9\u7f16\u8bd1\u5668\u6765\u663e\u5f0f\u7684\u5b9e\u4f8b\u5316\u6a21\u677f\u7c7b\u3002\u5728\u4e0a\u65b9\u7684\u4f8b\u5b50\u4e2d\uff0c\u7f16\u8bd1\u5668\u4f1a\u540c\u65f6\u751f\u6210 Array<int> \u548c Array<double> \u5728 template.cpp \u4e2d\u3002\u56e0\u4e3a templates.cpp \u5728\u6211\u4eec\u7684\u9879\u76ee\u4e2d\uff0c\u8fd9\u4e2a\u7d27\u63a5\u7740\u5c31\u4f1a\u88ab\u7f16\u8bd1\u3002\u7136\u540e\u8fd9\u4e9b\u51fd\u6570\u53ef\u4ee5\u88ab\u4ece\u5176\u4ed6\u5730\u65b9\u8fde\u63a5\u5230\u3002 \u8fd9\u65b9\u6cd5\u66f4\u9ad8\u6548\uff0c\u4f46\u662f\u9700\u8981\u4e3a\u6bcf\u4e2a\u7a0b\u5e8f\u7ba1\u7406 templaes.cpp \u6587\u4ef6\u3002","title":"\u5206\u5272\u6a21\u677f\u7c7b"},{"location":"19-templates/19.4-template-non-type-parameters/","text":"19.4 \u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570 \u00b6 By Alex on June 19 th , 2008 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u4f7f\u7528\u6a21\u677f\u6765\u521b\u5efa\u4e0d\u53d7\u7c7b\u578b\u5f71\u54cd\u7684\u51fd\u6570\u548c\u7c7b\u3002\u7136\u800c\uff0c\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u5e76\u4e0d\u662f\u6a21\u677f\u4e2d\u552f\u4e00\u53ef\u7528\u7684\u53c2\u6570\u3002\uff08However, template type parameters are not the only type of template parameters available.\uff09\u3002\u6a21\u677f\u7c7b\u578b\u548c\u51fd\u6570\u53ef\u4ee5\u5229\u7528\u53e6\u4e00\u7c7b\u7684\u6a21\u677f\u53c2\u6570\uff0c\u5b83\u4eec\u88ab\u53eb\u505a\u8d39\u7c7b\u578b\u53c2\u6570\uff08non-type parameter\uff09\u3002 \u975e\u7c7b\u578b\u53c2\u6570 \u00b6 \u4e00\u4e2a\u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u53c2\u6570\u4e0d\u9002\u5408\u7c7b\u578b\uff0c\u5374\u80fd\u88ab\u4e00\u4e2a\u503c\u66ff\u6362\u3002\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u53ef\u4ee5\u4e3a\u4ee5\u4e0b\u7684\u5176\u4e2d\u4e00\u4e2a\u3002 \u6574\u5f62\u6216\u679a\u4e3e\u578b\u7684\u503c \u6307\u5411\u7c7b\u5bf9\u8c61\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u51fd\u6570\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u4e00\u4e2a\u7c7b\u51fd\u6570\u7684\u7684\u6307\u9488\u6216\u5f15\u7528 std::nullptr_t \u5728\u4e0b\u5217\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u975e\u7c7b\u578b\uff08\u9759\u6001\uff09\u6570\u7ec4\u7c7b\uff0c\u540c\u65f6\u4f7f\u7528\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\u548c\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u9759\u6001\u6570\u7ec4\u6570\u636e\u7c7b\u578b\uff0c\u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u8fd9\u4e2a\u9759\u6001\u6570\u7ec4\u6709\u591a\u5927\u3002 #include <iostream> // size is the non-type parameter // size \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570 template < class T , int size > class StaticArray { private : // The non-type parameter controls the size of the array // \u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u6570\u7ec4\u7684\u5927\u5c0f T m_array [ size ]; public : T * getArray (); T & operator []( int index ) { return m_array [ index ]; } }; // \u5c55\u793a\u4e00\u4e2a\u5e26\u6709\u975e\u7c7b\u578b\u53c2\u6570\u7684\u6a21\u677f\u7c7b\u4e2d\u7684\u51fd\u6570\u662f\u5982\u4f55\u5728\u7c7b\u5916\u5b9a\u4e49 // Showing how a function for a class with a non-type parameter is defined outside of the class template < class T , int size > T * StaticArray < T , size >:: getArray () { return m_array ; } int main () { // declare an integer array with room for 12 integers StaticArray < int , 12 > intArray ; // Fill it up in order, then print it backwards for ( int count = 0 ; count < 12 ; ++ count ) intArray [ count ] = count ; for ( int count = 11 ; count >= 0 ; -- count ) std :: cout << intArray [ count ] << \" \" ; std :: cout << '\\n' ; // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray ; for ( int count = 0 ; count < 4 ; ++ count ) doubleArray [ count ] = 4.4 + 0.1 * count ; for ( int count = 0 ; count < 4 ; ++ count ) std :: cout << doubleArray [ count ] << ' ' ; return 0 ; } \u4ee3\u7801\u4ea7\u751f\u8ba9\u4ee5\u4e0b\u7ed3\u679c\uff1a 11 10 9 8 7 6 5 4 3 2 1 0 4.4 4.5 4.6 4.7 \u4e00\u70b9\u503c\u5f97\u6ce8\u610f\u7684\u4e8b\u60c5\u5173\u4e8e\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u6ca1\u6709\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u5728 m_array \u6210\u5458\u4e0a\uff01\u8fd9\u662f\u56e0\u4e3a\u4efb\u4f55\u4f20\u5165 StaticArray \u7c7b\u4e2d\u7684 size \u5b9e\u9645\u4e0a\u90fd\u662f\u4e00\u4e2a\u5e38\u6570\uff0c\u4f8b\u5982\u5982\u679c\u4f60\u5b9e\u4f8b\u5316\u4e86 StaticArray<int, 12> \uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u4f7f\u7528 12 \u66ff\u6362 size \u3002\u56e0\u6b64 m_array \u662f int[12] \u7c7b\u578b\u7684\uff0c\u8fd9\u53ef\u4ee5\u8fdb\u884c\u9759\u6001\u5206\u914d\u3002 \u8fd9\u4e2a\u529f\u80fd\u4e5f\u88ab\u7528\u5728\u6807\u51c6\u7c7b std::array \u4e2d\uff0c\u5f53\u4f60\u5206\u914d\u4e86\u4e00\u4e2a std::array<int, 5> \u65f6\uff0cint\u662f\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c5 \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002","title":"19.4 \u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570"},{"location":"19-templates/19.4-template-non-type-parameters/#194","text":"By Alex on June 19 th , 2008 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u4e86\u89e3\u5982\u4f55\u4f7f\u7528\u6a21\u677f\u6765\u521b\u5efa\u4e0d\u53d7\u7c7b\u578b\u5f71\u54cd\u7684\u51fd\u6570\u548c\u7c7b\u3002\u7136\u800c\uff0c\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u5e76\u4e0d\u662f\u6a21\u677f\u4e2d\u552f\u4e00\u53ef\u7528\u7684\u53c2\u6570\u3002\uff08However, template type parameters are not the only type of template parameters available.\uff09\u3002\u6a21\u677f\u7c7b\u578b\u548c\u51fd\u6570\u53ef\u4ee5\u5229\u7528\u53e6\u4e00\u7c7b\u7684\u6a21\u677f\u53c2\u6570\uff0c\u5b83\u4eec\u88ab\u53eb\u505a\u8d39\u7c7b\u578b\u53c2\u6570\uff08non-type parameter\uff09\u3002","title":"19.4 \u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570"},{"location":"19-templates/19.4-template-non-type-parameters/#_1","text":"\u4e00\u4e2a\u6a21\u677f\u975e\u7c7b\u578b\u53c2\u6570\u662f\u4e00\u4e2a\u7279\u6b8a\u7c7b\u578b\u7684\u53c2\u6570\u4e0d\u9002\u5408\u7c7b\u578b\uff0c\u5374\u80fd\u88ab\u4e00\u4e2a\u503c\u66ff\u6362\u3002\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u53ef\u4ee5\u4e3a\u4ee5\u4e0b\u7684\u5176\u4e2d\u4e00\u4e2a\u3002 \u6574\u5f62\u6216\u679a\u4e3e\u578b\u7684\u503c \u6307\u5411\u7c7b\u5bf9\u8c61\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u51fd\u6570\u7684\u6307\u9488\u6216\u5f15\u7528 \u6307\u5411\u4e00\u4e2a\u7c7b\u51fd\u6570\u7684\u7684\u6307\u9488\u6216\u5f15\u7528 std::nullptr_t \u5728\u4e0b\u5217\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u975e\u7c7b\u578b\uff08\u9759\u6001\uff09\u6570\u7ec4\u7c7b\uff0c\u540c\u65f6\u4f7f\u7528\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\u548c\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u9759\u6001\u6570\u7ec4\u6570\u636e\u7c7b\u578b\uff0c\u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u8fd9\u4e2a\u9759\u6001\u6570\u7ec4\u6709\u591a\u5927\u3002 #include <iostream> // size is the non-type parameter // size \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570 template < class T , int size > class StaticArray { private : // The non-type parameter controls the size of the array // \u975e\u7c7b\u578b\u53c2\u6570\u63a7\u5236\u6570\u7ec4\u7684\u5927\u5c0f T m_array [ size ]; public : T * getArray (); T & operator []( int index ) { return m_array [ index ]; } }; // \u5c55\u793a\u4e00\u4e2a\u5e26\u6709\u975e\u7c7b\u578b\u53c2\u6570\u7684\u6a21\u677f\u7c7b\u4e2d\u7684\u51fd\u6570\u662f\u5982\u4f55\u5728\u7c7b\u5916\u5b9a\u4e49 // Showing how a function for a class with a non-type parameter is defined outside of the class template < class T , int size > T * StaticArray < T , size >:: getArray () { return m_array ; } int main () { // declare an integer array with room for 12 integers StaticArray < int , 12 > intArray ; // Fill it up in order, then print it backwards for ( int count = 0 ; count < 12 ; ++ count ) intArray [ count ] = count ; for ( int count = 11 ; count >= 0 ; -- count ) std :: cout << intArray [ count ] << \" \" ; std :: cout << '\\n' ; // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray ; for ( int count = 0 ; count < 4 ; ++ count ) doubleArray [ count ] = 4.4 + 0.1 * count ; for ( int count = 0 ; count < 4 ; ++ count ) std :: cout << doubleArray [ count ] << ' ' ; return 0 ; } \u4ee3\u7801\u4ea7\u751f\u8ba9\u4ee5\u4e0b\u7ed3\u679c\uff1a 11 10 9 8 7 6 5 4 3 2 1 0 4.4 4.5 4.6 4.7 \u4e00\u70b9\u503c\u5f97\u6ce8\u610f\u7684\u4e8b\u60c5\u5173\u4e8e\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u6ca1\u6709\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u5728 m_array \u6210\u5458\u4e0a\uff01\u8fd9\u662f\u56e0\u4e3a\u4efb\u4f55\u4f20\u5165 StaticArray \u7c7b\u4e2d\u7684 size \u5b9e\u9645\u4e0a\u90fd\u662f\u4e00\u4e2a\u5e38\u6570\uff0c\u4f8b\u5982\u5982\u679c\u4f60\u5b9e\u4f8b\u5316\u4e86 StaticArray<int, 12> \uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u4f7f\u7528 12 \u66ff\u6362 size \u3002\u56e0\u6b64 m_array \u662f int[12] \u7c7b\u578b\u7684\uff0c\u8fd9\u53ef\u4ee5\u8fdb\u884c\u9759\u6001\u5206\u914d\u3002 \u8fd9\u4e2a\u529f\u80fd\u4e5f\u88ab\u7528\u5728\u6807\u51c6\u7c7b std::array \u4e2d\uff0c\u5f53\u4f60\u5206\u914d\u4e86\u4e00\u4e2a std::array<int, 5> \u65f6\uff0cint\u662f\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c5 \u662f\u4e00\u4e2a\u975e\u7c7b\u578b\u53c2\u6570\u3002","title":"\u975e\u7c7b\u578b\u53c2\u6570"},{"location":"19-templates/19.5-function-template-specialization/","text":"19.5 \u51fd\u6570\u6a21\u677f\u7279\u5316 \u00b6 By Alex on December 3 rd , 2016 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5f53\u4f60\u5b9e\u4f8b\u5316\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\uff0c\u4f7f\u7528\u7ed9\u5b9a\u7684\u7c7b\u578b\uff0c\u7f16\u8bd1\u5668\u4f1a\u590d\u523b\u4e00\u4efd\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u7528\u5b9e\u9645\u5b9a\u4e49\u7684\u8981\u4f7f\u7528\u7684\u53c2\u6570\u7c7b\u578b\u66ff\u6362\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u3002\u8fd9\u610f\u5473\u7740\u4e00\u4e2a\u7279\u5b9a\u7684\u51fd\u6570\u5c06\u4f1a\u5728\u6bcf\u4e2a\u5b9e\u4f8b\u7c7b\u6709\u540c\u6837\u7684\u5b9e\u73b0\u7ec6\u8282\uff08\u4e5f\u5c31\u662f\u8bf4\u53ea\u662f\u7c7b\u578b\u4e0d\u540c\uff09\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u8fd9\u6b63\u662f\u4f60\u60f3\u8981\u7684\uff0c\u5076\u5c14\u4e5f\u6709\u4e00\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5728\u67d0\u4e9b\u7279\u6b8a\u7c7b\u578b\u7684\u6570\u636e\u4e0a\u5b9e\u4f8b\u5316\u6a21\u677f\u51fd\u6570\u4f1a\u6709\u8f7b\u5fae\u7684\u4e0d\u540c\u3002 \u6a21\u677f\u7279\u5316\u5c31\u662f\u89e3\u51b3\u8fd9\u4e2a\u7684\u65b9\u6cd5\u4e4b\u4e00\u3002 \u8ba9\u6211\u4eec\u54ea\u6765\u770b\u4e00\u4e2a\u5f88\u7b80\u5355\u7684\u4f8b\u5b50\uff1a template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; \u4ee5\u4e0a\u7684\u4ee3\u7801\u53ef\u4ee5\u5728\u5f88\u591a\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\u3002 int main () { // Define some storage units Storage < int > nValue ( 5 ); Storage < double > dValue ( 6.7 ); // Print out some values nValue . print (); dValue . print (); } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c 5 6.7 \u73b0\u5728\uff0c\u5047\u8bbe\u8bf4\u6211\u4eec\u60f3\u8981 double \u7c7b\u578b\uff08\u4ec5\u4ec5\u662f\u53cc\u7cbe\u6d6e\u70b9\u6570\uff09\u8f93\u51fa\u4e3a\u7279\u6b8a\u7684\u79d1\u5b66\u8ba1\u6570\u6cd5\u3002\u4e3a\u4e86\u8fbe\u5230\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u51fd\u6570\u6a21\u677f\u7279\u5316\uff08\u6709\u65f6\u4e5f\u53eb\u505a\u663e\u5f0f\u51fd\u6570\u6a21\u677f\u7279\u5316\uff09\u6765\u4e3a double \u521b\u5efa\u4e00\u4e2a\u7279\u6b8a\u7248\u672c\u7684 print() \u51fd\u6570\u3002\u8fd9\u76f8\u5f53\u7b80\u5355\uff1a\u7b80\u5355\u7684\u5b9a\u4e49\u7279\u5316\u7684\u51fd\u6570\uff08\u5982\u679c\u51fd\u6570\u662f\u4e00\u4e2a\u7c7b\u578b\uff0c\u5728\u7c7b\u5b9a\u4e49\u5916\u7167\u505a\u5373\u53ef\u3002\uff09\u66ff\u6362\u6a21\u677f\u7c7b\u4e3a\u4f60\u60f3\u8981\u4e3a\u4e4b\u91cd\u5b9a\u4e49\u7684\u7279\u6b8a\u7c7b\u578b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u4e3adoubles\u4e13\u95e8\u7279\u5316\u540e\u7684 print() \u51fd\u6570\uff1a template <> void Storage < double >:: print () { std :: cout << std :: scientific << m_value << '\\n' ; } \u5f53\u7f16\u8bd1\u5668\u5b9e\u4f8b\u5316 Storage<double>::print() \uff0c\u4ed6\u4f1a\u68c0\u67e5\u6211\u4eec\u65e9\u5c31\u663e\u5f0f\u7684\u5b9a\u4e49\u4e86\u51fd\u6570\uff0c\u5e76\u4e14\u5b83\u5c06\u4f1a\u4f7f\u7528\u90a3\u4e2a\u6211\u4eec\u65e9\u5c31\u5b9a\u4e49\u597d\u7684\u51fd\u6570\u66ff\u6362\u901a\u7528\u6a21\u677f\u51fd\u6570\u3002 \u6a21\u677f <> \u544a\u8bc9\u7f16\u8bd1\u5668\u8fd9\u662f\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u6ca1\u6709\u6a21\u677f\u53c2\u6570\uff08\u56e0\u4e3a\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u6211\u4eec\u5df2\u7ecf\u663e\u5f0f\u7684\u5236\u5b9a\u4e86\u6240\u6709\u53c2\u6570\uff09\u3002\u4e00\u4e9b\u7f16\u8bd1\u5668\u53ef\u80fd\u5141\u8bb8\u4f60\u7701\u7565\u8fd9\u4e2a\uff0c\u4f46\u662f\u5e26\u4e0a\u5b83\u66f4\u5408\u9002\u3002 \u7ed3\u679c\uff0c\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u4e4b\u524d\u7684\u7684\u7a0b\u5e8f\uff0c\u5c06\u4f1a\u6253\u5370\uff1a 5 6.700000e+000 \u53e6\u4e00\u4e2a\u4f8b\u5b50 \u73b0\u5728\u8ba9\u6211\u4eec\u6765\u4e3e\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u7684\u51fd\u6570\u7279\u5316\u662f\u53ef\u4ee5\u975e\u5e38\u6709\u7528\u3002\u601d\u8003\u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 char* \u6765\u5b9e\u4f8b\u5316\u6211\u4eec\u7684\u6a21\u677f\u7c7b Storage \uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { // Dynamically allocate a temporary string char * string = new char [ 40 ]; // Ask user for their name std :: cout << \"Enter your name: \" ; std :: cin >> string ; // Store the name Storage < char *> storage ( string ); // Delete the temporary string delete [] string ; // Print out our value storage . print (); // This will print garbage } \u5f53\u7ed3\u679c\u51fa\u73b0\u65f6\uff0c\u4ee3\u66ff\u672c\u5e94\u8be5\u6253\u5370\u7528\u6237\u8f93\u5165\u7684 storage.print() \u6253\u5370\u4e86\u5783\u573e\uff08garbage\uff09\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5f53 Storate \u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c Storage<char*> \u7684\u6784\u9020\u51fd\u6570\u770b\u8d77\u6765\u5c31\u50cf\u8fd9\u6837\uff1a template <> Storage < char *>:: Storage ( char * value ) { m_value = value ; } \u6362\u53e5\u8bdd\u8bf4\uff0c\u8fd9\u5c31\u662f\u505a\u4e86\u4e00\u4e2a\u6307\u9488\u8d4b\u503c\uff08\u6d45\u62f7\u8d1d\uff09\uff01\u7ed3\u679c\uff0c m_value \u548c string \u6307\u5411\u76f8\u540c\u7684\u5185\u5b58\u5730\u5740\u3002\u5f53\u6211\u4eec\u5220\u9664 string \u5728 main \u4e2d\uff0c\u6211\u4eec\u5220\u9664\u4e86 m_value \u6307\u5411\u7684\u6570\u636e\uff01\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u6253\u5370\u8fd9\u4e9b\u503c\u65f6\uff0c\u51fa\u73b0\u7684\u5c31\u662f\u4e00\u4e9b\u5783\u573e\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6a21\u677f\u7279\u5316\u4fee\u590d\u8fd9\u4e9b\u95ee\u9898\u3002\u76f8\u6bd4\u4e8e\u505a\u4e00\u4e2a\u6307\u9488\u62f7\u8d1d\uff0c\u6211\u4eec\u5e94\u8be5\u50cf\u6784\u9020\u51fd\u6570\u90a3\u6837\uff0c\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u505a\u4e00\u4e2a\u5b8c\u5168\u62f7\u8d1d\u3002\u56e0\u6b64\u6211\u4eec\u6765\u4e3a char* \u8fd9\u4e2a\u7c7b\u5199\u4e00\u4e2a\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\uff0c\uff0c\u4e13\u95e8\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } \u73b0\u5728\u5f53\u4e3a Strorage<char*> \u7ed9\u53d8\u91cf\u5206\u914d\u5185\u5b58\u65f6\uff0c\u8fd9\u4e2a\u6784\u9020\u51fd\u6570\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u66ff\u4ee3\u9ed8\u8ba4\u7684\u90a3\u4e2a\u3002\u7ed3\u679c m_value \u5c06\u4f1a\u6536\u5230\u5b83\u81ea\u5df1\u7684\u90a3\u4efd string \u7684\u62f7\u8d1d\u3002\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u5220\u9664 string \u65f6\uff0cm_value \u5c06\u4e0d\u4f1a\u88ab\u5f71\u54cd\u3002 \u7136\u800c\uff0c\u8fd9\u4e2a\u7c7b\u73b0\u5728\u6709\u5185\u5b58\u6cc4\u9732\u5f53\u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c\u56e0\u4e3a m_value \u5c06\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u5f53\u4e00\u4e2a Storage \u53d8\u91cf\u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\u3002\u5c31\u50cf\u4f60\u731c\u7684\u90a3\u6837\uff0c\u8fd9\u4e5f\u53ef\u4ee5\u88ab\u89e3\u51b3\uff0c\u901a\u8fc7\u7279\u5316 Storage<char*> \u3002 template <> Storage < char *>::~ Storage () { delete [] m_value ; } \u73b0\u5728\u5f53 Storate<char*> \u79bb\u5f00\u4f5c\u7528\u4e8e\u7684\u65f6\u5019\uff0c\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\u5206\u914d\u7684\u5185\u5b58\u5c06\u4f1a\u88ab\u7279\u5316\u7684\u6790\u6784\u51fd\u6570\u7ed9\u5220\u9664\u3002 \u4ee5\u4e0a\u7684\u4f8b\u5b50\u867d\u7136\u5168\u90fd\u7528\u4e86\u6210\u5458\u51fd\u6570\uff0c\u4f60\u4ecd\u7136\u53ef\u4ee5\u7279\u5316\u4e00\u4e2a\u975e\u6210\u5458\u6a21\u677f\u51fd\u6570\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u3002","title":"19.5 \u51fd\u6570\u6a21\u677f\u7279\u5316"},{"location":"19-templates/19.5-function-template-specialization/#195","text":"By Alex on December 3 rd , 2016 | last modified by Alex on January 23 rd , 2020 | \u7ffb\u8bd1by dashjay 2020.07.10 \u5f53\u4f60\u5b9e\u4f8b\u5316\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\uff0c\u4f7f\u7528\u7ed9\u5b9a\u7684\u7c7b\u578b\uff0c\u7f16\u8bd1\u5668\u4f1a\u590d\u523b\u4e00\u4efd\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u7528\u5b9e\u9645\u5b9a\u4e49\u7684\u8981\u4f7f\u7528\u7684\u53c2\u6570\u7c7b\u578b\u66ff\u6362\u6a21\u677f\u7c7b\u578b\u53c2\u6570\u3002\u8fd9\u610f\u5473\u7740\u4e00\u4e2a\u7279\u5b9a\u7684\u51fd\u6570\u5c06\u4f1a\u5728\u6bcf\u4e2a\u5b9e\u4f8b\u7c7b\u6709\u540c\u6837\u7684\u5b9e\u73b0\u7ec6\u8282\uff08\u4e5f\u5c31\u662f\u8bf4\u53ea\u662f\u7c7b\u578b\u4e0d\u540c\uff09\u3002\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u8fd9\u6b63\u662f\u4f60\u60f3\u8981\u7684\uff0c\u5076\u5c14\u4e5f\u6709\u4e00\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5728\u67d0\u4e9b\u7279\u6b8a\u7c7b\u578b\u7684\u6570\u636e\u4e0a\u5b9e\u4f8b\u5316\u6a21\u677f\u51fd\u6570\u4f1a\u6709\u8f7b\u5fae\u7684\u4e0d\u540c\u3002 \u6a21\u677f\u7279\u5316\u5c31\u662f\u89e3\u51b3\u8fd9\u4e2a\u7684\u65b9\u6cd5\u4e4b\u4e00\u3002 \u8ba9\u6211\u4eec\u54ea\u6765\u770b\u4e00\u4e2a\u5f88\u7b80\u5355\u7684\u4f8b\u5b50\uff1a template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; \u4ee5\u4e0a\u7684\u4ee3\u7801\u53ef\u4ee5\u5728\u5f88\u591a\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\u3002 int main () { // Define some storage units Storage < int > nValue ( 5 ); Storage < double > dValue ( 6.7 ); // Print out some values nValue . print (); dValue . print (); } \u8fd9\u5c06\u4ea7\u751f\u7ed3\u679c 5 6.7 \u73b0\u5728\uff0c\u5047\u8bbe\u8bf4\u6211\u4eec\u60f3\u8981 double \u7c7b\u578b\uff08\u4ec5\u4ec5\u662f\u53cc\u7cbe\u6d6e\u70b9\u6570\uff09\u8f93\u51fa\u4e3a\u7279\u6b8a\u7684\u79d1\u5b66\u8ba1\u6570\u6cd5\u3002\u4e3a\u4e86\u8fbe\u5230\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u51fd\u6570\u6a21\u677f\u7279\u5316\uff08\u6709\u65f6\u4e5f\u53eb\u505a\u663e\u5f0f\u51fd\u6570\u6a21\u677f\u7279\u5316\uff09\u6765\u4e3a double \u521b\u5efa\u4e00\u4e2a\u7279\u6b8a\u7248\u672c\u7684 print() \u51fd\u6570\u3002\u8fd9\u76f8\u5f53\u7b80\u5355\uff1a\u7b80\u5355\u7684\u5b9a\u4e49\u7279\u5316\u7684\u51fd\u6570\uff08\u5982\u679c\u51fd\u6570\u662f\u4e00\u4e2a\u7c7b\u578b\uff0c\u5728\u7c7b\u5b9a\u4e49\u5916\u7167\u505a\u5373\u53ef\u3002\uff09\u66ff\u6362\u6a21\u677f\u7c7b\u4e3a\u4f60\u60f3\u8981\u4e3a\u4e4b\u91cd\u5b9a\u4e49\u7684\u7279\u6b8a\u7c7b\u578b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u4e3adoubles\u4e13\u95e8\u7279\u5316\u540e\u7684 print() \u51fd\u6570\uff1a template <> void Storage < double >:: print () { std :: cout << std :: scientific << m_value << '\\n' ; } \u5f53\u7f16\u8bd1\u5668\u5b9e\u4f8b\u5316 Storage<double>::print() \uff0c\u4ed6\u4f1a\u68c0\u67e5\u6211\u4eec\u65e9\u5c31\u663e\u5f0f\u7684\u5b9a\u4e49\u4e86\u51fd\u6570\uff0c\u5e76\u4e14\u5b83\u5c06\u4f1a\u4f7f\u7528\u90a3\u4e2a\u6211\u4eec\u65e9\u5c31\u5b9a\u4e49\u597d\u7684\u51fd\u6570\u66ff\u6362\u901a\u7528\u6a21\u677f\u51fd\u6570\u3002 \u6a21\u677f <> \u544a\u8bc9\u7f16\u8bd1\u5668\u8fd9\u662f\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\uff0c\u5e76\u4e14\u6ca1\u6709\u6a21\u677f\u53c2\u6570\uff08\u56e0\u4e3a\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u6211\u4eec\u5df2\u7ecf\u663e\u5f0f\u7684\u5236\u5b9a\u4e86\u6240\u6709\u53c2\u6570\uff09\u3002\u4e00\u4e9b\u7f16\u8bd1\u5668\u53ef\u80fd\u5141\u8bb8\u4f60\u7701\u7565\u8fd9\u4e2a\uff0c\u4f46\u662f\u5e26\u4e0a\u5b83\u66f4\u5408\u9002\u3002 \u7ed3\u679c\uff0c\u6211\u4eec\u518d\u6b21\u8fd0\u884c\u4e4b\u524d\u7684\u7684\u7a0b\u5e8f\uff0c\u5c06\u4f1a\u6253\u5370\uff1a 5 6.700000e+000 \u53e6\u4e00\u4e2a\u4f8b\u5b50 \u73b0\u5728\u8ba9\u6211\u4eec\u6765\u4e3e\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff0c\u8fd9\u65f6\u5019\u7684\u51fd\u6570\u7279\u5316\u662f\u53ef\u4ee5\u975e\u5e38\u6709\u7528\u3002\u601d\u8003\u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 char* \u6765\u5b9e\u4f8b\u5316\u6211\u4eec\u7684\u6a21\u677f\u7c7b Storage \uff0c\u5c06\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f int main () { // Dynamically allocate a temporary string char * string = new char [ 40 ]; // Ask user for their name std :: cout << \"Enter your name: \" ; std :: cin >> string ; // Store the name Storage < char *> storage ( string ); // Delete the temporary string delete [] string ; // Print out our value storage . print (); // This will print garbage } \u5f53\u7ed3\u679c\u51fa\u73b0\u65f6\uff0c\u4ee3\u66ff\u672c\u5e94\u8be5\u6253\u5370\u7528\u6237\u8f93\u5165\u7684 storage.print() \u6253\u5370\u4e86\u5783\u573e\uff08garbage\uff09\uff01\u53d1\u751f\u4e86\u4ec0\u4e48\uff1f \u5f53 Storate \u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c Storage<char*> \u7684\u6784\u9020\u51fd\u6570\u770b\u8d77\u6765\u5c31\u50cf\u8fd9\u6837\uff1a template <> Storage < char *>:: Storage ( char * value ) { m_value = value ; } \u6362\u53e5\u8bdd\u8bf4\uff0c\u8fd9\u5c31\u662f\u505a\u4e86\u4e00\u4e2a\u6307\u9488\u8d4b\u503c\uff08\u6d45\u62f7\u8d1d\uff09\uff01\u7ed3\u679c\uff0c m_value \u548c string \u6307\u5411\u76f8\u540c\u7684\u5185\u5b58\u5730\u5740\u3002\u5f53\u6211\u4eec\u5220\u9664 string \u5728 main \u4e2d\uff0c\u6211\u4eec\u5220\u9664\u4e86 m_value \u6307\u5411\u7684\u6570\u636e\uff01\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u6253\u5370\u8fd9\u4e9b\u503c\u65f6\uff0c\u51fa\u73b0\u7684\u5c31\u662f\u4e00\u4e9b\u5783\u573e\u3002 \u5e78\u8fd0\u7684\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6a21\u677f\u7279\u5316\u4fee\u590d\u8fd9\u4e9b\u95ee\u9898\u3002\u76f8\u6bd4\u4e8e\u505a\u4e00\u4e2a\u6307\u9488\u62f7\u8d1d\uff0c\u6211\u4eec\u5e94\u8be5\u50cf\u6784\u9020\u51fd\u6570\u90a3\u6837\uff0c\u5bf9\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u505a\u4e00\u4e2a\u5b8c\u5168\u62f7\u8d1d\u3002\u56e0\u6b64\u6211\u4eec\u6765\u4e3a char* \u8fd9\u4e2a\u7c7b\u5199\u4e00\u4e2a\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\uff0c\uff0c\u4e13\u95e8\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } \u73b0\u5728\u5f53\u4e3a Strorage<char*> \u7ed9\u53d8\u91cf\u5206\u914d\u5185\u5b58\u65f6\uff0c\u8fd9\u4e2a\u6784\u9020\u51fd\u6570\u5c06\u4f1a\u88ab\u4f7f\u7528\u6765\u66ff\u4ee3\u9ed8\u8ba4\u7684\u90a3\u4e2a\u3002\u7ed3\u679c m_value \u5c06\u4f1a\u6536\u5230\u5b83\u81ea\u5df1\u7684\u90a3\u4efd string \u7684\u62f7\u8d1d\u3002\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u5220\u9664 string \u65f6\uff0cm_value \u5c06\u4e0d\u4f1a\u88ab\u5f71\u54cd\u3002 \u7136\u800c\uff0c\u8fd9\u4e2a\u7c7b\u73b0\u5728\u6709\u5185\u5b58\u6cc4\u9732\u5f53\u4f7f\u7528 char* \u5b9e\u4f8b\u5316\u65f6\uff0c\u56e0\u4e3a m_value \u5c06\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u5f53\u4e00\u4e2a Storage \u53d8\u91cf\u79bb\u5f00\u4f5c\u7528\u4e8e\u65f6\u3002\u5c31\u50cf\u4f60\u731c\u7684\u90a3\u6837\uff0c\u8fd9\u4e5f\u53ef\u4ee5\u88ab\u89e3\u51b3\uff0c\u901a\u8fc7\u7279\u5316 Storage<char*> \u3002 template <> Storage < char *>::~ Storage () { delete [] m_value ; } \u73b0\u5728\u5f53 Storate<char*> \u79bb\u5f00\u4f5c\u7528\u4e8e\u7684\u65f6\u5019\uff0c\u7279\u5316\u7684\u6784\u9020\u51fd\u6570\u5206\u914d\u7684\u5185\u5b58\u5c06\u4f1a\u88ab\u7279\u5316\u7684\u6790\u6784\u51fd\u6570\u7ed9\u5220\u9664\u3002 \u4ee5\u4e0a\u7684\u4f8b\u5b50\u867d\u7136\u5168\u90fd\u7528\u4e86\u6210\u5458\u51fd\u6570\uff0c\u4f60\u4ecd\u7136\u53ef\u4ee5\u7279\u5316\u4e00\u4e2a\u975e\u6210\u5458\u6a21\u677f\u51fd\u6570\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u3002","title":"19.5 \u51fd\u6570\u6a21\u677f\u7279\u5316"},{"location":"19-templates/19.6-class-template-specialization/","text":"19.6 \u7c7b\u6a21\u677f\u7279\u5316 \u00b6 By Alex on August 16 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 by dashjay 2020-12-27 |\u6700\u540e\u4fee\u6539\u4e8e 2020-12-27 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b 19.5 -- Function template specialization \uff0c\u6211\u4eec\u77e5\u9053\u4e86\u53ef\u4ee5\u7279\u5316\u51fd\u6570\uff0c\u4e3a\u4e86\u7ed9\u7279\u6b8a\u7684\u6570\u636e\u7c7b\u578b\u63d0\u4f9b\u4e0d\u540c\u7684\u529f\u80fd\u3002\u4e0d\u4ec5\u4ec5\u53ef\u4ee5\u7279\u5316\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u7279\u5316\u6574\u4e2a\u7c7b\uff01 \u601d\u8003\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u4f60\u60f3\u8bbe\u8ba1\u4e00\u4e2a\u7c7b\u53ef\u4ee5\u5b58\u50a8 8 \u4e2a\u5bf9\u8c61\u3002\u8fd9\u6709\u4e00\u4e2a\u7b80\u5316\u7c7b\u8fd9\u6837\u505a\uff1a template < class T > class Storage8 { private : T m_array [ 8 ]; public : void set ( int index , const T & value ) { m_array [ index ] = value ; } const T & get ( int index ) const { return m_array [ index ]; } }; \u56e0\u4e3a\u8fd9\u4e2a\u7c7b\u662f\u6a21\u677f\u7c7b\uff0c\u5b83\u80fd\u5728\u4efb\u4f55\u7ed9\u5b9a\u7684\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff1a #include <iostream> int main () { // Define a Storage8 for integers Storage8 < int > intStorage ; for ( int count { 0 }; count < 8 ; ++ count ) intStorage . set ( count , count ); for ( int count { 0 }; count < 8 ; ++ count ) std :: cout << intStorage . get ( count ) << '\\n' ; // Define a Storage8 for bool Storage8 < bool > boolStorage ; for ( int count { 0 }; count < 8 ; ++ count ) boolStorage . set ( count , count & 3 ); std :: cout << std :: boolalpha ; for ( int count { 0 }; count < 8 ; ++ count ) { std :: cout << boolStorage . get ( count ) << '\\n' ; } return 0 ; } \u4f8b\u5b50\u6253\u5370\uff1a 0 1 2 3 4 5 6 7 false true true true false true true true \u8fd9\u4e2a\u7c7b\u662f\u53ef\u4ee5\u5b8c\u5168\u6b63\u5e38\u5de5\u4f5c\u7684\uff0c\u4f46\u662f\u5c31\u662f Storage8<bool> \u7684\u5b9e\u73b0\u6548\u7387\u8fdc\u8fdc\u4f4e\u4e8e\u5b9e\u9645\u9700\u8981\u3002\u56e0\u4e3a\u6240\u6709\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u4e00\u4e2a\u5730\u5740\uff0c\u5e76\u4e14 CPU \u4e0d\u80fd\u5b9a\u4f4d\u6bd4\u4e00 byte \u66f4\u5c0f\u7684\u5355\u4f4d\uff0c\u6240\u6709\u53d8\u91cf\u5fc5\u987b\u81f3\u5c11\u662f 1 byte\u3002\u56e0\u6b64\uff0c\u4e00\u4e2a bool \u503c\u6574\u6574\u7528\u6389\u4e86\u6574\u4e2a byte\uff0c\u7136\u540e 7 bits \u90fd\u88ab\u6d6a\u8d39\u4e86\u3002\u6211\u4eec\u7684 Storage8<bool> \u7c7b\u4e00\u5171\u5305\u542b\u4e86 8 \u4e2abool\u503c\uff0c\u5176\u4e2d 1 byte \u662f\u5305\u542b\u6709\u7528\u7684\u4fe1\u606f\uff0c\u53e6\u5916 7 byte \u90fd\u662f\u6d6a\u8d39\u7684\u3002 \u7ed3\u679c\uff0c\u4f7f\u7528\u4e00\u4e2a\u57fa\u7840\u4f4d\u903b\u8f91\uff0c\u6709\u53ef\u80fd\u5427 8 \u4e2a bool \u503c\u538b\u7f29\u5230\u4e00\u4e2a\u5355 byte \u4e2d\uff0c\u6d88\u9664\u6d6a\u8d39\u7684\u7a7a\u95f4\u5230\u4e00\u8d77\u3002\u7136\u800c\uff0c\u4e3a\u4e86\u8fbe\u6210\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u9700\u8981\u5728\u4f7f\u7528 bool \u7684\u65f6\u5019\uff0c\u4fee\u6539\u8fd9\u4e2a\u7c7b\u578b\uff0c\u66ff\u6362 8 \u4e2a bool \u7684\u6570\u7ec4\u4e3a\u4e00\u4e2a\u5355 byte \u5927\u5c0f\u7684\u53d8\u91cf\u3002\u6211\u4eec\u5f53\u7136\u53ef\u4ee5\u521b\u5efa\u6574\u4e2a\u7684\u65b0\u7c7b\u6765\u5b8c\u6210\u9700\u6c42\uff0c\u4f46\u662f\u8fd9\u6837\u505a\u6709\u4e00\u4e2a\u6700\u5927\u7684\u7f3a\u70b9\u5c31\u662f\uff1a\u6211\u4eec\u4e0d\u5f97\u4e0d\u53d6\u4e00\u4e2a\u65b0\u7684\u540d\u5b57\u3002\u7a0b\u5e8f\u5458\u5c31\u5fc5\u987b\u8bb0\u5728\u8111\u5b50\u91cc\uff0c Storage8<T> \u4e0d\u80fd\u63d0\u4f9b\u7ed9 bool \u7c7b\u4f7f\u7528\uff0c\u5fc5\u987b\u4f7f\u7528 Storage8Bool \uff08\u6216\u8005\u4ec0\u4e48\u5176\u4ed6\u7684\u65b0\u7c7b\uff09\u3002\u8fd9\u4e9b\u6ca1\u6709\u5fc5\u8981\u7684\u590d\u6742\u6211\u4eec\u5e94\u8be5\u907f\u514d\u3002\u5e78\u8fd0\u7684\u662f\uff0cC++ \u7ed9\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u79cd\u66f4\u597d\u7684\u65b9\u6cd5\uff1a\u7c7b\u6a21\u677f\u7279\u5316\u3002 \u7c7b\u6a21\u677f\u7279\u5316 \u00b6 \u7c7b\u6a21\u677f\u7279\u5316\u5141\u8bb8\u6211\u4eec\u7279\u5316\u6a21\u677f\u5728\u67d0\u4e2a\u7279\u5b9a\u7c7b\u578b\uff08\u6216\u8005\u51e0\u4e2a\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\uff0c\u5982\u679c\u4e0d\u6b62\u4e00\u4e2a\u6a21\u677f\u53c2\u6570\u7684\u8bdd\uff09\u3002\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u8981\u53bb\u4f7f\u7528\u6a21\u677f\u7c7b\u7279\u5316\u6765\u5199\u4e00\u4e2a\u7279\u5b9a\u7248\u672c\u7684 Storage8<bool> \u5c06\u4f1a\u6bd4\u6cdb\u578b\u7684 Storage8<T> \u7c7b\u4f18\u5148\u7ea7\u66f4\u9ad8\u3002\u8fd9\u4e2a\u7c7b\u4f3c\u4e8e\u7279\u5b9a\u51fd\u6570\u4f18\u5148\u4e8e\u6cdb\u578b\u6a21\u677f\u51fd\u6570\u3002 \u5c3d\u7ba1\u4ed6\u4eec\u548c\u6a21\u677f\u7c7b\u4e00\u6837\uff0c\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u5206\u914d\uff0c\u7c7b\u6a21\u677f\u7279\u5316\u88ab\u5f53\u505a\u662f\u72ec\u7acb\u7684\u7c7b\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u53ef\u4ee5\u6539\u53d8\u5173\u4e8e\u6211\u4eec\u7279\u5316\u6a21\u677f\u7684\u4efb\u4f55\u5185\u5bb9\uff0c\u5305\u542b\u5b83\u5b9e\u73b0\u00b7\u7684\u65b9\u5f0f\uff0c\u751a\u81f3\u662f\u516c\u5f00\u7684\u51fd\u6570\uff0c\u5c31\u50cf\u4ed6\u662f\u4e00\u4e2a\u72ec\u7acb\u7684\u7c7b\uff0c\u8fd9\u662f\u6211\u4eec\u7684\u7279\u5316\u7c7b\uff1a template <> // the following is a template class with no templated parameters class Storage8 < bool > // we're specializing Storage8 for bool { // What follows is just standard class implementation details private : unsigned char m_data {}; public : void set ( int index , bool value ) { // Figure out which bit we're setting/unsetting // This will put a 1 in the bit we're interested in turning on/off auto mask { 1 << index }; if ( value ) // If we're setting a bit m_data |= mask ; // Use bitwise-or to turn that bit on else // if we're turning a bit off m_data &= ~ mask ; // bitwise-and the inverse mask to turn that bit off } bool get ( int index ) { // Figure out which bit we're getting auto mask { 1 << index }; // bitwise-and to get the value of the bit we're interested in // Then implicit cast to boolean return ( m_data & mask ); } }; \u9996\u5148\uff0c\u6ce8\u610f\u6211\u4eec\u4f7f\u7528 template<> \u6765\u5f00\u59cb\u3002\u6a21\u677f\u5173\u952e\u8bcd\u544a\u8bc9\u7f16\u8bd1\u5668\u4e0b\u65b9\u7684\u5185\u5bb9\u662f\u5c5e\u4e8e\u6a21\u677f\u7684\uff0c\u7a7a\u7684\u5c16\u62ec\u53f7\u8868\u793a\u6ca1\u6709\u4efb\u4f55\u6a21\u677f\u53c2\u6570\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u65e0\u9700\u4efb\u4f55\u7684\u6a21\u677f\u53c2\u6570\uff0c\u56e0\u4e3a\u6211\u4eec\u66ff\u6362\u4ec5\u6709\u7684\u6a21\u677f\u53c2\u6570\uff08T\uff09\u4e3a\u7279\u5b9a\u7684\u7c7b\u578b\uff08bool\uff09\u3002 \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u6dfb\u52a0\u4e86 <bool> \u5230\u7c7b\u540d\u6765\u8868\u793a\u6211\u4eec\u7279\u5316\u4e86 bool \u7248\u672c\u7684 Storage8 \u7c7b\u3002 \u6240\u6709\u7684\u5176\u4ed6\u7684\u6539\u53d8\u5c31\u53ea\u662f\u7c7b\u5b9e\u73b0\u7684\u7ec6\u8282\u3002\u4ec5\u4ec5\u4e3a\u4e86\u4f7f\u7528\u8fd9\u4e2a\u7c7b\uff0c\u4f60\u5b8c\u5168\u6ca1\u6709\u5fc5\u8981\u7406\u89e3\u4f4d\u903b\u8f91\uff08\u5c3d\u7ba1\u4f60\u53ef\u4ee5\u590d\u4e60 O.2 -- Bitwise operators \u5982\u679c\u4f60\u60f3\u8981\u89e3\u51b3\uff0c\u4f46\u662f\u9700\u8981\u590d\u4e60\u5982\u4f55\u8fdb\u884c\u672a\u64cd\u4f5c\uff09\u3002 \u6ce8\u610f\u8fd9\u4e2a\u7279\u5316\u7c7b\u5229\u7528\u4e86\u4e00\u4e2a single unsigned char (1 byte) \u66ff\u6362\u4e86\u4e00\u4e2a 8 \u4e2a bool \u7684\u6570\u7ec4\uff088 bytes\uff09\u3002 \u73b0\u5728\uff0c\u5f53\u6211\u4eec\u751f\u547d\u4e00\u4e2a\u7c7b\u578b\u4e3a Storage8<T> \uff0c\u5e76\u4e14 T \u4e0d\u662f\u4e00\u4e2a bool \u7c7b\u578b\uff0c\u6211\u4eec\u5c31\u4f1a\u83b7\u5f97\u4e00\u4e2a\u4ece\u901a\u7528\u6a21\u677f\u7c7b Storage8<T> \u751f\u6210\u7684\u7248\u672c\u3002 \u73b0\u5728\uff0c\u5f53\u6211\u4eec\u58f0\u660e\u4e86\u4e00\u4e2a Storage8<T> \u7684\u7c7b\uff0c\u5f53 T \u4e0d\u662f\u4e00\u4e2a bool \uff0c\u6211\u4eec\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u4ece\u901a\u7528\u6cdb\u578b\u7248\u672c\u6a21\u677f Storage8<T> \u7684\u7248\u672c\u3002\u5f53\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a Stroage8<bool> \u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u521a\u521a\u521b\u5efa\u7684\u7279\u5316\u7684\u7248\u672c\u3002\u6ce8\u610f\uff0c\u6211\u4eec\u4fdd\u6301\u4e86\u4e24\u4e2a\u7c7b\u7684\u516c\u5f00\u63a5\u53e3\u76f8\u540c \u2014\u2014\u2014\u2014 C++ \u7ed9\u6211\u4eec\u81ea\u7531\u6765\u6dfb\u52a0\uff0c\u79fb\u9664\uff0c\u6216\u8005\u5c06 Storage8<bool> \u7684\u51fd\u6570\u6539\u6210\u6211\u4eec\u770b\u5230\u7684\u90a3\u6837\uff0c\u6765\u9002\u914d T \u6240\u5236\u5b9a\u7684\u7c7b\u578b\uff0c\u4fdd\u6301\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u63a5\u53e3\u662f\u7684\u7a0b\u5e8f\u5458\u53ef\u4ee5\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u6765\u4f7f\u7528\u8fd9\u4e2a\u7c7b\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u548c\u4e4b\u524d\u6070\u597d\u76f8\u540c\u7684\u65b9\u5f0f\u6765\u5c55\u793a Storage8<T> \u548c Storage8<bool> \u88ab\u5b9e\u4f8b\u5316\uff1a int main () { // Define a Storage8 for integers (instantiates Storage8<T>, where T = int) Storage8 < int > intStorage ; for ( int count { 0 }; count < 8 ; ++ count ) { intStorage . set ( count , count ); } for ( int count { 0 }; count < 8 ; ++ count ) { std :: cout << intStorage . get ( count ) << '\\n' ; } // Define a Storage8 for bool (instantiates Storage8<bool> specialization) Storage8 < bool > boolStorage ; for ( int count { 0 }; count < 8 ; ++ count ) { boolStorage . set ( count , count & 3 ); } std :: cout << std :: boolalpha ; for ( int count { 0 }; count < 8 ; ++ count ) { std :: cout << boolStorage . get ( count ) << '\\n' ; } return 0 ; } \u5982\u4f60\u6240\u671f\u5f85\u7684\u90a3\u6837\uff0c\u8fd9\u6253\u5370\u51fa\u4e86\u548c\u4e4b\u524d\u6ca1\u6709\u8fdb\u884c\u6a21\u677f\u7279\u5316\u7684\u65f6\u5019\u7684 Storage8<bool> \u4ea7\u751f\u76f8\u540c\u7684\u7ed3\u679c\u3002 0 1 2 3 4 5 6 7 false true true true false true true true \u503c\u5f97\u518d\u6b21\u6ce8\u610f\u7684\u662f\uff0c\u4fdd\u6301\u6a21\u677f\u7c7b\u548c\u6a21\u677f\u7279\u5316\u7684\u516c\u5f00\u63a5\u53e3\u76f8\u540c\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u4e60\u60ef\uff0c\u56e0\u4e3a\u5b83\u8ba9\u8fd9\u4e9b\u4ee3\u7801\u66f4\u6613\u7528 \u2014\u2014\u2014\u2014 \u7136\u800c\uff0c\u4e5f\u4e0d\u662f\u4e25\u683c\u6709\u5fc5\u8981\u8fd9\u6837\u505a\u7684\u3002","title":"19.6 \u7c7b\u6a21\u677f\u7279\u5316"},{"location":"19-templates/19.6-class-template-specialization/#196","text":"By Alex on August 16 th , 2008 | last modified by Alex on December 21 st , 2020 \u7ffb\u8bd1 by dashjay 2020-12-27 |\u6700\u540e\u4fee\u6539\u4e8e 2020-12-27 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b 19.5 -- Function template specialization \uff0c\u6211\u4eec\u77e5\u9053\u4e86\u53ef\u4ee5\u7279\u5316\u51fd\u6570\uff0c\u4e3a\u4e86\u7ed9\u7279\u6b8a\u7684\u6570\u636e\u7c7b\u578b\u63d0\u4f9b\u4e0d\u540c\u7684\u529f\u80fd\u3002\u4e0d\u4ec5\u4ec5\u53ef\u4ee5\u7279\u5316\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u7279\u5316\u6574\u4e2a\u7c7b\uff01 \u601d\u8003\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u4f60\u60f3\u8bbe\u8ba1\u4e00\u4e2a\u7c7b\u53ef\u4ee5\u5b58\u50a8 8 \u4e2a\u5bf9\u8c61\u3002\u8fd9\u6709\u4e00\u4e2a\u7b80\u5316\u7c7b\u8fd9\u6837\u505a\uff1a template < class T > class Storage8 { private : T m_array [ 8 ]; public : void set ( int index , const T & value ) { m_array [ index ] = value ; } const T & get ( int index ) const { return m_array [ index ]; } }; \u56e0\u4e3a\u8fd9\u4e2a\u7c7b\u662f\u6a21\u677f\u7c7b\uff0c\u5b83\u80fd\u5728\u4efb\u4f55\u7ed9\u5b9a\u7684\u6570\u636e\u7c7b\u578b\u4e0b\u5de5\u4f5c\uff1a #include <iostream> int main () { // Define a Storage8 for integers Storage8 < int > intStorage ; for ( int count { 0 }; count < 8 ; ++ count ) intStorage . set ( count , count ); for ( int count { 0 }; count < 8 ; ++ count ) std :: cout << intStorage . get ( count ) << '\\n' ; // Define a Storage8 for bool Storage8 < bool > boolStorage ; for ( int count { 0 }; count < 8 ; ++ count ) boolStorage . set ( count , count & 3 ); std :: cout << std :: boolalpha ; for ( int count { 0 }; count < 8 ; ++ count ) { std :: cout << boolStorage . get ( count ) << '\\n' ; } return 0 ; } \u4f8b\u5b50\u6253\u5370\uff1a 0 1 2 3 4 5 6 7 false true true true false true true true \u8fd9\u4e2a\u7c7b\u662f\u53ef\u4ee5\u5b8c\u5168\u6b63\u5e38\u5de5\u4f5c\u7684\uff0c\u4f46\u662f\u5c31\u662f Storage8<bool> \u7684\u5b9e\u73b0\u6548\u7387\u8fdc\u8fdc\u4f4e\u4e8e\u5b9e\u9645\u9700\u8981\u3002\u56e0\u4e3a\u6240\u6709\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u4e00\u4e2a\u5730\u5740\uff0c\u5e76\u4e14 CPU \u4e0d\u80fd\u5b9a\u4f4d\u6bd4\u4e00 byte \u66f4\u5c0f\u7684\u5355\u4f4d\uff0c\u6240\u6709\u53d8\u91cf\u5fc5\u987b\u81f3\u5c11\u662f 1 byte\u3002\u56e0\u6b64\uff0c\u4e00\u4e2a bool \u503c\u6574\u6574\u7528\u6389\u4e86\u6574\u4e2a byte\uff0c\u7136\u540e 7 bits \u90fd\u88ab\u6d6a\u8d39\u4e86\u3002\u6211\u4eec\u7684 Storage8<bool> \u7c7b\u4e00\u5171\u5305\u542b\u4e86 8 \u4e2abool\u503c\uff0c\u5176\u4e2d 1 byte \u662f\u5305\u542b\u6709\u7528\u7684\u4fe1\u606f\uff0c\u53e6\u5916 7 byte \u90fd\u662f\u6d6a\u8d39\u7684\u3002 \u7ed3\u679c\uff0c\u4f7f\u7528\u4e00\u4e2a\u57fa\u7840\u4f4d\u903b\u8f91\uff0c\u6709\u53ef\u80fd\u5427 8 \u4e2a bool \u503c\u538b\u7f29\u5230\u4e00\u4e2a\u5355 byte \u4e2d\uff0c\u6d88\u9664\u6d6a\u8d39\u7684\u7a7a\u95f4\u5230\u4e00\u8d77\u3002\u7136\u800c\uff0c\u4e3a\u4e86\u8fbe\u6210\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u9700\u8981\u5728\u4f7f\u7528 bool \u7684\u65f6\u5019\uff0c\u4fee\u6539\u8fd9\u4e2a\u7c7b\u578b\uff0c\u66ff\u6362 8 \u4e2a bool \u7684\u6570\u7ec4\u4e3a\u4e00\u4e2a\u5355 byte \u5927\u5c0f\u7684\u53d8\u91cf\u3002\u6211\u4eec\u5f53\u7136\u53ef\u4ee5\u521b\u5efa\u6574\u4e2a\u7684\u65b0\u7c7b\u6765\u5b8c\u6210\u9700\u6c42\uff0c\u4f46\u662f\u8fd9\u6837\u505a\u6709\u4e00\u4e2a\u6700\u5927\u7684\u7f3a\u70b9\u5c31\u662f\uff1a\u6211\u4eec\u4e0d\u5f97\u4e0d\u53d6\u4e00\u4e2a\u65b0\u7684\u540d\u5b57\u3002\u7a0b\u5e8f\u5458\u5c31\u5fc5\u987b\u8bb0\u5728\u8111\u5b50\u91cc\uff0c Storage8<T> \u4e0d\u80fd\u63d0\u4f9b\u7ed9 bool \u7c7b\u4f7f\u7528\uff0c\u5fc5\u987b\u4f7f\u7528 Storage8Bool \uff08\u6216\u8005\u4ec0\u4e48\u5176\u4ed6\u7684\u65b0\u7c7b\uff09\u3002\u8fd9\u4e9b\u6ca1\u6709\u5fc5\u8981\u7684\u590d\u6742\u6211\u4eec\u5e94\u8be5\u907f\u514d\u3002\u5e78\u8fd0\u7684\u662f\uff0cC++ \u7ed9\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u79cd\u66f4\u597d\u7684\u65b9\u6cd5\uff1a\u7c7b\u6a21\u677f\u7279\u5316\u3002","title":"19.6 \u7c7b\u6a21\u677f\u7279\u5316"},{"location":"19-templates/19.6-class-template-specialization/#_1","text":"\u7c7b\u6a21\u677f\u7279\u5316\u5141\u8bb8\u6211\u4eec\u7279\u5316\u6a21\u677f\u5728\u67d0\u4e2a\u7279\u5b9a\u7c7b\u578b\uff08\u6216\u8005\u51e0\u4e2a\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\uff0c\u5982\u679c\u4e0d\u6b62\u4e00\u4e2a\u6a21\u677f\u53c2\u6570\u7684\u8bdd\uff09\u3002\u5728\u8fd9\u4e2a\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u8981\u53bb\u4f7f\u7528\u6a21\u677f\u7c7b\u7279\u5316\u6765\u5199\u4e00\u4e2a\u7279\u5b9a\u7248\u672c\u7684 Storage8<bool> \u5c06\u4f1a\u6bd4\u6cdb\u578b\u7684 Storage8<T> \u7c7b\u4f18\u5148\u7ea7\u66f4\u9ad8\u3002\u8fd9\u4e2a\u7c7b\u4f3c\u4e8e\u7279\u5b9a\u51fd\u6570\u4f18\u5148\u4e8e\u6cdb\u578b\u6a21\u677f\u51fd\u6570\u3002 \u5c3d\u7ba1\u4ed6\u4eec\u548c\u6a21\u677f\u7c7b\u4e00\u6837\uff0c\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u5206\u914d\uff0c\u7c7b\u6a21\u677f\u7279\u5316\u88ab\u5f53\u505a\u662f\u72ec\u7acb\u7684\u7c7b\u3002\u8fd9\u610f\u5473\u7740\u6211\u4eec\u53ef\u4ee5\u6539\u53d8\u5173\u4e8e\u6211\u4eec\u7279\u5316\u6a21\u677f\u7684\u4efb\u4f55\u5185\u5bb9\uff0c\u5305\u542b\u5b83\u5b9e\u73b0\u00b7\u7684\u65b9\u5f0f\uff0c\u751a\u81f3\u662f\u516c\u5f00\u7684\u51fd\u6570\uff0c\u5c31\u50cf\u4ed6\u662f\u4e00\u4e2a\u72ec\u7acb\u7684\u7c7b\uff0c\u8fd9\u662f\u6211\u4eec\u7684\u7279\u5316\u7c7b\uff1a template <> // the following is a template class with no templated parameters class Storage8 < bool > // we're specializing Storage8 for bool { // What follows is just standard class implementation details private : unsigned char m_data {}; public : void set ( int index , bool value ) { // Figure out which bit we're setting/unsetting // This will put a 1 in the bit we're interested in turning on/off auto mask { 1 << index }; if ( value ) // If we're setting a bit m_data |= mask ; // Use bitwise-or to turn that bit on else // if we're turning a bit off m_data &= ~ mask ; // bitwise-and the inverse mask to turn that bit off } bool get ( int index ) { // Figure out which bit we're getting auto mask { 1 << index }; // bitwise-and to get the value of the bit we're interested in // Then implicit cast to boolean return ( m_data & mask ); } }; \u9996\u5148\uff0c\u6ce8\u610f\u6211\u4eec\u4f7f\u7528 template<> \u6765\u5f00\u59cb\u3002\u6a21\u677f\u5173\u952e\u8bcd\u544a\u8bc9\u7f16\u8bd1\u5668\u4e0b\u65b9\u7684\u5185\u5bb9\u662f\u5c5e\u4e8e\u6a21\u677f\u7684\uff0c\u7a7a\u7684\u5c16\u62ec\u53f7\u8868\u793a\u6ca1\u6709\u4efb\u4f55\u6a21\u677f\u53c2\u6570\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u65e0\u9700\u4efb\u4f55\u7684\u6a21\u677f\u53c2\u6570\uff0c\u56e0\u4e3a\u6211\u4eec\u66ff\u6362\u4ec5\u6709\u7684\u6a21\u677f\u53c2\u6570\uff08T\uff09\u4e3a\u7279\u5b9a\u7684\u7c7b\u578b\uff08bool\uff09\u3002 \u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u6dfb\u52a0\u4e86 <bool> \u5230\u7c7b\u540d\u6765\u8868\u793a\u6211\u4eec\u7279\u5316\u4e86 bool \u7248\u672c\u7684 Storage8 \u7c7b\u3002 \u6240\u6709\u7684\u5176\u4ed6\u7684\u6539\u53d8\u5c31\u53ea\u662f\u7c7b\u5b9e\u73b0\u7684\u7ec6\u8282\u3002\u4ec5\u4ec5\u4e3a\u4e86\u4f7f\u7528\u8fd9\u4e2a\u7c7b\uff0c\u4f60\u5b8c\u5168\u6ca1\u6709\u5fc5\u8981\u7406\u89e3\u4f4d\u903b\u8f91\uff08\u5c3d\u7ba1\u4f60\u53ef\u4ee5\u590d\u4e60 O.2 -- Bitwise operators \u5982\u679c\u4f60\u60f3\u8981\u89e3\u51b3\uff0c\u4f46\u662f\u9700\u8981\u590d\u4e60\u5982\u4f55\u8fdb\u884c\u672a\u64cd\u4f5c\uff09\u3002 \u6ce8\u610f\u8fd9\u4e2a\u7279\u5316\u7c7b\u5229\u7528\u4e86\u4e00\u4e2a single unsigned char (1 byte) \u66ff\u6362\u4e86\u4e00\u4e2a 8 \u4e2a bool \u7684\u6570\u7ec4\uff088 bytes\uff09\u3002 \u73b0\u5728\uff0c\u5f53\u6211\u4eec\u751f\u547d\u4e00\u4e2a\u7c7b\u578b\u4e3a Storage8<T> \uff0c\u5e76\u4e14 T \u4e0d\u662f\u4e00\u4e2a bool \u7c7b\u578b\uff0c\u6211\u4eec\u5c31\u4f1a\u83b7\u5f97\u4e00\u4e2a\u4ece\u901a\u7528\u6a21\u677f\u7c7b Storage8<T> \u751f\u6210\u7684\u7248\u672c\u3002 \u73b0\u5728\uff0c\u5f53\u6211\u4eec\u58f0\u660e\u4e86\u4e00\u4e2a Storage8<T> \u7684\u7c7b\uff0c\u5f53 T \u4e0d\u662f\u4e00\u4e2a bool \uff0c\u6211\u4eec\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u4ece\u901a\u7528\u6cdb\u578b\u7248\u672c\u6a21\u677f Storage8<T> \u7684\u7248\u672c\u3002\u5f53\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a Stroage8<bool> \u7684\u5bf9\u8c61\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u521a\u521a\u521b\u5efa\u7684\u7279\u5316\u7684\u7248\u672c\u3002\u6ce8\u610f\uff0c\u6211\u4eec\u4fdd\u6301\u4e86\u4e24\u4e2a\u7c7b\u7684\u516c\u5f00\u63a5\u53e3\u76f8\u540c \u2014\u2014\u2014\u2014 C++ \u7ed9\u6211\u4eec\u81ea\u7531\u6765\u6dfb\u52a0\uff0c\u79fb\u9664\uff0c\u6216\u8005\u5c06 Storage8<bool> \u7684\u51fd\u6570\u6539\u6210\u6211\u4eec\u770b\u5230\u7684\u90a3\u6837\uff0c\u6765\u9002\u914d T \u6240\u5236\u5b9a\u7684\u7c7b\u578b\uff0c\u4fdd\u6301\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u63a5\u53e3\u662f\u7684\u7a0b\u5e8f\u5458\u53ef\u4ee5\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u6765\u4f7f\u7528\u8fd9\u4e2a\u7c7b\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u548c\u4e4b\u524d\u6070\u597d\u76f8\u540c\u7684\u65b9\u5f0f\u6765\u5c55\u793a Storage8<T> \u548c Storage8<bool> \u88ab\u5b9e\u4f8b\u5316\uff1a int main () { // Define a Storage8 for integers (instantiates Storage8<T>, where T = int) Storage8 < int > intStorage ; for ( int count { 0 }; count < 8 ; ++ count ) { intStorage . set ( count , count ); } for ( int count { 0 }; count < 8 ; ++ count ) { std :: cout << intStorage . get ( count ) << '\\n' ; } // Define a Storage8 for bool (instantiates Storage8<bool> specialization) Storage8 < bool > boolStorage ; for ( int count { 0 }; count < 8 ; ++ count ) { boolStorage . set ( count , count & 3 ); } std :: cout << std :: boolalpha ; for ( int count { 0 }; count < 8 ; ++ count ) { std :: cout << boolStorage . get ( count ) << '\\n' ; } return 0 ; } \u5982\u4f60\u6240\u671f\u5f85\u7684\u90a3\u6837\uff0c\u8fd9\u6253\u5370\u51fa\u4e86\u548c\u4e4b\u524d\u6ca1\u6709\u8fdb\u884c\u6a21\u677f\u7279\u5316\u7684\u65f6\u5019\u7684 Storage8<bool> \u4ea7\u751f\u76f8\u540c\u7684\u7ed3\u679c\u3002 0 1 2 3 4 5 6 7 false true true true false true true true \u503c\u5f97\u518d\u6b21\u6ce8\u610f\u7684\u662f\uff0c\u4fdd\u6301\u6a21\u677f\u7c7b\u548c\u6a21\u677f\u7279\u5316\u7684\u516c\u5f00\u63a5\u53e3\u76f8\u540c\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u4e60\u60ef\uff0c\u56e0\u4e3a\u5b83\u8ba9\u8fd9\u4e9b\u4ee3\u7801\u66f4\u6613\u7528 \u2014\u2014\u2014\u2014 \u7136\u800c\uff0c\u4e5f\u4e0d\u662f\u4e25\u683c\u6709\u5fc5\u8981\u8fd9\u6837\u505a\u7684\u3002","title":"\u7c7b\u6a21\u677f\u7279\u5316"},{"location":"19-templates/19.7-partial-template-specialization/","text":"19.7 \u6a21\u677f\u5c40\u90e8\u7279\u5316 \u00b6 By Alex on August 17 th , 2008 | last modified by Alex on December 21 st , 2020 Translated by Dashjay 2021-02-24 | last modified by Dashjay 2021-02-24 \u8fd9\u8282\u8bfe\u548c\u4e0b\u8282\u8bfe\u90fd\u662f\u53ef\u9009\u7684\uff0c\u60f3\u8981\u4e86\u89e3\u66f4\u6df1\u7684 C++ \u6a21\u677f\u77e5\u8bc6\u53ef\u4ee5\u9009\u62e9\u7ee7\u7eed\u9605\u8bfb\u3002\u5c40\u90e8\u6a21\u677f\u7279\u5316\u5e76\u4e0d\u662f\u90a3\u4e48\u5e38\u7528\uff08\u4f46\u662f\u53ef\u4ee5\u5728\u7279\u6b8a\u60c5\u51b5\u4e0b\u8fb9\u7684\u5f88\u6709\u7528\uff09 \u7ffb\u8bd1\u5f00\u4e86\u4e2a\u5934\uff0c\u6682\u7f13\u2026\u2026 In lesson 19.4 -- Template non-type parameters, you learned how expression parameters could be used to parameterize template classes. Let\u2019s take another look at the Static Array class we used in one of our previous examples: template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; This class takes two template parameters, a type parameter, and an expression parameter. Now, let\u2019s say we wanted to write a function to print out the whole array. Although we could implement this as a member function, we\u2019re going to do it as a non-member function instead because it will make the successive examples easier to follow. Using templates, we might write something like this: template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } This would allow us to do the following: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } int main () { // declare an int array StaticArray < int , 4 > int4 {}; int4 [ 0 ] = 0 ; int4 [ 1 ] = 1 ; int4 [ 2 ] = 2 ; int4 [ 3 ] = 3 ; // Print the array print ( int4 ); return 0 ; } and get the following result: 0 1 2 3 Although this works, it has a design flaw. Consider the following: int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } (We covered std::strcpy in lesson 9.6 -- C-style strings if you need a refresher) This program will compile, execute, and produce the following value (or one similar): H e l l o , w o r l d ! For non-char types, it makes sense to put a space between each array element, so they don\u2019t run together. However, with a char type, it makes more sense to print everything run together as a C-style string, which our print() function doesn\u2019t do. So how can we fix this? Template specialization to the rescue? One might first think of using template specialization. The problem with full template specialization is that all template parameters must be explicitly defined. Consider: # include <iostream> # include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // Override print() for fully specialized StaticArray<char, 14> template <> void print ( StaticArray < char , 14 > & array ) { for ( int count { 0 }; count < 14 ; ++ count ) std :: cout << array [ count ]; } int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } As you can see, we\u2019ve now provided an overloaded print function for fully specialized StaticArray . Indeed, this prints: Hello, world! Although this solves the issue of making sure print() can be called with a StaticArray , it brings up another problem: using full template specialization means we have to explicitly define the length of the array this function will accept! Consider the following example: int main () { // declare a char array StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } Calling print() with char12 will call the version of print() that takes a StaticArray , because char12 is of type StaticArray , and our overloaded print() will only be called when passed a StaticArray . Although we could make a copy of print() that handles StaticArray , what happens when we want to call print() with an array size of 5, or 22? We\u2019d have to copy the function for each different array size. That\u2019s redundant. Obviously full template specialization is too restrictive a solution here. The solution we are looking for is partial template specialization. Partial template specialization Partial template specialization allows us to specialize classes (but not individual functions!) where some, but not all, of the template parameters have been explicitly defined. For our challenge above, the ideal solution would be to have our overloaded print function work with StaticArray of type char, but leave the length expression parameter templated so it can vary as needed. Partial template specialization allows us to do just that! Here\u2019s our example with an overloaded print function that takes a partially specialized StaticArray: // overload of print() function for partially specialized StaticArray<char, size> template < int size > // size is still a templated expression parameter void print ( StaticArray < char , size > & array ) // we're explicitly defining type char here { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } As you can see here, we\u2019ve explicitly declared that this function will only work for StaticArray of type char, but size is still a templated expression parameter, so it will work for char arrays of any size. That\u2019s all there is to it! Here\u2019s a full program using this: # include <iostream> # include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // overload of print() function for partially specialized StaticArray<char, size> template < int size > void print ( StaticArray < char , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } int main () { // Declare an char array of size 14 StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); // Now declare an char array of size 12 StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } This prints: Hello, world! Hello, mom! Just as we expect. Note that as of C++14, partial template specialization can only be used with classes, not template functions (functions must be fully specialized). Our void print(StaticArray &array) example works because the print function is not partially specialized (it\u2019s just an overloaded function using a class parameter that\u2019s partially specialized). Partial template specialization for member functions The limitation on the partial specialization of functions can lead to some challenges when dealing with member functions. For example, what if we had defined StaticArray like this? template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; print() is now a member function of class StaticArray . So what happens when we want to partially specialize print(), so that it works differently? You might try this: // Doesn't work template < int size > void StaticArray < double , size >:: print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } Unfortunately, this doesn\u2019t work, because we\u2019re trying to partially specialize a function, which is disallowed. So how do we get around this? One obvious way is to partially specialize the entire class: # include<iostream> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << \" \\n \" ; } }; template < int size > // size is the expression parameter class StaticArray < double , size > { private : // The expression parameter controls the size of the array double m_array [ size ]{}; public : double * getArray () { return m_array ; } double & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints: 0 1 2 3 4 5 4.000000e+00 4.100000e+00 4.200000e+00 4.300000e+00 While it works, this isn\u2019t a great solution, because we had to duplicate a lot of code from StaticArray to StaticArray . If only there were some way to reuse the code in StaticArray in StaticArray . Sounds like a job for inheritance! You might start off trying to write that code like this: template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray < // Then what? How do we reference StaticArray? We can\u2019t. Fortunately, there\u2019s a workaround, by using a common base class: # include<iostream> template < class T , int size > // size is the expression parameter class StaticArray_Base { protected : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ]; std :: cout << '\\n' ; } virtual ~ StaticArray_Base () = default ; }; template < class T , int size > // size is the expression parameter class StaticArray : public StaticArray_Base < T , size > { public : }; template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray_Base < double , size > { public : void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << this -> m_array [ i ] << ' ' ; // note: The this-> prefix in the above line is needed. // See <https://stackoverflow.com/a/6592617> or <https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members> for more info on why. std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints the same as above, but has significantly less duplicated code.","title":"19.7 \u6a21\u677f\u5c40\u90e8\u7279\u5316"},{"location":"19-templates/19.7-partial-template-specialization/#197","text":"By Alex on August 17 th , 2008 | last modified by Alex on December 21 st , 2020 Translated by Dashjay 2021-02-24 | last modified by Dashjay 2021-02-24 \u8fd9\u8282\u8bfe\u548c\u4e0b\u8282\u8bfe\u90fd\u662f\u53ef\u9009\u7684\uff0c\u60f3\u8981\u4e86\u89e3\u66f4\u6df1\u7684 C++ \u6a21\u677f\u77e5\u8bc6\u53ef\u4ee5\u9009\u62e9\u7ee7\u7eed\u9605\u8bfb\u3002\u5c40\u90e8\u6a21\u677f\u7279\u5316\u5e76\u4e0d\u662f\u90a3\u4e48\u5e38\u7528\uff08\u4f46\u662f\u53ef\u4ee5\u5728\u7279\u6b8a\u60c5\u51b5\u4e0b\u8fb9\u7684\u5f88\u6709\u7528\uff09 \u7ffb\u8bd1\u5f00\u4e86\u4e2a\u5934\uff0c\u6682\u7f13\u2026\u2026 In lesson 19.4 -- Template non-type parameters, you learned how expression parameters could be used to parameterize template classes. Let\u2019s take another look at the Static Array class we used in one of our previous examples: template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; This class takes two template parameters, a type parameter, and an expression parameter. Now, let\u2019s say we wanted to write a function to print out the whole array. Although we could implement this as a member function, we\u2019re going to do it as a non-member function instead because it will make the successive examples easier to follow. Using templates, we might write something like this: template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } This would allow us to do the following: #include <iostream> #include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } int main () { // declare an int array StaticArray < int , 4 > int4 {}; int4 [ 0 ] = 0 ; int4 [ 1 ] = 1 ; int4 [ 2 ] = 2 ; int4 [ 3 ] = 3 ; // Print the array print ( int4 ); return 0 ; } and get the following result: 0 1 2 3 Although this works, it has a design flaw. Consider the following: int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } (We covered std::strcpy in lesson 9.6 -- C-style strings if you need a refresher) This program will compile, execute, and produce the following value (or one similar): H e l l o , w o r l d ! For non-char types, it makes sense to put a space between each array element, so they don\u2019t run together. However, with a char type, it makes more sense to print everything run together as a C-style string, which our print() function doesn\u2019t do. So how can we fix this? Template specialization to the rescue? One might first think of using template specialization. The problem with full template specialization is that all template parameters must be explicitly defined. Consider: # include <iostream> # include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // Override print() for fully specialized StaticArray<char, 14> template <> void print ( StaticArray < char , 14 > & array ) { for ( int count { 0 }; count < 14 ; ++ count ) std :: cout << array [ count ]; } int main () { // declare a char array StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); return 0 ; } As you can see, we\u2019ve now provided an overloaded print function for fully specialized StaticArray . Indeed, this prints: Hello, world! Although this solves the issue of making sure print() can be called with a StaticArray , it brings up another problem: using full template specialization means we have to explicitly define the length of the array this function will accept! Consider the following example: int main () { // declare a char array StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } Calling print() with char12 will call the version of print() that takes a StaticArray , because char12 is of type StaticArray , and our overloaded print() will only be called when passed a StaticArray . Although we could make a copy of print() that handles StaticArray , what happens when we want to call print() with an array size of 5, or 22? We\u2019d have to copy the function for each different array size. That\u2019s redundant. Obviously full template specialization is too restrictive a solution here. The solution we are looking for is partial template specialization. Partial template specialization Partial template specialization allows us to specialize classes (but not individual functions!) where some, but not all, of the template parameters have been explicitly defined. For our challenge above, the ideal solution would be to have our overloaded print function work with StaticArray of type char, but leave the length expression parameter templated so it can vary as needed. Partial template specialization allows us to do just that! Here\u2019s our example with an overloaded print function that takes a partially specialized StaticArray: // overload of print() function for partially specialized StaticArray<char, size> template < int size > // size is still a templated expression parameter void print ( StaticArray < char , size > & array ) // we're explicitly defining type char here { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } As you can see here, we\u2019ve explicitly declared that this function will only work for StaticArray of type char, but size is still a templated expression parameter, so it will work for char arrays of any size. That\u2019s all there is to it! Here\u2019s a full program using this: # include <iostream> # include <cstring> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } }; template < typename T , int size > void print ( StaticArray < T , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ] << ' ' ; } // overload of print() function for partially specialized StaticArray<char, size> template < int size > void print ( StaticArray < char , size > & array ) { for ( int count { 0 }; count < size ; ++ count ) std :: cout << array [ count ]; } int main () { // Declare an char array of size 14 StaticArray < char , 14 > char14 {}; std :: strcpy ( char14 . getArray (), \"Hello, world!\" ); // Print the array print ( char14 ); // Now declare an char array of size 12 StaticArray < char , 12 > char12 {}; std :: strcpy ( char12 . getArray (), \"Hello, mom!\" ); // Print the array print ( char12 ); return 0 ; } This prints: Hello, world! Hello, mom! Just as we expect. Note that as of C++14, partial template specialization can only be used with classes, not template functions (functions must be fully specialized). Our void print(StaticArray &array) example works because the print function is not partially specialized (it\u2019s just an overloaded function using a class parameter that\u2019s partially specialized). Partial template specialization for member functions The limitation on the partial specialization of functions can lead to some challenges when dealing with member functions. For example, what if we had defined StaticArray like this? template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; print() is now a member function of class StaticArray . So what happens when we want to partially specialize print(), so that it works differently? You might try this: // Doesn't work template < int size > void StaticArray < double , size >:: print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } Unfortunately, this doesn\u2019t work, because we\u2019re trying to partially specialize a function, which is disallowed. So how do we get around this? One obvious way is to partially specialize the entire class: # include<iostream> template < class T , int size > // size is the expression parameter class StaticArray { private : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ] << ' ' ; std :: cout << \" \\n \" ; } }; template < int size > // size is the expression parameter class StaticArray < double , size > { private : // The expression parameter controls the size of the array double m_array [ size ]{}; public : double * getArray () { return m_array ; } double & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << m_array [ i ] << ' ' ; std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints: 0 1 2 3 4 5 4.000000e+00 4.100000e+00 4.200000e+00 4.300000e+00 While it works, this isn\u2019t a great solution, because we had to duplicate a lot of code from StaticArray to StaticArray . If only there were some way to reuse the code in StaticArray in StaticArray . Sounds like a job for inheritance! You might start off trying to write that code like this: template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray < // Then what? How do we reference StaticArray? We can\u2019t. Fortunately, there\u2019s a workaround, by using a common base class: # include<iostream> template < class T , int size > // size is the expression parameter class StaticArray_Base { protected : // The expression parameter controls the size of the array T m_array [ size ]{}; public : T * getArray () { return m_array ; } T & operator []( int index ) { return m_array [ index ]; } void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << m_array [ i ]; std :: cout << '\\n' ; } virtual ~ StaticArray_Base () = default ; }; template < class T , int size > // size is the expression parameter class StaticArray : public StaticArray_Base < T , size > { public : }; template < int size > // size is the expression parameter class StaticArray < double , size >: public StaticArray_Base < double , size > { public : void print () { for ( int i { 0 }; i < size ; ++ i ) std :: cout << std :: scientific << this -> m_array [ i ] << ' ' ; // note: The this-> prefix in the above line is needed. // See <https://stackoverflow.com/a/6592617> or <https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members> for more info on why. std :: cout << '\\n' ; } }; int main () { // declare an integer array with room for 6 integers StaticArray < int , 6 > intArray {}; // Fill it up in order, then print it for ( int count { 0 }; count < 6 ; ++ count ) intArray [ count ] = count ; intArray . print (); // declare a double buffer with room for 4 doubles StaticArray < double , 4 > doubleArray {}; for ( int count { 0 }; count < 4 ; ++ count ) doubleArray [ count ] = ( 4.0 + 0.1 * count ); doubleArray . print (); return 0 ; } This prints the same as above, but has significantly less duplicated code.","title":"19.7 \u6a21\u677f\u5c40\u90e8\u7279\u5316"},{"location":"19-templates/19.8-partial-template-specialization-for-pointers/","text":"19.8 \u5c40\u90e8\u6a21\u677f\u7279\u5316\u6307\u9488\u7684 \u00b6 By Alex on December 5 th , 2016 | last modified by Alex on December 22 nd , 2020 Translated By Dashjay 2021-02-24 | last modifeid by Dashjay on 2021-02-24 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b 19.5 -- Function template specialization \u4e2d\uff0c\u6211\u4eec\u770b\u4e86\u4e00\u773c\u7b80\u5355\u7684\u6a21\u677f\u5316\u7684 Storage \u7c7b\uff1a #include <iostream> template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; We showed that this class had problems when template parameter T was of type char*because of the shallow copy/pointer assignment that takes place in the constructor. In that lesson, we used full template specialization to create a specialized version of the Storage constructor for type char* that allocated memory and created an actual deep copy of m_value. For reference, here\u2019s the fully specialized char* Storage constructor and destructor: // You need to include the Storage<T> class from the example above here template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } template <> Storage < char *>::~ Storage () { delete [] m_value ; } While that worked great for Storage , what about other pointer types (such as int*)? It\u2019s fairly easy to see that if T is any pointer type, then we run into the problem of the constructor doing a pointer assignment instead of making an actual deep copy of the element being pointed to. Because full template specialization forces us to fully resolve templated types, in order to fix this issue we\u2019d have to define a new specialized constructor (and destructor) for each and every pointer type we wanted to use Storage with! This leads to lots of duplicate code, which as you well know by now is something we want to avoid as much as possible. Fortunately, partial template specialization offers us a convenient solution. In this case, we\u2019ll use class partial template specialization to define a special version of the Storage class that works for pointer values. This class is considered partially specialized because we\u2019re telling the compiler that it\u2019s only for use with pointer types, even though we haven\u2019t specified the underlying type exactly. #include <iostream> // You need to include the Storage<T> class from the example above here template < typename T > class Storage < T *> // this is a partial-specialization of Storage that works with pointer types { private : T * m_value ; public : Storage ( T * value ) // for pointer type T { // For pointers, we'll do a deep copy m_value = new T ( * value ); // this copies a single value, not an array } ~ Storage () { delete m_value ; // so we use scalar delete here, not array delete } void print () { std :: cout << * m_value << '\\n' ; } }; And an example of this working: int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // Let's show that myintptr is separate from x. // If we change x, myintptr should not change x = 9 ; myintptr . print (); return 0 ; } This prints the value: 5 7 When myintptr is defined with an int* template parameter, the compiler sees that we have defined a partially specialized template class that works with any pointer type, and instantiates a version of Storage using that template. The constructor of that class makes a deep copy of parameter x. Later, when we change x to 9, the myintptr.m_value is not affected because it\u2019s pointing at its own separate copy of the value. If the partial template specialization class did not exist, myintptr would have used the normal (non-partially-specialized) version of the template. The constructor of that class does a shallow copy pointer assignment, which means that myintptr.m_value and x would be referencing the same address. Then when we changed the value of x to 9, we would have changed myintptr\u2019s value too. It\u2019s worth noting that because this partially specialized Storage class only allocates a single value, for C-style strings, only the first character will be copied. If the desire is to copy entire strings, a specialization of the constructor (and destructor) for type char*can be fully specialized. The fully specialized version will take precedence over the partially specialized version. Here\u2019s an example program that uses both partial specialization for pointers, and full specialization for char*: #include <iostream> #include <cstring> // Our Storage class for non-pointers template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; // Partial-specialization of Storage class for pointers template < class T > class Storage < T *> { private : T * m_value ; public : Storage ( T * value ) { m_value = new T ( * value ); } ~ Storage () { delete m_value ; } void print () { std :: cout << * m_value << '\\n' ; } }; // Full specialization of constructor for type char* template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } // Full specialization of destructor for type char* template <> Storage < char *>::~ Storage () { delete [] m_value ; } // Full specialization of print function for type char* // Without this, printing a Storage<char*> would call Storage<T*>::print(), which only prints the first element template <> void Storage < char *>:: print () { std :: cout << m_value ; } int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // If myintptr did a pointer assignment on x, // then changing x will change myintptr too x = 9 ; myintptr . print (); // Dynamically allocate a temporary string char * name = new char [ 40 ]{ \"Alex\" }; // requires C++14 // If your compiler isn't C++14 compatible, comment out the above line and uncomment these // char *name = new char[40]; // strcpy(name, \"Alex\"); // Store the name Storage < char *> myname ( name ); // Delete the temporary string delete [] name ; // Print out our name myname . print (); } This works as we expect: 5 7 Alex Using partial template class specialization to create separate pointer and non-pointer implementations of a class is extremely useful when you want a class to handle both differently, but in a way that\u2019s completely transparent to the end-user.","title":"19.8 \u5c40\u90e8\u6a21\u677f\u7279\u5316\u6307\u9488\u7684"},{"location":"19-templates/19.8-partial-template-specialization-for-pointers/#198","text":"By Alex on December 5 th , 2016 | last modified by Alex on December 22 nd , 2020 Translated By Dashjay 2021-02-24 | last modifeid by Dashjay on 2021-02-24 \u5728\u4e4b\u524d\u7684\u8bfe\u7a0b 19.5 -- Function template specialization \u4e2d\uff0c\u6211\u4eec\u770b\u4e86\u4e00\u773c\u7b80\u5355\u7684\u6a21\u677f\u5316\u7684 Storage \u7c7b\uff1a #include <iostream> template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; We showed that this class had problems when template parameter T was of type char*because of the shallow copy/pointer assignment that takes place in the constructor. In that lesson, we used full template specialization to create a specialized version of the Storage constructor for type char* that allocated memory and created an actual deep copy of m_value. For reference, here\u2019s the fully specialized char* Storage constructor and destructor: // You need to include the Storage<T> class from the example above here template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } template <> Storage < char *>::~ Storage () { delete [] m_value ; } While that worked great for Storage , what about other pointer types (such as int*)? It\u2019s fairly easy to see that if T is any pointer type, then we run into the problem of the constructor doing a pointer assignment instead of making an actual deep copy of the element being pointed to. Because full template specialization forces us to fully resolve templated types, in order to fix this issue we\u2019d have to define a new specialized constructor (and destructor) for each and every pointer type we wanted to use Storage with! This leads to lots of duplicate code, which as you well know by now is something we want to avoid as much as possible. Fortunately, partial template specialization offers us a convenient solution. In this case, we\u2019ll use class partial template specialization to define a special version of the Storage class that works for pointer values. This class is considered partially specialized because we\u2019re telling the compiler that it\u2019s only for use with pointer types, even though we haven\u2019t specified the underlying type exactly. #include <iostream> // You need to include the Storage<T> class from the example above here template < typename T > class Storage < T *> // this is a partial-specialization of Storage that works with pointer types { private : T * m_value ; public : Storage ( T * value ) // for pointer type T { // For pointers, we'll do a deep copy m_value = new T ( * value ); // this copies a single value, not an array } ~ Storage () { delete m_value ; // so we use scalar delete here, not array delete } void print () { std :: cout << * m_value << '\\n' ; } }; And an example of this working: int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // Let's show that myintptr is separate from x. // If we change x, myintptr should not change x = 9 ; myintptr . print (); return 0 ; } This prints the value: 5 7 When myintptr is defined with an int* template parameter, the compiler sees that we have defined a partially specialized template class that works with any pointer type, and instantiates a version of Storage using that template. The constructor of that class makes a deep copy of parameter x. Later, when we change x to 9, the myintptr.m_value is not affected because it\u2019s pointing at its own separate copy of the value. If the partial template specialization class did not exist, myintptr would have used the normal (non-partially-specialized) version of the template. The constructor of that class does a shallow copy pointer assignment, which means that myintptr.m_value and x would be referencing the same address. Then when we changed the value of x to 9, we would have changed myintptr\u2019s value too. It\u2019s worth noting that because this partially specialized Storage class only allocates a single value, for C-style strings, only the first character will be copied. If the desire is to copy entire strings, a specialization of the constructor (and destructor) for type char*can be fully specialized. The fully specialized version will take precedence over the partially specialized version. Here\u2019s an example program that uses both partial specialization for pointers, and full specialization for char*: #include <iostream> #include <cstring> // Our Storage class for non-pointers template < class T > class Storage { private : T m_value ; public : Storage ( T value ) { m_value = value ; } ~ Storage () { } void print () { std :: cout << m_value << '\\n' ; } }; // Partial-specialization of Storage class for pointers template < class T > class Storage < T *> { private : T * m_value ; public : Storage ( T * value ) { m_value = new T ( * value ); } ~ Storage () { delete m_value ; } void print () { std :: cout << * m_value << '\\n' ; } }; // Full specialization of constructor for type char* template <> Storage < char *>:: Storage ( char * value ) { // Figure out how long the string in value is int length = 0 ; while ( value [ length ] != '\\0' ) ++ length ; ++ length ; // +1 to account for null terminator // Allocate memory to hold the value string m_value = new char [ length ]; // Copy the actual value string into the m_value memory we just allocated for ( int count = 0 ; count < length ; ++ count ) m_value [ count ] = value [ count ]; } // Full specialization of destructor for type char* template <> Storage < char *>::~ Storage () { delete [] m_value ; } // Full specialization of print function for type char* // Without this, printing a Storage<char*> would call Storage<T*>::print(), which only prints the first element template <> void Storage < char *>:: print () { std :: cout << m_value ; } int main () { // Declare a non-pointer Storage to show it works Storage < int > myint ( 5 ); myint . print (); // Declare a pointer Storage to show it works int x = 7 ; Storage < int *> myintptr ( & x ); // If myintptr did a pointer assignment on x, // then changing x will change myintptr too x = 9 ; myintptr . print (); // Dynamically allocate a temporary string char * name = new char [ 40 ]{ \"Alex\" }; // requires C++14 // If your compiler isn't C++14 compatible, comment out the above line and uncomment these // char *name = new char[40]; // strcpy(name, \"Alex\"); // Store the name Storage < char *> myname ( name ); // Delete the temporary string delete [] name ; // Print out our name myname . print (); } This works as we expect: 5 7 Alex Using partial template class specialization to create separate pointer and non-pointer implementations of a class is extremely useful when you want a class to handle both differently, but in a way that\u2019s completely transparent to the end-user.","title":"19.8 \u5c40\u90e8\u6a21\u677f\u7279\u5316\u6307\u9488\u7684"},{"location":"19-templates/19.x%20chapter-19-comprehensice-quiz/","text":"19.x - 19\u7ae0\u8282\u7ec3\u4e60 \u00b6 By Alex on December 19 th , 2016 | last modified by Alex on December 21 st , 2020 Translated by dashjay on 2021-02-24 | last modified by dashjay on 2021-02-24 Templates allow us to write functions or classes using placeholder types, so that we can stencil out identical versions of the function or class using different types. A function or class that has been instantiated is called a function or class instance. All template functions or classes must start with a template parameter declaration that tells the compiler that the following function or class is a template function or class. Within the template parameter declaration, the template type parameters or expression parameters are specified. Template type parameters are just placeholder types, normally named T, T1, T2, or other single letter names (e.g. S). Expression parameters are usually integral types, but can be a pointer or reference to a function, class object, or member function. Splitting up template class definition and member function definitions doesn\u2019t work like normal classes -- you can\u2019t put your class definition in a header and member function definitions in a .cpp file. It\u2019s usually best to keep all of them in a header file, with the member function definitions underneath the class. Template specialization can be used when we want to override the default behavior from the templated function or class for a specific type. If all types are overridden, this is called full specialization. Classes also support partial specialization, where only some of the templated parameters are specialized. Functions do not support partial specialization as of C++14. Many classes in the C++ standard library use templates, including std::array and std::vector. Templates are often used for implementing container classes, so a container can be written once and used with any appropriate type. Quiz time 1) It\u2019s sometimes useful to define data that travels in pairs. Write a templated class named Pair1 that allows the user to define one template type that is used for both values in the pair. The following function should work: int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 8 Pair: 2.3 4.5 Solution\uff1a #include <iostream> template < class T > class Pair1 { private : T m_x ; T m_y ; public : Pair1 ( const T & x , const T & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const T & second () const { return m_y ; } }; int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 2) Write a Pair class that allows you to specify separate types for each of the two values in the pair. Note: We\u2019re naming this class differently from the previous one because C++ does not currently allow you to \u201coverload\u201d classes that differ only in the number or type of template parameters. The following program should work: int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 6.7 Pair: 2.3 4 Hint: To define a template using two different types, separate the two types by a comma in the template parameter declaration. See lesson 19.1 -- Function templates for more information. Solution\uff1a #include <iostream> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 3) A string-value pair is a special type of pair where the first value is always a string type, and the second value can be any type. Write a template class named StringValuePair that inherits from a partially specialized Pair class (using std::string as the first type, and allowing the user to specify the second type). The following program should run: int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; } and print: Pair: Hello 5 Hint: When you call the Pair constructor from the StringValuePair constructor, don\u2019t forget to include the template parameters as part of the Pair class name. Solution\uff1a #include <iostream> #include <string> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; template < class S > class StringValuePair : public Pair < std :: string , S > { public : StringValuePair ( const std :: string & key , const S & value ) : Pair < std :: string , S > ( key , value ) { } }; int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; }","title":"19.x - 19\u7ae0\u8282\u7ec3\u4e60"},{"location":"19-templates/19.x%20chapter-19-comprehensice-quiz/#19x-19","text":"By Alex on December 19 th , 2016 | last modified by Alex on December 21 st , 2020 Translated by dashjay on 2021-02-24 | last modified by dashjay on 2021-02-24 Templates allow us to write functions or classes using placeholder types, so that we can stencil out identical versions of the function or class using different types. A function or class that has been instantiated is called a function or class instance. All template functions or classes must start with a template parameter declaration that tells the compiler that the following function or class is a template function or class. Within the template parameter declaration, the template type parameters or expression parameters are specified. Template type parameters are just placeholder types, normally named T, T1, T2, or other single letter names (e.g. S). Expression parameters are usually integral types, but can be a pointer or reference to a function, class object, or member function. Splitting up template class definition and member function definitions doesn\u2019t work like normal classes -- you can\u2019t put your class definition in a header and member function definitions in a .cpp file. It\u2019s usually best to keep all of them in a header file, with the member function definitions underneath the class. Template specialization can be used when we want to override the default behavior from the templated function or class for a specific type. If all types are overridden, this is called full specialization. Classes also support partial specialization, where only some of the templated parameters are specialized. Functions do not support partial specialization as of C++14. Many classes in the C++ standard library use templates, including std::array and std::vector. Templates are often used for implementing container classes, so a container can be written once and used with any appropriate type. Quiz time 1) It\u2019s sometimes useful to define data that travels in pairs. Write a templated class named Pair1 that allows the user to define one template type that is used for both values in the pair. The following function should work: int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 8 Pair: 2.3 4.5 Solution\uff1a #include <iostream> template < class T > class Pair1 { private : T m_x ; T m_y ; public : Pair1 ( const T & x , const T & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const T & second () const { return m_y ; } }; int main () { Pair1 < int > p1 ( 5 , 8 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair1 < double > p2 ( 2.3 , 4.5 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 2) Write a Pair class that allows you to specify separate types for each of the two values in the pair. Note: We\u2019re naming this class differently from the previous one because C++ does not currently allow you to \u201coverload\u201d classes that differ only in the number or type of template parameters. The following program should work: int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } and print: Pair: 5 6.7 Pair: 2.3 4 Hint: To define a template using two different types, separate the two types by a comma in the template parameter declaration. See lesson 19.1 -- Function templates for more information. Solution\uff1a #include <iostream> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; int main () { Pair < int , double > p1 ( 5 , 6.7 ); std :: cout << \"Pair: \" << p1 . first () << ' ' << p1 . second () << '\\n' ; const Pair < double , int > p2 ( 2.3 , 4 ); std :: cout << \"Pair: \" << p2 . first () << ' ' << p2 . second () << '\\n' ; return 0 ; } 3) A string-value pair is a special type of pair where the first value is always a string type, and the second value can be any type. Write a template class named StringValuePair that inherits from a partially specialized Pair class (using std::string as the first type, and allowing the user to specify the second type). The following program should run: int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; } and print: Pair: Hello 5 Hint: When you call the Pair constructor from the StringValuePair constructor, don\u2019t forget to include the template parameters as part of the Pair class name. Solution\uff1a #include <iostream> #include <string> template < class T , class S > class Pair { private : T m_x ; S m_y ; public : Pair ( const T & x , const S & y ) : m_x ( x ), m_y ( y ) { } const T & first () const { return m_x ; } const S & second () const { return m_y ; } }; template < class S > class StringValuePair : public Pair < std :: string , S > { public : StringValuePair ( const std :: string & key , const S & value ) : Pair < std :: string , S > ( key , value ) { } }; int main () { StringValuePair < int > svp ( \"Hello\" , 5 ); std :: cout << \"Pair: \" << svp . first () << ' ' << svp . second () << '\\n' ; return 0 ; }","title":"19.x - 19\u7ae0\u8282\u7ec3\u4e60"},{"location":"23-input-and-output/23.1-input-and-output-streams/","text":"18.1 \u8f93\u5165\u8f93\u51fa\u6d41 \u00b6 18.1 \u2014 Input and output (I/O) streams By Alex on February 28 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1By dashjay \u8f93\u5165\u548c\u8f93\u51fa\u529f\u80fd\u6ca1\u6709\u5b9a\u4e49\u4f5c\u4e3a C++ \u7684\u6838\u5fc3\u90e8\u5206\uff0c\u4f46\u662f\u4e5f\u88ab\u901a\u8fc7 C++ \u7684\u6807\u51c6\u5e93\u63d0\u4f9b\uff08\u4e5f\u5b58\u5728\u4e8e std \u547d\u540d\u7a7a\u95f4\uff09\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u4f60\u5f15\u7528\u4e86 <iostrea> \u5e93\u7684\u5934\u90e8\u5e76\u4e14\u4f7f\u7528 cin \u548c cout \u5bf9\u8c61\u6765\u505a\u7b80\u5355\u7684 I/O. \u5728\u8fd9\u4e2a\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u4f1a\u66f4\u8be6\u7ec6\u7684\u770b\u4e00\u4e0b\u554a iostream \u5e93\u3002 The iostream library \u00b6 \u5f53\u4f60\u5f15\u7528\u4e86 iostream \u7684\u5934\u90e8\uff0c\u4f60\u53ef\u4ee5\u8bbf\u95ee\u6574\u4e2a I/O \u7684\u67b6\u6784\u3002\uff08\u5f15\u5165\u4e86\u4e00\u4e2a\u540d\u5b57\u53eb\u505a iostream \u7684\u7c7b\uff09\u3002\u7c7b\u7ed3\u6784\uff08\u975e\u6587\u4ef6IO\uff09\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff1a \u7b2c\u4e00\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u4e8b\u60c5\u5c31\u662f\u5b83\u4f7f\u7528\u4e86\u591a\u7ee7\u627f\uff08\u4ee5\u524d\u6211\u4eec\u8bf4\u8fc7\u8981\u907f\u514d\u7684\uff09\u3002\u7136\u800c\uff0c iostream \u5e93\u88ab\u8bbe\u8ba1\u5e76\u4e14\u5e7f\u6cdb\u5730\u6d4b\u8bd5\u907f\u514d\u591a\u7ee7\u627f\u7684\u95ee\u9898\uff0c\u56e0\u6b64\u4f60\u53ef\u4ee5\u4e0d\u7528\u4e1d\u6beb\u62c5\u5fc3\u7684\u4f7f\u7528\u5b83\u3002 \u6d41 \u00b6 Streams \u7b2c\u4e8c\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u5c31\u662f\u5355\u8bcd stream \uff0c\u5b83\u7ecf\u5e38\u88ab\u6ee5\u7528\u3002\u4f5c\u4e3a\u6700\u57fa\u7840\u7684\u57fa\u7c7b\uff0cC++ \u4e2d\u7684 I/O \u4f7f\u7528\u6d41\u6765\u5b9e\u73b0\u3002\u62bd\u8c61\u6765\u8bb2\uff0c\u4e00\u4e2a stream \u5c31\u662f\u4e00\u4e2a\u5b57\u8282\u5e8f\u5217\u53ef\u4ee5\u88ab\u6309\u987a\u5e8f\u8bbf\u95ee\u3002\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\uff0c\u4e00\u4e2a stream \u53ef\u80fd\u4ea7\u751f\u6216\u8005\u6d88\u8d39\u6f5c\u5728\u7684\u65e0\u9650\u7684\u6570\u636e\u3002 \u901a\u5e38\uff0c\u6211\u4eec\u5904\u7406\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6d41\u3002\u8f93\u5165\u6d41\u88ab\u7528\u6765\u4ece\u4e00\u4e2a\u6570\u636e\u751f\u4ea7\u8005\u7ef4\u6301\u8f93\u5165\uff0c\u4f8b\u5982\u4e00\u6b21\u952e\u76d8\u89e6\u53d1\uff0c\u4e00\u4e2a\u6587\u4ef6\uff0c\u6216\u8005\u4e00\u4e2a\u7f51\u7edc\u3002\u4f8b\u5982\uff0c\u7528\u6237\u53ef\u80fd\u6309\u4e0b\u4e00\u4e2a\u6309\u94ae\u5f53\u7a0b\u5e8f\u6ca1\u6709\u671f\u5f85\u4efb\u4f55\u8f93\u5165\u3002\u4e0d\u4f1a\u5ffd\u7565\u7528\u6237\u7684\u6309\u952e\uff0c\u800c\u662f\u628a\u6570\u636e\u653e\u8fdb\u8f93\u5165\u6d41\u4e2d\uff0c\u5b83\u4f1a\u7b49\u5f85\u77e5\u9053\u7a0b\u5e8f\u63a5\u6536\u8fd9\u4e2a\u8f93\u5165\u3002 \u76f8\u53cd\u7684\uff0c\u8f93\u51fa\u6d41\u88ab\u7528\u6765\u6301\u7eed\u8f93\u51fa\u63d0\u4f9b\u7ed9\u7279\u5b9a\u7684\u6570\u636e\u6d88\u8d39\u8005\uff0c\u4f8b\u5982\u4e00\u4e2a\u663e\u793a\u5668\uff0c\u4e00\u4e2a\u6587\u4ef6\u6216\u8005\u4e00\u4e2a\u6253\u5370\u673a\u3002\u5f53\u5199\u6570\u636e\u5230\u4efb\u4f55\u8bbe\u5907\uff0c\u5e76\u4e14\u8bbe\u5907\u53ef\u80fd\u6ca1\u6709\u51c6\u5907\u597d\u63a5\u6536\u6570\u636e \u2014\u2014\u2014\u2014 \u4f8b\u5982\uff0c\u6253\u5370\u673a\u4ecd\u7136\u6b63\u5728\u9884\u70ed\u5f53\u7a0b\u5e8f\u5c1d\u8bd5\u5199\u5165\u6570\u636e\u5230\u5b83\u7684\u8f93\u51fa\u6d41\u3002\u6570\u636e\u5c06\u4f1a\u5728\u8f93\u51fa\u6d41\u7b49\u5f85\uff0c\u76f4\u5230\u5f00\u59cb\u6d88\u8d39\u5b83\u3002 \u4e00\u4e9b\u8bbe\u5907\uff0c\u5217\u5982\u6587\u4ef6\u548c\u7f51\u8def\uff0c\u6709\u80fd\u529b\u4f5c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u6e90\u3002 \u6d41\u7684\u597d\u5904\u5c31\u662f\u7a0b\u5e8f\u5458\u53ea\u9700\u8981\u5b66\u4f1a\u7b80\u5355\u7684\u4ea4\u4e92\uff0c\u5c31\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u4e2d\u8bfb\u5199\u6570\u636e\u3002\u6d41\u5b9e\u9645\u4e0a\u5982\u4f55\u4e0e\u8fde\u63a5\u5230\u5b83\u7684\u5b9e\u9645\u8bbe\u5907\u63a5\u53e3\u8fdb\u884c\u6c9f\u901a\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u3002 C++ \u4e2d\u7684\u8f93\u5165\u8f93\u51fa \u00b6 \u5c3d\u7ba1 ios \u6d3e\u751f\u81ea ios_base \uff0c ios \u901a\u5e38\u662f\u4f60\u4f1a\u4f7f\u7528\u7684\u6700\u57fa\u7840\u7684\u7c7b\u3002 ios \u7c7b\u5b9a\u4e49\u4e86\u5f88\u591a\u4e1c\u897f\uff0c\u5e38\u89c1\u4e8e\u8f93\u5165\u8f93\u51fa\u6d41\u3002\u6211\u4eec\u5c06\u4f1a\u5728\u672a\u6765\u7684\u8bfe\u7a0b\u4e2d\u4f7f\u7528\u4ed6\u4eec\u3002 istream \u7c7b\u662f\u4e00\u4e2a\u57fa\u7840\u7c7b\uff0c\u88ab\u4f7f\u7528\u4e3a\u8f93\u5165\u6d41\u3002\u4f7f\u7528\u8f93\u5165\u6d41\uff0c\u63d0\u53d6\u64cd\u4f5c\u7b26(>>) \u88ab\u7528\u6765\u79fb\u9664\u6d41\u4e2d\u7684\u503c\u3002\u8fd9\u662f\u6709\u610f\u4e49\u7684\uff1a\u5f53\u7528\u6237\u6309\u4e0b\u952e\u76d8\u7684\u952e\uff0c\u8f93\u5165\u7684\u952e\u7801\u88ab\u653e\u5728\u8f93\u5165\u6d41\u4e2d\u3002\u4f60\u7684\u7a0b\u5e8f\u7d27\u63a5\u7740\u4f1a\u63d0\u53d6\u8fd9\u4e2a\u503c\u5f53\u5b83\u53ef\u7528\u65f6\u3002 ostream \u7c7b\u662f\u57fa\u7840\u7684\u5904\u7406\u8f93\u51fa\u6d41\u7684\u7c7b\u3002\u4f7f\u7528\u8f93\u51fa\u6d41\uff0c\u63d2\u5165\u64cd\u4f5c\u7b26(<<)\u88ab\u7528\u6765\u5c06\u503c\u653e\u5165\u6d41\u4e2d\u3002\u8fd9\u4e5f\u5f88\u6709\u610f\u4e49\uff1a\u4f60\u63d2\u5165\u4f60\u7684\u503c\u5230\u6d41\u4e2d\uff0c\u6570\u636e\u4e4b\u540e\u4f1a\u88ab\u6d88\u8d39\u8005\uff08\u4f8b\u5982\uff1a\u663e\u793a\u5668\uff09\u4f7f\u7528\u3002 iostream \u7c7b\u53ef\u4ee5\u540c\u5c5e\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u5141\u8bb8\u53cc\u5411I/O \u00b6 \u6700\u540e\uff0c\u6709\u51e0\u4e2a\u7c7b\u540d\u4ee5 _withassign \u7ed3\u5c3e\u7684\u7c7b\u3002\u8fd9\u4e9b\u6d41\u7c7b\u6d3e\u751f\u81ea istream \uff0c ostream \u548c iostream \uff08\u5206\u522b\u7684\uff09\u5e26\u6709\u4e00\u4e2a \u8d4b\u503c\u64cd\u4f5c\u7b26\u5b9a\u4e49\uff0c\u5141\u8bb8\u4f60\u8d4b\u503c\u4e00\u4e2a\u6d41\u7ed9\u53e6\u4e00\u4e2a\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u4f1a\u76f4\u63a5\u64cd\u4f5c\u8fd9\u4e9b\u7c7b\u3002 C++ \u4e2d\u7684\u6807\u51c6\u6d41 \u00b6 A standard stream is a pre-connected stream provided to a computer program by its environment. C++ comes with four predefined standard stream objects that have already been set up for your use. The first three, you have seen before: \u4e00\u4e2a\u6807\u51c6\u6d41\u662f\uff0c\u63d0\u4f9b\u7ed9\u4e00\u4e2a\u7535\u8111\u7a0b\u5e8f\u7684\u4e00\u4e2a\u9884\u94fe\u63a5\u7684\u6d41\uff08A standard stream is a pre-connected stream provided to a computer program by its environment.\uff09\u3002C++ \u9644\u5e26\u4e864\u4e2a\u9884\u5b9a\u4e49\u7684\u6807\u51c6\u6d41\uff0c\u88ab\u5b9a\u4e49\u6765\u63d0\u4f9b\u7ed9\u4f60\u4f7f\u7528\u7684\uff0c\u4f60\u4e4b\u524d\u770b\u5230\u8fc7\u7684\uff1a cin \u2014\u2014 \u4e00\u4e2a istream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u8f93\u5165\uff08\u901a\u5e38\u662f\u952e\u76d8\uff09 cout \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u6ce8\u8f93\u51fa\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09 cerr \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u65e0buffer\u7684\u8f93\u51fa clog \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u6709buffer\u7684\u8f93\u51fa \u65e0 buffer \u70b9\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u7acb\u523b\u6267\u884c\uff0c\u800c\u5e26buffer\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u50a8\u5b58\u5e76\u4e14\u4ee5\u5757\u4e3a\u5355\u4f4d\u5199\u51fa\u3002\u56e0\u4e3a clog \u4e0d\u662f\u5f88\u5e38\u7528\uff0c\u5b83\u901a\u5e38\u4e5f\u88ab\u6807\u51c6\u6d41\u5217\u8868\u4e2d\u5ffd\u7565\u3002 \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u770b\u66f4\u591a\u7684 I/O \u76f8\u5173\u7684\u8be6\u7ec6\u529f\u80fd","title":"18.1 \u8f93\u5165\u8f93\u51fa\u6d41"},{"location":"23-input-and-output/23.1-input-and-output-streams/#181","text":"18.1 \u2014 Input and output (I/O) streams By Alex on February 28 th , 2008 | last modified by Alex on January 23 rd , 2020 \u7ffb\u8bd1By dashjay \u8f93\u5165\u548c\u8f93\u51fa\u529f\u80fd\u6ca1\u6709\u5b9a\u4e49\u4f5c\u4e3a C++ \u7684\u6838\u5fc3\u90e8\u5206\uff0c\u4f46\u662f\u4e5f\u88ab\u901a\u8fc7 C++ \u7684\u6807\u51c6\u5e93\u63d0\u4f9b\uff08\u4e5f\u5b58\u5728\u4e8e std \u547d\u540d\u7a7a\u95f4\uff09\u3002\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u4f60\u5f15\u7528\u4e86 <iostrea> \u5e93\u7684\u5934\u90e8\u5e76\u4e14\u4f7f\u7528 cin \u548c cout \u5bf9\u8c61\u6765\u505a\u7b80\u5355\u7684 I/O. \u5728\u8fd9\u4e2a\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u4f1a\u66f4\u8be6\u7ec6\u7684\u770b\u4e00\u4e0b\u554a iostream \u5e93\u3002","title":"18.1 \u8f93\u5165\u8f93\u51fa\u6d41"},{"location":"23-input-and-output/23.1-input-and-output-streams/#the-iostream-library","text":"\u5f53\u4f60\u5f15\u7528\u4e86 iostream \u7684\u5934\u90e8\uff0c\u4f60\u53ef\u4ee5\u8bbf\u95ee\u6574\u4e2a I/O \u7684\u67b6\u6784\u3002\uff08\u5f15\u5165\u4e86\u4e00\u4e2a\u540d\u5b57\u53eb\u505a iostream \u7684\u7c7b\uff09\u3002\u7c7b\u7ed3\u6784\uff08\u975e\u6587\u4ef6IO\uff09\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff1a \u7b2c\u4e00\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u4e8b\u60c5\u5c31\u662f\u5b83\u4f7f\u7528\u4e86\u591a\u7ee7\u627f\uff08\u4ee5\u524d\u6211\u4eec\u8bf4\u8fc7\u8981\u907f\u514d\u7684\uff09\u3002\u7136\u800c\uff0c iostream \u5e93\u88ab\u8bbe\u8ba1\u5e76\u4e14\u5e7f\u6cdb\u5730\u6d4b\u8bd5\u907f\u514d\u591a\u7ee7\u627f\u7684\u95ee\u9898\uff0c\u56e0\u6b64\u4f60\u53ef\u4ee5\u4e0d\u7528\u4e1d\u6beb\u62c5\u5fc3\u7684\u4f7f\u7528\u5b83\u3002","title":"The iostream library"},{"location":"23-input-and-output/23.1-input-and-output-streams/#_1","text":"Streams \u7b2c\u4e8c\u4ef6\u4f60\u53ef\u80fd\u6ce8\u610f\u5230\u7684\u5c31\u662f\u5355\u8bcd stream \uff0c\u5b83\u7ecf\u5e38\u88ab\u6ee5\u7528\u3002\u4f5c\u4e3a\u6700\u57fa\u7840\u7684\u57fa\u7c7b\uff0cC++ \u4e2d\u7684 I/O \u4f7f\u7528\u6d41\u6765\u5b9e\u73b0\u3002\u62bd\u8c61\u6765\u8bb2\uff0c\u4e00\u4e2a stream \u5c31\u662f\u4e00\u4e2a\u5b57\u8282\u5e8f\u5217\u53ef\u4ee5\u88ab\u6309\u987a\u5e8f\u8bbf\u95ee\u3002\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\uff0c\u4e00\u4e2a stream \u53ef\u80fd\u4ea7\u751f\u6216\u8005\u6d88\u8d39\u6f5c\u5728\u7684\u65e0\u9650\u7684\u6570\u636e\u3002 \u901a\u5e38\uff0c\u6211\u4eec\u5904\u7406\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6d41\u3002\u8f93\u5165\u6d41\u88ab\u7528\u6765\u4ece\u4e00\u4e2a\u6570\u636e\u751f\u4ea7\u8005\u7ef4\u6301\u8f93\u5165\uff0c\u4f8b\u5982\u4e00\u6b21\u952e\u76d8\u89e6\u53d1\uff0c\u4e00\u4e2a\u6587\u4ef6\uff0c\u6216\u8005\u4e00\u4e2a\u7f51\u7edc\u3002\u4f8b\u5982\uff0c\u7528\u6237\u53ef\u80fd\u6309\u4e0b\u4e00\u4e2a\u6309\u94ae\u5f53\u7a0b\u5e8f\u6ca1\u6709\u671f\u5f85\u4efb\u4f55\u8f93\u5165\u3002\u4e0d\u4f1a\u5ffd\u7565\u7528\u6237\u7684\u6309\u952e\uff0c\u800c\u662f\u628a\u6570\u636e\u653e\u8fdb\u8f93\u5165\u6d41\u4e2d\uff0c\u5b83\u4f1a\u7b49\u5f85\u77e5\u9053\u7a0b\u5e8f\u63a5\u6536\u8fd9\u4e2a\u8f93\u5165\u3002 \u76f8\u53cd\u7684\uff0c\u8f93\u51fa\u6d41\u88ab\u7528\u6765\u6301\u7eed\u8f93\u51fa\u63d0\u4f9b\u7ed9\u7279\u5b9a\u7684\u6570\u636e\u6d88\u8d39\u8005\uff0c\u4f8b\u5982\u4e00\u4e2a\u663e\u793a\u5668\uff0c\u4e00\u4e2a\u6587\u4ef6\u6216\u8005\u4e00\u4e2a\u6253\u5370\u673a\u3002\u5f53\u5199\u6570\u636e\u5230\u4efb\u4f55\u8bbe\u5907\uff0c\u5e76\u4e14\u8bbe\u5907\u53ef\u80fd\u6ca1\u6709\u51c6\u5907\u597d\u63a5\u6536\u6570\u636e \u2014\u2014\u2014\u2014 \u4f8b\u5982\uff0c\u6253\u5370\u673a\u4ecd\u7136\u6b63\u5728\u9884\u70ed\u5f53\u7a0b\u5e8f\u5c1d\u8bd5\u5199\u5165\u6570\u636e\u5230\u5b83\u7684\u8f93\u51fa\u6d41\u3002\u6570\u636e\u5c06\u4f1a\u5728\u8f93\u51fa\u6d41\u7b49\u5f85\uff0c\u76f4\u5230\u5f00\u59cb\u6d88\u8d39\u5b83\u3002 \u4e00\u4e9b\u8bbe\u5907\uff0c\u5217\u5982\u6587\u4ef6\u548c\u7f51\u8def\uff0c\u6709\u80fd\u529b\u4f5c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u6e90\u3002 \u6d41\u7684\u597d\u5904\u5c31\u662f\u7a0b\u5e8f\u5458\u53ea\u9700\u8981\u5b66\u4f1a\u7b80\u5355\u7684\u4ea4\u4e92\uff0c\u5c31\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u4e2d\u8bfb\u5199\u6570\u636e\u3002\u6d41\u5b9e\u9645\u4e0a\u5982\u4f55\u4e0e\u8fde\u63a5\u5230\u5b83\u7684\u5b9e\u9645\u8bbe\u5907\u63a5\u53e3\u8fdb\u884c\u6c9f\u901a\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u3002","title":"\u6d41"},{"location":"23-input-and-output/23.1-input-and-output-streams/#c","text":"\u5c3d\u7ba1 ios \u6d3e\u751f\u81ea ios_base \uff0c ios \u901a\u5e38\u662f\u4f60\u4f1a\u4f7f\u7528\u7684\u6700\u57fa\u7840\u7684\u7c7b\u3002 ios \u7c7b\u5b9a\u4e49\u4e86\u5f88\u591a\u4e1c\u897f\uff0c\u5e38\u89c1\u4e8e\u8f93\u5165\u8f93\u51fa\u6d41\u3002\u6211\u4eec\u5c06\u4f1a\u5728\u672a\u6765\u7684\u8bfe\u7a0b\u4e2d\u4f7f\u7528\u4ed6\u4eec\u3002 istream \u7c7b\u662f\u4e00\u4e2a\u57fa\u7840\u7c7b\uff0c\u88ab\u4f7f\u7528\u4e3a\u8f93\u5165\u6d41\u3002\u4f7f\u7528\u8f93\u5165\u6d41\uff0c\u63d0\u53d6\u64cd\u4f5c\u7b26(>>) \u88ab\u7528\u6765\u79fb\u9664\u6d41\u4e2d\u7684\u503c\u3002\u8fd9\u662f\u6709\u610f\u4e49\u7684\uff1a\u5f53\u7528\u6237\u6309\u4e0b\u952e\u76d8\u7684\u952e\uff0c\u8f93\u5165\u7684\u952e\u7801\u88ab\u653e\u5728\u8f93\u5165\u6d41\u4e2d\u3002\u4f60\u7684\u7a0b\u5e8f\u7d27\u63a5\u7740\u4f1a\u63d0\u53d6\u8fd9\u4e2a\u503c\u5f53\u5b83\u53ef\u7528\u65f6\u3002 ostream \u7c7b\u662f\u57fa\u7840\u7684\u5904\u7406\u8f93\u51fa\u6d41\u7684\u7c7b\u3002\u4f7f\u7528\u8f93\u51fa\u6d41\uff0c\u63d2\u5165\u64cd\u4f5c\u7b26(<<)\u88ab\u7528\u6765\u5c06\u503c\u653e\u5165\u6d41\u4e2d\u3002\u8fd9\u4e5f\u5f88\u6709\u610f\u4e49\uff1a\u4f60\u63d2\u5165\u4f60\u7684\u503c\u5230\u6d41\u4e2d\uff0c\u6570\u636e\u4e4b\u540e\u4f1a\u88ab\u6d88\u8d39\u8005\uff08\u4f8b\u5982\uff1a\u663e\u793a\u5668\uff09\u4f7f\u7528\u3002","title":"C++ \u4e2d\u7684\u8f93\u5165\u8f93\u51fa"},{"location":"23-input-and-output/23.1-input-and-output-streams/#iostream-io","text":"\u6700\u540e\uff0c\u6709\u51e0\u4e2a\u7c7b\u540d\u4ee5 _withassign \u7ed3\u5c3e\u7684\u7c7b\u3002\u8fd9\u4e9b\u6d41\u7c7b\u6d3e\u751f\u81ea istream \uff0c ostream \u548c iostream \uff08\u5206\u522b\u7684\uff09\u5e26\u6709\u4e00\u4e2a \u8d4b\u503c\u64cd\u4f5c\u7b26\u5b9a\u4e49\uff0c\u5141\u8bb8\u4f60\u8d4b\u503c\u4e00\u4e2a\u6d41\u7ed9\u53e6\u4e00\u4e2a\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4f60\u4e0d\u4f1a\u76f4\u63a5\u64cd\u4f5c\u8fd9\u4e9b\u7c7b\u3002","title":"iostream \u7c7b\u53ef\u4ee5\u540c\u5c5e\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u5141\u8bb8\u53cc\u5411I/O"},{"location":"23-input-and-output/23.1-input-and-output-streams/#c_1","text":"A standard stream is a pre-connected stream provided to a computer program by its environment. C++ comes with four predefined standard stream objects that have already been set up for your use. The first three, you have seen before: \u4e00\u4e2a\u6807\u51c6\u6d41\u662f\uff0c\u63d0\u4f9b\u7ed9\u4e00\u4e2a\u7535\u8111\u7a0b\u5e8f\u7684\u4e00\u4e2a\u9884\u94fe\u63a5\u7684\u6d41\uff08A standard stream is a pre-connected stream provided to a computer program by its environment.\uff09\u3002C++ \u9644\u5e26\u4e864\u4e2a\u9884\u5b9a\u4e49\u7684\u6807\u51c6\u6d41\uff0c\u88ab\u5b9a\u4e49\u6765\u63d0\u4f9b\u7ed9\u4f60\u4f7f\u7528\u7684\uff0c\u4f60\u4e4b\u524d\u770b\u5230\u8fc7\u7684\uff1a cin \u2014\u2014 \u4e00\u4e2a istream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u8f93\u5165\uff08\u901a\u5e38\u662f\u952e\u76d8\uff09 cout \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u6ce8\u8f93\u51fa\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09 cerr \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u65e0buffer\u7684\u8f93\u51fa clog \u2014\u2014 \u4e00\u4e2a ostream_withassign \u7c7b\uff0c\u8fde\u63a5\u5230\u6807\u51c6\u9519\u8bef\uff08\u901a\u5e38\u662f\u663e\u793a\u5668\uff09\uff0c\u63d0\u4f9b\u6709buffer\u7684\u8f93\u51fa \u65e0 buffer \u70b9\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u7acb\u523b\u6267\u884c\uff0c\u800c\u5e26buffer\u7684\u8f93\u51fa\u901a\u5e38\u88ab\u50a8\u5b58\u5e76\u4e14\u4ee5\u5757\u4e3a\u5355\u4f4d\u5199\u51fa\u3002\u56e0\u4e3a clog \u4e0d\u662f\u5f88\u5e38\u7528\uff0c\u5b83\u901a\u5e38\u4e5f\u88ab\u6807\u51c6\u6d41\u5217\u8868\u4e2d\u5ffd\u7565\u3002 \u5728\u63a5\u4e0b\u6765\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u770b\u66f4\u591a\u7684 I/O \u76f8\u5173\u7684\u8be6\u7ec6\u529f\u80fd","title":"C++ \u4e2d\u7684\u6807\u51c6\u6d41"},{"location":"23-input-and-output/23.2-input-with-istream/","text":"18.2 \u4f7f\u7528 istream \u8f93\u5165 \u00b6 By Alex on March 4 th , 2008 | last modified by nascardriver on August 3 rd , 2020 \u7ffb\u8bd1by dashjay 2020-08-10 iostream \u5e93\u662f\u76f8\u5f53\u590d\u6742\u7684 \u2014\u2014 \u56e0\u6b64\u5728\u8fd9\u4e9b\u6559\u7a0b\u4e2d\u6211\u4eec\u5c06\u4e0d\u4f1a\u6709\u80fd\u529b\u53bb\u8986\u76d6\u5168\u9762\u3002\u7136\u800c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u7ed9\u4f60\u6700\u5e38\u7528\u7684\u51fd\u6570\u3002\u5728\u8fd9\u6b21\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5b66\u4e60\u8f93\u5165\u8fd9\u5757\u5185\u5bb9\uff08istrea\uff09\u3002 \u63d0\u53d6\u64cd\u4f5c\u7b26 \u00b6 \u6b63\u5982\u73b0\u5728\u5f88\u591a\u8bfe\u7a0b\u4e2d\u6240\u770b\u5230\u7684\u90a3\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u63d0\u53d6\u64cd\u4f5c\u7b26 (>>) \u6765\u4ece\u8f93\u5165\u6d41\u8bfb\u53d6\u4fe1\u606f\u3002C++ \u5bf9\u6240\u6709\u5185\u5efa\u7684\u6570\u636e\u7c7b\u578b\u90fd\u6709\u9884\u5b9a\u4e49\u7684\u63d0\u53d6\u64cd\u4f5c\u7b26\uff0c\u5e76\u4e14\u4f60\u65e9\u5df2\u77e5\u9053\u5982\u4f55\u4e3a\u81ea\u5df1\u7684\u7c7b\u91cd\u8f7d\u63d0\u53d6\u8fd0\u7b97\u7b26\u6765\u76f4\u63a5\u8f93\u51fa\u3002 \u5f53\u8bfb\u53d6\u5b57\u7b26\u4e32\u65f6\uff0c\u4e00\u4e2a\u5e38\u89c1\u662f\u5982\u4f55\u907f\u514d\u8f93\u5165\u8d8a\u754c\u3002\u8fd9\u6709\u4e00\u4e2a\u4f8b\u5b50\uff1a char buf [ 10 ]; std :: cin >> buf ; \u5982\u679c\u7528\u6237\u8f93\u5165 18 \u4e2a\u5b57\u7b26\u4e32\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u7f13\u51b2\u533a\u6ea2\u51fa\uff0c\u7cdf\u7cd5\u7684\u4e1c\u897f\u4f1a\u53d1\u751f\u3002\u5927\u4f53\u4e0a\u8bb2\uff0c\u5047\u8bbe\u7528\u6237\u4f1a\u8f93\u5165\u591a\u5c11\u5b57\u7b26\u4e0d\u662f\u4e00\u4e2a\u597d\u529e\u6cd5\u3002 \u6709\u4e00\u4e2a\u901a\u8fc7\u64cd\u7eb5\u5668(manipulators)\u89e3\u51b3\u6b64\u95ee\u9898\u7684\u65b9\u6cd5\u3002\u4e00\u4e2a manipulators \u662f\u4e00\u4e2a\u5bf9\u8c61\u7528\u6765\u4fee\u6539\u4e00\u4e2a\u6d41\uff0c\u5f53\u4f7f\u7528 \u63d0\u53d6(>>) \u6216\u63d2\u5165(<<)\u64cd\u4f5c\u7b26\u65f6\u3002\u4e00\u4e2a\u4f60\u65e9\u5c31\u4f7f\u7528\u8fc7\u7684 manipulators \u5c31\u662f std::endl \uff0c\u5b83\u53ef\u4ee5\u6253\u5370\u4e00\u4e2a\u65b0\u884c\uff0c\u5e76\u4e14\u5237\u65b0\u4efb\u4f55\u5df2\u7ecf\u7f13\u5b58\u7684\u8f93\u51fa\u3002C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a manipulators \u53eb\u505a setw \uff08\u5728 iomanip.h \u5934\u4e2d\uff09\u53ef\u4ee5\u88ab\u7528\u6765\u9650\u5236\u8bfb\u53d6\u7684\u5b57\u7b26\u6570\u91cf\u3002\u8981\u4f7f\u7528 setw() \uff0c\u7b80\u5355\u7684\u63d0\u4f9b\u4e00\u4e2a\u6700\u5927\u7684\u8981\u8bfb\u53d6\u5b57\u7b26\u6570\u91cf\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u4e14\u63d2\u5165\u5230\u4f60\u7684\u8f93\u5165\u8bed\u53e5\u4e2d\uff0c\u50cf\u8fd9\u6837\uff1a #include <iomanip.h> char buf [ 10 ]; std :: cin >> std :: setw ( 10 ) >> buf ; This program will now only read the first 9 characters out of the stream (leaving room for a terminator). Any remaining characters will be left in the stream until the next extraction. \u8fd9\u4e2a\u7a0b\u5e8f\u73b0\u5728\u5c06\u4f1a\u8bfb\u53d6\u4ece\u6d41\u4e2d\u8bfb\u53d6\u524d9\u4e2a\u5b57\u7b26\uff08\u7559\u4e00\u4e2a\u7a7a\u95f4\u7ed9\u7ec8\u6b62\u7b26\uff09\u3002\u4efb\u4f55\u5176\u4ed6\u7684\u5b57\u7b26\u90fd\u4f1a\u88ab\u7559\u5728\u6d41\u4e2d\uff0c\u6307\u5bfc\u4e0b\u6b21\u63d0\u53d6\u3002 \u63d0\u53d6\u548c\u7a7a\u683c \u00b6 \u4e00\u4ef6\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u90fd\u5fd8\u4e86\u63d0\u8d77\u7684\u4e8b\u60c5\uff0c\u5c31\u662f\u63d0\u53d6\u64cd\u4f5c\u7b26\u548c \u201d\u683c\u5f0f\u5316\u201c \u540e\u7684\u6570\u636e\u5de5\u4f5c \u2014\u2014\u2014\u2014 \u662f\u7684\uff0c\u5b83\u4f1a\u8df3\u8fc7\u7a7a\u767d\uff08\u7a7a\u767d\uff0c\u5236\u8868\u7b26\uff0c\u65b0\u884c\uff09\u3002 \u770b\u4e00\u773c\u4e0b\u5217\u7a0b\u5e8f\uff1a int main () { char ch ; while ( std :: cin >> ch ) std :: cout << ch ; return 0 ; } \u5f53\u7528\u6237\u8f93\u5165\u4e0b\u5217\u5b57\u7b26\u65f6\uff1a Hello my name is Alex \u63d0\u53d6\u64cd\u4f5c\u7b26\u8df3\u8fc7\u4e86\u7a7a\u683c\u548c\u65b0\u884c\uff0c\u56e0\u6b64\u8f93\u51fa\u662f\uff1a HellomynameisAlex \u901a\u5e38\uff0c\u4f60\u5c06\u4f1a\u60f3\u83b7\u53d6\u7528\u6237\u8f93\u5165\u4f46\u662f\u4e00\u8d77\u7a7a\u683c\u3002\u4e3a\u4e86\u8fd9\u4e48\u505a\uff0c istream \u7c7b\u63d0\u4f9b\u4e86\u8bb8\u591a\u51fd\u6570\u53ef\u4ee5\u51fd\u6570\u3002 \u6700\u6709\u7528\u7684\u5c31\u662f get() \u51fd\u6570\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u4ece\u8f93\u5165\u6d41\u4e2d\u83b7\u53d6\u4e00\u4e2a\u5b57\u7b26\uff0c\u4e0b\u9762\u662f\u4e00\u4e2a\u548c\u4e0a\u65b9\u5177\u6709\u7528\u6837\u529f\u80fd\u7684\u7b80\u5355\u4f8b\u5b50\uff0c\u4f46\u662f\u5b83\u4f7f\u7528 get() int main () { char ch ; while ( std :: cin . get ( ch )) std :: cout << ch ; return 0 ; } \u73b0\u5728\u6211\u4eec\u4f7f\u7528\u4e0b\u5217\u8f93\u5165\uff1a Hello my name is Alex \u8f93\u51fa\u5219\u662f\uff1a Hello my name is Alex std::get() \u4e5f\u6709\u4e00\u4e2a string \u7248\u672c\uff0c\u53ef\u4ee5\u4f20\u5165\u4e00\u4e2a\u6700\u5927\u5b57\u7b26\u6570\u6765\u8bfb\u53d6\uff1a int main () { char strBuf [ 11 ]; std :: cin . get ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; return 0 ; } \u5982\u679c\u4f60\u8f93\u5165\uff1a Hello my name is Alex \u8f93\u51fa\u5219\u662f\uff1a Hello my n \u6ce8\u610f\u5230\u6211\u4eec\u4ec5\u4ec5\u8bfb\u53d6\u4e86\u524d 10 \u4e2a\u5b57\u7b26\uff08\u6211\u4eec\u4e0d\u5f97\u4e0d\u4e3a\u7ec8\u6b62\u7b26\u7559\u4e00\u4e2a\u7a7a\uff09\u3002\u5269\u4e0b\u7684\u5b57\u7b26\u4f1a\u7559\u5728\u8f93\u5165\u6d41\u4e2d\u3002 \u4e00\u4ef6\u6709\u5173 get() \u7684\u91cd\u8981\u7684\u4e8b\u662f\u4ed6\u4e0d\u80fd\u8bfb\u53d6\u4e00\u4e2a\u65b0\u884c\u5b57\u7b26\uff01\u8fd9\u53ef\u80fd\u4f1a\u5f97\u5230\u4e00\u4e9b\u610f\u6599\u4e4b\u5916\u7684\u7ed3\u679c int main () { char strBuf [ 11 ]; // Read up to 10 characters std :: cin . get ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; // Read up to 10 more characters std :: cin . get ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; return 0 ; } \u5982\u679c\u7528\u6237\u8f93\u5165\uff1a Hello ! \u7a0b\u5e8f\u5c06\u4f1a\u8f93\u51fa Hello ! \u7136\u540e\u5c31\u7a81\u7136\u4e2d\u6b62\u4e86\uff01\u4e3a\u4ec0\u4e48\u5b83\u4e0d\u8be2\u95ee\u53e6\u591610\u4e2a\u5b57\u7b26\u5462\uff1f\u7b54\u6848\u5c31\u662f\u56e0\u4e3a\u7b2c\u4e00\u6b21 get() \u8bfb\u53d6\u5230\u4e86\u65b0\u884c\uff0c\u7136\u540e\u505c\u6b62\u4e86\u3002\u7b2c\u4e8c\u4e2a get() \u770b\u5230\u8fd9\u4f9d\u7136\u60f3\u8981\u8bfb\u53d6\u3002\u4f46\u662f\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f\u4e00\u4e2a\u65b0\u884c\u3002\u56e0\u6b64\u5b83\u7acb\u523b\u4e2d\u6b62\u3002 \u56e0\u6b64\uff0c\u8fd9\u6709\u53e6\u4e00\u4e2a\u51fd\u6570\u53eb\u505a getline() \u80fd\u591f\u60f3 get() \u90a3\u6837\u5de5\u4f5c\uff0c\u4f46\u662f\u4e5f\u80fd\u8bfb\u53d6\u4e00\u4e2a\u65b0\u884c\u3002 int main () { char strBuf [ 11 ]; // Read up to 10 characters std :: cin . getline ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; // Read up to 10 more characters std :: cin . getline ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; return 0 ; } \u8fd9\u7aef\u4ee3\u7801\u5c06\u4f1a\u50cf\u4f60\u6240\u671f\u5f85\u7684\u90a3\u6837\u5de5\u4f5c\uff0c\u5373\u4f7f\u7528\u6237\u8f93\u5165\u4e00\u4e2a\u5e26\u6709\u65b0\u884c\u7684\u5b57\u7b26\u4e32\u3002 \u5982\u679c\u4f60\u9700\u8981\u77e5\u9053\u4e0a\u6b21 getline() \u63d0\u53d6\u4e86\u591a\u5c11\u5b57\u7b26\uff0c\u7528 gcount() \uff1a int main () { char strBuf [ 100 ]; std :: cin . getline ( strBuf , 100 ); std :: cout << strBuf << '\\n' ; std :: cout << std :: cin . gcount () << \" characters were read\" << std :: endl ; return 0 ; } \u4e00\u4e2a\u4e3a std::string \u63d0\u4f9b\u7684 getline() \u6709\u4e00\u4e2a\u7279\u6b8a\u7248\u672c\u7684 getline() \u5728 istream \u7c7b\u7684\u5916\u9762\uff0c\u88ab\u7528\u6765\u8bfb\u53d6\u5230 std::stirng \u4e2d\u3002\u8fd9\u4e2a\u7279\u6b8a\u7248\u672c\u7684\u51fd\u6570\u4e0d\u662f ostream \u4e5f\u4e0d\u662f istream \u7684\u6210\u5458\u3002\u5e76\u4e14\u5b83\u88ab\u5305\u542b\u5728 string \u5934\u90e8\u4e2d\u3002\u8fd9\u662f\u4e00\u4e2a\u4f7f\u7528\u5b83\u7684\u4f8b\u5b50\uff1a # include <string> # include <iostream> int main () { std :: string strBuf ; std :: getline ( std :: cin , strBuf ); std :: cout << strBuf << '\\n' ; return 0 ; } \u4e00\u4e9b\u6709\u7528\u7684\u8f93\u5165\u51fd\u6570 \u00b6 \u8fd9\u91cc\u6709\u4e00\u4e9b\u6709\u7528\u7684\u8f93\u5165\u51fd\u6570\u4f60\u53ef\u80fd\u4f1a\u4f7f\u7528\uff1a ignore() \u9057\u5f03\u6d41\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u3002 ignore(int nCount) \u9057\u5f03\u524d nCount \u4e2a\u5b57\u7b26\u3002 peek() \u5141\u8bb8\u4ece\u6d41\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u5b57\u7b26\uff0c\u5e76\u4e14\u4e0d\u5c06\u4ed6\u4ece\u6d41\u4e2d\u79fb\u9664 unget() \u5f52\u8fd8\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\uff0c\u4f7f\u5f97\u5b83\u53ef\u4ee5\u53ef\u4ee5\u4e0b\u6b21\u518d\u88ab\u8bfb\u53d6\u3002 pushback(char ch) \u5141\u8bb8\u4f60\u653e\u7f6e\u4e00\u4e2a\u4f60\u9009\u62e9\u7684\u5b57\u7b26\u8fdb\u5165\u6d41\u4e2d\uff0c\u4ee5\u4fbf\u4e0b\u6b21\u8c03\u7528\u65f6\u8bfb\u53d6\u3002 \u6839\u636e\u4f60\u7684\u5de5\u4f5c\uff0cistream \u5305\u542b\u4e86\u8bb8\u591a\u5176\u4ed6\u7684\u51fd\u6570\u548c\u53d8\u91cf\u53ef\u80fd\u975e\u5e38\u6709\u7528\u3002\u7136\u800c\u90a3\u4e9b\u8bdd\u9898\u66f4\u52a0\u9002\u5408\u51fa\u73b0\u5728\u4e00\u4e2a\u6559\u7a0b\u6216\u8005\u4e13\u6ce8\u4e8e\u6807\u51c6\u5e93\u7684\u4e66\u4e2d\uff08\u4f8b\u5982 \u201cThe C++ Standard Library\u201d by Nicolai M. Josuttis\uff09","title":"18.2 \u4f7f\u7528 istream \u8f93\u5165"},{"location":"23-input-and-output/23.2-input-with-istream/#182-istream","text":"By Alex on March 4 th , 2008 | last modified by nascardriver on August 3 rd , 2020 \u7ffb\u8bd1by dashjay 2020-08-10 iostream \u5e93\u662f\u76f8\u5f53\u590d\u6742\u7684 \u2014\u2014 \u56e0\u6b64\u5728\u8fd9\u4e9b\u6559\u7a0b\u4e2d\u6211\u4eec\u5c06\u4e0d\u4f1a\u6709\u80fd\u529b\u53bb\u8986\u76d6\u5168\u9762\u3002\u7136\u800c\u6211\u4eec\u5c06\u4f1a\u5c55\u793a\u7ed9\u4f60\u6700\u5e38\u7528\u7684\u51fd\u6570\u3002\u5728\u8fd9\u6b21\u8bfe\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5b66\u4e60\u8f93\u5165\u8fd9\u5757\u5185\u5bb9\uff08istrea\uff09\u3002","title":"18.2 \u4f7f\u7528 istream \u8f93\u5165"},{"location":"23-input-and-output/23.2-input-with-istream/#_1","text":"\u6b63\u5982\u73b0\u5728\u5f88\u591a\u8bfe\u7a0b\u4e2d\u6240\u770b\u5230\u7684\u90a3\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u63d0\u53d6\u64cd\u4f5c\u7b26 (>>) \u6765\u4ece\u8f93\u5165\u6d41\u8bfb\u53d6\u4fe1\u606f\u3002C++ \u5bf9\u6240\u6709\u5185\u5efa\u7684\u6570\u636e\u7c7b\u578b\u90fd\u6709\u9884\u5b9a\u4e49\u7684\u63d0\u53d6\u64cd\u4f5c\u7b26\uff0c\u5e76\u4e14\u4f60\u65e9\u5df2\u77e5\u9053\u5982\u4f55\u4e3a\u81ea\u5df1\u7684\u7c7b\u91cd\u8f7d\u63d0\u53d6\u8fd0\u7b97\u7b26\u6765\u76f4\u63a5\u8f93\u51fa\u3002 \u5f53\u8bfb\u53d6\u5b57\u7b26\u4e32\u65f6\uff0c\u4e00\u4e2a\u5e38\u89c1\u662f\u5982\u4f55\u907f\u514d\u8f93\u5165\u8d8a\u754c\u3002\u8fd9\u6709\u4e00\u4e2a\u4f8b\u5b50\uff1a char buf [ 10 ]; std :: cin >> buf ; \u5982\u679c\u7528\u6237\u8f93\u5165 18 \u4e2a\u5b57\u7b26\u4e32\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u7f13\u51b2\u533a\u6ea2\u51fa\uff0c\u7cdf\u7cd5\u7684\u4e1c\u897f\u4f1a\u53d1\u751f\u3002\u5927\u4f53\u4e0a\u8bb2\uff0c\u5047\u8bbe\u7528\u6237\u4f1a\u8f93\u5165\u591a\u5c11\u5b57\u7b26\u4e0d\u662f\u4e00\u4e2a\u597d\u529e\u6cd5\u3002 \u6709\u4e00\u4e2a\u901a\u8fc7\u64cd\u7eb5\u5668(manipulators)\u89e3\u51b3\u6b64\u95ee\u9898\u7684\u65b9\u6cd5\u3002\u4e00\u4e2a manipulators \u662f\u4e00\u4e2a\u5bf9\u8c61\u7528\u6765\u4fee\u6539\u4e00\u4e2a\u6d41\uff0c\u5f53\u4f7f\u7528 \u63d0\u53d6(>>) \u6216\u63d2\u5165(<<)\u64cd\u4f5c\u7b26\u65f6\u3002\u4e00\u4e2a\u4f60\u65e9\u5c31\u4f7f\u7528\u8fc7\u7684 manipulators \u5c31\u662f std::endl \uff0c\u5b83\u53ef\u4ee5\u6253\u5370\u4e00\u4e2a\u65b0\u884c\uff0c\u5e76\u4e14\u5237\u65b0\u4efb\u4f55\u5df2\u7ecf\u7f13\u5b58\u7684\u8f93\u51fa\u3002C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a manipulators \u53eb\u505a setw \uff08\u5728 iomanip.h \u5934\u4e2d\uff09\u53ef\u4ee5\u88ab\u7528\u6765\u9650\u5236\u8bfb\u53d6\u7684\u5b57\u7b26\u6570\u91cf\u3002\u8981\u4f7f\u7528 setw() \uff0c\u7b80\u5355\u7684\u63d0\u4f9b\u4e00\u4e2a\u6700\u5927\u7684\u8981\u8bfb\u53d6\u5b57\u7b26\u6570\u91cf\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u4e14\u63d2\u5165\u5230\u4f60\u7684\u8f93\u5165\u8bed\u53e5\u4e2d\uff0c\u50cf\u8fd9\u6837\uff1a #include <iomanip.h> char buf [ 10 ]; std :: cin >> std :: setw ( 10 ) >> buf ; This program will now only read the first 9 characters out of the stream (leaving room for a terminator). Any remaining characters will be left in the stream until the next extraction. \u8fd9\u4e2a\u7a0b\u5e8f\u73b0\u5728\u5c06\u4f1a\u8bfb\u53d6\u4ece\u6d41\u4e2d\u8bfb\u53d6\u524d9\u4e2a\u5b57\u7b26\uff08\u7559\u4e00\u4e2a\u7a7a\u95f4\u7ed9\u7ec8\u6b62\u7b26\uff09\u3002\u4efb\u4f55\u5176\u4ed6\u7684\u5b57\u7b26\u90fd\u4f1a\u88ab\u7559\u5728\u6d41\u4e2d\uff0c\u6307\u5bfc\u4e0b\u6b21\u63d0\u53d6\u3002","title":"\u63d0\u53d6\u64cd\u4f5c\u7b26"},{"location":"23-input-and-output/23.2-input-with-istream/#_2","text":"\u4e00\u4ef6\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u90fd\u5fd8\u4e86\u63d0\u8d77\u7684\u4e8b\u60c5\uff0c\u5c31\u662f\u63d0\u53d6\u64cd\u4f5c\u7b26\u548c \u201d\u683c\u5f0f\u5316\u201c \u540e\u7684\u6570\u636e\u5de5\u4f5c \u2014\u2014\u2014\u2014 \u662f\u7684\uff0c\u5b83\u4f1a\u8df3\u8fc7\u7a7a\u767d\uff08\u7a7a\u767d\uff0c\u5236\u8868\u7b26\uff0c\u65b0\u884c\uff09\u3002 \u770b\u4e00\u773c\u4e0b\u5217\u7a0b\u5e8f\uff1a int main () { char ch ; while ( std :: cin >> ch ) std :: cout << ch ; return 0 ; } \u5f53\u7528\u6237\u8f93\u5165\u4e0b\u5217\u5b57\u7b26\u65f6\uff1a Hello my name is Alex \u63d0\u53d6\u64cd\u4f5c\u7b26\u8df3\u8fc7\u4e86\u7a7a\u683c\u548c\u65b0\u884c\uff0c\u56e0\u6b64\u8f93\u51fa\u662f\uff1a HellomynameisAlex \u901a\u5e38\uff0c\u4f60\u5c06\u4f1a\u60f3\u83b7\u53d6\u7528\u6237\u8f93\u5165\u4f46\u662f\u4e00\u8d77\u7a7a\u683c\u3002\u4e3a\u4e86\u8fd9\u4e48\u505a\uff0c istream \u7c7b\u63d0\u4f9b\u4e86\u8bb8\u591a\u51fd\u6570\u53ef\u4ee5\u51fd\u6570\u3002 \u6700\u6709\u7528\u7684\u5c31\u662f get() \u51fd\u6570\uff0c\u53ef\u4ee5\u7b80\u5355\u7684\u4ece\u8f93\u5165\u6d41\u4e2d\u83b7\u53d6\u4e00\u4e2a\u5b57\u7b26\uff0c\u4e0b\u9762\u662f\u4e00\u4e2a\u548c\u4e0a\u65b9\u5177\u6709\u7528\u6837\u529f\u80fd\u7684\u7b80\u5355\u4f8b\u5b50\uff0c\u4f46\u662f\u5b83\u4f7f\u7528 get() int main () { char ch ; while ( std :: cin . get ( ch )) std :: cout << ch ; return 0 ; } \u73b0\u5728\u6211\u4eec\u4f7f\u7528\u4e0b\u5217\u8f93\u5165\uff1a Hello my name is Alex \u8f93\u51fa\u5219\u662f\uff1a Hello my name is Alex std::get() \u4e5f\u6709\u4e00\u4e2a string \u7248\u672c\uff0c\u53ef\u4ee5\u4f20\u5165\u4e00\u4e2a\u6700\u5927\u5b57\u7b26\u6570\u6765\u8bfb\u53d6\uff1a int main () { char strBuf [ 11 ]; std :: cin . get ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; return 0 ; } \u5982\u679c\u4f60\u8f93\u5165\uff1a Hello my name is Alex \u8f93\u51fa\u5219\u662f\uff1a Hello my n \u6ce8\u610f\u5230\u6211\u4eec\u4ec5\u4ec5\u8bfb\u53d6\u4e86\u524d 10 \u4e2a\u5b57\u7b26\uff08\u6211\u4eec\u4e0d\u5f97\u4e0d\u4e3a\u7ec8\u6b62\u7b26\u7559\u4e00\u4e2a\u7a7a\uff09\u3002\u5269\u4e0b\u7684\u5b57\u7b26\u4f1a\u7559\u5728\u8f93\u5165\u6d41\u4e2d\u3002 \u4e00\u4ef6\u6709\u5173 get() \u7684\u91cd\u8981\u7684\u4e8b\u662f\u4ed6\u4e0d\u80fd\u8bfb\u53d6\u4e00\u4e2a\u65b0\u884c\u5b57\u7b26\uff01\u8fd9\u53ef\u80fd\u4f1a\u5f97\u5230\u4e00\u4e9b\u610f\u6599\u4e4b\u5916\u7684\u7ed3\u679c int main () { char strBuf [ 11 ]; // Read up to 10 characters std :: cin . get ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; // Read up to 10 more characters std :: cin . get ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; return 0 ; } \u5982\u679c\u7528\u6237\u8f93\u5165\uff1a Hello ! \u7a0b\u5e8f\u5c06\u4f1a\u8f93\u51fa Hello ! \u7136\u540e\u5c31\u7a81\u7136\u4e2d\u6b62\u4e86\uff01\u4e3a\u4ec0\u4e48\u5b83\u4e0d\u8be2\u95ee\u53e6\u591610\u4e2a\u5b57\u7b26\u5462\uff1f\u7b54\u6848\u5c31\u662f\u56e0\u4e3a\u7b2c\u4e00\u6b21 get() \u8bfb\u53d6\u5230\u4e86\u65b0\u884c\uff0c\u7136\u540e\u505c\u6b62\u4e86\u3002\u7b2c\u4e8c\u4e2a get() \u770b\u5230\u8fd9\u4f9d\u7136\u60f3\u8981\u8bfb\u53d6\u3002\u4f46\u662f\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f\u4e00\u4e2a\u65b0\u884c\u3002\u56e0\u6b64\u5b83\u7acb\u523b\u4e2d\u6b62\u3002 \u56e0\u6b64\uff0c\u8fd9\u6709\u53e6\u4e00\u4e2a\u51fd\u6570\u53eb\u505a getline() \u80fd\u591f\u60f3 get() \u90a3\u6837\u5de5\u4f5c\uff0c\u4f46\u662f\u4e5f\u80fd\u8bfb\u53d6\u4e00\u4e2a\u65b0\u884c\u3002 int main () { char strBuf [ 11 ]; // Read up to 10 characters std :: cin . getline ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; // Read up to 10 more characters std :: cin . getline ( strBuf , 11 ); std :: cout << strBuf << '\\n' ; return 0 ; } \u8fd9\u7aef\u4ee3\u7801\u5c06\u4f1a\u50cf\u4f60\u6240\u671f\u5f85\u7684\u90a3\u6837\u5de5\u4f5c\uff0c\u5373\u4f7f\u7528\u6237\u8f93\u5165\u4e00\u4e2a\u5e26\u6709\u65b0\u884c\u7684\u5b57\u7b26\u4e32\u3002 \u5982\u679c\u4f60\u9700\u8981\u77e5\u9053\u4e0a\u6b21 getline() \u63d0\u53d6\u4e86\u591a\u5c11\u5b57\u7b26\uff0c\u7528 gcount() \uff1a int main () { char strBuf [ 100 ]; std :: cin . getline ( strBuf , 100 ); std :: cout << strBuf << '\\n' ; std :: cout << std :: cin . gcount () << \" characters were read\" << std :: endl ; return 0 ; } \u4e00\u4e2a\u4e3a std::string \u63d0\u4f9b\u7684 getline() \u6709\u4e00\u4e2a\u7279\u6b8a\u7248\u672c\u7684 getline() \u5728 istream \u7c7b\u7684\u5916\u9762\uff0c\u88ab\u7528\u6765\u8bfb\u53d6\u5230 std::stirng \u4e2d\u3002\u8fd9\u4e2a\u7279\u6b8a\u7248\u672c\u7684\u51fd\u6570\u4e0d\u662f ostream \u4e5f\u4e0d\u662f istream \u7684\u6210\u5458\u3002\u5e76\u4e14\u5b83\u88ab\u5305\u542b\u5728 string \u5934\u90e8\u4e2d\u3002\u8fd9\u662f\u4e00\u4e2a\u4f7f\u7528\u5b83\u7684\u4f8b\u5b50\uff1a # include <string> # include <iostream> int main () { std :: string strBuf ; std :: getline ( std :: cin , strBuf ); std :: cout << strBuf << '\\n' ; return 0 ; }","title":"\u63d0\u53d6\u548c\u7a7a\u683c"},{"location":"23-input-and-output/23.2-input-with-istream/#_3","text":"\u8fd9\u91cc\u6709\u4e00\u4e9b\u6709\u7528\u7684\u8f93\u5165\u51fd\u6570\u4f60\u53ef\u80fd\u4f1a\u4f7f\u7528\uff1a ignore() \u9057\u5f03\u6d41\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u3002 ignore(int nCount) \u9057\u5f03\u524d nCount \u4e2a\u5b57\u7b26\u3002 peek() \u5141\u8bb8\u4ece\u6d41\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u5b57\u7b26\uff0c\u5e76\u4e14\u4e0d\u5c06\u4ed6\u4ece\u6d41\u4e2d\u79fb\u9664 unget() \u5f52\u8fd8\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\uff0c\u4f7f\u5f97\u5b83\u53ef\u4ee5\u53ef\u4ee5\u4e0b\u6b21\u518d\u88ab\u8bfb\u53d6\u3002 pushback(char ch) \u5141\u8bb8\u4f60\u653e\u7f6e\u4e00\u4e2a\u4f60\u9009\u62e9\u7684\u5b57\u7b26\u8fdb\u5165\u6d41\u4e2d\uff0c\u4ee5\u4fbf\u4e0b\u6b21\u8c03\u7528\u65f6\u8bfb\u53d6\u3002 \u6839\u636e\u4f60\u7684\u5de5\u4f5c\uff0cistream \u5305\u542b\u4e86\u8bb8\u591a\u5176\u4ed6\u7684\u51fd\u6570\u548c\u53d8\u91cf\u53ef\u80fd\u975e\u5e38\u6709\u7528\u3002\u7136\u800c\u90a3\u4e9b\u8bdd\u9898\u66f4\u52a0\u9002\u5408\u51fa\u73b0\u5728\u4e00\u4e2a\u6559\u7a0b\u6216\u8005\u4e13\u6ce8\u4e8e\u6807\u51c6\u5e93\u7684\u4e66\u4e2d\uff08\u4f8b\u5982 \u201cThe C++ Standard Library\u201d by Nicolai M. Josuttis\uff09","title":"\u4e00\u4e9b\u6709\u7528\u7684\u8f93\u5165\u51fd\u6570"},{"location":"23-input-and-output/23.3-output-with-ostream-and-ios/","text":"18.3 \u4f7f\u7528 ostrea \u548c ios \u8fdb\u884c\u8f93\u51fa \u00b6 \u5728\u8fd9\u4e2a\u90e8\u5206\uff0c\u6211\u4eec\u4f1a\u770b ostream \u7684\u5f88\u591a\u65b9\u9762\u3002 \u6ce8\u610f\uff1a\u672c\u8282\u8bfe\u6240\u6709\u7684 I/O \u51fd\u6570\u90fd\u5728 std \u547d\u540d\u7a7a\u95f4\u4e2d\u3002\u90a3\u610f\u5473\u7740\uff0c\u6240\u6709\u7684 I/O \u5bf9\u8c61\u548c\u51fd\u6570\u90fd\u4e0d\u5f97\u4e0d\u4f7f\u7528\u524d\u7f00 std:: \uff0c\u6216\u8005\u4f7f\u7528 using namespace std; \uff0c\u8fd9\u4e2a\u60c5\u51b5\u5fc5\u987b\u5411\u5927\u5bb6\u8bf4\u660e\u3002 \u8f93\u5165\u63d2\u5165\u64cd\u4f5c\u7b26 \u00b6 \u63d2\u5165\u64cd\u4f5c\u7b26 \uff08<<\uff09 \u88ab\u7528\u6765\u653e\u7f6e\u4fe1\u606f\u5230\u4e00\u4e2a\u8f93\u51fa\u6d41\u4e2d\u3002C++ \u4e3a\u6240\u6709\u7684\u5185\u5efa\u7c7b\u578b\u5b9a\u4e49\u4e86\u63d2\u5165\u64cd\u4f5c\uff0c\u5e76\u4e14\u4f60\u65e9\u5c31\u5b66\u4e60\u8fc7\u5982\u4f55\u901a\u8fc7\u4e3a\u4f60\u81ea\u5df1\u7c7b\u8fdb\u884c\u64cd\u4f5c\u7b26\u91cd\u8f7d\uff0c\u6765\u5b9e\u73b0\u63d2\u5165\u64cd\u4f5c\u7b26\u3002 \u5728\u8fd9\u8282\u6709\u5173 stream \u7684\u8bfe\uff0c\u4f60\u53ef\u4ee5\u770b\u5230 istrea \u548c ostream \u90fd\u662f\u6d3e\u751f\u81ea ios \u7c7b\u3002ios\uff08\u548cios_base\uff09 \u7684\u5de5\u4f5c\u4e4b\u4e00\u5c31\u662f\u63a7\u5236\u8f93\u51fa\u7684\u683c\u5f0f\u3002 \u683c\u5f0f\u5316 \u00b6 \u6709\u4e24\u4e2a\u65b9\u5f0f\u6765\u6539\u53d8\u683c\u5f0f\u53c2\u6570\uff1aflag \u548c manipulators\u3002\u4f60\u53ef\u4ee5\u628a flags \u770b\u505a\u5e03\u5c14\u53d8\u91cf\u53ef\u4ee5\u88ab\u5f00\u5173\u3002Manipulators \u662f\u653e\u5728 stream \u5f71\u54cd\u8f93\u5165\u548c\u8f93\u51fa\u7684\u4e8b\u60c5\u3002 \u8981\u5207\u6362\u4e00\u4e2aflag\uff0c\u4f7f\u7528 setf() \u65b9\u6cd5\uff0c\u53ef\u4ee5\u5408\u9002\u7684\u4f7f\u7528 flag \u4f5c\u4e3a\u4e00\u4e2a\u53d8\u91cf\u3002\u4f8b\u5982\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cC++ \u4e0d\u4f1a\u5728\u6b63\u6570\u524d\u6253\u5370\u4e00\u4e2a\u52a0\u53f7\u3002\u7136\u800c\uff0c\u901a\u8fc7\u4f7f\u7528 std::ios::showpos \u7684 flag\uff0c\u6211\u4eec\u53ef\u4ee5\u6539\u53d8\u8fd9\u4e2a\u8868\u73b0\uff1a std :: cout . setf ( std :: ios :: showpos ); // turn on the std::ios::showpos flag std :: cout << 27 << '\\n' ; \u8f93\u51fa\uff1a +27 It is possible to turn on multiple ios flags at once using the OR (|) operator: \u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 OR (|) \u64cd\u4f5c\u7b26\u6765\u5728\u4e00\u6b21\u4f7f\u7528\u4e2d\u5f00\u542f\u591a\u4e2a\u64cd\u4f5c\u7b26\uff1a std :: cout . setf ( std :: ios :: showpos | std :: ios :: uppercase ); // turn on the std::ios::showpos and std::ios::uppercase flag std :: cout << 27 << '\\n' ; \u8981\u5173\u95ed flag\uff0c\u4f7f\u7528 unsetf() \u51fd\u6570\uff1a std :: cout . setf ( std :: ios :: showpos ); // turn on the std::ios::showpos flag std :: cout << 27 << '\\n' ; std :: cout . unsetf ( std :: ios :: showpos ); // turn off the std::ios::showpos flag std :: cout << 28 << '\\n' ; \u8f93\u51fa\uff1a + 27 28 \u5f53\u4f7f\u7528 setf() \u65f6\u53ef\u4ee5\u544a\u8bc9\u5927\u5bb6\u4e00\u4e2a\u5176\u4ed6\u7684 bit \u7684\u4f7f\u7528\u6280\u5de7\uff0c\u8bb8\u591a flags \u5c5e\u4e8e\u4e00\u4e2a\u7ec4\uff0c\u53eb\u505a\u683c\u5f0f\u5316\u7ec4\u3002\u4e00\u4e2a\u683c\u5f0f\u5316\u7ec4\u662f\u4e00\u7ec4 flag \u8868\u73b0\u76f8\u4f3c\uff08\u6709\u65f6\u5019\u4e92\u76f8\u6392\u65a5\uff09\u7684\u683c\u5f0f\u5316\u914d\u7f6e\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u914d\u7f6e\u7ec4\u53eb\u505a \u201cbasefield\u201d \u5305\u542b\u51e0\u4e2aflag \u201doct\u201c\uff0c\u201ddec\u201c\uff0c\u201dhex\u201c\uff0c\u53ef\u4ee5\u63a7\u5236\u6574\u6570\u7684\u8f93\u51fa\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u201ddec\u201c flag\u88ab\u8bbe\u7f6e\uff0c\u518d\u8fd9\u6837\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u6211\u4eec\u8fd9\u6837\u505a\uff1a std :: cout . setf ( std :: ios :: hex ); // try to turn on hex output std :: cout << 27 << '\\n' ; \u4f1a\u8f93\u51fa\uff1a 27 \u5b83\u4e0d\u5de5\u4f5c\uff01\u8fd9\u662f\u56e0\u4e3a setf() \u53ea\u4f1a\u5f00\u542fflag \u2014\u2014 \u5b83\u8fd8\u4e0d\u8db3\u591f\u806a\u660e\u5230\u80fd\u5173\u95ed\u51b2\u7a81\u7684flags\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5f53\u6211\u4eec\u5f00\u542f\u4e86 std::ios::hex \uff0c std::ios::dec \u4e5f\u4ecd\u7136\u662f\u5f00\u542f\u7684\u3002\u5e76\u4e14 std::ios::dec \u663e\u7136\u4f18\u5148\u3002\u8fd9\u91cc\u6709\u4e24\u4e2a\u65b9\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff1a \u7b2c\u4e00\uff0c\u6211\u4eec\u53ef\u4ee5\u5173\u95ed std::ios::dec \uff0c\u4ee5\u4fbf\u4e8e\u5f00\u542f std::ios::hex \u751f\u6548\uff1a std :: cout . unsetf ( std :: ios :: dec ); // turn off decimal output std :: cout . setf ( std :: ios :: hex ); // turn on hexadecimal output std :: cout << 27 << '\\n' ; \u73b0\u5728\u6211\u4eec\u5f97\u5230\u671f\u671b\u4e2d\u7684\u8f93\u51fa\u4e86\uff1a 1 b \u7b2c\u4e8c\u79cd\u65b9\u5f0f\u5c31\u662f\u4f7f\u7528\u4e00\u4e2a\u4e0d\u540c\u5f62\u5f0f\u7684 setf() \u4f1a\u643a\u5e26\u4e24\u4e2a\u53c2\u6570\uff1a\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u60f3\u8981\u8bbe\u7f6e\u7684 flag\uff0c\u7136\u540e\u7b2c\u4e8c\u4e2a\u53c2\u6570\u5c31\u662f\u5b83\u5c5e\u4e8e\u7684\u90a3\u4e2a\u7ec4\u3002\u5f53\u4f7f\u7528\u8fd9\u4e2a\u5f62\u5f0f\u7684 setf() \u65f6\uff0c\u6240\u6709\u7684\u540c\u7ec4 flag \u5c06\u4f1a\u88ab\u5173\u95ed\uff0c\u7136\u540e\u53ea\u6709 \u4f20\u5165\u7684 flag \u4f1a\u88ab\u6253\u5f00\uff1a // Turn on std::ios::hex as the only std::ios::basefield flag std :: cout . setf ( std :: ios :: hex , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; \u8fd9\u4e2a\u4e5f\u4f1a\u5982\u671f\u8f93\u51fa\uff1a 1 b \u4f7f\u7528 setf() \u548c unsetf() \u5176\u5b9e\u6bd4\u8f83\u5c34\u5c2c\uff0c\u56e0\u6b64 C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b2c\u4e8c\u7684\u65b9\u5f0f\u6765\u6539\u53d8\u683c\u5f0f\u5316\u53c2\u6570\uff1amanipulators\u3002\u6709\u5173 manipulators \u597d\u7684\u4e00\u65b9\u9762\u662f\u4ed6\u4eec\u8db3\u591f\u806a\u660e\u6765\u5f00\u542f\u6216\u8005\u5173\u95ed\u548c\u662f\u7684flags\u3002\u8fd9\u6709\u4e00\u4e2a\u4f7f\u7528 manipulators \u6539\u53d8 base \u7684\u4f8b\u5b50\uff1a std :: cout << std :: hex << 27 << '\\n' ; // print 27 in hex std :: cout << 28 << '\\n' ; // we're still in hex std :: cout << std :: dec << 29 << '\\n' ; // back to decimal \u8f93\u51fa 1 b 1 c 29 \u5927\u4f53\u4e0a\u8bb2\uff0c\u4f7f\u7528 manipulators \u66f4\u5bb9\u6613\u6bd4\u8d77\u8bbe\u7f6e\u548c\u53d6\u6d88 flag \u8bbe\u7f6e\u3002\u8bb8\u591a\u914d\u7f6e\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7 \u914d\u7f6e flag \u548c manipulators \u6765\u5b9e\u73b0\u7684\u3002\uff08\u4f8b\u5982\u6539\u53d8 base\uff09\uff0c\u7136\u800c\uff0c\u5176\u4ed6\u7684\u4e00\u4e9b\u914d\u7f6e\u53ea\u5141\u8bb8\u901a\u8fc7 flags \u6216\u8005 \u53ea\u5141\u8bb8\u901a\u8fc7 manipulators\uff0c\u56e0\u6b64\u4e86\u89e3\u5982\u4f55\u4f7f\u7528\u4ed6\u4eec\u4e8c\u8005\u975e\u5e38\u91cd\u8981\u3002 \u6709\u7528\u7684\u683c\u5f0f\u5316 \u00b6 \u8fd9\u662f\u4e00\u4e2a\u5217\u8868\u7684\u4e00\u4e9b\u6700\u6709\u7528\u7684 flags\uff0cmanipulators\uff0c\u548c\u4e00\u4e9b\u6210\u5458\u51fd\u6570\u3002Flags \u5728 std::ios \u7c7b\u4e2d\uff0cmanipulators \u5728 std \u547d\u540d\u7a7a\u95f4\u4e2d\uff0c\u7136\u540e\u6210\u5458\u51fd\u6570\u5728 std::ostream \u7c7b\u3002 group flag meaning std::ios::boolalpha If set, booleans print \u201ctrue\u201d or \u201cfalse\u201d. If not set, booleans print 0 or 1 Manipulator Meaning std::boolalpha Booleans print \u201ctrue\u201d or \u201cfalse\u201d std::noboolalpha Booleans print 0 or 1 (default) \u4f8b\u5b50\uff1a std :: cout << true << \" \" << false << '\\n' ; std :: cout . setf ( std :: ios :: boolalpha ); std :: cout << true << \" \" << false << '\\n' ; std :: cout << std :: noboolalpha << true << \" \" << false << '\\n' ; std :: cout << std :: boolalpha << true << \" \" << false << '\\n' ; \u8f93\u51fa\uff1a 1 0 true false 1 0 true false Group Flag Meaning std::ios::showpos If set, prefix positive numbers with a + Manipulator Meaning std::showpos Prefixes positive numbers with a + std::noshowpos Doesn\u2019t prefix positive numbers with a + \u4f8b\u5b50\uff1a std :: cout << 5 << '\\n' ; std :: cout . setf ( std :: ios :: showpos ); std :: cout << 5 << '\\n' ; std :: cout << std :: noshowpos << 5 << '\\n' ; std :: cout << std :: showpos << 5 << '\\n' ; \u8f93\u51fa\uff1a 5 + 5 5 + 5 Group Flag Meaning std::ios::uppercase If set, uses upper case letters Manipulator Meaning std::uppercase Uses upper case letters std::nouppercase Uses lower case letters std :: cout << 12345678.9 << '\\n' ; std :: cout . setf ( std :: ios :: uppercase ); std :: cout << 12345678.9 << '\\n' ; std :: cout << std :: nouppercase << 12345678.9 << '\\n' ; std :: cout << std :: uppercase << 12345678.9 << '\\n' ; \u8f93\u51fa 1.23457e+007 1.23457E+007 1.23457e+007 1.23457E+007 Group Flag Meaning std::ios::basefield std::ios::dec Prints values in decimal (default) std::ios::basefield std::ios::hex Prints values in hexadecimal std::ios::basefield std::ios::oct Prints values in octal std::ios::basefield (none) Prints values according to leading characters of value Manipulator Meaning std::dec Prints values in decimal std::hex Prints values in hexadecimal std::oct Prints values in octal std :: cout << 27 << '\\n' ; std :: cout . setf ( std :: ios :: dec , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; std :: cout . setf ( std :: ios :: oct , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; std :: cout . setf ( std :: ios :: hex , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; std :: cout << std :: dec << 27 << '\\n' ; std :: cout << std :: oct << 27 << '\\n' ; std :: cout << std :: hex << 27 << '\\n' ; \u8f93\u51fa 27 27 33 1 b 27 33 1 b \u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u4f60\u5e94\u8be5\u80fd\u591f\u770b\u51fa\u8bbe\u7f6e\u683c\u5f0f\u5316\u901a\u8fc7 flag \u548c\u901a\u8fc7 manipulators \u7684\u533a\u522b\u4e86\u3002\u5728\u672a\u6765\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 manipulators \u9664\u975e\u4e0d\u53ef\u7528\u3002 \u7cbe\u5ea6\uff0c\u7b26\u53f7\uff0c\u5c0f\u6570\u70b9 \u00b6 \u4f7f\u7528 manipulators \uff08\u6216\u8005 flags\uff09\uff0c\u53ef\u4ee5\u6539\u53d8\u6d6e\u70b9\u6570\u663e\u793a\u7684\u7cbe\u5ea6\u548c\u683c\u5f0f\u3002\u6709\u4e00\u4e9b\u683c\u5f0f\u7684\u9009\u9879\u4ee5\u4e00\u79cd\u590d\u6742\u7684\u65b9\u5f0f\u7ed3\u5408\uff0c\u6211\u4eec\u63a5\u4e0b\u6765\u4f1a\u4ed4\u7ec6\u770b \u6240\u5728\u7684\u7ec4 Flag \u610f\u4e49 std::ios::floatfield std::ios::fixed \u5bf9\u6d6e\u70b9\u6570\u91c7\u7528\u5341\u8fdb\u5236\u8bb0\u6cd5 std::ios::floatfield std::ios::scientific \u5bf9\u6d6e\u70b9\u6570\u91c7\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5 std::ios::floatfield (none) \u5982\u679c\u4f4d\u6570\u5f88\u5c11\u5219\u4f7f\u7528\u6570\u5b57\uff0c\u5426\u5219\u4f7f\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5 std::ios::floatfield std::ios::showpoint \u5bf9\u4e8e\u6d6e\u70b9\u6570\uff0c\u59cb\u7ec8\u5c55\u793a\u5c0f\u6570\u70b9\u548c\u540e\u65b9\u7684\u96f6 Manipulator Meaning std::fixed \u5bf9\u6570\u503c\u4f7f\u7528\u5341\u8fdb\u5236\u8ba1\u6570\u6cd5 std::scientific \u4f7f\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5 std::showpoint \u663e\u793a\u6d6e\u70b9\u6570\u7684\u5c0f\u6570\u70b9\u548c\u540e\u65b9\u7684\u96f6 std::noshowpoint \u4e0d\u8981\u663e\u793a\u5c0f\u6570\u70b9\u548c\u540e\u65b9\u7684\u96f6 std::setprecision(int) \u8bbe\u5b9a\u6d6e\u70b9\u6570\u7684\u8f93\u51fa\u7cbe\u5ea6 (\u5b9a\u4e49\u5728 iomanip.h \u5934\u4e2d) Member function Meaning std::precision() \u8fd4\u56de\u5f53\u524d\u8bbe\u7f6e\u7684\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6 std::precision(int) \u8bbe\u7f6e\u65b0\u7684\u7cbe\u5ea6\u5e76\u4e14\u8fd4\u56de\u65e7\u7684\u7cbe\u5ea6 \u5982\u679c\u56fa\u5b9a\u5730\u6216\u8005\u79d1\u5b66\u8ba1\u6570\u6cd5\u88ab\u4f7f\u7528\uff0c\u7cbe\u5ea6\u4f1a\u51b3\u5b9a\u5206\u6570\u4e2d\u663e\u793a\u591a\u5c11\u5c0f\u6570\u4f4d\u3002\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u7cbe\u5ea6\u6709\u6548\u6570\u5b57\u7684\u4e2a\u6570\uff0c\u6570\u5b57\u5c06\u4f1a\u88ab\u56db\u820d\u4e94\u5165\u3002 std :: cout << std :: fixed << '\\n' ; std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; std :: cout << std :: scientific << '\\n' ; std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; \u8f93\u51fa 123.456 123.4560 123.45600 123.456000 123.4560000 1.235e+002 1.2346e+002 1.23456e+002 1.234560e+002 1.2345600e+002 \u5982\u679c\u56fa\u5b9a\u4f4d\u6570\uff08fixed\uff09\u548c\u79d1\u5b66\u8ba1\u6570\u6cd5\uff08scientific\uff09\u90fd\u6ca1\u6709\u88ab\u4f7f\u7528\uff0c\u7cbe\u5ea6\u4f1a\u51b3\u5b9a\u4e86\u8be5\u6570\u5b57\u663e\u793a\u591a\u5c11\u4f4d\u3002\u518d\u8bf4\u4e00\u6b21\uff0c\u5982\u679c\u7cbe\u5ea6\u5c0f\u4e8e\u6709\u6548\u6570\u5b57\u4e2a\u6570\uff0c\u6570\u5b57\u5c06\u4f1a\u88ab\u56db\u820d\u4e94\u5165\u3002 std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; \u8f93\u51fa 123 123.5 123.46 123.456 123.456 \u4f7f\u7528\u4e86 showpoint manipulator \u6216\u8005 flag\uff0c\u4f60\u53ef\u4ee5\u8ba9\u4e00\u4e2a\u6d41\u5199\u5165\u6570\u5b57\u548c\u540e\u9762\u7684\u96f6\u3002 std :: cout << std :: showpoint << '\\n' ; std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; \u8f93\u51fa 123. 123.5 123.46 123.456 123.4560 \u8fd9\u662f\u4e00\u4e9b\u4f8b\u5b50 Option Precision 12345.0 0.12345 Normal 3 1.23e+004 0.123 4 1.235e+004 0.1235 5 12345 0.12345 6 12345 0.12345 Showpoint 3 1.23e+004 0.123 4 1.235e+004 0.1235 5 12345. 0.12345 6 12345.0 0.123450 Fixed 3 12345.000 0.123 4 12345.0000 0.1235 5 12345.00000 0.12345 6 12345.000000 0.123450 Scientific 3 1.235e+004 1.235e-001 4 1.2345e+004 1.2345e-001 5 1.23450e+004 1.23450e-001 6 1.234500e+004 1.234500e-001 \u5bbd\u5ea6\uff0c\u586b\u5145\u5b57\u7b26\uff0c\u548c\u8303\u56f4\u8c03\u6574 \u00b6 ... \u672a\u5b8c \u901a\u5e38\u5f53\u4f60\u6253\u5370\u6570\u5b57\u7684\u65f6\u5019\uff0c\u8fd9\u4e9b\u88ab\u6253\u5370\u7684\u6570\u5b57\u5468\u56f4\u4e0d\u4f1a\u6709\u4efb\u4f55\u7684\u7a7a\u95f4\u3002\u7136\u800c\uff0c\u5176\u5b9e\u6253\u5370\u7684\u6570\u5b57\u53ef\u4ee5\u5411\u5de6\u6216\u8005\u5411\u53f3\u5bf9\u9f50\u3002\u4e3a\u4e86\u5b8c\u6210\u8fd9\u4e2a\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u5b9a\u4e49\u4e00\u4e2a\u5b57\u6bb5\u5bbd\u5ea6\uff0c\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6570\u5b57\u6765\u89c4\u5b9a\u8f93\u51fa\u7a7a\u95f4\u7684\u91cf\u3002\u5982\u679c\u5b9e\u9645\u6253\u5370\u7684\u6570\u5b57\u5c0f\u4e8e\u5b57\u6bb5\u5bbd\u5ea6\uff0c\u5b83\u5c06\u5de6\u5bf9\u9f50\u6216\u53f3\u5bf9\u9f50\uff08\u5982\u6307\u5b9a\uff09\u3002\u5982\u679c\u5b9e\u9645\u6570\u5b57\u5927\u4e8e\u5b57\u6bb5\u5bbd\u5ea6\uff0c\u5b83\u5c06\u4e0d\u4f1a\u88ab\u622a\u65ad\u2014\u2014\u5b83\u5c06\u4f7f\u5b57\u6bb5\u6ea2\u51fa\u3002","title":"18.3 \u4f7f\u7528 ostrea \u548c ios \u8fdb\u884c\u8f93\u51fa"},{"location":"23-input-and-output/23.3-output-with-ostream-and-ios/#183-ostrea-ios","text":"\u5728\u8fd9\u4e2a\u90e8\u5206\uff0c\u6211\u4eec\u4f1a\u770b ostream \u7684\u5f88\u591a\u65b9\u9762\u3002 \u6ce8\u610f\uff1a\u672c\u8282\u8bfe\u6240\u6709\u7684 I/O \u51fd\u6570\u90fd\u5728 std \u547d\u540d\u7a7a\u95f4\u4e2d\u3002\u90a3\u610f\u5473\u7740\uff0c\u6240\u6709\u7684 I/O \u5bf9\u8c61\u548c\u51fd\u6570\u90fd\u4e0d\u5f97\u4e0d\u4f7f\u7528\u524d\u7f00 std:: \uff0c\u6216\u8005\u4f7f\u7528 using namespace std; \uff0c\u8fd9\u4e2a\u60c5\u51b5\u5fc5\u987b\u5411\u5927\u5bb6\u8bf4\u660e\u3002","title":"18.3 \u4f7f\u7528 ostrea \u548c ios \u8fdb\u884c\u8f93\u51fa"},{"location":"23-input-and-output/23.3-output-with-ostream-and-ios/#_1","text":"\u63d2\u5165\u64cd\u4f5c\u7b26 \uff08<<\uff09 \u88ab\u7528\u6765\u653e\u7f6e\u4fe1\u606f\u5230\u4e00\u4e2a\u8f93\u51fa\u6d41\u4e2d\u3002C++ \u4e3a\u6240\u6709\u7684\u5185\u5efa\u7c7b\u578b\u5b9a\u4e49\u4e86\u63d2\u5165\u64cd\u4f5c\uff0c\u5e76\u4e14\u4f60\u65e9\u5c31\u5b66\u4e60\u8fc7\u5982\u4f55\u901a\u8fc7\u4e3a\u4f60\u81ea\u5df1\u7c7b\u8fdb\u884c\u64cd\u4f5c\u7b26\u91cd\u8f7d\uff0c\u6765\u5b9e\u73b0\u63d2\u5165\u64cd\u4f5c\u7b26\u3002 \u5728\u8fd9\u8282\u6709\u5173 stream \u7684\u8bfe\uff0c\u4f60\u53ef\u4ee5\u770b\u5230 istrea \u548c ostream \u90fd\u662f\u6d3e\u751f\u81ea ios \u7c7b\u3002ios\uff08\u548cios_base\uff09 \u7684\u5de5\u4f5c\u4e4b\u4e00\u5c31\u662f\u63a7\u5236\u8f93\u51fa\u7684\u683c\u5f0f\u3002","title":"\u8f93\u5165\u63d2\u5165\u64cd\u4f5c\u7b26"},{"location":"23-input-and-output/23.3-output-with-ostream-and-ios/#_2","text":"\u6709\u4e24\u4e2a\u65b9\u5f0f\u6765\u6539\u53d8\u683c\u5f0f\u53c2\u6570\uff1aflag \u548c manipulators\u3002\u4f60\u53ef\u4ee5\u628a flags \u770b\u505a\u5e03\u5c14\u53d8\u91cf\u53ef\u4ee5\u88ab\u5f00\u5173\u3002Manipulators \u662f\u653e\u5728 stream \u5f71\u54cd\u8f93\u5165\u548c\u8f93\u51fa\u7684\u4e8b\u60c5\u3002 \u8981\u5207\u6362\u4e00\u4e2aflag\uff0c\u4f7f\u7528 setf() \u65b9\u6cd5\uff0c\u53ef\u4ee5\u5408\u9002\u7684\u4f7f\u7528 flag \u4f5c\u4e3a\u4e00\u4e2a\u53d8\u91cf\u3002\u4f8b\u5982\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cC++ \u4e0d\u4f1a\u5728\u6b63\u6570\u524d\u6253\u5370\u4e00\u4e2a\u52a0\u53f7\u3002\u7136\u800c\uff0c\u901a\u8fc7\u4f7f\u7528 std::ios::showpos \u7684 flag\uff0c\u6211\u4eec\u53ef\u4ee5\u6539\u53d8\u8fd9\u4e2a\u8868\u73b0\uff1a std :: cout . setf ( std :: ios :: showpos ); // turn on the std::ios::showpos flag std :: cout << 27 << '\\n' ; \u8f93\u51fa\uff1a +27 It is possible to turn on multiple ios flags at once using the OR (|) operator: \u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 OR (|) \u64cd\u4f5c\u7b26\u6765\u5728\u4e00\u6b21\u4f7f\u7528\u4e2d\u5f00\u542f\u591a\u4e2a\u64cd\u4f5c\u7b26\uff1a std :: cout . setf ( std :: ios :: showpos | std :: ios :: uppercase ); // turn on the std::ios::showpos and std::ios::uppercase flag std :: cout << 27 << '\\n' ; \u8981\u5173\u95ed flag\uff0c\u4f7f\u7528 unsetf() \u51fd\u6570\uff1a std :: cout . setf ( std :: ios :: showpos ); // turn on the std::ios::showpos flag std :: cout << 27 << '\\n' ; std :: cout . unsetf ( std :: ios :: showpos ); // turn off the std::ios::showpos flag std :: cout << 28 << '\\n' ; \u8f93\u51fa\uff1a + 27 28 \u5f53\u4f7f\u7528 setf() \u65f6\u53ef\u4ee5\u544a\u8bc9\u5927\u5bb6\u4e00\u4e2a\u5176\u4ed6\u7684 bit \u7684\u4f7f\u7528\u6280\u5de7\uff0c\u8bb8\u591a flags \u5c5e\u4e8e\u4e00\u4e2a\u7ec4\uff0c\u53eb\u505a\u683c\u5f0f\u5316\u7ec4\u3002\u4e00\u4e2a\u683c\u5f0f\u5316\u7ec4\u662f\u4e00\u7ec4 flag \u8868\u73b0\u76f8\u4f3c\uff08\u6709\u65f6\u5019\u4e92\u76f8\u6392\u65a5\uff09\u7684\u683c\u5f0f\u5316\u914d\u7f6e\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u914d\u7f6e\u7ec4\u53eb\u505a \u201cbasefield\u201d \u5305\u542b\u51e0\u4e2aflag \u201doct\u201c\uff0c\u201ddec\u201c\uff0c\u201dhex\u201c\uff0c\u53ef\u4ee5\u63a7\u5236\u6574\u6570\u7684\u8f93\u51fa\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u201ddec\u201c flag\u88ab\u8bbe\u7f6e\uff0c\u518d\u8fd9\u6837\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u6211\u4eec\u8fd9\u6837\u505a\uff1a std :: cout . setf ( std :: ios :: hex ); // try to turn on hex output std :: cout << 27 << '\\n' ; \u4f1a\u8f93\u51fa\uff1a 27 \u5b83\u4e0d\u5de5\u4f5c\uff01\u8fd9\u662f\u56e0\u4e3a setf() \u53ea\u4f1a\u5f00\u542fflag \u2014\u2014 \u5b83\u8fd8\u4e0d\u8db3\u591f\u806a\u660e\u5230\u80fd\u5173\u95ed\u51b2\u7a81\u7684flags\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5f53\u6211\u4eec\u5f00\u542f\u4e86 std::ios::hex \uff0c std::ios::dec \u4e5f\u4ecd\u7136\u662f\u5f00\u542f\u7684\u3002\u5e76\u4e14 std::ios::dec \u663e\u7136\u4f18\u5148\u3002\u8fd9\u91cc\u6709\u4e24\u4e2a\u65b9\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff1a \u7b2c\u4e00\uff0c\u6211\u4eec\u53ef\u4ee5\u5173\u95ed std::ios::dec \uff0c\u4ee5\u4fbf\u4e8e\u5f00\u542f std::ios::hex \u751f\u6548\uff1a std :: cout . unsetf ( std :: ios :: dec ); // turn off decimal output std :: cout . setf ( std :: ios :: hex ); // turn on hexadecimal output std :: cout << 27 << '\\n' ; \u73b0\u5728\u6211\u4eec\u5f97\u5230\u671f\u671b\u4e2d\u7684\u8f93\u51fa\u4e86\uff1a 1 b \u7b2c\u4e8c\u79cd\u65b9\u5f0f\u5c31\u662f\u4f7f\u7528\u4e00\u4e2a\u4e0d\u540c\u5f62\u5f0f\u7684 setf() \u4f1a\u643a\u5e26\u4e24\u4e2a\u53c2\u6570\uff1a\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u60f3\u8981\u8bbe\u7f6e\u7684 flag\uff0c\u7136\u540e\u7b2c\u4e8c\u4e2a\u53c2\u6570\u5c31\u662f\u5b83\u5c5e\u4e8e\u7684\u90a3\u4e2a\u7ec4\u3002\u5f53\u4f7f\u7528\u8fd9\u4e2a\u5f62\u5f0f\u7684 setf() \u65f6\uff0c\u6240\u6709\u7684\u540c\u7ec4 flag \u5c06\u4f1a\u88ab\u5173\u95ed\uff0c\u7136\u540e\u53ea\u6709 \u4f20\u5165\u7684 flag \u4f1a\u88ab\u6253\u5f00\uff1a // Turn on std::ios::hex as the only std::ios::basefield flag std :: cout . setf ( std :: ios :: hex , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; \u8fd9\u4e2a\u4e5f\u4f1a\u5982\u671f\u8f93\u51fa\uff1a 1 b \u4f7f\u7528 setf() \u548c unsetf() \u5176\u5b9e\u6bd4\u8f83\u5c34\u5c2c\uff0c\u56e0\u6b64 C++ \u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b2c\u4e8c\u7684\u65b9\u5f0f\u6765\u6539\u53d8\u683c\u5f0f\u5316\u53c2\u6570\uff1amanipulators\u3002\u6709\u5173 manipulators \u597d\u7684\u4e00\u65b9\u9762\u662f\u4ed6\u4eec\u8db3\u591f\u806a\u660e\u6765\u5f00\u542f\u6216\u8005\u5173\u95ed\u548c\u662f\u7684flags\u3002\u8fd9\u6709\u4e00\u4e2a\u4f7f\u7528 manipulators \u6539\u53d8 base \u7684\u4f8b\u5b50\uff1a std :: cout << std :: hex << 27 << '\\n' ; // print 27 in hex std :: cout << 28 << '\\n' ; // we're still in hex std :: cout << std :: dec << 29 << '\\n' ; // back to decimal \u8f93\u51fa 1 b 1 c 29 \u5927\u4f53\u4e0a\u8bb2\uff0c\u4f7f\u7528 manipulators \u66f4\u5bb9\u6613\u6bd4\u8d77\u8bbe\u7f6e\u548c\u53d6\u6d88 flag \u8bbe\u7f6e\u3002\u8bb8\u591a\u914d\u7f6e\u90fd\u662f\u53ef\u4ee5\u901a\u8fc7 \u914d\u7f6e flag \u548c manipulators \u6765\u5b9e\u73b0\u7684\u3002\uff08\u4f8b\u5982\u6539\u53d8 base\uff09\uff0c\u7136\u800c\uff0c\u5176\u4ed6\u7684\u4e00\u4e9b\u914d\u7f6e\u53ea\u5141\u8bb8\u901a\u8fc7 flags \u6216\u8005 \u53ea\u5141\u8bb8\u901a\u8fc7 manipulators\uff0c\u56e0\u6b64\u4e86\u89e3\u5982\u4f55\u4f7f\u7528\u4ed6\u4eec\u4e8c\u8005\u975e\u5e38\u91cd\u8981\u3002","title":"\u683c\u5f0f\u5316"},{"location":"23-input-and-output/23.3-output-with-ostream-and-ios/#_3","text":"\u8fd9\u662f\u4e00\u4e2a\u5217\u8868\u7684\u4e00\u4e9b\u6700\u6709\u7528\u7684 flags\uff0cmanipulators\uff0c\u548c\u4e00\u4e9b\u6210\u5458\u51fd\u6570\u3002Flags \u5728 std::ios \u7c7b\u4e2d\uff0cmanipulators \u5728 std \u547d\u540d\u7a7a\u95f4\u4e2d\uff0c\u7136\u540e\u6210\u5458\u51fd\u6570\u5728 std::ostream \u7c7b\u3002 group flag meaning std::ios::boolalpha If set, booleans print \u201ctrue\u201d or \u201cfalse\u201d. If not set, booleans print 0 or 1 Manipulator Meaning std::boolalpha Booleans print \u201ctrue\u201d or \u201cfalse\u201d std::noboolalpha Booleans print 0 or 1 (default) \u4f8b\u5b50\uff1a std :: cout << true << \" \" << false << '\\n' ; std :: cout . setf ( std :: ios :: boolalpha ); std :: cout << true << \" \" << false << '\\n' ; std :: cout << std :: noboolalpha << true << \" \" << false << '\\n' ; std :: cout << std :: boolalpha << true << \" \" << false << '\\n' ; \u8f93\u51fa\uff1a 1 0 true false 1 0 true false Group Flag Meaning std::ios::showpos If set, prefix positive numbers with a + Manipulator Meaning std::showpos Prefixes positive numbers with a + std::noshowpos Doesn\u2019t prefix positive numbers with a + \u4f8b\u5b50\uff1a std :: cout << 5 << '\\n' ; std :: cout . setf ( std :: ios :: showpos ); std :: cout << 5 << '\\n' ; std :: cout << std :: noshowpos << 5 << '\\n' ; std :: cout << std :: showpos << 5 << '\\n' ; \u8f93\u51fa\uff1a 5 + 5 5 + 5 Group Flag Meaning std::ios::uppercase If set, uses upper case letters Manipulator Meaning std::uppercase Uses upper case letters std::nouppercase Uses lower case letters std :: cout << 12345678.9 << '\\n' ; std :: cout . setf ( std :: ios :: uppercase ); std :: cout << 12345678.9 << '\\n' ; std :: cout << std :: nouppercase << 12345678.9 << '\\n' ; std :: cout << std :: uppercase << 12345678.9 << '\\n' ; \u8f93\u51fa 1.23457e+007 1.23457E+007 1.23457e+007 1.23457E+007 Group Flag Meaning std::ios::basefield std::ios::dec Prints values in decimal (default) std::ios::basefield std::ios::hex Prints values in hexadecimal std::ios::basefield std::ios::oct Prints values in octal std::ios::basefield (none) Prints values according to leading characters of value Manipulator Meaning std::dec Prints values in decimal std::hex Prints values in hexadecimal std::oct Prints values in octal std :: cout << 27 << '\\n' ; std :: cout . setf ( std :: ios :: dec , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; std :: cout . setf ( std :: ios :: oct , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; std :: cout . setf ( std :: ios :: hex , std :: ios :: basefield ); std :: cout << 27 << '\\n' ; std :: cout << std :: dec << 27 << '\\n' ; std :: cout << std :: oct << 27 << '\\n' ; std :: cout << std :: hex << 27 << '\\n' ; \u8f93\u51fa 27 27 33 1 b 27 33 1 b \u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u4f60\u5e94\u8be5\u80fd\u591f\u770b\u51fa\u8bbe\u7f6e\u683c\u5f0f\u5316\u901a\u8fc7 flag \u548c\u901a\u8fc7 manipulators \u7684\u533a\u522b\u4e86\u3002\u5728\u672a\u6765\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 manipulators \u9664\u975e\u4e0d\u53ef\u7528\u3002","title":"\u6709\u7528\u7684\u683c\u5f0f\u5316"},{"location":"23-input-and-output/23.3-output-with-ostream-and-ios/#_4","text":"\u4f7f\u7528 manipulators \uff08\u6216\u8005 flags\uff09\uff0c\u53ef\u4ee5\u6539\u53d8\u6d6e\u70b9\u6570\u663e\u793a\u7684\u7cbe\u5ea6\u548c\u683c\u5f0f\u3002\u6709\u4e00\u4e9b\u683c\u5f0f\u7684\u9009\u9879\u4ee5\u4e00\u79cd\u590d\u6742\u7684\u65b9\u5f0f\u7ed3\u5408\uff0c\u6211\u4eec\u63a5\u4e0b\u6765\u4f1a\u4ed4\u7ec6\u770b \u6240\u5728\u7684\u7ec4 Flag \u610f\u4e49 std::ios::floatfield std::ios::fixed \u5bf9\u6d6e\u70b9\u6570\u91c7\u7528\u5341\u8fdb\u5236\u8bb0\u6cd5 std::ios::floatfield std::ios::scientific \u5bf9\u6d6e\u70b9\u6570\u91c7\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5 std::ios::floatfield (none) \u5982\u679c\u4f4d\u6570\u5f88\u5c11\u5219\u4f7f\u7528\u6570\u5b57\uff0c\u5426\u5219\u4f7f\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5 std::ios::floatfield std::ios::showpoint \u5bf9\u4e8e\u6d6e\u70b9\u6570\uff0c\u59cb\u7ec8\u5c55\u793a\u5c0f\u6570\u70b9\u548c\u540e\u65b9\u7684\u96f6 Manipulator Meaning std::fixed \u5bf9\u6570\u503c\u4f7f\u7528\u5341\u8fdb\u5236\u8ba1\u6570\u6cd5 std::scientific \u4f7f\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5 std::showpoint \u663e\u793a\u6d6e\u70b9\u6570\u7684\u5c0f\u6570\u70b9\u548c\u540e\u65b9\u7684\u96f6 std::noshowpoint \u4e0d\u8981\u663e\u793a\u5c0f\u6570\u70b9\u548c\u540e\u65b9\u7684\u96f6 std::setprecision(int) \u8bbe\u5b9a\u6d6e\u70b9\u6570\u7684\u8f93\u51fa\u7cbe\u5ea6 (\u5b9a\u4e49\u5728 iomanip.h \u5934\u4e2d) Member function Meaning std::precision() \u8fd4\u56de\u5f53\u524d\u8bbe\u7f6e\u7684\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6 std::precision(int) \u8bbe\u7f6e\u65b0\u7684\u7cbe\u5ea6\u5e76\u4e14\u8fd4\u56de\u65e7\u7684\u7cbe\u5ea6 \u5982\u679c\u56fa\u5b9a\u5730\u6216\u8005\u79d1\u5b66\u8ba1\u6570\u6cd5\u88ab\u4f7f\u7528\uff0c\u7cbe\u5ea6\u4f1a\u51b3\u5b9a\u5206\u6570\u4e2d\u663e\u793a\u591a\u5c11\u5c0f\u6570\u4f4d\u3002\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u7cbe\u5ea6\u6709\u6548\u6570\u5b57\u7684\u4e2a\u6570\uff0c\u6570\u5b57\u5c06\u4f1a\u88ab\u56db\u820d\u4e94\u5165\u3002 std :: cout << std :: fixed << '\\n' ; std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; std :: cout << std :: scientific << '\\n' ; std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; \u8f93\u51fa 123.456 123.4560 123.45600 123.456000 123.4560000 1.235e+002 1.2346e+002 1.23456e+002 1.234560e+002 1.2345600e+002 \u5982\u679c\u56fa\u5b9a\u4f4d\u6570\uff08fixed\uff09\u548c\u79d1\u5b66\u8ba1\u6570\u6cd5\uff08scientific\uff09\u90fd\u6ca1\u6709\u88ab\u4f7f\u7528\uff0c\u7cbe\u5ea6\u4f1a\u51b3\u5b9a\u4e86\u8be5\u6570\u5b57\u663e\u793a\u591a\u5c11\u4f4d\u3002\u518d\u8bf4\u4e00\u6b21\uff0c\u5982\u679c\u7cbe\u5ea6\u5c0f\u4e8e\u6709\u6548\u6570\u5b57\u4e2a\u6570\uff0c\u6570\u5b57\u5c06\u4f1a\u88ab\u56db\u820d\u4e94\u5165\u3002 std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; \u8f93\u51fa 123 123.5 123.46 123.456 123.456 \u4f7f\u7528\u4e86 showpoint manipulator \u6216\u8005 flag\uff0c\u4f60\u53ef\u4ee5\u8ba9\u4e00\u4e2a\u6d41\u5199\u5165\u6570\u5b57\u548c\u540e\u9762\u7684\u96f6\u3002 std :: cout << std :: showpoint << '\\n' ; std :: cout << std :: setprecision ( 3 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 4 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 5 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 6 ) << 123.456 << '\\n' ; std :: cout << std :: setprecision ( 7 ) << 123.456 << '\\n' ; \u8f93\u51fa 123. 123.5 123.46 123.456 123.4560 \u8fd9\u662f\u4e00\u4e9b\u4f8b\u5b50 Option Precision 12345.0 0.12345 Normal 3 1.23e+004 0.123 4 1.235e+004 0.1235 5 12345 0.12345 6 12345 0.12345 Showpoint 3 1.23e+004 0.123 4 1.235e+004 0.1235 5 12345. 0.12345 6 12345.0 0.123450 Fixed 3 12345.000 0.123 4 12345.0000 0.1235 5 12345.00000 0.12345 6 12345.000000 0.123450 Scientific 3 1.235e+004 1.235e-001 4 1.2345e+004 1.2345e-001 5 1.23450e+004 1.23450e-001 6 1.234500e+004 1.234500e-001","title":"\u7cbe\u5ea6\uff0c\u7b26\u53f7\uff0c\u5c0f\u6570\u70b9"},{"location":"23-input-and-output/23.3-output-with-ostream-and-ios/#_5","text":"... \u672a\u5b8c \u901a\u5e38\u5f53\u4f60\u6253\u5370\u6570\u5b57\u7684\u65f6\u5019\uff0c\u8fd9\u4e9b\u88ab\u6253\u5370\u7684\u6570\u5b57\u5468\u56f4\u4e0d\u4f1a\u6709\u4efb\u4f55\u7684\u7a7a\u95f4\u3002\u7136\u800c\uff0c\u5176\u5b9e\u6253\u5370\u7684\u6570\u5b57\u53ef\u4ee5\u5411\u5de6\u6216\u8005\u5411\u53f3\u5bf9\u9f50\u3002\u4e3a\u4e86\u5b8c\u6210\u8fd9\u4e2a\uff0c\u6211\u4eec\u4e0d\u5f97\u4e0d\u5b9a\u4e49\u4e00\u4e2a\u5b57\u6bb5\u5bbd\u5ea6\uff0c\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6570\u5b57\u6765\u89c4\u5b9a\u8f93\u51fa\u7a7a\u95f4\u7684\u91cf\u3002\u5982\u679c\u5b9e\u9645\u6253\u5370\u7684\u6570\u5b57\u5c0f\u4e8e\u5b57\u6bb5\u5bbd\u5ea6\uff0c\u5b83\u5c06\u5de6\u5bf9\u9f50\u6216\u53f3\u5bf9\u9f50\uff08\u5982\u6307\u5b9a\uff09\u3002\u5982\u679c\u5b9e\u9645\u6570\u5b57\u5927\u4e8e\u5b57\u6bb5\u5bbd\u5ea6\uff0c\u5b83\u5c06\u4e0d\u4f1a\u88ab\u622a\u65ad\u2014\u2014\u5b83\u5c06\u4f7f\u5b57\u6bb5\u6ea2\u51fa\u3002","title":"\u5bbd\u5ea6\uff0c\u586b\u5145\u5b57\u7b26\uff0c\u548c\u8303\u56f4\u8c03\u6574"}]}