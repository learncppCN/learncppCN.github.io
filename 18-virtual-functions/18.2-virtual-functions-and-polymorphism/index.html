
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.0">
    
    
      
        <title>18.2 — 虚函数和多态 - LearnCPP 中文教程</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.a3f8f96a.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.7fa14f5b.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#182" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="LearnCPP 中文教程" class="md-header__button md-logo" aria-label="LearnCPP 中文教程">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LearnCPP 中文教程
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              18.2 — 虚函数和多态
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LearnCPP 中文教程" class="md-nav__button md-logo" aria-label="LearnCPP 中文教程">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    LearnCPP 中文教程
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        目录
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%BF%BB%E8%AF%91%E6%97%A5%E8%AE%B0/" class="md-nav__link">
        翻译日记
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" >
      
      <label class="md-nav__link" for="nav-3">
        00 Introduction getting started
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="00 Introduction getting started" data-md-level="1">
        <label class="md-nav__title" for="nav-3">
          <span class="md-nav__icon md-icon"></span>
          00 Introduction getting started
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../00-Introduction-getting-started/" class="md-nav__link">
        第零章 介绍/起步
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../00-Introduction-getting-started/0.1-Introduction-to-these-tutorials/" class="md-nav__link">
        0.1 教程介绍
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" >
      
      <label class="md-nav__link" for="nav-4">
        08 basic object oriented programming
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="08 basic object oriented programming" data-md-level="1">
        <label class="md-nav__title" for="nav-4">
          <span class="md-nav__icon md-icon"></span>
          08 basic object oriented programming
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../08-basic-object-oriented-programming/" class="md-nav__link">
        第八章 面向对象编程基础
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../08-basic-object-oriented-programming/8.1-welcome-to-object-oriented-programming/" class="md-nav__link">
        8.1 欢迎来到面向对象的世界
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../08-basic-object-oriented-programming/8.2-classes-and-class-member/" class="md-nav__link">
        8.2 类和类成员 (Classes and class member)
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" >
      
      <label class="md-nav__link" for="nav-5">
        14 exceptions
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="14 exceptions" data-md-level="1">
        <label class="md-nav__title" for="nav-5">
          <span class="md-nav__icon md-icon"></span>
          14 exceptions
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/" class="md-nav__link">
        14 异常
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.1-the-need-for-exceptions/" class="md-nav__link">
        14.1 为什么需要异常
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.2-basic-exception-handloing/" class="md-nav__link">
        14.2 基本异常处理
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.3-exceptions-functions-and-stack-unwinding/" class="md-nav__link">
        14.3 异常，函数，栈展开
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.4-uncaught-exceptions-catch-all-handlers-and-exception-specifiers/" class="md-nav__link">
        14.4 未捕获异常，捕获全部异常和异常说明符
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.5-exceptions-classes-and-inheritance/" class="md-nav__link">
        14.5 异常，类和继承
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.6-rethrowing-exceptions/" class="md-nav__link">
        14.6 异常的再抛出
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.7-function-try-blocks/" class="md-nav__link">
        14.7 函数级的 try 代码块
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../14-exceptions/14.8-exception-dangers-and-downsides/" class="md-nav__link">
        14.8 异常的危险和缺点
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" >
      
      <label class="md-nav__link" for="nav-6">
        15 move semantics and smart pointers
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="15 move semantics and smart pointers" data-md-level="1">
        <label class="md-nav__title" for="nav-6">
          <span class="md-nav__icon md-icon"></span>
          15 move semantics and smart pointers
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/" class="md-nav__link">
        15 移动语义和智能指针
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.1-intro-to-smart-pointers-and-move-semantics/" class="md-nav__link">
        15.1 智能指针和移动语义的介绍
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.2-r-value-reference/" class="md-nav__link">
        15.2 右值引用
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.3-move-constructors-and-move-assignment/" class="md-nav__link">
        15.3 移动构造和移动赋值
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.4-std%3A%3Amove/" class="md-nav__link">
        15.4 std::move
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.5-std%3A%3Aunique_ptr/" class="md-nav__link">
        15.5 std::unique_ptr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.6-std%3A%3Ashared_ptr/" class="md-nav__link">
        15.6 std::shared_ptr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.7-std%3A%3Aweak_ptr/" class="md-nav__link">
        15.7 std::shared_ptr 的循环依赖问题，介绍 std::weak_ptr
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../15-move-semantics-and-smart-pointers/15.x-chapter15-comprehensive-review/" class="md-nav__link">
        15.x 十五章理解和复习
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7" checked>
      
      <label class="md-nav__link" for="nav-7">
        18 virtual functions
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="18 virtual functions" data-md-level="1">
        <label class="md-nav__title" for="nav-7">
          <span class="md-nav__icon md-icon"></span>
          18 virtual functions
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        第十八章 虚函数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.1-pointers-and-references-to-the-base-class-of-derived-objects/" class="md-nav__link">
        18.1 基类指针和引用指向派生类
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          18.2 — 虚函数和多态
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        18.2 — 虚函数和多态
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    虚函数和多态
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    一个更加复杂的例子
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#virtual" class="md-nav__link">
    virtual 关键词的使用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    一个虚函数的返回类型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    不要在构造函数和解构函数中调用虚函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    虚函数的缺点
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.3-The-override-and-final-specifiers-and-covariant-return-types/" class="md-nav__link">
        18.3 重写 final 标识符，并且协变返回类型
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.4-Virtual-destructors-virtual-assignment-and-overriding-virtualization/" class="md-nav__link">
        18.4 虚构造函数，虚赋值，重写虚函数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.5-early-binding-and-late-binding/" class="md-nav__link">
        18.5 预绑定和后期绑定
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.6-the-virtual-table/" class="md-nav__link">
        18.6 虚表
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.7-virtual-base-classes/" class="md-nav__link">
        18.7 虚基类 (Virtual base classes)
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.8-object-slicing/" class="md-nav__link">
        18.8 对象切割
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.9-dynamic-casting/" class="md-nav__link">
        18.9 动态类型转换
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../18.x%20chapter-18-comprehensice-quiz/" class="md-nav__link">
        18.x 十二章理解和练习
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8" >
      
      <label class="md-nav__link" for="nav-8">
        19 templates
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="19 templates" data-md-level="1">
        <label class="md-nav__title" for="nav-8">
          <span class="md-nav__icon md-icon"></span>
          19 templates
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/" class="md-nav__link">
        十九章 模板
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.1-function-templates/" class="md-nav__link">
        19.1 函数模板 Function templates
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.2-function-template-instances/" class="md-nav__link">
        19.2 类模板实例
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.3-template-classes/" class="md-nav__link">
        19.3 模板类
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.4-template-non-type-parameters/" class="md-nav__link">
        19.4 模板非类型参数
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.5-function-template-specialization/" class="md-nav__link">
        19.5 函数模板特化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.6-class-template-specialization/" class="md-nav__link">
        19.6 类模板特化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.7-partial-template-specialization/" class="md-nav__link">
        19.7 模板局部特化
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.8-partial-template-specialization-for-pointers/" class="md-nav__link">
        19.8 局部模板特化指针的
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../19-templates/19.x%20chapter-19-comprehensice-quiz/" class="md-nav__link">
        19.x - 19章节练习
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-9" type="checkbox" id="nav-9" >
      
      <label class="md-nav__link" for="nav-9">
        23 input and output
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="23 input and output" data-md-level="1">
        <label class="md-nav__title" for="nav-9">
          <span class="md-nav__icon md-icon"></span>
          23 input and output
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../23-input-and-output/23.1-input-and-output-streams/" class="md-nav__link">
        18.1 输入输出流
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../23-input-and-output/23.2-input-with-istream/" class="md-nav__link">
        18.2 使用 istream 输入
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../23-input-and-output/23.3-output-with-ostream-and-ios/" class="md-nav__link">
        18.3 使用 ostrea 和 ios 进行输出
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    虚函数和多态
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    一个更加复杂的例子
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#virtual" class="md-nav__link">
    virtual 关键词的使用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    一个虚函数的返回类型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    不要在构造函数和解构函数中调用虚函数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    虚函数的缺点
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="182">18.2 — 虚函数和多态<a class="headerlink" href="#182" title="Permanent link">&para;</a></h1>
<blockquote>
<p>By Alex on January 30<sup>th</sup>, 2008 | last modified by Alex on January 23<sup>rd</sup>, 2020
翻译 by dashjay Dec 20<sup>th</sup> 2020</p>
</blockquote>
<!-- In the previous lesson on pointers and references to the base class of derived objects, we took a look at a number of examples where using pointers or references to a base class had the potential to simplify code. However, in every case, we ran up against the problem that the base pointer or reference was only able to call the base version of a function, not a derived version. -->
<p>在之前的关于指向派生类中基类部分的指针和引用的课程中，我们看了很多例子使用指针或者引用指向基类，有可能优化代码。然而，在每个例子中，我们遇到的问题都是基类指针或者引用只能调用基类版本的函数，而不是派生类版本的。</p>
<p>这有一个简单的例子：</p>
<!-- Here’s a simple example of this behavior: -->

<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Base&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Derived&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">derived</span><span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">derived</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;rBase is a &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>例子输出：</p>
<!-- This example prints the result: -->

<div class="highlight"><pre><span></span><code><span class="n">rBase</span> <span class="n">is</span> <span class="n">a</span> <span class="n">Base</span>
</code></pre></div>
<!-- Because rBase is a Base reference, it calls Base::getName(), even though it’s actually referencing the Base portion of a Derived object. -->

<p>因为 <code>rBase</code> 是一个 <code>Base</code> 的引用，它调用了 <code>Base::getName()</code>，即便它实际上引用的是派生类对象的基类部分。</p>
<!-- In this lesson, we will show how to address this issue using virtual functions. -->

<p>在这节课中，我们将会展示如何使用虚函数去解决这种问题。</p>
<!-- Virtual functions and polymorphism -->
<h2 id="_1">虚函数和多态<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<!-- A virtual function is a special type of function that, when called, resolves to the most-derived version of the function that exists between the base and derived class. This capability is known as polymorphism. A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides. -->

<p>一个虚汗是是一种特殊的函数，当被调用时，解析到存在于基类和派生类中的最后的派生版本的函数。这个能力被叫做多态。我们认为一个派生函数匹配同样的签名（名字，参数类型，是否为 const 函数，和他的返回值类型都要和基类版本一样），这样的函数被叫做重写。</p>
<!-- To make a function virtual, simply place the “virtual” keyword before the function declaration. -->

<p>为了编写一个虚函数，简单的在函数申明前放置一个 <code>virtual</code> 的关键词即可。</p>
<!-- Here’s the above example with a virtual function: -->

<p>这是一个虚函数的例子：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Base&quot;</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// note addition of virtual keyword</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Derived&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">derived</span><span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">derived</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;rBase is a &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<!-- This example prints the result: -->

<p>这个例子输出：</p>
<div class="highlight"><pre><span></span><code><span class="n">rBase</span> <span class="n">is</span> <span class="n">a</span> <span class="n">Derived</span>
</code></pre></div>
<!-- Because rBase is a reference to the Base portion of a Derived object, when rBase.getName() is evaluated, it would normally resolve to Base::getName(). However, Base::getName() is virtual, which tells the program to go look and see if there are any more-derived versions of the function available between Base and Derived. In this case, it will resolve to Derived::getName()! -->

<p>因为 <code>rBase</code> 是一个派生类对象的基类部分的引用，当 <code>rBase.getName()</code> 被调用时，他将会解析到 <code>Base::getName()</code>。然而，<code>Base::getName()</code> 是一个虚函数，将会告诉程序去检查是否有更外层的派生版本的函数（在基类和派生类之间）。在这个例子中，会解析到 <code>Derived::getName()</code>！</p>
<!-- Let’s take a look at a slightly more complex example: -->

<p>让我们看一个稍稍复杂的例子：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;C&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">c</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;rBase is a &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<!-- What do you think this program will output? -->
<p>你认为他会输出什么？</p>
<!-- Let’s look at how this works. First, we instantiate a C class object. rBase is an A reference, which we set to reference the A portion of the C object. Finally, we call rBase.getName(). rBase.getName() evaluates to A::getName(). However, A::getName() is virtual, so the compiler will call the most-derived match between A and C. In this case, that is C::getName(). Note that it will not call D::getName(), because our original object was a C, not a D, so only functions between A and C are considered. -->

<p>让我们来看看它是如何工作的。首先我们实例化了一个C类对象，rBase是一个 A 类的引用，我们将引用指向 C 对象的中的 A 基类部分。最后，我们调用 <code>rBase.getName()</code>。<code>rBase.getName()</code> 取值到 <code>A::getName()</code>。然而 <code>A::getName()</code> 是一个虚函数，因此编译器将调用最外层的派生版本（介于 A 和 C 之间）。在这个例子中，就是会调用 <code>C::getName()</code>。注意，它不会去调用 D::getName() 因为我们原始对象是一个 C 类对象，而不是 D，因此只有 A 和 C 之间的函数会被考虑。</p>
<p>结果就是，我们的程序输出：</p>
<!-- As a result, our program outputs: -->

<div class="highlight"><pre><span></span><code><span class="n">rBase</span> <span class="n">is</span> <span class="n">a</span> <span class="n">C</span>
</code></pre></div>
<!-- A more complex example -->
<h2 id="_2">一个更加复杂的例子<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<!-- Let’s take another look at the Animal example we were working with in the previous lesson. Here’s the original class, along with some test code: -->
<p>让我们来看一个之前课上提到的 <code>Animal</code> 的例子。这里是之前的代码：</p>
<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>

    <span class="c1">// We&#39;re making this constructor protected because</span>
    <span class="c1">// we don&#39;t want people creating Animal objects directly,</span>
    <span class="c1">// but we still want derived classes to be able to use it.</span>
    <span class="n">Animal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_name</span><span class="p">{</span> <span class="n">name</span> <span class="p">}</span>
    <span class="p">{</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_name</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;???&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Animal</span><span class="p">{</span> <span class="n">name</span> <span class="p">}</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Meow&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Dog</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Animal</span><span class="p">{</span> <span class="n">name</span> <span class="p">}</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Woof&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">report</span><span class="p">(</span><span class="k">const</span> <span class="n">Animal</span> <span class="o">&amp;</span><span class="n">animal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">animal</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; says &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">animal</span><span class="p">.</span><span class="n">speak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Cat</span> <span class="n">cat</span><span class="p">{</span> <span class="s">&quot;Fred&quot;</span> <span class="p">};</span>
    <span class="n">Dog</span> <span class="n">dog</span><span class="p">{</span> <span class="s">&quot;Garbo&quot;</span> <span class="p">};</span>

    <span class="n">report</span><span class="p">(</span><span class="n">cat</span><span class="p">);</span>
    <span class="n">report</span><span class="p">(</span><span class="n">dog</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<!-- This prints: -->
<p>程序输出：</p>
<div class="highlight"><pre><span></span><code><span class="n">Fred</span> <span class="n">says</span> <span class="o">???</span>
<span class="n">Garbo</span> <span class="n">says</span> <span class="o">???</span>
</code></pre></div>
<p>下面是等效的代码，其中不同的将 speak() 声明为虚函数：</p>
<!-- Here’s the equivalent class with the speak() function made virtual: -->

<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>

    <span class="c1">// We&#39;re making this constructor protected because</span>
    <span class="c1">// we don&#39;t want people creating Animal objects directly,</span>
    <span class="c1">// but we still want derived classes to be able to use it.</span>
    <span class="n">Animal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_name</span><span class="p">{</span> <span class="n">name</span> <span class="p">}</span>
    <span class="p">{</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_name</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;???&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Animal</span><span class="p">{</span> <span class="n">name</span> <span class="p">}</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Meow&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Dog</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Animal</span><span class="p">{</span> <span class="n">name</span> <span class="p">}</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;Woof&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">report</span><span class="p">(</span><span class="k">const</span> <span class="n">Animal</span> <span class="o">&amp;</span><span class="n">animal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">animal</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; says &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">animal</span><span class="p">.</span><span class="n">speak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Cat</span> <span class="n">cat</span><span class="p">{</span> <span class="s">&quot;Fred&quot;</span> <span class="p">};</span>
    <span class="n">Dog</span> <span class="n">dog</span><span class="p">{</span> <span class="s">&quot;Garbo&quot;</span> <span class="p">};</span>

    <span class="n">report</span><span class="p">(</span><span class="n">cat</span><span class="p">);</span>
    <span class="n">report</span><span class="p">(</span><span class="n">dog</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<!-- This program produces the result: -->
<p>程序打印结果：</p>
<div class="highlight"><pre><span></span><code><span class="n">Fred</span> <span class="n">says</span> <span class="n">Meow</span>
<span class="n">Garbo</span> <span class="n">says</span> <span class="n">Woof</span>
</code></pre></div>
<p>成功了！</p>
<!-- It works! -->

<!-- When animal.speak() is evaluated, the program notes that Animal::speak() is a virtual function. In the case where animal is referencing the Animal portion of a Cat object, the program looks at all the classes between Animal and Cat to see if it can find a more derived function. In that case, it finds Cat::speak(). In the case where animal references the Animal portion of a Dog object, the program resolves the function call to Dog::speak(). -->

<p>当 <code>animal.speak()</code> 被取值(evaluated)的时候，程序 <code>Animal:speak()</code> 是一个虚函数。在这个例子中，<code>animal</code> 引用了 <code>Cat</code> 类对象的 <code>Animal</code> 部分，程序就会寻找所有在 <code>Animal</code> 和 <code>Cat</code> 之间的类，来检查有没有靠后(more-derived)的派生函数版本。在这个例子中，它找到了 <code>Cat::speak()</code>。在这个例子中， <code>animal</code> 又引用了 <code>Dog</code> 类对象中的 <code>Animal</code> 部分，这个程序解析到了 <code>Dog::speak()</code> 并调用。</p>
<!-- Note that we didn’t make Animal::getName() virtual. This is because getName() is never overridden in any of the derived classes, therefore there is no need. -->

<p>注意到我们没有让 <code>Animal::getName()</code> 成为一个虚函数。这是因为 <code>getName()</code> 不会在任何派生类中被重写，没有那样做的必要</p>
<!-- Similarly, the following array example now works as expected: -->

<p>相似的是，下面的数组例子也按照期望工作了：</p>
<div class="highlight"><pre><span></span><code><span class="n">Cat</span> <span class="n">fred</span><span class="p">{</span> <span class="s">&quot;Fred&quot;</span> <span class="p">};</span>
<span class="n">Cat</span> <span class="n">misty</span><span class="p">{</span> <span class="s">&quot;Misty&quot;</span> <span class="p">};</span>
<span class="n">Cat</span> <span class="n">zeke</span><span class="p">{</span> <span class="s">&quot;Zeke&quot;</span> <span class="p">};</span>

<span class="n">Dog</span> <span class="n">garbo</span><span class="p">{</span> <span class="s">&quot;Garbo&quot;</span> <span class="p">};</span>
<span class="n">Dog</span> <span class="n">pooky</span><span class="p">{</span> <span class="s">&quot;Pooky&quot;</span> <span class="p">};</span>
<span class="n">Dog</span> <span class="n">truffle</span><span class="p">{</span> <span class="s">&quot;Truffle&quot;</span> <span class="p">};</span>

<span class="c1">// Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</span>
<span class="n">Animal</span> <span class="o">*</span><span class="n">animals</span><span class="p">[]{</span> <span class="o">&amp;</span><span class="n">fred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">garbo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">misty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pooky</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">truffle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zeke</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">*</span><span class="nl">animal</span> <span class="p">:</span> <span class="n">animals</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">animal</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; says &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">animal</span><span class="o">-&gt;</span><span class="n">speak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</code></pre></div>
<!-- Which produces the result: -->
<p>产生结果：</p>
<div class="highlight"><pre><span></span><code><span class="n">Fred</span> <span class="n">says</span> <span class="n">Meow</span>
<span class="n">Garbo</span> <span class="n">says</span> <span class="n">Woof</span>
<span class="n">Misty</span> <span class="n">says</span> <span class="n">Meow</span>
<span class="n">Pooky</span> <span class="n">says</span> <span class="n">Woof</span>
<span class="n">Truffle</span> <span class="n">says</span> <span class="n">Woof</span>
<span class="n">Zeke</span> <span class="n">says</span> <span class="n">Meow</span>
</code></pre></div>
<!-- Even though these two examples only use Cat and Dog, any other classes we derive from Animal would also work with our report() function and animal array without further modification! This is perhaps the biggest benefit of virtual functions -- the ability to structure your code in such a way that newly derived classes will automatically work with the old code without modification! -->

<p>即便这两个例子仅仅使用了 <code>Cat</code> 和 <code>Dog</code>，但是其他的派生自 <code>Animal</code> 的类也会在 <code>report()</code> 函数起作用，甚至是 animal 数组也可以！这也许就是虚函数最大的好处了吧 —— 有能力使新派生的类能够在不进行修改的情况下自动使用旧代码来构造代码！</p>
<!-- A word of warning: the signature of the derived class function must exactly match the signature of the base class virtual function in order for the derived class function to be used. If the derived class function has different parameter types, the program will likely still compile fine, but the virtual function will not resolve as intended. -->

<p>提醒一句：为了使派生类的函数被调用，派生类的签名必须正好和基类的一样。如果派生类的函数有不同的参数类型，这个程序也会被调用，但是虚函数实际上不会按照期望被调用。</p>
<!-- Use of the virtual keyword -->

<h2 id="virtual">virtual 关键词的使用<a class="headerlink" href="#virtual" title="Permanent link">&para;</a></h2>
<!-- If a function is marked as virtual, all matching overrides are also considered virtual, even if they are not explicitly marked as such. However, having the keyword virtual on the derived functions does not hurt, and it serves as a useful reminder that the function is a virtual function rather than a normal one. Consequently, it’s generally a good idea to use the virtual keyword for virtualized functions in derived classes even though it’s not strictly necessary. -->

<p>如果一个函数被标记为虚函数，那么所有重写的函数也会被认为是虚函数，即便没有像那样显式的申明。然而，派生类有一个 virtual 的关键词也无伤大雅，并且也作为一个函数是虚函数而不是普通函数的提示。因此，对派生类中的虚函数使用 virtual 关键词也是一个不错的习惯，尽管这不是严格必须的。</p>
<!-- Return types of virtual functions -->

<h2 id="_3">一个虚函数的返回类型<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<!-- Under normal circumstances, the return type of a virtual function and its override must match. Consider the following example: -->

<p>在常规的情况下，重写虚函数的返回值必须和虚函数保持一致，看如下例子：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">5</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">6.78</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<!-- In this case, Derived::getValue() is not considered a matching override for Base::getValue() (it is considered a completely separate function). -->

<p>在这个例子中， <code>Derived::getValue()</code> 不会被当做 <code>Base::getValue()</code> 的重写（它被认为是一个不同的函数）。</p>
<!-- Do not call virtual functions from constructors or destructors -->

<h2 id="_4">不要在构造函数和解构函数中调用虚函数<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<!-- Here’s another gotcha that often catches unsuspecting new programmers. You should not call virtual functions from constructors or destructors. Why? -->

<p>这有一个其他的问题经常为新手程序员代码不可预料的问题。你不应该从构造函数和解构函数中调用虚函数。为什么？</p>
<!-- Remember that when a Derived class is created, the Base portion is constructed first. If you were to call a virtual function from the Base constructor, and Derived portion of the class hadn’t even been created yet, it would be unable to call the Derived version of the function because there’s no Derived object for the Derived function to work on. In C++, it will call the Base version instead. -->

<p>记住当一个派生类被构造时，基类部分先被构造，如果你在基类的构造函数调用虚函数，并且派生类部分至今并没有被创造出来，就不能调用到派生版本的函数，因为没有派生对象能够支持派生类函数的调用，在 C++ 中，它会先调用基类版本的函数。</p>
<!-- A similar issue exists for destructors. If you call a virtual function in a Base class destructor, it will always resolve to the Base class version of the function, because the Derived portion of the class will already have been destroyed. -->

<p>在解构函数中有一个类似的问题。如果你调用一个虚函数在基类的结构函数中，他将总是解析到基类版本的函数中，因为派生类版本的函数早就被销毁了。</p>
<!-- Rule: Never call virtual functions from constructors or destructors -->
<p>规定：绝对不从构造函数和解构函数中调用虚函数。</p>
<!-- The downside of virtual functions -->
<h2 id="_5">虚函数的缺点<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<!-- Since most of the time you’ll want your functions to be virtual, why not just make all functions virtual? The answer is because it’s inefficient -- resolving a virtual function call takes longer than resolving a regular one. Furthermore, the compiler also has to allocate an extra pointer for each class object that has one or more virtual functions. We’ll talk about this more in future lessons in this chapter. -->

<p>大多数的时候，你希望你的函数成为一个虚函数，为什么不让所有函数都是虚函数呢？答案就是因为它不高效——解析一个虚函数的调用会消耗更长的时间，相比解析普通的函数。而且，编译器需要为有一个或者多个虚函数的类的对象分配额外的指针，我们将会在接下来的课程中讨论这个问题。</p>
<p>Quiz time</p>
<p>1) What do the following programs print? This exercise is meant to be done by inspection, not by compiling the examples with your compiler.</p>
<p>1a)</p>
<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="c1">// Note: no getName() function here</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">c</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>B. rBase is an A reference pointing to a C object. Normally rBase.getName() would call A::getName(), but A::getName() is virtual so it instead calls the most derived matching function between A and C. That is B::getName(), which prints B.</p>
<p>1b)</p>
<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;C&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">B</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">c</span> <span class="p">};</span> <span class="c1">// note: rBase is a B this time</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>C. This is pretty straightforward, as C::getName() is the most derived matching call between classes B and C.</p>
<p>1c)</p>
<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// note: no virtual keyword</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;C&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">c</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>A. Since A is not virtual, when rBase.getName() is called, A::getName() is called.</p>
<p>1d)</p>
<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// note: no virtual keyword in B, C, and D</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;C&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">B</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">c</span> <span class="p">};</span> <span class="c1">// note: rBase is a B this time</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>C. Even though B and C aren’t marked as virtual functions, A::getName() is virtual and B::getName() and C::getName() are overrides. Therefore, B::getName() and C::getName() are considered implicitly virtual, and thus the call to rBase.getName() resolves to C::getName(), not B::getName().</p>
<p>1e)</p>
<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// Note: Functions in B, C, and D are non-const.</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;C&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">rBase</span><span class="p">{</span> <span class="n">c</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rBase</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>A. This one is a little trickier. rBase is an A reference to a C object, so rBase.getName() would normally call A::getName(). But A::getName() is virtual, so it calls the most derived version of the function between A and C. And that is A::getName(). Because B::getName() and c::getName() are not const, they are not considered overrides! Consequently, this program prints A.</p>
<p>1f)</p>
<div class="highlight"><pre><span></span><code><span class="cp"># include &lt;iostream&gt;</span>
<span class="cp"># include &lt;string_view&gt;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
 <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">getName</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// note addition of constructor</span>

 <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
 <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
 <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;C&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
 <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">C</span> <span class="n">c</span><span class="p">;</span>

 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>A. Another tricky one. When we create a C object, the A part is constructed first. When the A constructor is called to do this, it calls virtual function getName(). Because the B and C parts of the class aren’t set up yet, this resolves to A::getName().</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../18.1-pointers-and-references-to-the-base-class-of-derived-objects/" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              18.1 基类指针和引用指向派生类
            </div>
          </div>
        </a>
      
      
        <a href="../18.3-The-override-and-final-specifiers-and-covariant-return-types/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              18.3 重写 final 标识符，并且协变返回类型
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../assets/javascripts/workers/search.217ffd95.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.926459b3.min.js"></script>
      
    
  </body>
</html>